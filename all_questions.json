[
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Input Validation] Can an attacker bypass the isValidAddress filter by providing addresses that pass validation but cause SQL injection or unexpected behavior in the subsequent db.query at line 40, potentially corrupting the aa_addresses table or causing a network-wide database desynchronization?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Empty Input Handling] If readAADefinitions is called with an empty array after filtering invalid addresses at line 37-39, does the early return with empty array cause wallet.js sendMultiPayment to proceed without bounce fee validation, allowing payments to AA addresses without sufficient bounce fees and leading to permanent fund freezing when AA execution fails?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Array Manipulation] Can an attacker provide a large array of addresses (approaching or exceeding database query limits) at line 40 to cause the SQL query to fail, timeout, or consume excessive resources, resulting in transaction delays of 1+ hours or denial of service for all users attempting to send to AA addresses?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Race Condition] If multiple concurrent calls to readAADefinitions process the same arrRemainingAddresses at lines 44-109, can they all simultaneously request definitions from light vendors and insert duplicate entries via storage.insertAADefinitions, causing database constraint violations or inconsistent AA definition storage that leads to non-deterministic AA execution across nodes?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Malicious Light Vendor] In light client mode (conf.bLight), when network.requestFromLightVendor fetches AA definitions at line 73, can a compromised or malicious light vendor return a valid-looking definition with objectHash.getChash160 matching the address but containing malicious formula logic that steals funds during AA execution, causing direct loss of funds for all users triggering that AA?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Definition Spoofing] At line 84, if objectHash.getChash160(arrDefinition) !== address check passes but the arrDefinition contains a base_aa pointing to a malicious AA address, can an attacker create a proxy AA that delegates execution to their controlled contract, bypassing intended AA logic and causing unintended smart contract behavior or fund theft?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Response Validation] If network.requestFromLightVendor returns response.error at line 74-76 but the error is logged and ignored via cb(), does the function proceed with rows potentially missing critical AA definitions, causing checkAAOutputs to incorrectly validate payments as having sufficient bounce fees when they don't, leading to permanent fund freezing?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Network Timeout] If network.requestFromLightVendor hangs or times out for multiple addresses without calling the callback, does async.each block indefinitely at line 70-105, preventing handleRows from ever being called and causing all transactions to AA addresses to freeze for 1+ day until the process is restarted?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Light Vendor Denial] Can a malicious light vendor selectively return response.error or no response for specific AA addresses at lines 74-81, causing those addresses to be cached in cacheOfNewAddresses with timestamp at line 79, preventing legitimate users from sending to those AAs for 60 seconds and enabling a repeated DoS attack that freezes transactions to specific AAs for extended periods?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Cache Poisoning] Can an attacker exploit the cacheOfNewAddresses mechanism at lines 57-66 by repeatedly querying non-existent AA addresses to populate the cache with fake entries, then use the 60-second cache window to send payments to these addresses that bypass bounce fee validation, causing funds to be sent to invalid destinations and permanently lost?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Cache Timing Attack] At lines 62-63, if Date.now() - ts > 60 * 1000 check is evaluated differently across nodes due to clock skew or timestamp manipulation, can some nodes delete cache entries while others retain them, causing non-deterministic behavior in readAADefinitions results and leading to network divergence where different nodes accept different sets of transactions?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Cache Overflow] If an attacker continuously queries unique non-existent addresses to populate cacheOfNewAddresses at line 79, can the cache grow unbounded without eviction beyond the 60-second timeout, causing memory exhaustion that crashes the node and results in temporary network transaction delays of 1+ hour?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Cache Race Condition] Between lines 59-66 where cache entries are checked and potentially deleted based on timestamps, if multiple concurrent calls process the same address, can they race to read/write/delete the cache entry simultaneously, causing inconsistent cache state where some calls see cached entries and others don't, leading to duplicate light vendor requests and potential database insertion conflicts?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [INSERT IGNORE Abuse] At line 95-96, the storage.insertAADefinitions call with INSERT IGNORE behavior (via db.getIgnore()) may silently fail to insert if an AA definition already exists, but the function still adds the definition to rows array at line 94, causing callers like checkAAOutputs to use potentially stale or incorrect definition data that doesn't match the database, leading to incorrect bounce fee validation?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Database Transaction Atomicity] The function performs multiple database operations (SELECT at line 40, nested SELECT at line 46-51, and INSERT at lines 95-99) without explicit transaction boundaries - can a crash or error between these operations leave the database in an inconsistent state where some AA definitions are partially recorded, causing permanent divergence in AA execution behavior across nodes that requires a hard fork?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Foreign Key Violation] When storage.insertAADefinitions inserts with constants.GENESIS_UNIT as the unit parameter at line 95, if GENESIS_UNIT is not present in the units table or the mci value 0 is invalid, can this cause foreign key constraint violations that silently fail with INSERT IGNORE, leaving no record of the AA definition in aa_addresses table but causing subsequent AA triggers to fail with unclear errors?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Concurrent Read-After-Write] If one call to readAADefinitions inserts an AA definition via storage.insertAADefinitions at line 95 while another concurrent call is executing the initial SELECT query at line 40, can the second call miss the newly inserted definition due to database isolation levels, causing duplicate insertion attempts and potential race conditions in AA state initialization?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [JSON Parsing Vulnerability] At line 83, when parsing response as arrDefinition without validation, if the light vendor returns malformed JSON or a non-array structure, does the subsequent objectHash.getChash160(arrDefinition) call at line 84 fail gracefully or throw an unhandled exception that crashes the node, causing network-wide outages when multiple nodes query the same malicious light vendor?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Definition Structure Validation] At line 91, the check for arrDefinition[0] === 'autonomous agent' may pass for malformed definitions like ['autonomous agent'] without a second element, causing arrDefinition[1].base_aa access at line 93 to throw undefined reference errors that crash the async callback chain and prevent handleRows from being called, freezing all AA transactions?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Base AA Validation] When extracting base_aa at line 93, if arrDefinition[1].base_aa is undefined, null, or an invalid address format, does this get stored in the aa_addresses table and later cause AA validation or execution to fail with cryptic errors, permanently bricking the AA address and freezing any funds sent to it?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Hash Collision Attack] At line 84, if an attacker crafts a definition where objectHash.getChash160(arrDefinition) collides with a legitimate AA address through a hash collision (however unlikely), can they substitute a malicious AA definition that passes validation but executes attacker-controlled logic, enabling direct theft of all funds sent to that AA address?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Definition Type Confusion] If the definition returned by light vendor at line 83 is a valid address definition but NOT an AA (e.g., ['sig', {pubkey: '...'}]), does the check at line 91 correctly identify it as non-AA and insert via db.query at line 99, or can type confusion between AA and non-AA definitions cause incorrect routing where regular addresses are treated as AAs or vice versa?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Bounce Fee Bypass] At lines 131-134, if an AA definition specifies bounce_fees without including the 'base' asset, the default MIN_BYTES_BOUNCE_FEE is added only if !bounce_fees.base, but what if bounce_fees.base is explicitly set to 0? Can an attacker create an AA with zero base bounce fees, then trigger it with minimal payment, causing the AA to fail but refund nothing, effectively stealing the trigger payment?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Asset Amount Calculation] At lines 115-121, when aggregating amounts by address and asset, if payment.outputs contains duplicate output addresses or the same address with multiple outputs, does the addition at line 120 correctly sum all amounts, or can integer overflow occur when assocAmounts[output.address][asset] exceeds Number.MAX_SAFE_INTEGER, causing wrap-around that makes bounce fee checks incorrectly pass?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Missing Asset Handling] At line 136, when checking if amount < bounce_fees[asset], if assocAmounts[row.address][asset] is undefined (line 136 defaults to 0), but the AA's bounce_fees requires that asset, the check correctly identifies missing bounce fees - however, if an attacker sends payment in one asset but the AA requires bounce fees in a different asset, does the validation fail gracefully or does it allow the payment through, causing funds to be lost when the AA bounces?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Recommended Amount Manipulation] At line 138, the missing_bounce_fees object includes both missing_amount and recommended_amount fields, but only recommended_amount is used in the error aggregation at lines 19-27 - can an attacker create an AA with extremely high bounce_fees values that trigger at line 138, causing wallet.js to display misleading error messages that trick users into sending excessive funds to the AA that are then captured?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Multiple AA Payment] If arrPayments contains outputs to multiple different AA addresses with different bounce fee requirements, and one AA check passes while another fails at line 142, does handleResult get called with MissingBounceFeesErrorMessage containing only the failing AAs, potentially allowing the transaction to proceed partially for some AAs and fail for others, causing inconsistent state?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Callback Error Propagation] At lines 76, 81, 86, and 89-90, various error conditions call cb() without arguments, but there's no error parameter passed - if a critical error occurs (like definition mismatch at line 85), does the async.each completion callback at line 102 receive any error indication, or does it silently continue with incomplete data, causing incorrect bounce fee validation?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Promise Rejection Handling] At lines 35-36, if readAADefinitions is called without a handleRows callback, it returns a Promise that resolves with readAADefinitions result, but there's no explicit error handling - if any database query or async operation throws an exception, does the Promise reject properly, or can unhandled rejections crash the process?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Synchronous Exception] At line 129, JSON.parse(row.definition) is called without try-catch - if the definition field in aa_addresses table contains invalid JSON (due to database corruption or migration issues), does this throw an unhandled exception that crashes the node during transaction validation, causing network-wide inability to confirm new transactions?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Callback Inconsistency] The function calls handleResult() with no arguments at lines 126 and 142 to indicate success, but with MissingBounceFeesErrorMessage at line 143 to indicate failure - if calling code in wallet.js doesn't properly check whether the argument is truthy/error-like, can successful validations be incorrectly interpreted as failures, blocking legitimate transactions to AA addresses?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [storage.insertAADefinitions Failure] When calling storage.insertAADefinitions at line 95, if that function fails internally (e.g., due to database errors, validation failures in storage.js, or constraint violations), does the insert_cb callback at line 89 receive an error indication, or does it silently complete, causing the definition to be added to the returned rows array at line 94 even though it wasn't successfully persisted?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Definition.hasReferences Exploitation] At line 99, Definition.hasReferences(arrDefinition) is called to determine whether to set has_references flag - if this function incorrectly evaluates complex or malicious definition structures, can an attacker craft a definition that bypasses reference validation, allowing circular references or invalid cross-AA dependencies that cause infinite loops during AA execution?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Interaction with wallet.js] Since checkAAOutputs is called from wallet.js sendMultiPayment before transaction composition, if the function incorrectly returns success (handleResult with no args at line 126) for payments that should fail bounce fee validation, does wallet.js proceed to compose and send the transaction, causing user funds to be sent to AAs without adequate bounce fees and resulting in permanent fund freezing?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Light Mode Divergence] At line 41, the condition !conf.bLight || arrAddresses.length === rows.length causes different code paths for full vs light nodes - if full nodes immediately return cached AA definitions while light nodes fetch from vendors, can this create timing windows where a new AA is visible to full nodes but not yet available to light clients, causing transaction rejection inconsistencies?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Non-Deterministic Ordering] When async.each processes arrRemainingAddresses at line 70-75, the completion order of network requests is non-deterministic - if rows array is built in different orders on different nodes, does this cause non-deterministic AA definition ordering in the returned results, potentially leading to different bounce fee validation outcomes on different nodes and network partition?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Light Vendor Availability] If some nodes successfully fetch AA definitions from their configured light vendors while others timeout or receive errors at line 74, can this cause network divergence where some nodes have AA definitions in their database and accept AA trigger transactions, while other nodes reject the same transactions due to missing definitions, requiring a hard fork to reconcile?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Partial Definition Insertion] If storage.insertAADefinitions at line 95 partially completes (e.g., inserts into aa_addresses but fails to insert related state variable records in other tables), does this leave the AA in a partially initialized state where it can be triggered but has corrupt or missing state, causing all subsequent AA executions to fail and permanently freezing funds sent to that AA?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Concurrent Definition Updates] If an AA definition is fetched and inserted by multiple nodes simultaneously (or multiple calls on the same node), can the INSERT IGNORE behavior at line 96 mask conflicts where different definitions with the same address are attempted to be inserted, potentially causing the first-inserted definition to win even if it's malicious, while honest definitions are silently rejected?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [SQL Injection via db.escape] At line 40, addresses are escaped using db.escape().join(', ') - if db.escape() implementation has any vulnerabilities or if addresses can contain sequences that break out of escaping (e.g., through encoding issues), can an attacker inject SQL commands that modify aa_addresses table, delete definitions, or corrupt the entire database?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [SQL Injection in Nested Query] At lines 45-51, arrRemainingAddresses.map(db.escape).join(', ') is used in three separate UNION queries - if any of the escaped addresses contains malicious SQL that exploits differences between how the queries are constructed, can this cause unauthorized access to definitions, my_addresses, or shared_addresses tables, leaking sensitive key material or address associations?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Amount Overflow] At line 120, assocAmounts[output.address][asset] += output.amount performs unchecked addition - if an attacker includes multiple outputs to the same AA address with amounts that sum to exceed Number.MAX_SAFE_INTEGER (9007199254740991), does the addition wrap around or produce Infinity, causing bounce fee comparison at line 137 to incorrectly evaluate and allow insufficient payments through?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Bounce Fee Underflow] At line 138, missing_amount is calculated as bounce_fees[asset] - amount - if bounce_fees[asset] is maliciously set to a very large number approaching MAX_SAFE_INTEGER, and amount is also large, can integer overflow in the subtraction produce a negative or wrapped value that causes the MissingBounceFeesErrorMessage to display incorrect required amounts?",
  "[File: byteball/ocore/aa_addresses.js] [Function: MissingBounceFeesErrorMessage()] [Fee Aggregation Overflow] At lines 19-23, when aggregating required bounce fees by asset, if multiple AAs require the same asset and their recommended_amount values are large, can assocRequiredByAsset[fees.asset] += fees.recommended_amount overflow, causing the toString() method at line 28 to display incorrect total requirements that mislead users?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Memory Exhaustion via Large Definitions] When fetching AA definitions from light vendor at line 83, if the vendor returns an extremely large arrDefinition (e.g., multi-megabyte JSON with deeply nested structures), does stringifying it at line 90 and inserting into the database consume excessive memory and disk space, enabling an attacker to exhaust node resources by creating numerous large AA definitions?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Quadratic Complexity Attack] At lines 113-122, if arrPayments contains many payments each with many outputs all targeting AA addresses, the nested forEach loops create O(n*m) complexity - can an attacker submit a transaction with maximum outputs (128 per MAX_OUTPUTS_PER_PAYMENT_MESSAGE) all to AAs, causing checkAAOutputs to take excessive time and delay transaction validation by 1+ hour?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Concurrent Request Amplification] If multiple transactions are submitted simultaneously all referencing the same unknown AA address, does each trigger a separate network.requestFromLightVendor call at line 73, causing a request amplification attack against the light vendor that either overloads the vendor or triggers rate limiting that blocks legitimate requests?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Definition Mismatch Silent Failure] At line 85, if objectHash.getChash160(arrDefinition) !== address, the error is logged but cb() is called without storing any definition - does this cause checkAAOutputs to later not find the AA in rows array and incorrectly skip bounce fee validation, allowing payments to potentially non-existent or invalid addresses?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Stale Definition Detection] If an AA definition is updated on-chain (via a definition_chg message that changes an address from regular to AA), does readAADefinitions always fetch the latest definition, or can it return stale cached data from aa_addresses table that doesn't reflect the current on-chain state, causing divergence in AA execution?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Base AA Circular Reference] When storing base_aa at line 93-94, if the base_aa points to another AA that itself inherits from a third AA in a chain, or worse, creates a circular dependency (AA1 -> AA2 -> AA1), does any validation detect this before insertion, or can this create infinite recursion during AA formula evaluation that crashes nodes?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Clock Skew Exploitation] At line 62, cache expiration uses Date.now() to compare against stored timestamps - if an attacker can manipulate system time on some nodes (or if nodes have significant clock skew), can they cause some nodes to prematurely expire or indefinitely retain cache entries, leading to non-deterministic readAADefinitions behavior across the network?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Cache Timing Window Attack] Between caching a",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Zero Amount Payment] If payment.outputs includes an output with amount: 0 to an AA address, does the amount aggregation at line 120 correctly handle it, and does bounce fee validation at line 137 reject it as insufficient, or can zero-amount payments to AAs bypass bounce fee checks entirely?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Missing Asset in Bounce Fees] If an AA's bounce_fees object at line 130 specifies fees for 'base' and 'asset1', but a payment includes outputs with 'asset2' that's not in bounce_fees, does line 135 iterate over all assets in bounce_fees and miss the unlisted asset, potentially allowing payments in unexpected assets that the AA cannot handle?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [MIN_BYTES_BOUNCE_FEE Override] At lines 132-134, if an AA explicitly sets bounce_fees.base to a value less than constants.MIN_BYTES_BOUNCE_FEE (e.g., bounce_fees: {base: 1}), does the code override it with MIN_BYTES_BOUNCE_FEE or respect the AA's choice, and can malicious AAs set very low bounce fees to enable DoS attacks by triggering expensive operations with minimal cost?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Duplicate Address Handling] If arrAddresses contains duplicate addresses (e.g., ['AA1', 'AA2', 'AA1']), does the query at line 40 return duplicate rows, and does the subsequent processing correctly deduplicate them, or can duplicate entries cause checkAAOutputs to count bounce fees multiple times, rejecting legitimate transactions?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Invalid Address Format] While line 37 filters with isValidAddress, what if isValidAddress has edge cases or vulnerabilities that allow malformed addresses through - can these addresses cause db.escape at line 40 to produce invalid SQL, crash the query, or worse, leak information about database structure through error messages?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Array Mutation Race] If the arrAddresses array passed to readAADefinitions is mutated by the caller during execution (e.g., between line 37 filtering and line 40 query), can this cause inconsistent behavior where filtered addresses don't match queried addresses, leading to incorrect definition lookups?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Escaping Edge Case] At line 40, if an address is exactly at the character limit for valid addresses and contains special characters that require escaping, does db.escape produce a string that exceeds database column limits, causing the query to fail or truncate the address, matching wrong definitions?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [UNION Query Inconsistency] The query at lines 47-51 uses UNION to combine results from definitions, my_addresses, and shared_addresses tables - if these tables have different column types or constraints for the address field, can the UNION produce unexpected results or errors that cause the query to fail, blocking all AA payments?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Premature Callback Invocation] At line 103, handleRows(rows) is called after async.each completes - but if async.each calls its completion callback before all network requests have actually finished (due to bugs in async library or error conditions), can handleRows be called with incomplete rows data, causing bounce fee validation to use partial AA definitions?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Multiple Callback Invocation] If any of the cb() calls in the async.each iterator (lines 76, 81, 86, 90) are accidentally invoked multiple times due to error handling bugs, can async.each invoke its completion callback at line 102 multiple times, causing handleRows to execute repeatedly with potentially different rows data each time?",
  "[File: byteball/ocore/aa_addresses.js] [Function: checkAAOutputs()] [Early Return Bypass] At line 126, if rows.length === 0 causes early return with success (handleResult()), but this occurs because readAADefinitions failed to fetch any definitions due to errors, does this allow payments to AA addresses to proceed without bounce fee validation, causing funds to be sent without protection?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Mixed AA and Non-AA Handling] At lines 91-99, the code branches based on whether definition is AA or not - if an address transitions from non-AA to AA via definition_chg, can the old non-AA record in definitions table coexist with new AA record in aa_addresses table, causing queries to return both and confusing subsequent validation logic?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Definition String Length] When JSON.stringify(arrDefinition) is stored at line 90, if the resulting string exceeds the database column length limit for definition field in aa_addresses table, does the INSERT silently truncate it (causing invalid JSON on retrieval) or fail with error (preventing the AA from being registered)?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Base AA Null Value] If an AA definition at line 93 has base_aa property explicitly set to null or undefined, does this get stored as NULL in database and later cause queries filtering by base_aa to behave incorrectly, or can null base_aa values trigger bugs in AA validation/execution code that expects valid addresses?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Light Vendor Protocol Violation] If network.requestFromLightVendor at line 73 returns a response that doesn't conform to expected protocol (e.g., missing fields, wrong types, extra data), does the code gracefully handle all edge cases, or can protocol violations cause parsing errors, type confusion, or security vulnerabilities in definition processing?",
  "[File: byteball/ocore/aa_addresses.js] [Function: readAADefinitions()] [Request Response Mismatch] When requesting definition for address A but network.requestFromLightVendor returns a response for address B due to vendor error or MITM attack, does the objectHash.getChash160 check at line 84 always catch this mismatch, or can hash collisions or implementation bugs allow mismatched definitions to be accepted?",
  "[File: byteball/ocore/aa_addresses.js] [Function: MissingBounceFeesErrorMessage()] [Error Aggregation Logic] At lines 20-23, when aggregating missing bounce fees, if the same asset appears multiple times for the same address (due to multiple payments or outputs), does the aggregation correctly sum all missing amounts, or can duplicate counting cause error messages to overstate required fees and block legitimate transactions?",
  "[File: byteball/ocore/aa_addresses.js] [Function: MissingBounceFeesErrorMessage()] [Asset Display Name] At line 27, when formatting the required amount, if asset ID is very long or contains special characters, does the string concatenation handle it safely, or can maliciously crafted asset names cause the error message to be misformatted, confusing users or hiding important details?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateInitialAABalances()] [Race Condition - Balance Double-Counting] In updateInitialAABalances() at lines 440-500, if two concurrent AA triggers to the same address execute simultaneously on different nodes before database commit, can both triggers read the same initial balance from aa_balances table, then both add their received amounts via UPDATE queries (lines 467-472), resulting in balance double-counting and allowing the AA to spend more than it actually received?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateInitialAABalances()] [Integer Overflow] At line 472, when updating objValidationState.assocBalances[address][asset] = row.balance + trigger.outputs[asset], can an attacker send a trigger with trigger.outputs[asset] close to Number.MAX_SAFE_INTEGER to cause integer overflow, corrupting the in-memory balance tracking and allowing the AA to issue incorrect responses?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateInitialAABalances()] [Missing Balance Validation] At lines 476-482, when inserting new asset balances for assets not previously held by the AA, there's no validation that trigger.outputs[asset] is within safe integer bounds - can an attacker trigger with extremely large amounts to bypass balance checks?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateInitialAABalances()] [Balance Bug Reintroduction] At lines 461-462, the code conditionally calls reintroduceBalanceBug() for testnet before certain MCI - if this function (lines 1877-1892) modifies row.balance, can an attacker exploit the discrepancy between database and in-memory balances to cause state divergence between mainnet and testnet nodes?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateFinalAABalances()] [Negative Balance Exploit] In updateFinalAABalances() at lines 502-546, when calculating assocDeltas[asset] (line 510), if arrConsumedOutputs contains more outputs than the AA actually owns (due to race condition or double-spend), can the AA's balance go negative (line 540), and does the code properly reject such states or allow continued execution?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateFinalAABalances()] [Asset Creation Race] At lines 523-526, if an AA issues a new asset within its response, the code adds it to arrNewAssets and initializes its balance - can an attacker exploit race conditions where multiple concurrent responses from the same AA issue the same asset, causing duplicate INSERT attempts and database constraint violations?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateFinalAABalances()] [Balance Divergence] At lines 531-542, balances are updated in both the database (UPDATE query) and objValidationState.assocBalances - if the database UPDATE fails silently or partially, can in-memory balances diverge from database state, causing subsequent triggers to operate on incorrect balances?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateFinalAABalances()] [Uninitialized Asset Balance] At line 512, the comment notes 'this might happen if there is another pending invocation of our AA that created the outputs we are spending now' - can an attacker deliberately create this race condition by triggering the same AA multiple times rapidly, causing objValidationState.assocBalances[address][output.asset] to be undefined and breaking balance calculations?",
  "[File: byteball/ocore/aa_composer.js] [Function: handlePrimaryAATrigger()] [Transaction Isolation] At lines 88-144, the function begins a database transaction with BEGIN but the transaction spans multiple async operations including formula evaluation and secondary triggers - can a long-running AA execution hold database locks, causing deadlock with other concurrent AA triggers or main chain updates?",
  "[File: byteball/ocore/aa_composer.js] [Function: handlePrimaryAATrigger()] [KV Batch Write Failure] At lines 105-109, if batch.write() fails after database COMMIT (line 110), the database changes are persisted but state variable updates in KV store are lost - does this cause permanent state divergence where the AA's database balances don't match its state variables?",
  "[File: byteball/ocore/aa_composer.js] [Function: checkBalances()] [Balance Verification Gap] In checkBalances() at lines 1779-1875, the function skips verification if there are unhandled triggers (lines 1782-1787) - can an attacker keep the aa_triggers table perpetually non-empty by sending a continuous stream of triggers, preventing balance integrity checks from ever running and allowing accumulated balance corruption to go undetected?",
  "[File: byteball/ocore/aa_composer.js] [Function: checkBalances()] [Floating Point Precision Exploit] At lines 1853-1861, balance discrepancies are ignored if they're within 1e-5 relative difference for values exceeding Number.MAX_SAFE_INTEGER - can an attacker exploit this tolerance by crafting transactions that deliberately create small rounding errors that accumulate over many operations to siphon funds?",
  "[File: byteball/ocore/aa_composer.js] [Function: checkBalances()] [Temporary Table Race] At lines 1788-1814, checkBalances() creates a temporary table, fills it, and drops it - if multiple checkBalances() calls execute concurrently (despite mutex), can table name collisions or race conditions cause incorrect balance verification results?",
  "[File: byteball/ocore/aa_composer.js] [Function: insertFakeOutputsIntoMcUnit()] [Fake Output Persistence] In insertFakeOutputsIntoMcUnit() at lines 288-300, fake outputs are inserted into the outputs table for dryRun - if the subsequent ROLLBACK (line 262) fails, can these fake outputs persist in the database, allowing the AA to spend non-existent funds in future real executions?",
  "[File: byteball/ocore/aa_composer.js] [Function: estimatePrimaryAATrigger()] [State Pollution] In estimatePrimaryAATrigger() at lines 147-208, state variables and balances are modified in-place during estimation (lines 186-191) - if the 'updated' flag deletion (line 187) fails or is incomplete, can subsequent real triggers operate on polluted state?",
  "[File: byteball/ocore/aa_composer.js] [Function: estimatePrimaryAATrigger()] [Balance Mutation] At lines 444-446 (within trigger_opts.assocBalances path), originalBalances is cloned but trigger.outputs are added directly to trigger_opts.assocBalances - if the caller reuses trigger_opts.assocBalances across multiple estimations, can accumulated balance additions cause incorrect estimates?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateInitialAABalances()] [Undefined Byte Balance] At lines 484-486, if trigger.outputs.base is undefined and mci < constants.aa3UpgradeMci, byte_balance is set to undefined to maintain 'bug-compatibility' - can an attacker exploit this undefined byte_balance in subsequent fee calculations to bypass storage size checks or create malformed response units?",
  "[File: byteball/ocore/aa_composer.js] [Function: completePaymentPayload()] [Input Selection Race] In completePaymentPayload() at lines 969-1139, inputs are selected from outputs table with is_spent=0 condition (line 1045) - if another transaction spends these outputs between the SELECT and the response unit being saved, can the AA response reference already-spent outputs, creating an invalid unit?",
  "[File: byteball/ocore/aa_composer.js] [Function: completePaymentPayload()] [Change Output Manipulation] At lines 1023-1033, change outputs are calculated and added to payload.outputs - if the change_amount calculation (line 1023) results in a negative value due to fee miscalculation, can negative or zero change outputs be added, violating balance conservation?",
  "[File: byteball/ocore/aa_composer.js] [Function: completePaymentPayload()] [Send-All Bypass] At lines 977-989, send-all outputs (where amount === undefined) receive special handling - if multiple send-all outputs exist (checked at line 978), the function returns an error, but can an attacker craft a response formula that adds send-all outputs after this check, bypassing the validation?",
  "[File: byteball/ocore/aa_composer.js] [Function: iterateUnspentOutputs()] [Insufficient Funds Loop] In iterateUnspentOutputs() at lines 1000-1036, the loop continues until total_amount >= target_amount (line 1013) - if available outputs are exhausted before reaching target_amount and asset is non-base, execution falls through to issueAsset() - can an attacker trigger an AA with carefully chosen amounts to force repeated failed issuance attempts, causing DoS?",
  "[File: byteball/ocore/aa_composer.js] [Function: readStableOutputs()] [Dust Output Exclusion] At line 1045, byte outputs less than FULL_TRANSFER_INPUT_SIZE are excluded 'to prevent dust attack' - can an attacker exploit this by sending many outputs of exactly FULL_TRANSFER_INPUT_SIZE bytes, forcing the AA to consume maximum inputs and pay excessive fees when responding?",
  "[File: byteball/ocore/aa_composer.js] [Function: readUnstableOutputsSentByAAs()] [Unstable Output Spending] At lines 1054-1067, the function selects unstable outputs sent by other AAs (main_chain_index>mci OR NULL) - can an attacker exploit the non-deterministic ordering of unstable units to cause different nodes to select different inputs, leading to divergent response units and chain split?",
  "[File: byteball/ocore/aa_composer.js] [Function: completePaymentPayload()] [Oversize Fee Calculation Loop] At lines 991-1013, the code recalculates target_amount and oversize fees each iteration - if getOversizeFee() calculation is expensive and the loop requires many iterations, can an attacker trigger this with specific amounts to cause CPU exhaustion DoS?",
  "[File: byteball/ocore/aa_composer.js] [Function: completePaymentPayload()] [Storage Size Bypass] At lines 986-989, if storage_size > FULL_TRANSFER_INPUT_SIZE and mci >= aaStorageSizeUpgradeMci, a change output to the AA is added to maintain balance above storage_size - can an attacker manipulate storage_size (via state variable updates) immediately before this check to bypass the reserve requirement?",
  "[File: byteball/ocore/aa_composer.js] [Function: issueAsset()] [Capped Asset Reissuance] In issueAsset() at lines 1069-1106, for capped assets, the code checks if already issued (line 1091) - if two concurrent responses from the same AA both try to issue the same capped asset, can both pass the check before either commits, resulting in duplicate issuance exceeding the cap?",
  "[File: byteball/ocore/aa_composer.js] [Function: issueAsset()] [Serial Number Race] At lines 1097-1103, for uncapped assets, serial_number is determined by MAX(serial_number)+1 - if concurrent responses execute this query simultaneously, can they receive the same max_serial_number, causing duplicate serial number issuance?",
  "[File: byteball/ocore/aa_composer.js] [Function: issueAsset()] [Issue Amount Overflow] At line 1073, issue_amount is set to either objAsset.cap or (target_amount - total_amount) - can an attacker craft a scenario where target_amount is manipulated to cause issue_amount to be negative or exceed safe integer bounds?",
  "[File: byteball/ocore/aa_composer.js] [Function: sortOutputs()] [Non-Deterministic Sorting] At lines 1716-1719, sortOutputs() uses localeCompare() which may have locale-dependent behavior - can differences in locale settings across nodes cause different output orderings, leading to different unit hashes and chain split?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateFinalAABalances()] [Asset Balance Initialization Race] At lines 531-533, new assets are inserted with INSERT IGNORE (getIgnore()) - if multiple concurrent operations try to initialize the same asset balance, can race conditions cause only partial balance updates to be applied?",
  "[File: byteball/ocore/aa_composer.js] [Function: saveStateVars()] [State Persistence Failure] In saveStateVars() at lines 1348-1364, state variables are written to KV batch but the batch.write() happens later (line 106) - if the batch write fails after database commit, can state variables become permanently out of sync with database balances, breaking AA determinism?",
  "[File: byteball/ocore/aa_composer.js] [Function: saveStateVars()] [False Value Deletion] At line 1358, state.value === false signals deletion of the variable - can an attacker exploit AA logic that legitimately wants to store boolean false, causing unintended variable deletion and state corruption?",
  "[File: byteball/ocore/aa_composer.js] [Function: fixStateVars()] [Boolean Coercion] At line 1343, state.value === true is coerced to 1 'affects secondary triggers that execute after ours' - can this type coercion cause non-determinism if secondary triggers compare using === instead of ==, leading to divergent execution paths?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateStorageSize()] [Storage Size Race] In updateStorageSize() at lines 1388-1419, storage_size is read from cache (line 493) but updated via UPDATE query (line 1416) - if multiple concurrent AA responses update storage_size, can lost updates cause storage_size to diverge from actual KV store usage?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateStorageSize()] [Negative Storage Size] At lines 1410-1411, the code throws if new_storage_size < 0 - but can an attacker craft state deletions in a way that the calculation underflows before reaching this check, bypassing it and corrupting storage_size tracking?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateStorageSize()] [Storage Size Enforcement] At lines 1412-1413, the function rejects if byte_balance < new_storage_size (with MCI condition) - can an attacker exploit the timing between balance updates and storage size checks to temporarily violate this invariant, then restore it before checks run?",
  "[File: byteball/ocore/aa_composer.js] [Function: getValueSize()] [Size Calculation Inconsistency] In getValueSize() at lines 1377-1386, Decimal values are converted to string and measured - if Decimal.toString() uses different precision than the KV store's string serialization (line 1361), can size calculations be inaccurate, causing storage_size drift?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateOriginalOldValues()] [State Snapshot] At lines 1421-1430, updateOriginalOldValues() sets original_old_value for secondary triggers - if a primary trigger modifies state, then a secondary trigger reads and modifies the same state, can the original_old_value be overwritten, breaking delta calculations?",
  "[File: byteball/ocore/aa_composer.js] [Function: addUpdatedStateVarsIntoPrimaryResponse()] [State Variable Delta] At lines 1487-1516, state variable deltas are calculated as varInfo.value - varInfo.old_value (line 1506) - if both values are large Decimals close to Number.MAX_SAFE_INTEGER, can subtraction lose precision, reporting incorrect deltas to callers?",
  "[File: byteball/ocore/aa_composer.js] [Function: addUpdatedStateVarsIntoPrimaryResponse()] [Deleted Variable Handling] At lines 1511-1512, deleted variables (value === false) are removed from addressVars - but varInfo is still added to updatedStateVars (line 1510) - can this cause inconsistency where a deleted variable appears in updatedStateVars but not in actual state?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [State Cloning Depth] At line 434, originalStateVars is cloned via _.cloneDeep(stateVars) - if state variables contain deeply nested objects or circular references, can cloneDeep() fail or produce incorrect clones, breaking state restoration on bounce?",
  "[File: byteball/ocore/aa_composer.js] [Function: checkStorageSizes()] [KV Stream Race] In checkStorageSizes() at lines 1743-1777, the function iterates over KV store with a read stream while holding a database connection - if state variables are being written concurrently, can the stream read inconsistent state, reporting false positive mismatches?",
  "[File: byteball/ocore/aa_composer.js] [Function: checkStorageSizes()] [Address Filtering] At lines 1762-1767, the function compares storage_size between database and KV store - but does it account for state variables of AAs that were just defined but haven't executed yet? Can this cause false positive mismatches?",
  "[File: byteball/ocore/aa_composer.js] [Function: getTypeAndValue()] [Type Discrimination] In getTypeAndValue() at lines 1366-1375, values are prefixed with 's\\n', 'n\\n', or 'j\\n' - can an attacker craft a string state variable starting with 'n\\n' or 'j\\n' to cause type confusion when reading from KV store?",
  "[File: byteball/ocore/aa_composer.js] [Function: saveStateVars()] [Key Collision] At line 1357, KV keys are formatted as 'st\\n' + address + '\\n' + var_name - if var_name contains '\\n', can it cause key collision or parsing errors when reading back state variables?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [State Variable Namespace] The stateVars object is indexed by address (line 1336) - if multiple AAs are triggered in a chain and they share state variable names, can there be namespace collisions or cross-AA state leakage?",
  "[File: byteball/ocore/aa_composer.js] [Function: bounce()] [State Restoration] At lines 867-868, bounce() restores state via assignObject(stateVars, originalStateVars) - if assignObject() doesn't handle deletions properly (e.g., keys in stateVars but not in originalStateVars), can state from the failed execution persist?",
  "[File: byteball/ocore/aa_composer.js] [Function: revert()] [State Clearing] At line 1609, revert() clears all state variables with Object.keys(stateVars).forEach - but does this properly handle nested references? Can partially-executed state updates leave behind orphaned objects in memory?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateStorageSize()] [Delta Calculation Order] At lines 1391-1407, delta_storage_size is calculated by iterating addressVars - if state updates happen in a different order than variable enumeration, can the delta calculation be incorrect?",
  "[File: byteball/ocore/aa_composer.js] [Function: fixStateVars()] [Secondary Trigger State View] At line 1343, boolean true is converted to 1 'affects secondary triggers that execute after ours' - does this create non-determinism if secondary triggers on different nodes observe the state at slightly different timings?",
  "[File: byteball/ocore/aa_composer.js] [Function: estimatePrimaryAATrigger()] [Old Value Restoration] At lines 186-191, the 'updated' flag is deleted and old_value is restored after estimation - if estimation modifies state multiple times, can intermediate values be lost, making subsequent real executions see incorrect state?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [State Variable Initialization] At lines 434-437, if bSecondary is true, updateOriginalOldValues() is called - but if a secondary trigger is itself triggered by another secondary trigger (nested secondaries), can original_old_value tracking get confused?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateStorageSize()] [Variable Name Length] At lines 1399 and 1405, delta_storage_size includes var_name.length - if var_name contains multi-byte UTF-8 characters, does .length return byte count or character count? Can this cause storage_size to be incorrectly calculated?",
  "[File: byteball/ocore/aa_composer.js] [Function: addUpdatedStateVarsIntoPrimaryResponse()] [Type Conversion] At line 1500, state values are converted via toJsType(state.value) - if toJsType() changes representation (e.g., Decimal to number), can this cause precision loss in updatedStateVars while actual state retains full precision?",
  "[File: byteball/ocore/aa_composer.js] [Function: saveStateVars()] [Batch Clear Timing] At line 1610, batch.clear() is called during revert - but if batch operations were partially applied to KV store before clear(), can this leave the KV store in an inconsistent state with partial writes?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleAATriggers()] [Mutex Scope] In handleAATriggers() at lines 54-84, the 'aa_triggers' mutex is held for the entire batch of triggers (line 57) - if processing arrResponses takes a long time due to many secondary triggers, can this mutex block new trigger inserts, causing transaction timeouts or deadlock?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleAATriggers()] [Response Ordering] At lines 64-80, triggers are processed with ORDER BY mci, level, unit, address - if two triggers have the same mci and level but are processed in different orders on different nodes due to unit/address comparison differences, can this cause non-deterministic execution?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleAATriggers()] [Count Update Race] At lines 98-104, count_aa_responses is updated and cached - if multiple handleAATriggers() calls execute concurrently (shouldn't happen due to mutex, but if mutex fails), can count_aa_responses be incorrect, bypassing MAX_RESPONSES_PER_PRIMARY_TRIGGER check?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleAATriggers()] [Cache Corruption] At line 101, the code throws if unit not found in storage.assocStableUnits cache - can a cache eviction or corruption cause this throw, halting all AA trigger processing and freezing the network?",
  "[File: byteball/ocore/aa_composer.js] [Function: handlePrimaryAATrigger()] [Response Merging] At lines 112-127, if arrResponses.length > 1, updatedStateVars are copied and balances merged - if the same AA is called multiple times with different state updates, can the merging logic lose updates or apply them in wrong order?",
  "[File: byteball/ocore/aa_composer.js] [Function: handlePrimaryAATrigger()] [Balance Overwrite] At line 120, assocBalances[aa_address] is overwritten with the latest response's balances - if earlier responses in the chain had different balance states due to intermediate transfers, can this overwrite lose critical balance information?",
  "[File: byteball/ocore/aa_composer.js] [Function: getTrigger()] [Multi-Data Message] At line 345, getTrigger() uses the first data message and ignores subsequent ones - can an attacker include multiple data messages with conflicting data to cause confusion in AA logic or exploit validation bypasses?",
  "[File: byteball/ocore/aa_composer.js] [Function: getTrigger()] [Output Aggregation] At lines 351-356, outputs to the same address are aggregated - if an attacker sends multiple small outputs to avoid dust threshold but they aggregate above it, can this bypass intended economic dos protections?",
  "[File: byteball/ocore/aa_composer.js] [Function: getTrigger()] [Zero Output Check] At line 359, the function throws if no outputs to receiving_address - but can an attacker trigger AA with outputs to other addresses only, causing execution to fail after state changes have begun?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Max Responses Check] At lines 1674-1677, the code checks MAX_RESPONSES_PER_PRIMARY_TRIGGER after updating balances - can an attacker trigger cascading secondary triggers that bypass this limit by having each secondary create more secondaries?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Max AA Responses] At lines 1676-1677, if trigger.max_aa_responses is set, execution bounces when exceeded - can an attacker set max_aa_responses to 0 or 1 to deliberately cause legitimate multi-step AA operations to fail?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Bounce Fee Check Timing] At lines 1680-1687, bounce fees are checked after balance updates - if the balance update itself fails (due to race condition), can the bounce fee check pass incorrectly, allowing bounces without adequate fees?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Secondary Trigger Skip] At lines 1679-1688, bounce fee checks are skipped for secondary triggers - can an attacker deliberately trigger secondary AAs with insufficient fees, knowing they won't actually bounce but might cause unexpected state changes?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [AA Definition Caching] At lines 1539-1546, secondary triggers query aa_addresses for definition - if an AA definition was just updated (via definition_chg), can stale cached definitions cause secondary triggers to execute with old logic?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [Testnet Upgrade Bug] At lines 1540-1546, on testnet before testnetAAsDefinedByAAsAreActiveImmediatelyUpgradeMci, secondary triggers to AAs defined by AAs are skipped - can an attacker exploit the MCI boundary to cause divergence between testnet and mainnet behavior?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [Initial Address Propagation] At lines 1558-1559, child_trigger.initial_address and initial_unit are set from parent trigger - if the parent trigger itself is a secondary trigger with modified initial_address, can this cause confusion about the true originator?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [Bouncing Error Propagation] At lines 1569-1580, if a secondary AA bounces, the error propagates up - but at line 1580, primary bounces are converted to revert() calls - can this asymmetry cause different final states between primary and secondary bounces?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [Order Dependency] At lines 1539-1587, secondary triggers are processed via async.eachSeries with ORDER BY address - if the order of AAs in arrOutputAddresses doesn't match database query order, can execution order differ between nodes?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [State Inheritance] At line 1562, child_trigger_opts copies trigger_opts via Object.assign({}, trigger_opts) - does this create a shallow copy? Can secondary triggers unintentionally modify shared state like stateVars or assocBalances?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Parameterized AA Recursion] At lines 398-409, if template.base_aa exists, the function recursively calls handleTrigger() with base AA's definition - can an attacker create a circular chain of parameterized AAs (A -> B -> A) to cause infinite recursion and stack overflow?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Params Validation] At line 399, the code throws if params is non-empty for parameterized AA - but can an attacker pass params in the initial call that bypasses this check and affects base AA execution?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Bounce Fees Default] At lines 411-413, bounce_fees defaults to {base: constants.MIN_BYTES_BOUNCE_FEE} - can an attacker define an AA with bounce_fees.base = 0 to avoid paying bounce fees, then intentionally cause bounces to DOS the network?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Validation State Initialization] At lines 415-427, objValidationState is initialized with arrPreviousAAResponses - if arrResponses is modified during execution, can objValidationState become stale, causing formula evaluation to see incorrect prior responses?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [bAir vs assocBalances] At lines 384-385, the code throws if bAir and assocBalances don't match - but can an attacker call estimatePrimaryAATrigger() with mismatched flags to bypass validation checks?",
  "[File: byteball/ocore/aa_composer.js] [Function: finish()] [Secondary Bounce State] At lines 1519-1524, if bBouncing && bSecondary, logs are added to arrResponses but no response is actually created - can this cause the parent trigger to think the secondary succeeded when it actually bounced, leading to incorrect final state?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Stack Overflow via Recursion] In replace() at lines 576-825, the function is deeply recursive (can call itself via lines 609, 652, 698, 718, 777, 807) - can an attacker craft an AA definition with deeply nested formulas or arrays to cause stack overflow and crash the node?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Interrupt Loop Count] At lines 577-579, every 100 iterations, replace() interrupts the call stack with setImmediate - can an attacker craft formulas that require exactly 99 iterations repeatedly to bypass the interrupt mechanism and cause synchronous blocking?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Local Variable Cloning] At line 580, locals is cloned via _.clone(locals) (shallow copy) - if locals contains object references, can modifications in nested replace() calls leak between different branches of formula evaluation, causing non-determinism?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Duplicate Key Check] At lines 604-605, the function checks if calculated key already exists in obj - but if hasCases() branch (lines 654-721) or if/init branch (lines 723-779) modifies obj before this check runs, can duplicate keys be created?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Empty Value Removal] At lines 643-650, empty strings or objects signal key removal - but what if an AA legitimately wants to store empty array [] or empty object {}? Can this cause unintended data loss?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [State Update Formula Duplication] At lines 621-625, if objStateUpdate already exists, a second state update formula causes an error - but can an attacker exploit formula evaluation order to set objStateUpdate, then clear it, then set it again with different formula?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Case Selection Non-Determinism] At lines 656-687, cases are evaluated in array order with async.eachSeries - if formula evaluation has side effects (state reads/writes), can the order matter? Can different nodes select different cases due to concurrent state changes?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Case Init Locals] At line 683, locals from the selected case's if evaluation are used for subsequent replacements - if case.init (lines 700-718) modifies locals, can this affect sibling keys in unpredictable ways?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [If/Init Interaction] At lines 723-779, objects with 'if' and 'init' properties are evaluated - if 'if' evaluates to false, the object is removed (lines 745-749) - but what if 'init' has side effects (state changes)? Can those side effects occur even when 'if' is false?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Array Element Removal] At lines 781-801, array elements that evaluate to null are filtered out (line 790) - if this filtering happens after formula evaluation that modifies state based on array length, can array length change cause non-determinism?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Object Key Iteration Order] At lines 803-821, Object.keys() is used to iterate object properties - since JavaScript object key order is insertion order, can AAs written on different JS versions or with different key insertion patterns have different execution orders?",
  "[File: byteball/ocore/aa_composer.js] [Function: evaluateAA()] [Getter Evaluation] At lines 548-573, if getters exist, they're evaluated first (line 550) and then deleted from arrDefinition[1] (line 554) - can this deletion modify the arrDefinition that might be cached or reused, affecting subsequent triggers?",
  "[File: byteball/ocore/aa_composer.js] [Function: evaluateAA()] [Locals Passing] At line 549, locals is initialized as {} and passed to replace() - if getters define functions in locals (via function definitions in formulas), can those functions be called in subsequent message definitions with potentially unsafe operations?",
  "[File: byteball/ocore/aa_composer.js] [Function: executeStateUpdateFormula()] [Response Vars Length] At lines 1296-1299 and 1319-1321, response vars length is checked against MAX_RESPONSE_VARS_LENGTH - if formula execution adds large response vars incrementally, can it bypass the length check until the final check, wasting computation?",
  "[File: byteball/ocore/aa_composer.js] [Function: executeStateUpdateFormula()] [Bounce During State Update] At lines 1292-1299, if bBouncing is true, state update is skipped - but what if bounce() is called during state update formula evaluation? Can partial state updates be applied before the bounce?",
  "[File: byteball/ocore/aa_composer.js] [Function: executeStateUpdateFormula()] [objResponseUnit Availability] At line 1313, objResponseUnit is passed to formula evaluation - if state update formula queries the response unit hash (via response_unit variable), but the unit hasn't been validated yet, can this cause inconsistency?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Formula Reevaluation] At lines 606-607, the function checks if calculated key 'looks like a formula again' - but can an attacker craft a formula that generates another formula string, causing infinite reevaluation?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Boolean vs Number] At line 613, the function returns early for boolean values without replacement - but later at line 1343 (fixStateVars), true is converted to 1 - can this inconsistency cause issues if formulas use strict equality checks?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Messages Filtering] At lines 1697-1698, messages are filtered to exclude those without 'payload' or specific app types - if an AA response includes app='data' without payload, is it silently dropped? Can this hide errors in AA logic?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Empty Response] At lines 1699-1701, if all messages are filtered out, handleSuccessfulEmptyResponseUnit() is called - does this properly execute state updates? Can an attacker craft AAs that do state-only changes without sending anything, avoiding fees?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateInitialAABalances()] [Race Condition - Balance Double-Counting] In updateInitialAABalances() at lines 440-500, if two concurrent AA triggers to the same address execute simultaneously on different nodes before database commit, can both triggers read the same initial balance from aa_balances table, then both add their received amounts via UPDATE queries (lines 467-472), resulting in balance double-counting and allowing the AA to spend more than it actually received?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateInitialAABalances()] [Integer Overflow] At line 472, when updating objValidationState.assocBalances[address][asset] = row.balance + trigger.outputs[asset], can an attacker send a trigger with trigger.outputs[asset] close to Number.MAX_SAFE_INTEGER to cause integer overflow, corrupting the in-memory balance tracking and allowing the AA to issue incorrect responses?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateInitialAABalances()] [Missing Balance Validation] At lines 476-482, when inserting new asset balances for assets not previously held by the AA, there's no validation that trigger.outputs[asset] is within safe integer bounds - can an attacker trigger with extremely large amounts to bypass balance checks?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateInitialAABalances()] [Balance Bug Reintroduction] At lines 461-462, the code conditionally calls reintroduceBalanceBug() for testnet before certain MCI - if this function (lines 1877-1892) modifies row.balance, can an attacker exploit the discrepancy between database and in-memory balances to cause state divergence between mainnet and testnet nodes?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateFinalAABalances()] [Negative Balance Exploit] In updateFinalAABalances() at lines 502-546, when calculating assocDeltas[asset] (line 510), if arrConsumedOutputs contains more outputs than the AA actually owns (due to race condition or double-spend), can the AA's balance go negative (line 540), and does the code properly reject such states or allow continued execution?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateFinalAABalances()] [Asset Creation Race] At lines 523-526, if an AA issues a new asset within its response, the code adds it to arrNewAssets and initializes its balance - can an attacker exploit race conditions where multiple concurrent responses from the same AA issue the same asset, causing duplicate INSERT attempts and database constraint violations?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateFinalAABalances()] [Balance Divergence] At lines 531-542, balances are updated in both the database (UPDATE query) and objValidationState.assocBalances - if the database UPDATE fails silently or partially, can in-memory balances diverge from database state, causing subsequent triggers to operate on incorrect balances?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateFinalAABalances()] [Uninitialized Asset Balance] At line 512, the comment notes 'this might happen if there is another pending invocation of our AA that created the outputs we are spending now' - can an attacker deliberately create this race condition by triggering the same AA multiple times rapidly, causing objValidationState.assocBalances[address][output.asset] to be undefined and breaking balance calculations?",
  "[File: byteball/ocore/aa_composer.js] [Function: handlePrimaryAATrigger()] [Transaction Isolation] At lines 88-144, the function begins a database transaction with BEGIN but the transaction spans multiple async operations including formula evaluation and secondary triggers - can a long-running AA execution hold database locks, causing deadlock with other concurrent AA triggers or main chain updates?",
  "[File: byteball/ocore/aa_composer.js] [Function: handlePrimaryAATrigger()] [KV Batch Write Failure] At lines 105-109, if batch.write() fails after database COMMIT (line 110), the database changes are persisted but state variable updates in KV store are lost - does this cause permanent state divergence where the AA's database balances don't match its state variables?",
  "[File: byteball/ocore/aa_composer.js] [Function: checkBalances()] [Balance Verification Gap] In checkBalances() at lines 1779-1875, the function skips verification if there are unhandled triggers (lines 1782-1787) - can an attacker keep the aa_triggers table perpetually non-empty by sending a continuous stream of triggers, preventing balance integrity checks from ever running and allowing accumulated balance corruption to go undetected?",
  "[File: byteball/ocore/aa_composer.js] [Function: checkBalances()] [Floating Point Precision Exploit] At lines 1853-1861, balance discrepancies are ignored if they're within 1e-5 relative difference for values exceeding Number.MAX_SAFE_INTEGER - can an attacker exploit this tolerance by crafting transactions that deliberately create small rounding errors that accumulate over many operations to siphon funds?",
  "[File: byteball/ocore/aa_composer.js] [Function: checkBalances()] [Temporary Table Race] At lines 1788-1814, checkBalances() creates a temporary table, fills it, and drops it - if multiple checkBalances() calls execute concurrently (despite mutex), can table name collisions or race conditions cause incorrect balance verification results?",
  "[File: byteball/ocore/aa_composer.js] [Function: insertFakeOutputsIntoMcUnit()] [Fake Output Persistence] In insertFakeOutputsIntoMcUnit() at lines 288-300, fake outputs are inserted into the outputs table for dryRun - if the subsequent ROLLBACK (line 262) fails, can these fake outputs persist in the database, allowing the AA to spend non-existent funds in future real executions?",
  "[File: byteball/ocore/aa_composer.js] [Function: estimatePrimaryAATrigger()] [State Pollution] In estimatePrimaryAATrigger() at lines 147-208, state variables and balances are modified in-place during estimation (lines 186-191) - if the 'updated' flag deletion (line 187) fails or is incomplete, can subsequent real triggers operate on polluted state?",
  "[File: byteball/ocore/aa_composer.js] [Function: estimatePrimaryAATrigger()] [Balance Mutation] At lines 444-446 (within trigger_opts.assocBalances path), originalBalances is cloned but trigger.outputs are added directly to trigger_opts.assocBalances - if the caller reuses trigger_opts.assocBalances across multiple estimations, can accumulated balance additions cause incorrect estimates?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateInitialAABalances()] [Undefined Byte Balance] At lines 484-486, if trigger.outputs.base is undefined and mci < constants.aa3UpgradeMci, byte_balance is set to undefined to maintain 'bug-compatibility' - can an attacker exploit this undefined byte_balance in subsequent fee calculations to bypass storage size checks or create malformed response units?",
  "[File: byteball/ocore/aa_composer.js] [Function: completePaymentPayload()] [Input Selection Race] In completePaymentPayload() at lines 969-1139, inputs are selected from outputs table with is_spent=0 condition (line 1045) - if another transaction spends these outputs between the SELECT and the response unit being saved, can the AA response reference already-spent outputs, creating an invalid unit?",
  "[File: byteball/ocore/aa_composer.js] [Function: completePaymentPayload()] [Change Output Manipulation] At lines 1023-1033, change outputs are calculated and added to payload.outputs - if the change_amount calculation (line 1023) results in a negative value due to fee miscalculation, can negative or zero change outputs be added, violating balance conservation?",
  "[File: byteball/ocore/aa_composer.js] [Function: completePaymentPayload()] [Send-All Bypass] At lines 977-989, send-all outputs (where amount === undefined) receive special handling - if multiple send-all outputs exist (checked at line 978), the function returns an error, but can an attacker craft a response formula that adds send-all outputs after this check, bypassing the validation?",
  "[File: byteball/ocore/aa_composer.js] [Function: iterateUnspentOutputs()] [Insufficient Funds Loop] In iterateUnspentOutputs() at lines 1000-1036, the loop continues until total_amount >= target_amount (line 1013) - if available outputs are exhausted before reaching target_amount and asset is non-base, execution falls through to issueAsset() - can an attacker trigger an AA with carefully chosen amounts to force repeated failed issuance attempts, causing DoS?",
  "[File: byteball/ocore/aa_composer.js] [Function: readStableOutputs()] [Dust Output Exclusion] At line 1045, byte outputs less than FULL_TRANSFER_INPUT_SIZE are excluded 'to prevent dust attack' - can an attacker exploit this by sending many outputs of exactly FULL_TRANSFER_INPUT_SIZE bytes, forcing the AA to consume maximum inputs and pay excessive fees when responding?",
  "[File: byteball/ocore/aa_composer.js] [Function: readUnstableOutputsSentByAAs()] [Unstable Output Spending] At lines 1054-1067, the function selects unstable outputs sent by other AAs (main_chain_index>mci OR NULL) - can an attacker exploit the non-deterministic ordering of unstable units to cause different nodes to select different inputs, leading to divergent response units and chain split?",
  "[File: byteball/ocore/aa_composer.js] [Function: completePaymentPayload()] [Oversize Fee Calculation Loop] At lines 991-1013, the code recalculates target_amount and oversize fees each iteration - if getOversizeFee() calculation is expensive and the loop requires many iterations, can an attacker trigger this with specific amounts to cause CPU exhaustion DoS?",
  "[File: byteball/ocore/aa_composer.js] [Function: completePaymentPayload()] [Storage Size Bypass] At lines 986-989, if storage_size > FULL_TRANSFER_INPUT_SIZE and mci >= aaStorageSizeUpgradeMci, a change output to the AA is added to maintain balance above storage_size - can an attacker manipulate storage_size (via state variable updates) immediately before this check to bypass the reserve requirement?",
  "[File: byteball/ocore/aa_composer.js] [Function: issueAsset()] [Capped Asset Reissuance] In issueAsset() at lines 1069-1106, for capped assets, the code checks if already issued (line 1091) - if two concurrent responses from the same AA both try to issue the same capped asset, can both pass the check before either commits, resulting in duplicate issuance exceeding the cap?",
  "[File: byteball/ocore/aa_composer.js] [Function: issueAsset()] [Serial Number Race] At lines 1097-1103, for uncapped assets, serial_number is determined by MAX(serial_number)+1 - if concurrent responses execute this query simultaneously, can they receive the same max_serial_number, causing duplicate serial number issuance?",
  "[File: byteball/ocore/aa_composer.js] [Function: issueAsset()] [Issue Amount Overflow] At line 1073, issue_amount is set to either objAsset.cap or (target_amount - total_amount) - can an attacker craft a scenario where target_amount is manipulated to cause issue_amount to be negative or exceed safe integer bounds?",
  "[File: byteball/ocore/aa_composer.js] [Function: sortOutputs()] [Non-Deterministic Sorting] At lines 1716-1719, sortOutputs() uses localeCompare() which may have locale-dependent behavior - can differences in locale settings across nodes cause different output orderings, leading to different unit hashes and chain split?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateFinalAABalances()] [Asset Balance Initialization Race] At lines 531-533, new assets are inserted with INSERT IGNORE (getIgnore()) - if multiple concurrent operations try to initialize the same asset balance, can race conditions cause only partial balance updates to be applied?",
  "[File: byteball/ocore/aa_composer.js] [Function: saveStateVars()] [State Persistence Failure] In saveStateVars() at lines 1348-1364, state variables are written to KV batch but the batch.write() happens later (line 106) - if the batch write fails after database commit, can state variables become permanently out of sync with database balances, breaking AA determinism?",
  "[File: byteball/ocore/aa_composer.js] [Function: saveStateVars()] [False Value Deletion] At line 1358, state.value === false signals deletion of the variable - can an attacker exploit AA logic that legitimately wants to store boolean false, causing unintended variable deletion and state corruption?",
  "[File: byteball/ocore/aa_composer.js] [Function: fixStateVars()] [Boolean Coercion] At line 1343, state.value === true is coerced to 1 'affects secondary triggers that execute after ours' - can this type coercion cause non-determinism if secondary triggers compare using === instead of ==, leading to divergent execution paths?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateStorageSize()] [Storage Size Race] In updateStorageSize() at lines 1388-1419, storage_size is read from cache (line 493) but updated via UPDATE query (line 1416) - if multiple concurrent AA responses update storage_size, can lost updates cause storage_size to diverge from actual KV store usage?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateStorageSize()] [Negative Storage Size] At lines 1410-1411, the code throws if new_storage_size < 0 - but can an attacker craft state deletions in a way that the calculation underflows before reaching this check, bypassing it and corrupting storage_size tracking?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateStorageSize()] [Storage Size Enforcement] At lines 1412-1413, the function rejects if byte_balance < new_storage_size (with MCI condition) - can an attacker exploit the timing between balance updates and storage size checks to temporarily violate this invariant, then restore it before checks run?",
  "[File: byteball/ocore/aa_composer.js] [Function: getValueSize()] [Size Calculation Inconsistency] In getValueSize() at lines 1377-1386, Decimal values are converted to string and measured - if Decimal.toString() uses different precision than the KV store's string serialization (line 1361), can size calculations be inaccurate, causing storage_size drift?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateOriginalOldValues()] [State Snapshot] At lines 1421-1430, updateOriginalOldValues() sets original_old_value for secondary triggers - if a primary trigger modifies state, then a secondary trigger reads and modifies the same state, can the original_old_value be overwritten, breaking delta calculations?",
  "[File: byteball/ocore/aa_composer.js] [Function: addUpdatedStateVarsIntoPrimaryResponse()] [State Variable Delta] At lines 1487-1516, state variable deltas are calculated as varInfo.value - varInfo.old_value (line 1506) - if both values are large Decimals close to Number.MAX_SAFE_INTEGER, can subtraction lose precision, reporting incorrect deltas to callers?",
  "[File: byteball/ocore/aa_composer.js] [Function: addUpdatedStateVarsIntoPrimaryResponse()] [Deleted Variable Handling] At lines 1511-1512, deleted variables (value === false) are removed from addressVars - but varInfo is still added to updatedStateVars (line 1510) - can this cause inconsistency where a deleted variable appears in updatedStateVars but not in actual state?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [State Cloning Depth] At line 434, originalStateVars is cloned via _.cloneDeep(stateVars) - if state variables contain deeply nested objects or circular references, can cloneDeep() fail or produce incorrect clones, breaking state restoration on bounce?",
  "[File: byteball/ocore/aa_composer.js] [Function: checkStorageSizes()] [KV Stream Race] In checkStorageSizes() at lines 1743-1777, the function iterates over KV store with a read stream while holding a database connection - if state variables are being written concurrently, can the stream read inconsistent state, reporting false positive mismatches?",
  "[File: byteball/ocore/aa_composer.js] [Function: checkStorageSizes()] [Address Filtering] At lines 1762-1767, the function compares storage_size between database and KV store - but does it account for state variables of AAs that were just defined but haven't executed yet? Can this cause false positive mismatches?",
  "[File: byteball/ocore/aa_composer.js] [Function: getTypeAndValue()] [Type Discrimination] In getTypeAndValue() at lines 1366-1375, values are prefixed with 's\\n', 'n\\n', or 'j\\n' - can an attacker craft a string state variable starting with 'n\\n' or 'j\\n' to cause type confusion when reading from KV store?",
  "[File: byteball/ocore/aa_composer.js] [Function: saveStateVars()] [Key Collision] At line 1357, KV keys are formatted as 'st\\n' + address + '\\n' + var_name - if var_name contains '\\n', can it cause key collision or parsing errors when reading back state variables?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [State Variable Namespace] The stateVars object is indexed by address (line 1336) - if multiple AAs are triggered in a chain and they share state variable names, can there be namespace collisions or cross-AA state leakage?",
  "[File: byteball/ocore/aa_composer.js] [Function: bounce()] [State Restoration] At lines 867-868, bounce() restores state via assignObject(stateVars, originalStateVars) - if assignObject() doesn't handle deletions properly (e.g., keys in stateVars but not in originalStateVars), can state from the failed execution persist?",
  "[File: byteball/ocore/aa_composer.js] [Function: revert()] [State Clearing] At line 1609, revert() clears all state variables with Object.keys(stateVars).forEach - but does this properly handle nested references? Can partially-executed state updates leave behind orphaned objects in memory?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateStorageSize()] [Delta Calculation Order] At lines 1391-1407, delta_storage_size is calculated by iterating addressVars - if state updates happen in a different order than variable enumeration, can the delta calculation be incorrect?",
  "[File: byteball/ocore/aa_composer.js] [Function: fixStateVars()] [Secondary Trigger State View] At line 1343, boolean true is converted to 1 'affects secondary triggers that execute after ours' - does this create non-determinism if secondary triggers on different nodes observe the state at slightly different timings?",
  "[File: byteball/ocore/aa_composer.js] [Function: estimatePrimaryAATrigger()] [Old Value Restoration] At lines 186-191, the 'updated' flag is deleted and old_value is restored after estimation - if estimation modifies state multiple times, can intermediate values be lost, making subsequent real executions see incorrect state?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [State Variable Initialization] At lines 434-437, if bSecondary is true, updateOriginalOldValues() is called - but if a secondary trigger is itself triggered by another secondary trigger (nested secondaries), can original_old_value tracking get confused?",
  "[File: byteball/ocore/aa_composer.js] [Function: updateStorageSize()] [Variable Name Length] At lines 1399 and 1405, delta_storage_size includes var_name.length - if var_name contains multi-byte UTF-8 characters, does .length return byte count or character count? Can this cause storage_size to be incorrectly calculated?",
  "[File: byteball/ocore/aa_composer.js] [Function: addUpdatedStateVarsIntoPrimaryResponse()] [Type Conversion] At line 1500, state values are converted via toJsType(state.value) - if toJsType() changes representation (e.g., Decimal to number), can this cause precision loss in updatedStateVars while actual state retains full precision?",
  "[File: byteball/ocore/aa_composer.js] [Function: saveStateVars()] [Batch Clear Timing] At line 1610, batch.clear() is called during revert - but if batch operations were partially applied to KV store before clear(), can this leave the KV store in an inconsistent state with partial writes?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleAATriggers()] [Mutex Scope] In handleAATriggers() at lines 54-84, the 'aa_triggers' mutex is held for the entire batch of triggers (line 57) - if processing arrResponses takes a long time due to many secondary triggers, can this mutex block new trigger inserts, causing transaction timeouts or deadlock?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleAATriggers()] [Response Ordering] At lines 64-80, triggers are processed with ORDER BY mci, level, unit, address - if two triggers have the same mci and level but are processed in different orders on different nodes due to unit/address comparison differences, can this cause non-deterministic execution?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleAATriggers()] [Count Update Race] At lines 98-104, count_aa_responses is updated and cached - if multiple handleAATriggers() calls execute concurrently (shouldn't happen due to mutex, but if mutex fails), can count_aa_responses be incorrect, bypassing MAX_RESPONSES_PER_PRIMARY_TRIGGER check?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleAATriggers()] [Cache Corruption] At line 101, the code throws if unit not found in storage.assocStableUnits cache - can a cache eviction or corruption cause this throw, halting all AA trigger processing and freezing the network?",
  "[File: byteball/ocore/aa_composer.js] [Function: handlePrimaryAATrigger()] [Response Merging] At lines 112-127, if arrResponses.length > 1, updatedStateVars are copied and balances merged - if the same AA is called multiple times with different state updates, can the merging logic lose updates or apply them in wrong order?",
  "[File: byteball/ocore/aa_composer.js] [Function: handlePrimaryAATrigger()] [Balance Overwrite] At line 120, assocBalances[aa_address] is overwritten with the latest response's balances - if earlier responses in the chain had different balance states due to intermediate transfers, can this overwrite lose critical balance information?",
  "[File: byteball/ocore/aa_composer.js] [Function: getTrigger()] [Multi-Data Message] At line 345, getTrigger() uses the first data message and ignores subsequent ones - can an attacker include multiple data messages with conflicting data to cause confusion in AA logic or exploit validation bypasses?",
  "[File: byteball/ocore/aa_composer.js] [Function: getTrigger()] [Output Aggregation] At lines 351-356, outputs to the same address are aggregated - if an attacker sends multiple small outputs to avoid dust threshold but they aggregate above it, can this bypass intended economic dos protections?",
  "[File: byteball/ocore/aa_composer.js] [Function: getTrigger()] [Zero Output Check] At line 359, the function throws if no outputs to receiving_address - but can an attacker trigger AA with outputs to other addresses only, causing execution to fail after state changes have begun?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Max Responses Check] At lines 1674-1677, the code checks MAX_RESPONSES_PER_PRIMARY_TRIGGER after updating balances - can an attacker trigger cascading secondary triggers that bypass this limit by having each secondary create more secondaries?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Max AA Responses] At lines 1676-1677, if trigger.max_aa_responses is set, execution bounces when exceeded - can an attacker set max_aa_responses to 0 or 1 to deliberately cause legitimate multi-step AA operations to fail?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Bounce Fee Check Timing] At lines 1680-1687, bounce fees are checked after balance updates - if the balance update itself fails (due to race condition), can the bounce fee check pass incorrectly, allowing bounces without adequate fees?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Secondary Trigger Skip] At lines 1679-1688, bounce fee checks are skipped for secondary triggers - can an attacker deliberately trigger secondary AAs with insufficient fees, knowing they won't actually bounce but might cause unexpected state changes?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [AA Definition Caching] At lines 1539-1546, secondary triggers query aa_addresses for definition - if an AA definition was just updated (via definition_chg), can stale cached definitions cause secondary triggers to execute with old logic?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [Testnet Upgrade Bug] At lines 1540-1546, on testnet before testnetAAsDefinedByAAsAreActiveImmediatelyUpgradeMci, secondary triggers to AAs defined by AAs are skipped - can an attacker exploit the MCI boundary to cause divergence between testnet and mainnet behavior?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [Initial Address Propagation] At lines 1558-1559, child_trigger.initial_address and initial_unit are set from parent trigger - if the parent trigger itself is a secondary trigger with modified initial_address, can this cause confusion about the true originator?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [Bouncing Error Propagation] At lines 1569-1580, if a secondary AA bounces, the error propagates up - but at line 1580, primary bounces are converted to revert() calls - can this asymmetry cause different final states between primary and secondary bounces?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [Order Dependency] At lines 1539-1587, secondary triggers are processed via async.eachSeries with ORDER BY address - if the order of AAs in arrOutputAddresses doesn't match database query order, can execution order differ between nodes?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleSecondaryTriggers()] [State Inheritance] At line 1562, child_trigger_opts copies trigger_opts via Object.assign({}, trigger_opts) - does this create a shallow copy? Can secondary triggers unintentionally modify shared state like stateVars or assocBalances?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Parameterized AA Recursion] At lines 398-409, if template.base_aa exists, the function recursively calls handleTrigger() with base AA's definition - can an attacker create a circular chain of parameterized AAs (A -> B -> A) to cause infinite recursion and stack overflow?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Params Validation] At line 399, the code throws if params is non-empty for parameterized AA - but can an attacker pass params in the initial call that bypasses this check and affects base AA execution?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Bounce Fees Default] At lines 411-413, bounce_fees defaults to {base: constants.MIN_BYTES_BOUNCE_FEE} - can an attacker define an AA with bounce_fees.base = 0 to avoid paying bounce fees, then intentionally cause bounces to DOS the network?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Validation State Initialization] At lines 415-427, objValidationState is initialized with arrPreviousAAResponses - if arrResponses is modified during execution, can objValidationState become stale, causing formula evaluation to see incorrect prior responses?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [bAir vs assocBalances] At lines 384-385, the code throws if bAir and assocBalances don't match - but can an attacker call estimatePrimaryAATrigger() with mismatched flags to bypass validation checks?",
  "[File: byteball/ocore/aa_composer.js] [Function: finish()] [Secondary Bounce State] At lines 1519-1524, if bBouncing && bSecondary, logs are added to arrResponses but no response is actually created - can this cause the parent trigger to think the secondary succeeded when it actually bounced, leading to incorrect final state?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Stack Overflow via Recursion] In replace() at lines 576-825, the function is deeply recursive (can call itself via lines 609, 652, 698, 718, 777, 807) - can an attacker craft an AA definition with deeply nested formulas or arrays to cause stack overflow and crash the node?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Interrupt Loop Count] At lines 577-579, every 100 iterations, replace() interrupts the call stack with setImmediate - can an attacker craft formulas that require exactly 99 iterations repeatedly to bypass the interrupt mechanism and cause synchronous blocking?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Local Variable Cloning] At line 580, locals is cloned via _.clone(locals) (shallow copy) - if locals contains object references, can modifications in nested replace() calls leak between different branches of formula evaluation, causing non-determinism?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Duplicate Key Check] At lines 604-605, the function checks if calculated key already exists in obj - but if hasCases() branch (lines 654-721) or if/init branch (lines 723-779) modifies obj before this check runs, can duplicate keys be created?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Empty Value Removal] At lines 643-650, empty strings or objects signal key removal - but what if an AA legitimately wants to store empty array [] or empty object {}? Can this cause unintended data loss?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [State Update Formula Duplication] At lines 621-625, if objStateUpdate already exists, a second state update formula causes an error - but can an attacker exploit formula evaluation order to set objStateUpdate, then clear it, then set it again with different formula?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Case Selection Non-Determinism] At lines 656-687, cases are evaluated in array order with async.eachSeries - if formula evaluation has side effects (state reads/writes), can the order matter? Can different nodes select different cases due to concurrent state changes?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Case Init Locals] At line 683, locals from the selected case's if evaluation are used for subsequent replacements - if case.init (lines 700-718) modifies locals, can this affect sibling keys in unpredictable ways?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [If/Init Interaction] At lines 723-779, objects with 'if' and 'init' properties are evaluated - if 'if' evaluates to false, the object is removed (lines 745-749) - but what if 'init' has side effects (state changes)? Can those side effects occur even when 'if' is false?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Array Element Removal] At lines 781-801, array elements that evaluate to null are filtered out (line 790) - if this filtering happens after formula evaluation that modifies state based on array length, can array length change cause non-determinism?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Object Key Iteration Order] At lines 803-821, Object.keys() is used to iterate object properties - since JavaScript object key order is insertion order, can AAs written on different JS versions or with different key insertion patterns have different execution orders?",
  "[File: byteball/ocore/aa_composer.js] [Function: evaluateAA()] [Getter Evaluation] At lines 548-573, if getters exist, they're evaluated first (line 550) and then deleted from arrDefinition[1] (line 554) - can this deletion modify the arrDefinition that might be cached or reused, affecting subsequent triggers?",
  "[File: byteball/ocore/aa_composer.js] [Function: evaluateAA()] [Locals Passing] At line 549, locals is initialized as {} and passed to replace() - if getters define functions in locals (via function definitions in formulas), can those functions be called in subsequent message definitions with potentially unsafe operations?",
  "[File: byteball/ocore/aa_composer.js] [Function: executeStateUpdateFormula()] [Response Vars Length] At lines 1296-1299 and 1319-1321, response vars length is checked against MAX_RESPONSE_VARS_LENGTH - if formula execution adds large response vars incrementally, can it bypass the length check until the final check, wasting computation?",
  "[File: byteball/ocore/aa_composer.js] [Function: executeStateUpdateFormula()] [Bounce During State Update] At lines 1292-1299, if bBouncing is true, state update is skipped - but what if bounce() is called during state update formula evaluation? Can partial state updates be applied before the bounce?",
  "[File: byteball/ocore/aa_composer.js] [Function: executeStateUpdateFormula()] [objResponseUnit Availability] At line 1313, objResponseUnit is passed to formula evaluation - if state update formula queries the response unit hash (via response_unit variable), but the unit hasn't been validated yet, can this cause inconsistency?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Formula Reevaluation] At lines 606-607, the function checks if calculated key 'looks like a formula again' - but can an attacker craft a formula that generates another formula string, causing infinite reevaluation?",
  "[File: byteball/ocore/aa_composer.js] [Function: replace()] [Boolean vs Number] At line 613, the function returns early for boolean values without replacement - but later at line 1343 (fixStateVars), true is converted to 1 - can this inconsistency cause issues if formulas use strict equality checks?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Messages Filtering] At lines 1697-1698, messages are filtered to exclude those without 'payload' or specific app types - if an AA response includes app='data' without payload, is it silently dropped? Can this hide errors in AA logic?",
  "[File: byteball/ocore/aa_composer.js] [Function: handleTrigger()] [Empty Response] At lines 1699-1701, if all messages are filtered out, handleSuccessfulEmptyResponseUnit() is called - does this properly execute state updates? Can an attacker craft AAs that do state-only changes without sending anything, avoiding fees?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: getHash()] [Hash collision] Can an attacker craft two different contracts with identical hashes by manipulating the concatenation order of contract fields (title + text + creation_date + payer_name + arbiter_address + payee_name + amount + asset), potentially causing contract hash collisions that could lead to fund theft or contract confusion?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: getHash()] [Null byte injection] Does the hash calculation handle null bytes or special characters in party names correctly, or can an attacker inject null bytes to create hash collisions by making 'name1\\x00extra' hash identically to 'name1' when concatenated with other fields?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createAndSend()] [Deep clone bypass] Can an attacker manipulate the objContract object with prototype pollution before _.cloneDeep() executes, allowing them to inject malicious properties that persist after cloning and affect contract validation or execution?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createAndSend()] [Race condition on pairing info] If device.getOrGeneratePermanentPairingInfo() is called concurrently for multiple contracts, can race conditions cause pairing codes to be mixed between contracts, allowing an attacker to intercept messages intended for another contract party?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createAndSend()] [Database insertion race] Between lines 25-32, if two identical contracts (same hash) are created simultaneously, can both pass the INSERT query and create duplicate entries, causing database inconsistency and potential double-payment scenarios?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createAndSend()] [Cosigners not sent to peer] On line 27, cosigners are deleted from objContractForPeer before sending to peer - can this cause the peer to accept a contract without knowing about required cosigners, leading to signing failures or fund freezing when the shared address requires cosigner approval?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: store()] [SQL injection via INSERT IGNORE] Does the db.getIgnore() call on line 105 properly sanitize the IGNORE keyword across different database backends (SQLite vs MySQL), or can an attacker exploit database-specific syntax differences to bypass IGNORE and cause insertion errors or data corruption?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: store()] [Conditional field injection] If objContract.shared_address or objContract.unit are manipulated to contain SQL keywords or special characters, can the conditional field insertion logic (lines 93-102) be exploited to inject additional columns or values into the INSERT statement?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: decodeRow()] [JSON parsing vulnerability] On line 195, if row.cosigners contains maliciously crafted JSON that exploits JSON.parse() vulnerabilities (e.g., prototype pollution, __proto__ injection), can an attacker corrupt the contract object or inject malicious code that executes when the contract is retrieved?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: decodeRow()] [Date parsing DOS] On line 197, the date parsing logic replaces ' ' with 'T' and appends '.000Z' - can an attacker craft a creation_date value that causes Date constructor to hang or crash, creating a DOS condition when contracts are retrieved?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: getByHash()] [No existence check callback] If getByHash() is called with a non-existent hash, it returns null via callback - do all calling functions properly handle null responses, or can null contract objects cause null pointer exceptions leading to daemon crashes?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: setField()] [Whitelist bypass] The whitelist check on lines 77-79 only allows specific fields - however, can an attacker pass a field name with SQL injection characters that bypass the includes() check but still get concatenated into the UPDATE query on line 80, allowing arbitrary column updates?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: setField()] [Race condition on status updates] If setField() is called concurrently to update the same contract's status from multiple threads (e.g., payment received and arbiter resolution simultaneously), can the final status be non-deterministic or incorrect, causing fund loss or permanent fund freezing?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: setField()] [Skipsharing bypass] On line 81, if skipSharing parameter is true, updates are not shared with cosigners - can an attacker exploit this to silently update critical fields (like status or shared_address) without cosigners' knowledge, enabling theft or fraud?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: setField()] [Type confusion on value] The value parameter is directly inserted into SQL without type validation - can an attacker pass objects, arrays, or functions as value, causing type confusion errors or SQL injection when the UPDATE query executes?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: respond()] [Status check TOCTOU] Between checking objContract.status on line 115 and calling setField on line 127, can another thread change the status, creating a TOCTOU race condition that allows double-acceptance or acceptance after revocation?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: respond()] [Pairing code exposure] On lines 135-136, the pairing code is generated and sent to peer - if the device.sendMessageToDevice() call fails or the peer is malicious, can the pairing code be intercepted or reused to impersonate the accepter in future contracts?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: respond()] [Authors composition race] On line 137, composer.composeAuthorsAndMciForAddresses() is called without locking - if the same address is used in multiple concurrent contracts, can the authors/MCI composition produce inconsistent or duplicate signatures?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: respond()] [Missing signature validation] When signedMessageBase64 is received, is it validated against the signer's address before storing, or can an attacker send an invalid/forged signature that gets accepted, bypassing authorization checks?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: respond()] [Cosigner notification timing] On line 129, shareContractToCosigners() is called only for accepted status - but if a contract is rejected, cosigners are not notified - can this cause cosigners to incorrectly believe the contract is still pending, leading to confusion or signing invalid transactions?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: revoke()] [Revoke after payment] The revoke function only checks status !== 'pending' on line 152, but what if payment is received before revocation is processed? Can funds become permanently frozen if a contract is revoked after the payer sends payment but before it's detected?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: revoke()] [Peer notification failure] On line 155, shareUpdateToPeer() is called to notify peer of revocation - if this message fails to deliver or peer is offline, can the peer proceed with payment thinking the contract is still valid, causing fund loss?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createSharedAddressAndPostUnit()] [Definition array manipulation] The arrDefinition on lines 401-459 constructs a complex multi-sig definition with 5 branches - can an attacker manipulate contract fields to cause invalid definition construction, creating an address that locks funds permanently?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createSharedAddressAndPostUnit()] [Private asset branch confusion] For private assets, the definition uses 'in data feed' checks (lines 422-429) instead of 'has output' - if assetInfo.is_private is manipulated or incorrectly set, can funds be locked in an address with impossible-to-satisfy conditions?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createSharedAddressAndPostUnit()] [Arbstore cut calculation overflow] On lines 436 and 445, Math.floor(contract.amount * (1-arbstoreInfo.cut)) is calculated - if arbstoreInfo.cut is maliciously set to a value slightly above 1.0 or to NaN, can this cause negative amounts, integer overflow, or fund loss?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createSharedAddressAndPostUnit()] [Fixed denominations bypass] On line 436, the condition checks 'me_is_payer && !isFixedDen && hasArbStoreCut' - if isFixedDen is true but arbstore cut should still apply, can the payer avoid paying arbstore fees by using fixed denomination assets?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createSharedAddressAndPostUnit()] [Arbstore address validation] On line 455, arbstoreInfo.address is inserted into the definition without validation - if getArbstoreInfo() returns a malicious or invalid address, can funds be sent to attacker-controlled addresses instead of the legitimate arbstore?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createSharedAddressAndPostUnit()] [AssocSignersByPath manipulation] The assocSignersByPath object (lines 460-491) maps definition paths to signers - if an attacker registers a contract with manipulated peer_device_address, can they intercept signing requests and gain control over the shared address?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createSharedAddressAndPostUnit()] [Cosigners array injection] On line 516, contract.cosigners.length is checked, and if non-zero, cosigners are concatenated with peer and self device addresses - can an attacker inject malicious device addresses in the cosigners array to gain unauthorized signing control?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createSharedAddressAndPostUnit()] [SendMultiPayment callback delay] Between lines 511-530, sendMultiPayment can take a long time (especially for multisig) - if contract status changes during this period (e.g., revoked), can the unit still be posted, wasting the CHARGE_AMOUNT (4000 bytes)?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createSharedAddressAndPostUnit()] [Shared address reuse] If createSharedAddressAndPostUnit() is called multiple times for the same contract (e.g., due to retry logic), can multiple shared addresses be created, causing confusion about which address to pay to and potential fund loss?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: createSharedAddressAndPostUnit()] [Contract message hash validation] On line 507, objectHash.getBase64Hash(value, true) creates payload_hash - if an attacker can find a hash collision for the contract_text_hash, can they substitute contract terms after the shared address is created?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: pay()] [Status check bypass] On line 541, the function checks status === 'signed' and me_is_payer - but what if status changes to 'revoked' or 'cancelled' between the check and the payment execution? Can funds be sent to a cancelled contract's shared address?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: pay()] [Shared address existence] On line 541, if !objContract.shared_address, the function returns error - but if shared_address is set to an invalid or attacker-controlled address, can the payer lose funds by sending to the wrong address?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: pay()] [Asset mismatch] The payment uses objContract.asset on line 544 - if this field was manipulated after contract signing (e.g., via setField), can the payer send wrong asset type, causing funds to be locked?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: pay()] [Spend unconfirmed exploitation] On line 547, spend_unconfirmed can be 'all' - can an attacker exploit this by creating contracts that spend unconfirmed outputs in a chain, then double-spending the root transaction to invalidate all payments?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: pay()] [Watched address race] On lines 558-561, the peer address is added to my_watched_addresses for private assets - if payment happens before this INSERT completes, can the peer's completion data feed be missed, causing permanent fund freezing?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: pay()] [Private asset detection race] On line 558, storage.readAssetInfo() is called after payment - if asset info is not yet available or database is slow, can the watched address not be added, preventing detection of peer's completion signal?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: complete()] [Status check insufficient] On line 568, only 'paid' and 'in_dispute' statuses are allowed - but can an attacker call complete() on a 'cancelled' or 'revoked' contract if they can manipulate the status field between checks?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: complete()] [Private asset data feed forgery] For private assets (lines 573-588), the function posts a CONTRACT_DONE data feed - can an attacker forge this data feed from a different address and trick the system into completing a contract prematurely?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: complete()] [Paying address reuse] On line 592, paying_addresses is set to shared_address - if this address is used in multiple contracts simultaneously, can outputs get mixed up, causing wrong amounts to be transferred?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: complete()] [Arbstore cut retrieval timing] On lines 597-611, getArbstoreInfo() is called during completion - if arbstore info changes between contract creation and completion, can the cut amount be different, causing incorrect payment distribution?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: complete()] [Negative amount calculation] On line 604, peer_amount = Math.floor(contract.amount * (1-arbstoreInfo.cut)) - if cut is exactly 1.0, peer_amount becomes 0, and on line 607, arbstore gets contract.amount - 0 = full amount - can arbstore steal all funds?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: complete()] [Asset outputs array manipulation] On line 605, asset_outputs or base_outputs array is constructed - can an attacker manipulate this array to include duplicate addresses or negative amounts, causing fund theft or loss?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: complete()] [Refund vs complete confusion] On lines 612-615, if !me_is_payer, funds go to peer_address as 'refund' - but the logic seems to treat both payer completing (giving to payee) and payee cancelling (refunding to payer) the same way - can this cause funds to go to the wrong party?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: complete()] [Status assignment error] On line 624, status is set to 'completed' if me_is_payer, else 'cancelled' - but this logic seems inverted for the refund case - should a payer refunding set status to 'cancelled' not 'completed'?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: complete()] [SendMultiPayment error handling] If sendMultiPayment() fails (line 621-623) but returns a partial error (e.g., unit created but not broadcast), can the contract status be updated without the payment actually completing?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: openDispute()] [Status check timing] On line 205, only 'paid' contracts can be disputed - but what if a contract is in 'paid' status but payment is not yet stable? Can disputes be opened prematurely before payment confirmation?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: openDispute()] [Hub URL manipulation] On line 207, device.requestFromHub() gets arbstore URL - if the hub is compromised or returns a malicious URL, can dispute data be sent to an attacker's server instead of legitimate arbstore?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: openDispute()] [Arbiter info manipulation] On line 210, arbiters.getInfo() retrieves arbiter info including device_pub_key - if this returns a malicious public key, can encrypted contract data be decrypted by an attacker instead of the legitimate arbiter?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: openDispute()] [Encrypted package vulnerability] On line 223, device.createEncryptedPackage() encrypts contract details - if encryption is weak or key derivation is flawed, can an attacker decrypt the contract terms and gain unfair advantage in dispute?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: openDispute()] [Private asset amount exposure] On lines 227-231, if asset is private, asset and amount are included in dispute data - does this violate privacy guarantees by exposing private asset details to arbstore?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: openDispute()] [HTTP request injection] On line 233, httpRequest() posts JSON data to arbstore - can an attacker manipulate data fields to inject additional JSON properties or commands that exploit arbstore server vulnerabilities?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: openDispute()] [Arbstore address race] On lines 237-247, arbstore_address and arbstore_device_address are retrieved and stored - if these requests fail or return incorrect values, can disputes be misdirected or lost?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: openDispute()] [Status update before confirmation] On line 250, status is updated to 'in_dispute' before receiving HTTP response confirmation - if arbstore rejects the dispute, can the contract remain stuck in 'in_dispute' status?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: openDispute()] [Watched address insertion race] On line 253, arbiter_address is added to my_watched_addresses using INSERT IGNORE - if multiple disputes are opened simultaneously, can race conditions cause some arbiter responses to be missed?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: openDispute()] [Double dispute submission] If openDispute() is called multiple times on the same contract (e.g., by different cosigners), can multiple disputes be created, confusing the arbstore and causing incorrect resolution?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: appeal()] [Status check bypass] On line 266, only 'dispute_resolved' status is allowed - but if arbiter resolution is not yet stable, can appeals be submitted prematurely and processed before the resolution is confirmed?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: appeal()] [Arbstore address fallback] On lines 268-273, the function uses arbiter_address or arbstore_address depending on availability - can an attacker exploit this fallback logic to redirect appeals to a malicious arbstore?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: appeal()] [Contract data exposure] On line 283, contract title, text, and creation_date are sent unencrypted to arbstore - can an attacker intercept this data and gain unfair advantage in the appeal process?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: appeal()] [Appeal status update timing] On line 288, status is set to 'in_appeal' before receiving arbstore response - if arbstore rejects or fails to process the appeal, can the contract remain stuck in 'in_appeal' status?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: httpRequest()] [URL parsing vulnerability] On line 318, url.parse(host) is used - can an attacker exploit URL parsing vulnerabilities (e.g., SSRF, protocol smuggling) by providing malicious host values in arbstore URL?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: httpRequest()] [Content-Length calculation] On line 324, TextEncoder is used to calculate content length - can Unicode or multi-byte character encoding cause length mismatch, leading to truncated requests or server errors?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: httpRequest()] [Response size DOS] On lines 331-334, response data is accumulated without size limit - can an attacker cause arbstore to return huge responses, causing memory exhaustion and daemon crash?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: httpRequest()] [JSON parse error handling] On lines 336-344, JSON.parse() is wrapped in try-catch - but if parsing succeeds but data.error is a non-string value (e.g., object), can this cause incorrect error handling or type confusion?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: httpRequest()] [Request timeout missing] The http.request() call has no timeout setting - can a malicious arbstore hang the connection indefinitely, causing DOS by exhausting connection pool?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: parseWinnerFromUnit()] [Author address validation] On line 635, objUnit.authors[0].address is compared to arbiter_address - can an attacker forge a unit with arbiter address as author but invalid signatures, causing incorrect winner parsing?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: parseWinnerFromUnit()] [Multiple data feed messages] On lines 640-645, the function iterates through all messages and updates winner for each matching data feed - if arbiter posts multiple conflicting data feeds in one unit, which winner is used? Can this cause non-deterministic resolution?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: parseWinnerFromUnit()] [Winner validation insufficient] On line 646, winner is only checked to be either my_address or peer_address - but if arbiter posts a winner value that doesn't match either (e.g., typo or different capitalization), does the function silently fail or can this lock funds?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: parseWinnerFromUnit()] [Return value handling] The function returns undefined for invalid cases - do all callers properly handle undefined return values, or can undefined winner cause null pointer exceptions in downstream processing?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: arbiter_contract_update] [Watched address duplicate] On lines 655-660, when status becomes 'in_dispute', arbiter_address is added to my_watched_addresses - if this event fires multiple times, can duplicate entries cause database errors or performance degradation?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: new_my_transactions payment] [SQL injection in arrNewUnits] On line 665, arrNewUnits.map(db.escape) is used in IN clause - if db.escape() is not properly implemented or has edge cases, can SQL injection occur through unit hashes?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: new_my_transactions payment] [SUM aggregation race] On line 668, SUM(outputs.amount) is compared to contract.amount - if payments arrive in multiple small outputs across different units, can race conditions cause partial payment detection or double-counting?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: new_my_transactions payment] [Status transition race] On lines 671-679, if status is 'accepted' and unit not yet received, the code waits for arbiter_contract_update event - can this event never fire if unit message is lost, causing contract to remain stuck in 'accepted' status?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: new_my_transactions payment] [Recursive event handling] On line 674, newtxs(arrNewUnits) is called recursively from event listener - can infinite recursion occur if unit message arrives during payment processing, causing stack overflow?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: new_my_transactions payment] [Event listener not removed] On line 675, eventBus.removeListener is called only after successful retry - can failed retries cause event listener accumulation, creating memory leaks?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: new_my_transactions completion] [Input-output address mismatch] On lines 696-700, the query joins outputs to my_address and inputs from shared_address - can an attacker craft a transaction that satisfies this join but doesn't actually transfer funds from shared address to my_address?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: new_my_transactions completion] [Status inversion] On line 703, status is set to 'cancelled' if me_is_payer, else 'completed' - but shouldn't completion (funds received) be 'completed' for payee and 'cancelled' for payer only if they initiate cancellation?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: new_my_transactions arbiter] [Author address trust] On line 716, address = objUnit.authors[0].address is used without signature verification - can an attacker forge a unit claiming to be from arbiter address and trigger incorrect dispute resolution?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: new_my_transactions arbiter] [Resolution unit race] Between lines 726-729, resolution_unit and status are updated in separate setField() calls - can race conditions cause resolution_unit to be set without status update or vice versa?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: my_transactions_became_stable arbiter] [Stability check missing] On lines 737-766, arbiter response is processed when stable - but is there verification that the resolution_unit in the contract matches the stable unit being processed? Can stale or incorrect resolution units be processed?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: my_transactions_became_stable arbiter] [Watched address removal race] On line 760, wallet_general.removeWatchedAddress() is called when count === 0 - if new disputes are opened concurrently, can arbiter address be removed prematurely, causing future responses to be missed?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: my_transactions_became_stable private] [Contract hash extraction] On line 787, contract_hash is extracted via regex from key 'CONTRACT_DONE_xxx' - can an attacker craft malicious key names that match the regex but extract wrong hashes, causing incorrect contract completion?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: my_transactions_became_stable private] [Peer address validation] On line 791, peer_address must match objUnit.authors[0].address - but is this check sufficient? Can an attacker co-sign a unit with peer as one of multiple authors and bypass this check?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: my_transactions_became_stable private] [Data feed value validation] On line 796, m.payload[key] must equal my_address - but is capitalization, whitespace, or encoding normalized? Can an attacker use different address representations to bypass this check?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: my_transactions_became_stable private] [Status check in_dispute] On line 798, status 'paid' is checked, but what if contract is in 'in_dispute' and peer posts CONTRACT_DONE feed? Should disputed contracts be completable by peer unilaterally?",
  "[File: byteball/ocore/arbiter_contract.js] [Event: my_transactions_became_stable private] [Watched address removal logic] On lines 808-810, watched address is removed when count == 0 - but the count only includes 'paid' status contracts - can contracts in other statuses cause the address to be removed prematurely?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: getAllMyCosigners()] [SQL injection in hash] On line 384, hash parameter is directly used in WHERE clause - is it properly escaped? Can SQL injection occur if hash contains malicious characters?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: getAllMyCosigners()] [Self-device inclusion] On line 387, the function excludes device.getMyDeviceAddress() from cosigners - but if getMyDeviceAddress() returns incorrect value or changes during execution, can the device be incorrectly included or excluded?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: shareContractToCosigners()] [Contract object exposure] On line 165, the entire objContract is sent to cosigners - does this expose sensitive fields (e.g., peer_pairing_code, my_contact_info) that cosigners shouldn't have access to?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: shareContractToCosigners()] [Cosigner device address validation] On line 164, device addresses from getAllMyCosigners() are used without validation - can an attacker register as a cosigner with a malicious device address and intercept all contract updates?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: shareUpdateToCosigners()] [Field value manipulation] On line 175, objContract[field] value is sent to cosigners - if field was updated with a malicious value before this function is called, can cosigners be tricked into signing invalid transactions?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: shareUpdateToPeer()] [Peer device address trust] On line 183, objContract.peer_device_address is used to send updates - if this field was manipulated during contract creation, can updates be sent to wrong peer or attacker?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: insertDispute()] [SQL injection in contract_content] On line 366, JSON.stringify(objDispute.contract_content) is inserted - if contract_content contains exploit payloads that survive JSON stringification, can database corruption occur?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: insertDispute()] [No duplicate check] The insertDispute() function doesn't check for existing disputes with same contract_hash - can multiple disputes be created for one contract, causing arbstore confusion?",
  "[File: byteball/ocore/arbiter_contract.js] [Function: getDisputesByArbstore()] [Arbstore device address trust] On line 374, disputes are filtered by arbstore_device_address - if an attacker can register multiple device addresses for the same arbstore, can they hide disputes from legitimate arbiters?",
  "[File: byteball/ocore/arbiter_contract.js] [Module Level] [Event bus namespace collision] If multiple instances of arbiter_contract module are loaded or if other modules emit 'arbiter_contract_update' or 'new_my_transactions' events, can event handler collisions cause incorrect contract state transitions?",
  "[File: byteball/ocore/arbiter_contract.js] [Module Level] [CHARGE_AMOUNT constant] The CHARGE_AMOUNT is exported as 4000 bytes - can an attacker exploit this fixed amount by creating many contracts to drain bytes from victim wallets or by front-running contract creation to exhaust available bytes?",
  "[File: byteball/ocore/arbiter_contract.js] [Module Level] [Database connection pool exhaustion] Multiple functions perform database queries without connection limits - can an attacker create many contracts simultaneously to exhaust database connection pool, causing DOS?",
  "[File: byteball/ocore/arbiter_contract.js] [Module Level] [No rate limiting] There are no rate limits on contract creation, dispute opening, or appeal submission - can an attacker flood the system with contracts/disputes to cause network congestion or arbstore overload?",
  "[File: byteball/ocore/arbiter_contract.js] [Module Level] [TTL field unused] Contracts have a ttl field stored in database but it's never checked or enforced - can expired contracts remain active indefinitely, causing fund freezing if arbiters refuse to resolve old disputes?",
  "[File: byteball/ocore/arbiter_contract.js] [Module Level] [Asset type validation missing] Throughout the file, objContract.asset is used without validating it's a valid asset ID - can an attacker use non-existent or malformed asset IDs to cause errors or bypass validation checks?",
  "[File: byteball/ocore/arbiter_contract.js] [Module Level] [Amount overflow/underflow] Contract amounts are stored and used without overflow checks - can extremely large amounts cause integer overflow in calculations (e.g., arbstore cut calculation), leading to incorrect payment distribution?",
  "[File: byteball/ocore/arbiter_contract.js] [Module Level] [Reentrancy via event emitters] Multiple functions emit events via eventBus that trigger listeners in the same file - can reentrancy occur where a listener modifies contract state while the original function is still executing, causing state corruption?",
  "[File: byteball/ocore/arbiter_contract.js] [Module Level] [Cross-contract interaction] If the same address is used as peer/payer/payee in multiple contracts simultaneously, can race conditions or state interference between contracts cause fund loss or double-spending?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [Protocol downgrade attack] The code uses require('https') but does the function validate that the provided URL actually uses HTTPS protocol, or can an attacker-controlled hub response provide an HTTP URL leading to man-in-the-middle attacks on arbiter information retrieval?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [SSRF vulnerability] Can a malicious hub provide arbitrary URLs in the ArbStore URL response, allowing an attacker to make the node send HTTP requests to internal network resources (localhost, 127.0.0.1, 192.168.x.x, metadata services) and potentially exfiltrate sensitive information?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [DNS rebinding attack] If the ArbStore URL hostname resolves to a legitimate IP initially but changes to an internal IP after DNS TTL expires during the HTTP request, can this bypass SSRF protections and allow access to internal services?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [Response size DoS] Since data accumulation on line 34 has no size limit, can a malicious ArbStore send gigabytes of data in response, causing memory exhaustion and node crash (Critical: network shutdown)?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [Request timeout DoS] Since no timeout is set on the HTTP request, can a malicious ArbStore never respond or send data extremely slowly, causing the callback to never be called and potentially exhausting connection pools or causing resource leaks?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [JSON bomb DoS] Can a malicious ArbStore return deeply nested JSON objects (e.g., 10000+ levels deep) that cause JSON.parse() on line 39 to trigger stack overflow or excessive CPU usage, leading to node crash (Critical: network shutdown)?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [Prototype pollution] If the parsed JSON from ArbStore contains __proto__ or constructor.prototype keys, can this pollute the JavaScript prototype chain and cause unexpected behavior or security vulnerabilities in other parts of the codebase?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [NaN validation bug] On line 58, the check 'parseFloat(info.cut) === NaN' will always evaluate to false since NaN !== NaN in JavaScript - can an attacker provide NaN as the cut value, bypassing validation and causing incorrect arbiter fee calculations in arbiter_contract.js, potentially leading to fund loss?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Malformed typo] The error message on line 59 contains a typo 'mailformed' instead of 'malformed' - while not a security issue itself, does this indicate insufficient testing of this validation path, suggesting other validation bugs may exist?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Invalid address validation] If validationUtils.isValidAddress() on line 58 has any bugs or can be bypassed, can an attacker provide an invalid arbiter address that gets stored and later causes errors or exploits in arbiter_contract.js when creating shared addresses?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Cut value boundary] The validation checks 'parseFloat(info.cut) >= 1' but what happens if cut is exactly 0 or negative? Can this cause division by zero or negative amounts in arbiter fee calculations in arbiter_contract.js functions like createSharedAddressAndPostUnit()?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Cut precision attack] If info.cut contains a string like '0.12345678901234567890', does parseFloat() handle precision correctly, or can rounding errors in JavaScript floating-point arithmetic cause incorrect fee calculations leading to fund loss over many transactions?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Missing field validation] The validation only checks info.address and info.cut, but are there other fields expected from the ArbStore API (like device_pub_key from getInfo) that should be validated before storage in the cache?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Cache poisoning] The arbStoreInfos cache on line 62 stores whatever the ArbStore API returns without cryptographic verification - can a compromised ArbStore or man-in-the-middle attacker provide a malicious 'address' that belongs to the attacker, causing all arbiter fees to be sent to the attacker's address instead of the legitimate ArbStore?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Cache indefinite retention] The arbStoreInfos cache on line 8 is never cleared or has expiration - if an arbiter changes their ArbStore address or cut percentage, will the old cached values persist indefinitely, causing incorrect fee routing and potential fund loss?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Race condition in cache] If two calls to getArbstoreInfo() for the same arbiter_address occur simultaneously before the cache is populated, both will make HTTP requests to the hub - can this cause race conditions where different responses overwrite each other in the cache, or cause unnecessary load on the hub/ArbStore?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Cache key collision] The cache uses arbiter_address as the key - if there are any hash collisions or if arbiter addresses can be manipulated to match existing cache keys, can an attacker cause wrong ArbStore info to be returned for a different arbiter?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Memory leak via cache] Since the arbStoreInfos object grows without bounds and is never pruned, can an attacker create many arbiter addresses and trigger getArbstoreInfo() calls to gradually fill memory, eventually causing out-of-memory crashes (Critical: network shutdown)?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [SQL injection] Although using parameterized query on line 12, if the 'address' parameter contains special characters or the db.query implementation has bugs, could SQL injection occur allowing an attacker to read or modify arbitrary database records?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Database timing attack] By measuring the time it takes for getInfo() to return, can an attacker determine whether an arbiter exists in the wallet_arbiters table (fast return from line 14) versus needs to be fetched from hub (slow return), potentially leaking information about which arbiters the node has interacted with?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [REPLACE INTO race condition] The REPLACE INTO query on line 24 is not atomic with the preceding SELECT - if another process modifies wallet_arbiters between the SELECT and REPLACE, can this cause data inconsistency or lost updates?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Missing transaction isolation] The SELECT on line 12 and REPLACE INTO on line 24 are not wrapped in a database transaction - can concurrent calls to getInfo() for the same address cause race conditions where multiple HTTP requests are made and inconsistent data is written?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Hub response manipulation] The function trusts device.requestFromHub('hub/get_arbstore_url') to return a legitimate URL - if the hub is compromised or malicious, can it return a URL pointing to an attacker-controlled server that provides fake arbiter information, leading to fund theft when arbiter contracts are created?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Hub response validation] There is no validation that the URL returned by device.requestFromHub() matches expected patterns or is from a trusted domain - can the hub return arbitrary URLs to cause SSRF, data exfiltration, or cache poisoning attacks?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [URL construction SSRF] On line 20, the URL is constructed as url+'/api/arbiter/'+address - if the url contains special characters or the address parameter is not properly encoded, can this lead to URL injection allowing requests to different endpoints on the ArbStore server?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [API endpoint assumption] The code assumes the ArbStore has an '/api/get_info' endpoint on line 55 - if different ArbStores use different API paths, can this cause errors or make the node fetch info from wrong endpoints, potentially getting attacker-controlled data?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Callback not called] If device.requestFromHub() on line 16 never calls its callback (due to network issues or hub malfunction), the original callback passed to getInfo() will never be called - can this cause the caller in arbiter_contract.js to hang indefinitely, potentially freezing contract operations?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [Error callback with partial data] If the HTTP response ends normally but contains invalid JSON, the callback on line 41 is called with the parsing error - but if the 'data' variable already contains partial valid JSON before the error, is there any risk of this partial data being used?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Multiple callback invocations] If requestInfoFromArbStore() on line 20 somehow calls its callback multiple times (once with error, once with success due to a bug in HTTP library), can this cause the same arbiter info to be written to database multiple times or cause undefined behavior in the caller?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Promise rejection handling] The Promise-based version on lines 48-49 returns a Promise when no callback is provided, but if the callback is eventually called with an error, is the Promise properly rejected or could it remain pending forever causing memory leaks?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Error propagation] If validationUtils.isValidAddress() throws an exception instead of returning false, will this exception be caught and passed to the callback, or will it crash the node (Critical: network shutdown)?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Critical usage in fee calculations] Since arbiter_contract.js uses getArbstoreInfo() to calculate arbiter fees on lines 397-456, if the cached cut value is manipulated (via cache poisoning), can this cause incorrect fee distributions where funds intended for arbiters are sent elsewhere or the wrong amounts are sent?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Device pubkey validation] The device_pub_key retrieved on line 12 or 24 is used in arbiter_contract.js for encrypted communication - if this key is manipulated by a compromised hub/ArbStore, can an attacker intercept or forge arbiter messages, potentially controlling dispute resolutions?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Real name trust] The real_name field stored on line 24 is displayed to users - if a malicious ArbStore provides a misleading real_name (like 'Official Obyte Arbiter'), can this facilitate social engineering attacks where users trust fake arbiters with their funds?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Concurrent database writes] If multiple calls to getInfo() for the same arbiter happen concurrently and all find no real_name in database (line 13), they will all trigger HTTP requests and REPLACE INTO operations - can this cause the last write to win arbitrarily, potentially storing stale or incorrect arbiter info?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [HTTP connection exhaustion] If many calls to getInfo() or getArbstoreInfo() happen simultaneously for different arbiters, will each create a new HTTPS connection - can this exhaust the connection pool or file descriptors, causing new connections to fail (Medium: network delay)?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Cache check race condition] The cache check on line 50 and cache write on line 62 are not atomic - if two threads check the cache simultaneously, find it empty, and both proceed to fetch from hub, can the second response overwrite the first in the cache in a non-deterministic way?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Type coercion attack] If info.cut is provided as a non-numeric string that parseFloat() converts to 0 (like 'abc'), will the validation on line 58 (< 0 check) pass, allowing cut=0 which might cause division by zero in fee calculations elsewhere?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [URL injection in cache] On line 61, info.url is set to the url variable - if the url contains control characters or special characters, can this cause issues when the URL is later used for HTTP requests in other functions?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Missing field handling] If the ArbStore API response is missing expected fields like device_pub_key or real_name, will JSON.parse() succeed but the subsequent database insert on line 24 fail or insert NULL values, causing issues in arbiter_contract.js?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [Encoding issues] The HTTP response is concatenated as strings on line 34 without specifying encoding - if the ArbStore returns non-UTF8 data, can this cause garbled data or throw exceptions during JSON parsing?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Address normalization] If the 'address' parameter is not normalized (e.g., contains extra whitespace, different case for checksums), will the database query on line 12 find the correct record, or can this cause cache misses and redundant HTTP requests?",
  "[File: byteball/ocore/arbiters.js] [Dependency availability] The module requires './db.js', './device.js', and 'ocore/validation_utils.js' - if any of these modules fail to initialize or have circular dependency issues, can this cause arbiters.js to load incorrectly or crash on first use?",
  "[File: byteball/ocore/arbiters.js] [Global state corruption] The arbStoreInfos cache is module-level global state - if this object is accidentally modified by external code or garbage collected, can this cause unpredictable behavior or crashes when getArbstoreInfo() is called?",
  "[File: byteball/ocore/arbiters.js] [HTTPS module mocking] In testing environments, if the 'https' module is mocked or replaced with a different implementation, could this introduce vulnerabilities that wouldn't exist in production?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Amplification attack] Can an attacker repeatedly call getInfo() with different arbiter addresses that don't exist in the database, causing the node to make many HTTP requests to the hub and ArbStores, amplifying load and potentially being rate-limited or banned by external services?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Cache pollution DoS] Can an attacker programmatically generate thousands of valid arbiter addresses and call getArbstoreInfo() for each, filling the cache with entries and consuming gigabytes of memory, eventually crashing the node (Critical: network shutdown)?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [Slowloris attack] Can a malicious ArbStore implement a slowloris-style attack by sending response data one byte at a time over hours, keeping the connection and callback alive indefinitely and exhausting resources?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Arbiter usage leakage] By monitoring which arbiters a node queries via getInfo(), can an external observer (compromised hub, network sniffer) determine which arbiter contracts the node is participating in, potentially leaking business relationships or contract details?",
  "[File: byteball/ocore/arbiters.js] [Function: requestInfoFromArbStore()] [Error message leakage] If the ArbStore returns an error response with detailed error messages, are these error details propagated through the callback in a way that could leak sensitive information about the node's configuration or internal state?",
  "[File: byteball/ocore/arbiters.js] [Function: getArbstoreInfo()] [Arbiter_contract.js dependency] Since arbiter_contract.js heavily relies on getArbstoreInfo() for fee calculations in createSharedAddressAndPostUnit() and complete(), if getArbstoreInfo() returns incorrect or cached stale data, can this cause arbiter contracts to permanently lock funds in addresses with incorrect definitions (Critical: permanent fund freezing)?",
  "[File: byteball/ocore/arbiters.js] [Function: getInfo()] [Device messaging security] The device_pub_key from getInfo() is used to encrypt sensitive contract data in arbiter_contract.js openDispute() - if this key is wrong or belongs to an attacker, can the attacker decrypt plaintiff/respondent information and manipulate disputes?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Transaction Atomicity] If the arrQueries array is executed partially (e.g., database crash after unspending outputs but before deleting the unit), can the system enter an inconsistent state where outputs are marked unspent but the unit still exists, allowing those outputs to be double-spent?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Race Condition] If two concurrent calls to generateQueriesToArchiveJoint() target units that spend the same outputs, can both processes incorrectly unspend the same outputs twice, corrupting the is_spent flags in the outputs table?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [JSON Serialization] When storing JSON.stringify(objJoint) in the archived_joints table, can maliciously crafted joint objects with circular references or extremely deep nesting cause JSON.stringify() to throw an exception, preventing proper archiving and leaving the database in an inconsistent state?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Reason Validation] Since the 'reason' parameter is inserted directly into archived_joints without validation, can an attacker pass arbitrary strings (including SQL injection payloads or excessively long strings) that could corrupt the archived_joints table or cause database errors?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Callback Ordering] If the callback cb() is invoked before all queries in arrQueries are fully added, can the caller execute the queries prematurely, missing critical DELETE or UPDATE statements and leaving orphaned database records?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Logic Branching] Since the function chooses between generateQueriesToRemoveJoint and generateQueriesToVoidJoint based on reason === 'uncovered', can an attacker exploit differences in what data each function preserves to cause non-deterministic behavior across nodes if different nodes receive different reasons for the same unit?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint() vs generateQueriesToVoidJoint()] [Data Retention Inconsistency] The removeJoint function deletes aa_responses but voidJoint does not - if an AA response unit is voided instead of removed, can this cause AA state divergence where some nodes have AA responses for voided units while others don't, breaking deterministic AA execution?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Partial Deletion] Since voidJoint keeps unit_witnesses, unit_authors, and units tables but deletes messages, can this create a 'zombie unit' state where the unit exists without any payload, breaking validation logic that expects units to have messages and causing network sync failures?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Definition Chash Nullification] The UPDATE unit_authors SET definition_chash=NULL statement removes definition information - if a voided unit was the first unit to introduce a definition for an address, can this make the address permanently unusable since no other unit has the definition, causing permanent fund freezing?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Double-Spend Window] The query checks for alternative spenders using 'AND inputs.unit!=alt_inputs.unit' - if another unit spending the same output is in the process of being archived concurrently, can both archiving operations incorrectly conclude they should unspend the output, resulting in is_spent being set to 0 despite a valid spending unit still existing?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [NOT EXISTS Subquery Race] The NOT EXISTS subquery validates there are no other spenders, but this check happens at query generation time, not execution time - if a new valid unit spending the same output is added to the database between query generation and execution, can the output be incorrectly unspent, enabling a double-spend attack?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Type Filter Bypass] The query filters for inputs.type='transfer' - if a malicious unit spends the same output as both 'transfer' type and another type (e.g., through database corruption), can the unspending logic miss the alternative spender and incorrectly mark the output as unspent?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Output Triple Uniqueness] The query identifies outputs by (src_unit, src_message_index, src_output_index) - if database constraints don't enforce uniqueness on this triple in the outputs table, can multiple output records exist for the same logical output, causing some to be unspent while others remain spent, breaking balance calculations?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [MCI Range Overlap] The query uses 'from_main_chain_index <= +headers_commission_outputs.main_chain_index AND to_main_chain_index >= +headers_commission_outputs.main_chain_index' - if MCI ranges overlap between archived and non-archived units, can the same headers commission output be unspent while still being validly spent, allowing double-spending of witness rewards?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [Unary Plus Coercion] The use of '+headers_commission_outputs.main_chain_index' (unary plus) suggests potential type issues - if main_chain_index is stored as a string or null, can type coercion cause incorrect comparison logic, leading to wrong outputs being unspent or legitimate outputs remaining spent?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [Cross Join Performance] The CROSS JOIN between inputs and headers_commission_outputs with MCI range filtering - for units with many inputs covering large MCI ranges, can this query become extremely slow or timeout, causing the archiving transaction to fail and preventing database cleanup, leading to memory exhaustion?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [Address Matching Logic] The query matches by inputs.address = headers_commission_outputs.address - if an address has multiple headers commission outputs at different MCIs and the archived unit's input spans a large MCI range, can the wrong outputs be unspent, corrupting witness reward balances?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [Alt Inputs Subquery] The NOT EXISTS subquery checks if any alt_inputs spans the same MCI - if multiple units are being archived simultaneously and all reference overlapping MCI ranges, can the race condition cause all of them to incorrectly unspend the same headers commission outputs?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendWitnessingOutputsSpentInArchivedUnit()] [Witnessing Reward Integrity] Similar to headers commission, this function unspends witnessing outputs based on MCI ranges - if witnessing outputs are unspent incorrectly, can witnesses double-claim their witnessing rewards, inflating the total supply of bytes and breaking the economic model?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendWitnessingOutputsSpentInArchivedUnit()] [Concurrent Archiving] If multiple units spending witnessing outputs from overlapping MCI ranges are archived in parallel, can the lack of synchronization cause all of them to unspend the same witnessing outputs, resulting in is_spent=0 flags that don't match reality?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendWitnessingOutputsSpentInArchivedUnit()] [Type Safety] The query filters by inputs.type='witnessing' - if database integrity is compromised and input types are modified, can the wrong outputs be unspent, mixing witnessing and transfer outputs and corrupting user balances?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [AA Response Deletion] The function deletes from aa_responses WHERE trigger_unit=? OR response_unit=? - if an archived unit was both an AA trigger and had AA responses, can deleting these records break the AA execution chain for dependent AAs, causing subsequent AA triggers to fail validation because they reference missing response units?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [AA State Consistency] When deleting AA responses via trigger_unit or response_unit, is the corresponding AA state variable data (stored in aa_var_values table) also cleaned up, or can orphaned state variables persist, causing memory leaks and eventual database bloat that crashes nodes?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Asset Metadata Deletion] The function deletes from asset_metadata WHERE asset=? - if the archived unit is an asset issuance unit and other units still reference this asset in their outputs, can deleting the metadata break balance queries and asset validation for remaining holders?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Asset Denominations Cleanup] Deleting from asset_denominations for indivisible assets - if outputs with specific denominations from this asset still exist in unarchived units, can the missing denomination definitions cause transfer validation failures, permanently freezing those outputs?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Asset Attestors Reference] The DELETE from asset_attestors statement removes attestor requirements - if other nodes haven't synchronized this archiving yet and receive new transfers of this asset, can validation disagreements arise because some nodes enforce attestor requirements while others don't?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Parenthood Deletion] The DELETE FROM parenthoods WHERE child_unit=? removes parent relationships - if other units still reference the archived unit as a parent (stored in parenthoods.parent_unit), can this create orphaned parent references that break DAG traversal algorithms?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Witness List Hashes] Deleting from witness_list_hashes WHERE witness_list_unit=? - if other units reference this witness list through witness_list_unit field, can the missing hash data break witness compatibility validation for new units?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Address Definition Changes] The DELETE FROM address_definition_changes WHERE unit=? removes definition transitions - if an address changed its definition in the archived unit and this was the only record of that change, can the address become stuck in an old definition that doesn't match the actual signing authority, preventing any future spending?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Attestation Data Loss] Deleting from attestations and attested_fields - if these attestations were used by AAs for authentication logic, can removing them break AA formula evaluations that query attestation data, causing unexpected bounce responses?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Poll Data Removal] The function deletes poll_choices, polls, and votes - if other units reference this poll or its choices, can the missing data cause vote counting errors or make it impossible to validate vote units?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Spend Proof Deletion] DELETE FROM spend_proofs removes proof data - if light clients cached these proofs for validating spends, can the removal cause light client validation failures even though the unit was legitimately archived?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Original Addresses Cleanup] The DELETE FROM original_addresses statement - if these addresses are still referenced in payment messages or definition changes, can missing address records break address resolution logic?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Sent Mnemonics Privacy] DELETE FROM sent_mnemonics removes mnemonic records - while this is intended cleanup, if these mnemonics were used for account recovery and the user hasn't backed them up elsewhere, can archiving cause permanent loss of wallet access?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Earned Headers Commission] Deleting from earned_headers_commission_recipients - if commission calculations depend on historical recipient records, can removing this data cause miscalculation of witness rewards in subsequent units?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Messages Deletion Order] Messages are deleted before the unit itself - if foreign key constraints exist from messages to units with ON DELETE CASCADE, can this cause unintended cascading deletes of related data in other tables?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Unit Deletion Timing] The unit is deleted from units table near the end - if validation logic checks unit existence before checking messages, can the window between message deletion and unit deletion cause validation to pass for invalid states?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Joint Deletion Final] The DELETE FROM joints is the last operation - if joints table references are used for caching or indexing, can other processes accessing the joint between unit deletion and joint deletion crash or return corrupted data?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Ball Data Preservation] The commented line '// DELETE FROM balls WHERE unit=?' suggests balls should be preserved - but if a unit has a ball (meaning it was stable), can archiving a stable unit break the last_ball chain and cause consensus divergence?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Witness Preservation] The function preserves witnesses and author addresses but deletes everything else - can a voided unit still participate in witness level calculations, potentially allowing malicious voided units to affect main chain determination?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Parent Retention] Unlike removeJoint, voidJoint doesn't delete from parenthoods - can voided units remain in the DAG structure as 'ghost nodes' that break graph traversal algorithms expecting all referenced units to have complete data?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Definition Chash Nullification Impact] Setting definition_chash=NULL but keeping the author record - if signature validation checks both the author and definition_chash, can this null value cause validation to fail in unexpected ways or bypass security checks?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Message-less Unit State] After voiding, a unit exists in the units table but has no messages - can queries that JOIN units with messages fail or return incorrect results, breaking balance calculations that expect all units to have at least one message?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendOutputsSpentInArchivedUnit()] [Nested Callback Chain] The function chains three callbacks (transfer, headers commission, witnessing) sequentially - if any callback invokes its continuation (cb) prematurely due to an error condition, can subsequent unspending steps be skipped, leaving some outputs incorrectly marked as spent?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendOutputsSpentInArchivedUnit()] [Callback Completion Order] The three unspending operations execute in a fixed order (transfer  headers  witnessing) - if witnessing outputs must be unspent before transfer outputs for correctness, can this ordering cause temporary inconsistent states that other concurrent transactions can observe?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Query Execution Async] The conn.query() is asynchronous and the callback adds UPDATE queries to arrQueries - if the array is modified by another process between query completion and callback execution, can queries be lost or duplicated?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Row Iteration Non-Atomic] The rows.forEach() loop adds multiple UPDATE queries - if arrQueries is executed before forEach completes due to a race condition, can some outputs be missed and remain permanently marked as spent?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Unit Parameter Trust] The unit parameter (objJoint.unit.unit) is passed directly to multiple DELETE and UPDATE statements - if the caller provides a malicious objJoint with crafted unit values containing SQL syntax, can this bypass parameterized queries and enable SQL injection?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Row Data Trust] The function uses row.src_unit, row.src_message_index, row.src_output_index directly from query results - if database data is corrupted or manipulated, can malicious values in these fields cause UPDATE statements to target wrong outputs?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [Address Field Injection] The row.address field is used directly in UPDATE statements - if addresses contain SQL special characters or escape sequences, can this cause syntax errors or security vulnerabilities?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint() and generateQueriesToVoidJoint()] [Dual Path Consistency] Both functions call generateQueriesToUnspendOutputsSpentInArchivedUnit() but then diverge in what they delete - if the unspending logic depends on certain records (e.g., messages) still existing during execution, can the subsequent deletions in removeJoint break assumptions that voidJoint preserves?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Archived JSON Completeness] The full objJoint is serialized to JSON and stored - if objJoint contains sensitive private keys, signatures, or other data that shouldn't be archived, can this create a security leak or compliance violation?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Reason Immutability] Once a unit is archived with a specific reason, can it be re-archived with a different reason, and if so, does the INSERT with getIgnore() prevent this or allow duplicate records?",
  "[File: byteball/ocore/archiving.js] [All Functions] [Transaction Scope] The file generates queries but doesn't explicitly wrap them in BEGIN/COMMIT - if the caller doesn't properly manage transaction boundaries and a subset of queries fails, can the database be left in a partially-archived state with some tables cleaned but others not?",
  "[File: byteball/ocore/archiving.js] [All Functions] [Rollback Safety] If a query in the arrQueries array fails during execution and triggers a rollback, but the rows.forEach() callbacks have already executed and produced side effects, can those side effects persist even though the database rolled back?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Nested Transaction] The SELECT query executes inside what might be a larger transaction - if the outer transaction has a different isolation level, can the SELECT see uncommitted data from other transactions, leading to incorrect unspending decisions?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Genesis Unit Archiving] If the genesis unit is somehow passed to this function, can deleting it break the entire DAG structure since all units transitively reference genesis, causing network consensus failure?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Self-Spending Unit] If a unit theoretically spends its own outputs (circular reference), can the unspending logic correctly handle this or create an infinite loop or inconsistent state?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Zero Rows Result] If the SELECT query returns zero rows (no transfer inputs in the unit), the callback is still invoked - can this cause issues if the callback expects at least one row, or does proper error handling depend on row count checks?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [MCI Boundary] If from_main_chain_index or to_main_chain_index is at the boundary of the valid MCI range (e.g., 0 or MAX_INT), can integer overflow or underflow in comparisons cause incorrect output selection?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Large Joint Object] If objJoint contains an extremely large unit (e.g., with thousands of messages or huge data payloads), can JSON.stringify() produce a string that exceeds database column limits, causing the INSERT to fail and leaving the unit in a 'partially archived' state?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Voided Witness Unit] If a witness's own unit is voided, can this affect witness level calculations since the unit exists but has no messages, potentially breaking main chain determination?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Query Array Size] The function adds 21 DELETE queries to arrQueries - if archiving thousands of units in a batch, can the arrQueries array grow so large that it exceeds memory limits or causes the database driver to fail?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Row Set Size] If a unit has inputs spending thousands of outputs (e.g., a consolidation transaction), can the rows.forEach() loop add so many UPDATE queries that execution becomes prohibitively slow or causes memory exhaustion?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [CROSS JOIN Explosion] The CROSS JOIN between inputs and headers_commission_outputs - if a unit has many inputs and there are many headers commission outputs in the MCI range, can this produce a result set so large that it crashes the database or consumes all memory?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Foreign Key Constraints] The function deletes from multiple tables without checking foreign key relationships - if other tables (not listed in the function) have foreign keys to these tables without ON DELETE CASCADE, can the deletions fail with constraint violations, leaving the database in an inconsistent state?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Missing Table Deletions] If new tables were added to the schema that reference units but aren't included in the deletion list (e.g., aa_var_values, aa_balances), can orphaned records persist indefinitely, causing database bloat and incorrect query results?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Partial Foreign Key Cleanup] Since voidJoint deletes fewer tables than removeJoint, can foreign key constraints from those preserved tables to deleted tables cause constraint violations, making it impossible to execute the queries?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Duplicate Archiving] If two processes attempt to archive the same unit simultaneously, can both pass the INSERT with getIgnore() but then both proceed to delete the unit's data, causing double-deletion errors or leaving the archived_joints entry without corresponding data?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Read-Write Race] The SELECT query reads current input states, then later UPDATE queries modify output states - if another transaction inserts new inputs spending the same outputs between the SELECT and UPDATE, can this race condition cause incorrect unspending?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Reason Mismatch] If the same unit is archived with reason='uncovered' by one process and reason='voided' by another, can the different code paths (removeJoint vs voidJoint) execute concurrently, causing some tables to be fully deleted while others are only partially cleaned?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Stale Query Problem] The SELECT query executes immediately during query generation, but the resulting UPDATE queries are added to arrQueries for later execution - if the database state changes between SELECT completion and UPDATE execution (e.g., new units are added), can the UPDATEs operate on stale data?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [MCI Movement] The query checks MCI ranges, but if the main chain advances between query generation and execution, can new headers commission outputs be created in the same MCI range, causing the UPDATE to unspend outputs that were just created?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [AA Response Chain Break] When deleting aa_responses WHERE trigger_unit=?, if this unit triggered multiple AAs and those AAs triggered secondary AAs, can deleting just the first-level responses leave orphaned secondary responses that reference non-existent trigger units?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [AA State Variable Orphans] The function doesn't explicitly delete from aa_var_values - if the archived unit caused state variable updates in an AA, can these state variables persist without their originating response, causing AA state to become inconsistent with actual transaction history?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Response Unit vs Trigger Unit] The DELETE deletes WHERE response_unit=? - if an AA response unit is archived, but the trigger unit that caused it is still valid, can this break the triggerresponse relationship and cause validation failures when querying AA execution history?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Asset Supply Corruption] If an archived unit issued a divisible asset and that asset is still held by users, can deleting the asset definition from the assets table cause total supply calculations to fail or become incorrect, breaking balance validation?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Indivisible Asset Serials] For indivisible assets, if the archived unit issued specific serials and those serials are still owned by users, can deleting asset metadata break serial tracking and allow duplicate serial issuance?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Balance Calculation Impact] When outputs are unspent, can the corresponding address balances become incorrect if the balance tracking system doesn't receive notification of the unspending, causing balance queries to return inflated amounts?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [Witness Reward Double-Claim] If a witness's headers commission output is unspent incorrectly, can the witness spend it again in a new unit, effectively claiming witness rewards twice and inflating the total bytes supply?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Light Client Catchup] If a light client is catching up and requests a unit that has been archived, can the missing unit data cause catchup to fail, leaving the light client permanently out of sync?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Witness Proof Validity] If a voided unit was used in witness proof construction for light clients, can the missing message data break proof verification, causing light clients to reject valid proofs?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Historical Query Failure] If external services (e.g., block explorers, analytics) query archived units, can the missing data cause these services to display errors or incorrect information, affecting user trust?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Definition Change Archiving] If an address changed its definition via definition_chg in the archived unit, and this was the only unit recording that change, can the address become stuck with an old definition that doesn't match current signing keys?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Definition Chash Null Recovery] After setting definition_chash=NULL in a voided unit, if the address needs to be used again, how is the definition recovered - can this lead to situations where no definition is available, making the address permanently unusable?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Original Address Mapping] Deleting from original_addresses - if this table maps between original (pre-definition-change) addresses and current addresses, can losing this mapping break address resolution for historical queries?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Unit Validation State] After voiding, the unit exists in units table but has no messages - can validation logic that checks 'does unit exist?' pass even though the unit is effectively empty, causing invalid references to be accepted?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Parent Unit Deletion] If a unit that is still referenced as a parent by non-archived units is archived, can this create invalid parent references that break DAG validation and cause consensus failures?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [Non-Deterministic Archiving] If different nodes archive units at different times or with different reasons, can this cause nodes to have different database states, leading to non-deterministic validation results and chain splits?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Attestation Dependency] If an AA's formula queries attestations for authentication and those attestations are archived, can the AA formula fail to execute correctly, causing all subsequent triggers to that AA to bounce?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Attested Fields Loss] Deleting from attested_fields - if these fields were used to verify user identity or attributes, can archiving break KYC/compliance requirements or allow users to re-attest with different information?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Poll Result Integrity] If a poll unit is archived while voting is still ongoing or results are being tallied, can this corrupt poll results or make it impossible to verify vote counts?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Vote Chain Break] Deleting votes that reference a poll - if vote units reference the poll by unit hash, can archiving the poll unit cause those vote units to become invalid, affecting governance decisions?",
  "[File: byteball/ocore/archiving.js] [All Functions] [Callback Error Propagation] None of the functions include explicit error handling in callbacks - if a database query fails, can the error be silently swallowed, leaving the archiving process incomplete with no indication to the caller?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendTransferOutputsSpentInArchivedUnit()] [Query Failure Handling] If the conn.query() call fails due to database error, is the callback still invoked with empty rows, or does execution halt, potentially leaving arrQueries in an incomplete state?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToArchiveJoint()] [INSERT Failure] If the INSERT INTO archived_joints fails (e.g., due to constraint violations or disk full), but the deletion queries have already been added to arrQueries, can the unit be deleted without being archived, causing permanent data loss?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Spend Proof Dependencies] If light clients rely on spend_proofs for validating transfers, can deleting these proofs cause light clients to reject legitimate historical transfers when syncing?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToVoidJoint()] [Proof Availability] The voidJoint function deletes spend_proofs but keeps the unit - can this inconsistency where a unit exists but its spend proofs don't cause validation mismatches between full and light nodes?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Headers Commission Recipients] Deleting earned_headers_commission_recipients - if commission distribution logic queries this table for historical data, can the missing records cause incorrect future commission calculations?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToUnspendHeadersCommissionOutputsSpentInArchivedUnit()] [Partial MCI Coverage] If an input's MCI range (from_main_chain_index to to_main_chain_index) partially overlaps with a headers commission output's MCI, but the comparison logic uses >= and <=, can outputs at range boundaries be incorrectly included or excluded from unspending?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Sent Mnemonic Removal] Deleting from sent_mnemonics - if this table stores recovery mnemonics sent to users and the unit recording the sending is archived, can users who haven't backed up their mnemonics lose wallet access permanently?",
  "[File: byteball/ocore/archiving.js] [Function: generateQueriesToRemoveJoint()] [Mnemonic-Address Linkage] If sent_mnemonics links mnemonics to addresses and both are deleted, can this break wallet recovery flows that depend on querying which addresses were associated with a mnemonic?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Input Validation] Can an attacker pass a maliciously crafted walletOrAddress parameter that bypasses the length check (line 9) by using unicode characters, special encodings, or null bytes to inject SQL code into the WHERE clause, potentially reading balances from arbitrary addresses?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Race Condition] If two concurrent calls to readBalance() for the same address execute while a unit spending outputs from that address is being committed to the database, can the balance calculation include outputs that are simultaneously marked as spent, resulting in incorrect balance reporting that could be exploited for double-spending?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Integer Overflow] In the SUM(amount) aggregation (lines 15-18), if an address has accumulated an extremely large number of small outputs whose total exceeds JavaScript's MAX_SAFE_INTEGER (2^53-1), can the balance overflow and wrap around to a negative or incorrect value, causing the wallet to display incorrect balances?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [SQL Injection via db.escape()] Does the db.escape() function properly sanitize all possible SQL injection vectors including encoded characters, comment sequences, and nested escape sequences when building the asset list query (line 57), or can an attacker craft an asset ID that breaks out of the IN clause?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Asset Confusion] If an attacker creates a custom asset with unit hash that equals the string 'base' or matches constants.BLACKBYTES_ASSET, can this cause the balance aggregation logic (lines 23-26) to incorrectly merge balances between the native asset and the malicious asset, potentially allowing theft or balance manipulation?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Sequence Bypass] The query filters for sequence='good' (line 17), but if a malicious node or database corruption causes units with sequence='temp-bad' or other invalid sequences to have is_spent=0, will these outputs still be excluded from balance calculation, or could they inflate the reported balance?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Stability Confusion] When aggregating balances by is_stable flag (lines 21-26), if a unit's stability status changes between the first query (line 14) and subsequent queries (lines 30-34, 45-46), can this cause double-counting of outputs as both stable and pending, inflating the total balance?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [BLACKBYTES Deletion Logic] The logic deletes BLACKBYTES_ASSET from assocBalances if both stable and pending are 0 (lines 40-41), but what if there exists a 0-balance asset entry from the third query (lines 45-63) that gets deleted prematurely, causing private asset information to be hidden from the wallet?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Witnessing Outputs Double-Count] The second query adds witnessing_outputs and headers_commission_outputs to base.stable (line 38), but if these same outputs are also present in the outputs table with is_spent=0, could they be counted twice, artificially inflating the base asset balance?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [NULL Asset Handling] In line 23, row.asset || 'base' converts NULL/undefined assets to 'base', but what if the database contains a custom asset with the literal string 'base' as its unit hash? Could this cause all outputs with asset=NULL to be aggregated with outputs of the malicious 'base' asset?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Callback Hell Race] The function uses three nested callbacks (lines 20, 36, 48, 57), and if the handleBalance callback is invoked multiple times due to error handling or timing issues, can this cause the consuming code to process incorrect or stale balance data, potentially leading to double-spend attempts?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [UNION ALL Injection] The second query uses UNION ALL to combine witnessing_outputs and headers_commission_outputs (lines 31-34). If the walletOrAddress parameter appears twice in the parameter array (line 35), but the query construction logic changes, could this cause parameter misalignment and return balances from the wrong address?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Asset Privacy Leak] The third query marks assets as is_private=1 if they exist in the assets table with is_private=1 (lines 57-59), but if an attacker queries balances for addresses they don't control, can they enumerate which private assets those addresses hold by observing the is_private flag in the returned data structure?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Empty Result Handling] If all three database queries return empty result sets (no outputs, no witnessing outputs, no assets), the function still calls handleBalance with an assocBalances object containing base:{stable:0, pending:0} (line 12), but should it also handle the case where the address has never existed on the DAG, preventing phantom balance queries?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Total Calculation Precision] The total balance is calculated as stable + pending (line 43), but in JavaScript, if stable and pending are very large floating-point numbers with different magnitudes, can floating-point precision errors cause the total to be incorrect, potentially leading to insufficient balance errors during transaction composition?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Database Index Missing] If the database lacks proper indexes on (address, is_spent, sequence) for the outputs table, can an attacker force full table scans by querying balances for many addresses simultaneously, causing a DoS condition that freezes balance queries network-wide for more than 1 hour?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Asset List SQL Injection] The query at line 57 builds an IN clause using assets.map(db.escape).join(', '), but if db.escape() has a bug or if the assets array contains objects instead of strings, could this allow SQL injection that modifies the is_private flag incorrectly?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [MY_ADDRESSES Join Safety] When walletOrAddress is a wallet (not an address), the query joins with my_addresses table (line 10). If the my_addresses table contains stale or incorrect entries due to database corruption or race conditions, can this cause balances to be reported for addresses the wallet doesn't actually control?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Cross-Database Consistency] If the node is using database replication (master-slave) and there's replication lag between the outputs table write and the witnessing_outputs table write, can readBalance() return inconsistent balances where some commission outputs are counted but their corresponding unit outputs are not yet visible?",
  "[File: byteball/ocore/balances.js] [Function: readBalance()] [Performance DoS] If an address has millions of small unspent outputs (dust outputs), will the SUM(amount) aggregation and GROUP BY operation (lines 15-18) cause the query to take excessive time (>1 hour), allowing an attacker to create dust-attack addresses and freeze balance queries for those addresses?",
  "[File: byteball/ocore/balances.js] [Function: readOutputsBalance()] [Missing Commission Outputs] Unlike readBalance(), this function does NOT query witnessing_outputs or headers_commission_outputs (compare lines 14-18 vs 76-80), so can an attacker exploit this discrepancy by using readOutputsBalance() to check if they have sufficient balance, then compose a transaction that fails because it doesn't account for commission outputs?",
  "[File: byteball/ocore/balances.js] [Function: readOutputsBalance()] [API Confusion] Since readOutputsBalance() and readBalance() have nearly identical signatures but different behavior, can calling code mistakenly use the wrong function and get incomplete balance information, leading to transactions that appear valid but are actually under-funded?",
  "[File: byteball/ocore/balances.js] [Function: readOutputsBalance()] [Integer Overflow] Same SUM(amount) overflow concern as readBalance() - if total outputs exceed MAX_SAFE_INTEGER, will the balance wrap around to an incorrect value (line 78)?",
  "[File: byteball/ocore/balances.js] [Function: readOutputsBalance()] [Input Validation Bypass] The walletIsAddress check (line 72) uses the same length === 32 heuristic. Can an attacker pass a 32-character string that isn't a valid address hash but still passes this check, causing the query to search for a non-existent address column value?",
  "[File: byteball/ocore/balances.js] [Function: readOutputsBalance()] [Race Condition on is_spent] If a unit spending outputs is committed between the WHERE is_spent=0 check and the SUM aggregation, can outputs that are being spent in parallel transactions be counted in the balance, leading to potential double-spend attempts?",
  "[File: byteball/ocore/balances.js] [Function: readSharedAddressesOnWallet()] [Prosaic Contract Filter] The query excludes addresses that are prosaic contracts via LEFT JOIN (lines 98-101), but if the prosaic_contracts table is missing entries due to database corruption, can this function incorrectly include prosaic contract addresses in the shared address list?",
  "[File: byteball/ocore/balances.js] [Function: readSharedAddressesOnWallet()] [Recursive Explosion] The function calls readSharedAddressesDependingOnAddresses() which is recursive (line 105). If there's a cycle in the shared_address_signing_paths table where address A is a member of shared address B, which is a member of shared address A, can this cause infinite recursion and stack overflow?",
  "[File: byteball/ocore/balances.js] [Function: readSharedAddressesOnWallet()] [Empty Result Fast Path] If the wallet has no shared addresses (line 103), the function returns an empty array. But should it also verify that the wallet exists and is valid, or could this leak information about which wallets exist on the node?",
  "[File: byteball/ocore/balances.js] [Function: readSharedAddressesOnWallet()] [SQL Injection via Wallet Param] The wallet parameter is passed directly into the SQL query (line 101). If the calling code doesn't sanitize this parameter and it contains SQL injection characters, can this extract sensitive information about all shared addresses in the database?",
  "[File: byteball/ocore/balances.js] [Function: readSharedAddressesDependingOnAddresses()] [IN Clause SQL Injection] The function builds an IN clause using arrMemberAddresses.map(db.escape).join(', ') (line 112). If arrMemberAddresses contains non-string values or objects, could db.escape() fail and allow SQL injection?",
  "[File: byteball/ocore/balances.js] [Function: readSharedAddressesDependingOnAddresses()] [Infinite Recursion] The function recursively calls itself (line 120). If the shared_address_signing_paths table contains cyclic relationships (A  B  C  A), will this cause a stack overflow that crashes the node, resulting in network halt for that node?",
  "[File: byteball/ocore/balances.js] [Function: readSharedAddressesDependingOnAddresses()] [Memory Exhaustion] If an attacker creates a deeply nested hierarchy of shared addresses (100+ levels deep), can the recursive calls accumulate enough stack frames and intermediate arrays to exhaust memory, causing the node to crash and halt transaction processing?",
  "[File: byteball/ocore/balances.js] [Function: readSharedAddressesDependingOnAddresses()] [Lodash Difference Bug] The function uses _.difference() to find new addresses (line 117). If lodash's implementation has a bug or if the arrays contain objects instead of strings, could this return incorrect results that cause some shared addresses to be missed?",
  "[File: byteball/ocore/balances.js] [Function: readSharedAddressesDependingOnAddresses()] [Callback Hell] The recursive structure with nested callbacks (lines 113, 120) makes it difficult to reason about error handling. If a database error occurs mid-recursion, will the handleSharedAddresses callback be invoked with partial data, potentially missing some shared addresses?",
  "[File: byteball/ocore/balances.js] [Function: readSharedAddressesDependingOnAddresses()] [Duplicate Address Detection] If the shared_address_signing_paths table has duplicate entries (same shared_address, same address), could this cause the same address to appear multiple times in the final array, leading to incorrect balance calculations in readSharedBalance()?",
  "[File: byteball/ocore/balances.js] [Function: readSharedBalance()] [UNION ALL Join Inconsistency] The query uses three SELECT statements combined with UNION ALL (lines 133-142). If the outputs, witnessing_outputs, and headers_commission_outputs tables have inconsistent is_spent states due to race conditions, can this cause outputs to be counted multiple times or missed entirely?",
  "[File: byteball/ocore/balances.js] [Function: readSharedBalance()] [IN Clause Size Limit] The function builds an IN clause from arrSharedAddresses (line 131). If a wallet has thousands of shared addresses, can this exceed the database's maximum query size or IN clause limit, causing the query to fail and preventing balance retrieval?",
  "[File: byteball/ocore/balances.js] [Function: readSharedBalance()] [Asset NULL Handling] Similar to readBalance(), the query converts NULL assets to 'base' (line 146). Can an attacker create a custom asset with unit hash 'base' to confuse the balance aggregation?",
  "[File: byteball/ocore/balances.js] [Function: readSharedBalance()] [Address-Level Balance Tracking] The function returns balances grouped by both asset AND address (lines 147-151), creating a nested structure assocBalances[asset][address]. If two addresses have balances in the same asset, is this structure correctly aggregated, or could calling code accidentally only read the first address's balance?",
  "[File: byteball/ocore/balances.js] [Function: readSharedBalance()] [Witnessing Output Hardcoded Stable] The query marks all witnessing_outputs and headers_commission_outputs as is_stable=1 (lines 138, 141). If these outputs should actually be pending (not yet stable), could this cause the wallet to incorrectly allow spending of unstable outputs, leading to transaction failures?",
  "[File: byteball/ocore/balances.js] [Function: readSharedBalance()] [Empty Shared Addresses] If readSharedAddressesOnWallet() returns an empty array, the function returns an empty assocBalances object (line 130). Should this instead return balances with all assets showing zero, to maintain consistency with readBalance()?",
  "[File: byteball/ocore/balances.js] [Function: readSharedBalance()] [SQL Injection via Address List] Although addresses are escaped using db.escape() (line 131), if the array contains extremely long strings or special characters that cause db.escape() to fail or produce invalid SQL, could this crash the query or leak information?",
  "[File: byteball/ocore/balances.js] [Function: readSharedBalance()] [Balance Increment Bug] The balance aggregation uses += operator (line 151). If the assocBalances structure is corrupted or if row.balance is not a number (e.g., NULL, undefined, string), could this cause NaN to propagate through all balance calculations?",
  "[File: byteball/ocore/balances.js] [Function: readSharedBalance()] [Sequence Filter Missing] Unlike readBalance() and readOutputsBalance(), this function's outputs query doesn't explicitly filter by sequence='good' (line 135). If bad sequence units have is_spent=0, will their outputs be incorrectly included in shared address balances?",
  "[File: byteball/ocore/balances.js] [Function: readSharedBalance()] [Cross-Asset Total Bug] The function calculates total = stable + pending for each asset and address (line 155), but if stable or pending are undefined because is_stable returned unexpected values (not 0 or 1), could this result in incorrect totals?",
  "[File: byteball/ocore/balances.js] [Function: readAllUnspentOutputs()] [exclude_from_circulation Type] The function accepts exclude_from_circulation as an array (line 164), but if calling code passes a Set, Map, or other iterable, will the .includes() check (line 180) work correctly, or could this cause addresses that should be excluded to be counted in circulating supply?",
  "[File: byteball/ocore/balances.js] [Function: readAllUnspentOutputs()] [Total Supply Manipulation] The function calculates total_amount by summing all unspent outputs including those in exclude_from_circulation addresses (line 179), then separately calculates circulating_amount (line 182). If an attacker controls addresses in exclude_from_circulation and can manipulate is_spent flags, can they inflate or deflate the reported circulating supply?",
  "[File: byteball/ocore/balances.js] [Function: readAllUnspentOutputs()] [Asset Filter Missing] The first query filters for 'asset IS null' (line 174), meaning it only counts base asset outputs. If calling code expects this function to return total supply for custom assets as well, will this missing functionality cause supply calculations to be completely wrong for all non-base assets?",
  "[File: byteball/ocore/balances.js] [Function: readAllUnspentOutputs()] [Integer Overflow in Supply] If the total supply of base asset outputs exceeds MAX_SAFE_INTEGER (2^53-1 bytes, approximately 9 million gigabytes), will the SUM(amount) aggregation (line 174) overflow and wrap around, causing the reported total supply to be incorrect?",
  "[File: byteball/ocore/balances.js] [Function: readAllUnspentOutputs()] [Commission Output Separation] The function adds headers_commission_amount and payload_commission_amount to both total_amount and circulating_amount (lines 189-191), but should these be excluded from circulating supply if they're locked/unvested? Could this overstate the actual circulating supply?",
  "[File: byteball/ocore/balances.js] [Function: readAllUnspentOutputs()] [UNION Query Injection] The second query uses UNION to combine headers_commission_outputs and witnessing_outputs (line 186). If either table name is dynamically constructed or if there's SQL injection in the table names, could this query extract data from other tables?",
  "[File: byteball/ocore/balances.js] [Function: readAllUnspentOutputs()] [Address Count Accuracy] The function counts supply.addresses from the number of distinct addresses with unspent outputs (line 176). If the same address appears in both outputs and witnessing_outputs tables, is it counted once or twice? Could this inflate the address count metric?",
  "[File: byteball/ocore/balances.js] [Function: readAllUnspentOutputs()] [forEach Type Safety] The function uses rows.forEach() (lines 177, 188) assuming rows is an array. If a database error returns a non-array result or if rows is null/undefined, will this cause a crash that halts supply calculation queries?",
  "[File: byteball/ocore/balances.js] [Function: readAllUnspentOutputs()] [Exclude List Bypass] If exclude_from_circulation contains address strings, but the database stores addresses in a different encoding (e.g., uppercase vs lowercase, with checksums), will the .includes() check (line 180) fail to match, causing excluded addresses to be incorrectly counted in circulating supply?",
  "[File: byteball/ocore/balances.js] [Function: readAllUnspentOutputs()] [Missing Error Handling] Neither query has explicit error handling (lines 174, 186). If a database error occurs, will the handleSupply callback be invoked with partial or zero data, potentially causing calling code to report incorrect supply metrics?",
  "[File: byteball/ocore/balances.js] [General] [Database Transaction Isolation] None of the functions use explicit database transactions or locks. If multiple balance queries execute concurrently while outputs are being marked as spent, can different queries return inconsistent views of the UTXO set, causing balance calculation errors?",
  "[File: byteball/ocore/balances.js] [General] [is_spent Race Condition] All functions rely on is_spent=0 to identify unspent outputs. If the database update that sets is_spent=1 is not atomic with the unit commit, can there be a window where outputs are already spent on the DAG but still show as unspent in balance queries?",
  "[File: byteball/ocore/balances.js] [General] [Asset Type Validation] None of the functions validate that asset identifiers are valid unit hashes (44 characters, base64). Can an attacker insert rows into outputs table with invalid asset values that cause db.escape() or other downstream functions to behave incorrectly?",
  "[File: byteball/ocore/balances.js] [General] [Database Connection Pooling] If the db module uses connection pooling and a connection is reused between queries with different transaction isolation levels, can this cause non-repeatable reads where the same address shows different balances between sequential queries?",
  "[File: byteball/ocore/balances.js] [General] [Callback Execution Order] All functions use asynchronous callbacks. If calling code doesn't properly sequence balance queries and transaction composition, can a race condition occur where a transaction is composed using stale balance data that doesn't reflect recently confirmed units?",
  "[File: byteball/ocore/balances.js] [General] [Memory Leak in Aggregation] If assocBalances objects accumulate many assets and addresses without cleanup (especially in long-running processes), can this cause memory exhaustion over time, eventually crashing the node after hours of operation?",
  "[File: byteball/ocore/balances.js] [General] [Console.log Performance] Line 60 logs timing information using console.log(). If this function is called thousands of times per second during high transaction volume, can the console I/O become a bottleneck that delays balance queries and transaction composition for >1 hour?",
  "[File: byteball/ocore/balances.js] [General] [NULL vs Undefined Handling] The code doesn't consistently distinguish between NULL (from database) and undefined (from JavaScript). If asset or amount fields are NULL vs undefined, could this cause unexpected behavior in the || operator or arithmetic operations?",
  "[File: byteball/ocore/balances.js] [General] [Database Schema Mismatch] If the database schema doesn't match expectations (e.g., amount column is TEXT instead of INTEGER, or is_stable is 0/1 instead of boolean), will the SUM aggregations and balance calculations produce incorrect results?",
  "[File: byteball/ocore/balances.js] [General] [Witness vs Non-Witness Output Priority] The functions don't distinguish between outputs created by regular transactions vs witness transactions. If witnesses can create outputs with special properties, could this allow witness-created outputs to be double-counted or excluded incorrectly?",
  "[File: byteball/ocore/balances.js] [General] [Security Context Leak] If balance query functions are exposed via an API or RPC interface, can an attacker enumerate all addresses and their balances on the node by calling these functions repeatedly with different wallet/address parameters?",
  "[File: byteball/ocore/balances.js] [General] [is_private Flag Trust] The functions trust the is_private flag from the assets table (lines 57-59). If an attacker can manipulate this flag through a bug in asset creation code, can they make private assets appear as public or vice versa, breaking privacy guarantees?",
  "[File: byteball/ocore/balances.js] [General] [BLACKBYTES Constant Dependency] The code imports constants.BLACKBYTES_ASSET (line 4) but doesn't validate that this constant is correctly defined. If constants.js is corrupted or the constant is undefined, will all BLACKBYTES balance calculations fail silently?",
  "[File: byteball/ocore/balances.js] [General] [Lodash Version Vulnerability] The file imports lodash (line 3) but doesn't specify a version. If the node uses an outdated lodash version with known vulnerabilities (e.g., prototype pollution), can an attacker exploit this through the _.difference() call to corrupt balance data structures?",
  "[File: byteball/ocore/balances.js] [General] [Error Propagation] None of the functions have try-catch blocks or error callbacks. If a JavaScript runtime error occurs (e.g., TypeError, ReferenceError), will the error propagate up to crash the entire node process, causing network halt?",
  "[File: byteball/ocore/balances.js] [General] [Database Query Timeout] The functions don't set query timeouts. If a balance query hangs indefinitely due to database lock contention or deadlock, can this cause the entire node to become unresponsive for >24 hours until manual intervention?",
  "[File: byteball/ocore/balances.js] [General] [Parallel Query Inconsistency] readBalance() executes three queries in sequence (lines 14, 30, 45), but outputs could be added or spent between queries. Can this window of inconsistency cause the same output to be counted in multiple queries or missed entirely?",
  "[File: byteball/ocore/balances.js] [General] [GROUP BY Determinism] The queries use GROUP BY asset, is_stable (lines 18, 80) but don't specify an ORDER BY. If the database returns rows in non-deterministic order, could this cause balance calculations to be non-deterministic across nodes, leading to consensus failure?",
  "[File: byteball/ocore/balances.js] [General] [Total Calculation Atomicity] The total balance is calculated in JavaScript (line 43, 91, 155) rather than in the SQL query. If the stable or pending values change between the query and the calculation, can this cause the total to not equal stable + pending?",
  "[File: byteball/ocore/balances.js] [General] [Database Index Cardinality] If the is_spent column has poor cardinality (most outputs are spent), will the database optimizer choose suboptimal query plans that cause balance queries to perform full table scans, leading to >1 hour delays on large UTXO sets?",
  "[File: byteball/ocore/balances.js] [General] [Foreign Key Constraint Missing] If the outputs table doesn't have foreign key constraints to the units table, can orphaned outputs exist (unit deleted but outputs remain), causing balances to include outputs from non-existent units?",
  "[File: byteball/ocore/balances.js] [General] [Cascade Delete Risk] If the database uses CASCADE DELETE on foreign keys and a unit is deleted, will all its outputs be automatically deleted even if is_spent=0, causing funds to permanently disappear from balance calculations?",
  "[File: byteball/ocore/balances.js] [General] [Address Validation Weakness] The walletIsAddress check (line 9, 72) only validates length, not content. Can an attacker pass a 32-character string of special characters that causes SQL parser errors or injection when used in the WHERE clause?",
  "[File: byteball/ocore/balances.js] [General] [Commission Output Staleness] If witnessing_outputs and headers_commission_outputs are not updated when main chain advances, can these tables contain stale commission outputs that should have been spent or expired, inflating balance calculations?",
  "[File: byteball/ocore/balances.js] [General] [Callback Ordering Ambiguity] If handleBalance or handleSharedAddresses callbacks modify global state or trigger additional database operations, can callback re-entrancy cause race conditions where balance queries interfere with each other?",
  "[File: byteball/ocore/balances.js] [General] [Shared Address Cycle Detection] The recursive readSharedAddressesDependingOnAddresses() doesn't explicitly detect cycles. If shared addresses form a cycle (ABA), will the function eventually hit a stack overflow, or does the _.difference() check prevent infinite recursion?",
  "[File: byteball/ocore/balances.js] [General] [Asset Array Empty Check] When building the IN clause for assets (line 57), if assets.length === 0, does the query still execute correctly, or does it produce invalid SQL like 'WHERE unit IN()', causing a syntax error?",
  "[File: byteball/ocore/balances.js] [General] [JavaScript Number Precision] All balance amounts are stored as JavaScript numbers. For assets with high decimals (e.g., 18 decimals like Ethereum tokens), can precision loss occur when performing arithmetic operations like total = stable + pending, causing small balance errors to accumulate?",
  "[File: byteball/ocore/balances.js] [General] [Start Time Manipulation] The function records start_time = Date.now() (line 8) and logs elapsed time (line 60). If system time changes during execution (NTP sync, manual adjustment), can this cause negative elapsed times or overflow, potentially breaking monitoring systems?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Hub Response Validation] Can a compromised or malicious hub send arbitrary bot data without validation in the 'hub/get_bots' response, potentially injecting malicious pairing codes, overlong names, or malformed data structures that could crash the node or corrupt the bots_cache?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Array Injection] If the hub returns a non-array response (e.g., object, null, string) to 'hub/get_bots', will async.eachSeries fail gracefully or throw an uncaught exception that crashes the node, causing a temporary network halt?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Bot Data Structure] Does the code validate that each bot object contains required fields (id, pairing_code, name) before processing, or can a malformed bot object without pairing_code cause setPairingStatus() to crash when calling substr()?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Memory Exhaustion] Can a malicious hub send an extremely large array of bots (e.g., millions of entries) in the 'hub/get_bots' response, exhausting node memory and causing a crash that prevents transaction processing?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Duplicate Bot IDs] If the hub sends multiple bot objects with identical IDs, will they all be stored in bots_cache, and can this cause getBotByID() to return the wrong bot or create confusion in pairing status checks?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Pairing Code Parsing] If bot.pairing_code does not contain an '@' character, indexOf() returns -1, causing substr(0, -1) to extract an incorrect pubkey substring - can this lead to deriving wrong device addresses and incorrect pairing status?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Empty Pairing Code] If bot.pairing_code is an empty string or contains only '@', will the extracted pubkey be empty, and will objectHash.getDeviceAddress() produce a predictable device address that could match multiple bots?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Pairing Code Format] If pairing_code contains multiple '@' symbols (e.g., 'pubkey1@hub@extra'), does indexOf('@') return the first occurrence, and could this cause incorrect pubkey extraction if the format is 'pubkey@hub' but hub contains '@'?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Non-String Pairing Code] If bot.pairing_code is not a string (e.g., number, object, null), will substr() and indexOf() throw an exception, crashing the async.eachSeries iteration and preventing completion of load()?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Whitespace in Pubkey] If the extracted pubkey contains leading/trailing whitespace or newlines due to malformed pairing_code, will objectHash.getDeviceAddress() produce an incorrect device address, causing false negative pairing status?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Device Address Collision] Can two different pubkeys in pairing codes result in the same device address from getDeviceAddress() due to hash collisions, causing multiple bots to share the same isPaired status incorrectly?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Invalid Pubkey Format] If the extracted pubkey is not valid base64 or has incorrect length (not 44 characters as expected), will objectHash.getDeviceAddress() fail silently, throw an exception, or produce a malformed device address that breaks SQL query?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Device Address Length] If getDeviceAddress() returns a device address longer than 33 characters (the CHAR(33) constraint in correspondent_devices table), will the SQL query fail or truncate the address, causing incorrect pairing checks?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [SQL Injection] Although the query uses parameterized queries with '?' placeholder, if device_address contains special characters or SQL syntax, could this bypass parameter binding in certain database engines and enable SQL injection?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Database Unavailability] If db.query() fails due to database connection loss or corruption, is the error caught and handled, or will the callback never be invoked, causing load() to hang indefinitely with async.eachSeries stuck?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Query Result Interpretation] The code assumes rows.length == 1 means paired, but what if a database race condition or corruption causes multiple rows with the same device_address to exist - will isPaired be true even if the wrong correspondent is matched?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Null Device Address] If objectHash.getDeviceAddress() returns null or undefined due to an error, will the SQL query search for 'NULL' string or actual NULL value, and could this match unintended correspondent_devices entries?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Cache Race Condition] If load() is called multiple times concurrently (e.g., from different parts of the application), can multiple hub requests complete simultaneously and cause bots_cache to be overwritten non-atomically, losing bot data?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Cache Inconsistency] Between the time bot.isPaired is set in async.eachSeries and bots_cache assignment, if another load() call completes, will the first call's processed bots be lost, causing stale pairing status?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Partial Cache Update] If async.eachSeries fails mid-iteration (e.g., database error on one bot), will bots_cache be partially updated with some bots having isPaired and others not, causing inconsistent state?",
  "[File: byteball/ocore/bots.js] [Function: getBotByID()] [Cache Stale Data] If a bot's pairing status changes in the database after load() completes, will getBotByID() return stale isPaired status from bots_cache, misleading the application about pairing state?",
  "[File: byteball/ocore/bots.js] [Function: getBotByID()] [Cache Cleared Race] If bots_cache is set to empty array or cleared between checking for-loop condition and accessing bots_cache[i], could this cause an out-of-bounds access or return undefined?",
  "[File: byteball/ocore/bots.js] [Variable: bots_cache] [Global State Mutation] Since bots_cache is a module-level array, can malicious code in other modules directly modify it (push/pop/splice), injecting fake bots or removing legitimate ones to manipulate pairing checks?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Hub Request Failure] If device.requestFromHub() returns an error (network timeout, hub down, malformed response), the error is passed to callback but bots_cache may retain old stale data - could this cause operations to proceed with outdated bot information?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Callback Error Propagation] If err != null in the hub response, the callback is invoked with (err, null), but bots_cache is not cleared - will subsequent getBotByID() calls return stale cached bots even after load failure?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Uncaught Exceptions] If bot.pairing_code.substr() throws an exception due to null/undefined pairing_code, will this be caught by async.eachSeries, or will it propagate and crash the entire load() operation?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Database Error Silence] If db.query() silently fails without invoking the callback (database engine bug), will async.eachSeries hang forever, preventing load() from completing and blocking bot-dependent operations?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Async Error Handling] If setPairingStatus() throws a synchronous exception before calling cb(), will async.eachSeries catch it, or will the uncaught exception crash the node and prevent transaction processing?",
  "[File: byteball/ocore/bots.js] [Function: getBotByID()] [Multiple Callback Invocations] If multiple bots in bots_cache have the same ID, will setPairingStatus() be called multiple times, and will the callback cb be invoked multiple times, causing unexpected behavior in calling code?",
  "[File: byteball/ocore/bots.js] [Function: getBotByID()] [No Bot Found] If no bot matches the requested ID, getBotByID() returns undefined implicitly without invoking the callback - will calling code hang waiting for callback, causing application freeze?",
  "[File: byteball/ocore/bots.js] [Function: setBotPairingStatus()] [Callback Before State Update] The callback cb(bot) is invoked immediately after setting bot.isPaired, but is this synchronous mutation visible to other concurrent operations on the same bot object before callback completes?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Callback Timing] The final callback cb(err, bots) is invoked after bots_cache assignment, but if calling code immediately calls getBotByID(), is there a guarantee that bots_cache is fully updated with all isPaired fields?",
  "[File: byteball/ocore/bots.js] [Function: getBotByID()] [ID Type Validation] If the id parameter is not a string/number but an object or array, will the equality check (bot.id == id) use type coercion incorrectly, matching unintended bots?",
  "[File: byteball/ocore/bots.js] [Function: getBotByID()] [Null/Undefined ID] If getBotByID() is called with null or undefined as id parameter, will the for-loop iterate through all bots without match, silently returning undefined, or could this cause unexpected behavior?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Callback Type] If load() is called without a callback or with a non-function callback parameter, will the code throw 'cb is not a function' exception when trying to invoke cb(err, null) or cb(err, bots)?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Bot Object Validation] If the bot parameter passed to setPairingStatus() is null or not an object, will bot.pairing_code.substr() throw immediately, and is this exception properly caught?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Sequential Processing] Using async.eachSeries processes bots sequentially - if hub returns thousands of bots, will this cause load() to take minutes to complete, blocking operations that depend on bot data?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Database Query per Bot] Each bot requires a separate db.query() call - with thousands of bots, could this create a database query storm, overwhelming the database and slowing down critical transaction validation?",
  "[File: byteball/ocore/bots.js] [Function: getBotByID()] [Linear Search] The for-in loop searches bots_cache linearly - with a large cache, will repeated getBotByID() calls create O(n) performance issues, and could an attacker deliberately trigger this to slow down the node?",
  "[File: byteball/ocore/bots.js] [Variable: bots_cache] [Memory Growth] If load() is called repeatedly (e.g., on timer or user action) and bots_cache grows each time due to bugs, could unbounded cache growth eventually exhaust node memory and crash the process?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Hub Dependency] If device.requestFromHub() has a vulnerability (e.g., request forgery, MITM), could an attacker inject malicious bot data that appears legitimate, causing users to pair with attacker-controlled bots?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Device Address Derivation] If objectHash.getDeviceAddress() has a bug that produces predictable or colliding device addresses, could this cause isPaired to be incorrectly true/false, affecting user pairing decisions?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Database Table Schema] If the correspondent_devices table schema changes (e.g., device_address column renamed), will the hardcoded SQL query fail silently or throw, and is there any schema version check?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Hub Command Injection] If the 'hub/get_bots' command string is ever constructed dynamically (though it's not currently), could command injection in device.requestFromHub() allow an attacker to request arbitrary hub endpoints?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Pairing Status Persistence] The isPaired flag is computed from database query but stored only in-memory - if a bot is paired/unpaired in correspondent_devices after load(), will stale cache cause incorrect decisions until next load()?",
  "[File: byteball/ocore/bots.js] [Function: getBotByID()] [Reference vs Copy] Does getBotByID() return a reference to the cached bot object or a copy - if reference, can calling code mutate bot.isPaired and corrupt cache state for other consumers?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Bot Object Mutation] The code mutates bot.isPaired = handled_bot.isPaired in the async iterator - if the bots array from hub contains shared objects or prototypes, could mutation affect unexpected objects?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Device Address Mutation] The code adds bot.device_address property to the bot object - if this bot object is shared or cached elsewhere, could this mutation cause side effects in other modules that expect a different bot structure?",
  "[File: byteball/ocore/bots.js] [Function: load()] [Hub Response Delay] If device.requestFromHub() takes a long time to respond (slow network), and load() is called again during the wait, can multiple concurrent hub requests create race conditions when all complete and update bots_cache?",
  "[File: byteball/ocore/bots.js] [Function: setPairingStatus()] [Database Read Timing] If a correspondent_devices row is inserted/deleted between the time load() starts and the specific bot's db.query() executes, could isPaired reflect an intermediate state that becomes invalid by the time load() completes?",
  "[File: byteball/ocore/bots.js] [Function: getBotByID()] [Cache Update Timing] If load() is updating bots_cache while getBotByID() is iterating the for-in loop, could the iterator see a partially-updated cache with some bots missing isPaired fields?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Memory exhaustion] Can an attacker trigger rapid breadcrumb additions from critical paths (e.g., during validation.js double-spend detection or network.js peer message processing) to exceed the MAX_LENGTH limit of 200 entries repeatedly, causing memory thrashing and potential node crashes during critical consensus operations?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [Memory leak] Since arrBreadcrumbs is a module-level global array that persists for the lifetime of the Node.js process, can an attacker cause unbounded memory growth by triggering breadcrumb additions faster than the shift() operation can remove old entries, especially during network catchup or validation storms?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [DoS via shift() operation] When arrBreadcrumbs.length exceeds MAX_LENGTH (200), the shift() operation at line 14 has O(n) time complexity for array reindexing - can an attacker trigger continuous breadcrumb additions during main chain selection or unit validation to cause performance degradation leading to temporary network freezing (1 hour delay)?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: MAX_LENGTH] [Resource exhaustion] The MAX_LENGTH constant of 200 breadcrumbs with timestamps and messages could consume significant memory if each breadcrumb contains large string payloads (e.g., unit hashes, conflicting unit lists from validation.js) - can this cause memory exhaustion during high-load scenarios like massive unit validation or network sync?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Information disclosure] Breadcrumbs logged via console.log() at line 16 expose sensitive protocol state including unit hashes, addresses, witness operations, and network peer URLs (as seen in network.js usage) - can this leak private transaction patterns or network topology to unauthorized observers with access to logs?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: get()] [Privacy leak] The get() function returns the raw arrBreadcrumbs array without sanitization - if this is exposed via an API or debugging interface, can attackers extract sensitive information about recent validation failures, double-spend attempts, conflicting units, or network peer connections that should remain internal?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Timing attack] Each breadcrumb includes Date().toString() timestamp at line 15 - can timing analysis of breadcrumb sequences reveal sensitive protocol internals like main chain advancement patterns, witness vote timing, or unit validation ordering that could be exploited for MEV-style attacks or network manipulation?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Forensic analysis] Breadcrumbs persist in memory and contain detailed traces of validation logic from validation.js (e.g., 'found conflicting units', 'will accept a conflicting unit') - can this forensic data be extracted by an attacker who gains partial access to the node process to reconstruct security-sensitive decision-making?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Race condition] The add() function performs non-atomic operations (length check, shift, push) on the shared arrBreadcrumbs array at lines 13-15 - can concurrent calls from multiple async operations (e.g., parallel unit validation, simultaneous network message handling) cause array corruption or lost breadcrumbs?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: get()] [TOCTOU vulnerability] The get() function returns a direct reference to arrBreadcrumbs rather than a copy - can a caller mutate the array while another thread is calling add(), causing race conditions or corrupted state in the breadcrumb history?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [Cross-module contamination] Since arrBreadcrumbs is shared globally across all modules (validation.js, network.js, main_chain.js, wallet.js, writer.js, etc.), can breadcrumbs from unrelated operations interleave in ways that corrupt debugging context or cause misdiagnosis of critical issues during incident response?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Non-deterministic ordering] When multiple async operations add breadcrumbs concurrently during unit processing, the ordering depends on event loop scheduling - can this non-determinism obscure the actual causality chain during critical debugging scenarios like investigating double-spend attempts or main chain fork diagnosis?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Log injection] The breadcrumb parameter is concatenated directly into the array at line 15 without sanitization - can an attacker craft malicious unit hashes, addresses, or peer messages containing newline characters, ANSI escape codes, or control characters to corrupt log output or inject fake breadcrumb entries?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Console.log side effects] If console.log() at line 16 is redirected to a network logging service or file with size limits, can an attacker trigger excessive breadcrumb additions to cause log rotation failures, disk exhaustion, or logging service crashes that impair node operation monitoring?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Prototype pollution] If the breadcrumb parameter contains malicious object properties (e.g., __proto__, constructor), can string conversion via Date().toString() + ': ' + breadcrumb trigger prototype pollution or cause unexpected behavior in the JavaScript runtime?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [String coercion vulnerability] The breadcrumb parameter undergoes implicit string concatenation at line 15 - if an attacker passes an object with a malicious toString() method from a compromised peer message or crafted unit, can this execute arbitrary code or cause exceptions during breadcrumb addition?",
  "[File: byteball/ocore/breadcrumbs.js] [Integration: validation.js] [Double-spend detection interference] When validation.js adds breadcrumbs about conflicting units at lines 1141-1142, can the overhead of breadcrumb addition (Date() calls, array operations, console.log) delay critical validation checks enough to allow a time-of-check-time-of-use race condition in double-spend detection?",
  "[File: byteball/ocore/breadcrumbs.js] [Integration: main_chain.js] [Consensus timing impact] Main_chain.js adds breadcrumbs during stability point advancement (lines 1158, 1164) while holding mutex locks - can the breadcrumb addition overhead cause lock contention or delays that impact main chain monotonicity or stability point determination?",
  "[File: byteball/ocore/breadcrumbs.js] [Integration: network.js] [Peer communication timing] Network.js adds breadcrumbs during WebSocket connection establishment (line 449) - can malicious peers trigger connection storms that flood breadcrumbs, causing memory pressure or console.log blocking that delays legitimate peer message processing?",
  "[File: byteball/ocore/breadcrumbs.js] [Integration: writer.js] [Unit writing delays] Writer.js adds breadcrumbs during unit writing operations - if breadcrumb addition fails or hangs (e.g., console.log blocks on a full pipe), can this prevent new units from being written to the DAG, causing temporary network freezing?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Exception handling] The add() function has no try-catch blocks around Date().toString(), string concatenation, array operations, or console.log() - if any of these operations throw exceptions (e.g., out-of-memory, console.log failure), can this crash critical code paths in validation.js or network.js that call add()?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Undefined/null handling] If breadcrumb is undefined, null, or other non-string types, the concatenation at line 15 will coerce to string ('undefined', 'null') - can this obscure actual debugging information or cause confusion when investigating protocol issues?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: get()] [Empty array handling] The get() function returns arrBreadcrumbs even if empty - can code that depends on breadcrumb history for debugging or forensic analysis fail silently or make incorrect assumptions when the array is empty due to recent process restart?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [Persistence across errors] If a critical error occurs (e.g., database corruption, consensus failure), breadcrumbs persist across error recovery attempts - can stale breadcrumbs from pre-error state contaminate post-error debugging and lead to misdiagnosis?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Type validation] The add() function accepts any parameter type without validation - can passing objects, arrays, functions, or circular references as breadcrumb cause memory leaks, infinite loops during string conversion, or exceptions that crash the node?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Large payload handling] If calling code passes extremely large strings as breadcrumbs (e.g., entire unit objects, large arrays of conflicting unit hashes), can this cause memory exhaustion, slow string concatenation, or console.log blocking that impacts protocol performance?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: MAX_LENGTH] [Constant manipulation] While MAX_LENGTH is defined as a var (not const) at line 9, can other modules that require breadcrumbs.js modify this value to bypass the intended limit of 200 entries, causing unbounded memory growth?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Non-deterministic timestamps] The Date().toString() call at line 15 uses system time which may differ across nodes - if breadcrumb content (including timestamps) is ever serialized and compared across nodes, can timestamp differences cause false divergence detection or consensus issues?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [Non-deterministic state] Since breadcrumb accumulation depends on timing of async operations, different nodes may have different breadcrumb histories even when processing identical units - can this non-determinism complicate cross-node debugging or cause confusion during security incident investigation?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Side effect during validation] Breadcrumbs are added during deterministic validation operations in validation.js - while the breadcrumb itself doesn't affect validation outcome, can exceptions or performance issues from breadcrumb addition cause validation to fail inconsistently across nodes?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: get()] [Unused function] The get() function is never called in the codebase based on grep search - if this function is intended for external debugging tools or manual inspection, can unauthorized access to breadcrumb history via this function expose sensitive protocol state to attackers?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Console.log dependency] The module assumes console.log is available and synchronous - if the Node.js process is started with console redirection or in an environment where console.log is unavailable/async, can this cause exceptions or deadlocks during breadcrumb addition?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [Memory forensics] Since breadcrumbs contain detailed traces of recent protocol operations, can an attacker who gains read access to node memory (e.g., via heap dump, core dump, or side-channel) extract sensitive information about unit validation logic, network topology, or witness operations?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [CPU overhead] Each breadcrumb addition involves Date() creation, toString() conversion, string concatenation, length check, potential shift(), array push(), and console.log() - can this CPU overhead accumulate during high-throughput scenarios (e.g., network sync, validation storms) to cause node performance degradation?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [I/O blocking] Console.log() may perform blocking I/O if stdout is buffered or redirected to a file - can this cause critical async operations in validation.js, network.js, or main_chain.js to stall while waiting for console writes to complete?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [GC pressure] Continuously shifting and pushing breadcrumbs creates short-lived string objects that increase garbage collection pressure - can this cause GC pauses during critical operations like main chain advancement or unit validation, leading to network delays?",
  "[File: byteball/ocore/breadcrumbs.js] [Usage: validation.js conflicting units] When validation.js logs 'found conflicting units' breadcrumbs, can an attacker intentionally create units that trigger maximum breadcrumb additions (by crafting units with many conflicting ancestors) to cause DoS via memory exhaustion or console flooding?",
  "[File: byteball/ocore/breadcrumbs.js] [Usage: network.js peer connections] Network.js logs peer connection URLs in breadcrumbs (e.g., 'connected to <url>') - can an attacker operating a malicious peer with specially crafted hostnames or URLs cause injection attacks, log corruption, or information disclosure when these URLs are logged?",
  "[File: byteball/ocore/breadcrumbs.js] [Usage: main_chain.js mutex operations] Main_chain.js adds breadcrumbs while holding write locks - can breadcrumb addition failures or delays (e.g., console.log blocking) cause mutex deadlocks that freeze main chain advancement and trigger total network shutdown?",
  "[File: byteball/ocore/breadcrumbs.js] [Usage: writer.js unit writing] Writer.js logs breadcrumbs during unit writing - if an attacker crafts units that maximize breadcrumb additions during writing, can the accumulated overhead cause unit writing delays that lead to transaction processing delays (1 hour) violating Immunefi medium severity impact?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Memory exhaustion] Can an attacker trigger rapid breadcrumb additions from critical paths (e.g., during validation.js double-spend detection or network.js peer message processing) to exceed the MAX_LENGTH limit of 200 entries repeatedly, causing memory thrashing and potential node crashes during critical consensus operations?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [Memory leak] Since arrBreadcrumbs is a module-level global array that persists for the lifetime of the Node.js process, can an attacker cause unbounded memory growth by triggering breadcrumb additions faster than the shift() operation can remove old entries, especially during network catchup or validation storms?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [DoS via shift() operation] When arrBreadcrumbs.length exceeds MAX_LENGTH (200), the shift() operation at line 14 has O(n) time complexity for array reindexing - can an attacker trigger continuous breadcrumb additions during main chain selection or unit validation to cause performance degradation leading to temporary network freezing (1 hour delay)?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: MAX_LENGTH] [Resource exhaustion] The MAX_LENGTH constant of 200 breadcrumbs with timestamps and messages could consume significant memory if each breadcrumb contains large string payloads (e.g., unit hashes, conflicting unit lists from validation.js) - can this cause memory exhaustion during high-load scenarios like massive unit validation or network sync?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Information disclosure] Breadcrumbs logged via console.log() at line 16 expose sensitive protocol state including unit hashes, addresses, witness operations, and network peer URLs (as seen in network.js usage) - can this leak private transaction patterns or network topology to unauthorized observers with access to logs?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: get()] [Privacy leak] The get() function returns the raw arrBreadcrumbs array without sanitization - if this is exposed via an API or debugging interface, can attackers extract sensitive information about recent validation failures, double-spend attempts, conflicting units, or network peer connections that should remain internal?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Timing attack] Each breadcrumb includes Date().toString() timestamp at line 15 - can timing analysis of breadcrumb sequences reveal sensitive protocol internals like main chain advancement patterns, witness vote timing, or unit validation ordering that could be exploited for MEV-style attacks or network manipulation?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Forensic analysis] Breadcrumbs persist in memory and contain detailed traces of validation logic from validation.js (e.g., 'found conflicting units', 'will accept a conflicting unit') - can this forensic data be extracted by an attacker who gains partial access to the node process to reconstruct security-sensitive decision-making?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Race condition] The add() function performs non-atomic operations (length check, shift, push) on the shared arrBreadcrumbs array at lines 13-15 - can concurrent calls from multiple async operations (e.g., parallel unit validation, simultaneous network message handling) cause array corruption or lost breadcrumbs?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: get()] [TOCTOU vulnerability] The get() function returns a direct reference to arrBreadcrumbs rather than a copy - can a caller mutate the array while another thread is calling add(), causing race conditions or corrupted state in the breadcrumb history?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [Cross-module contamination] Since arrBreadcrumbs is shared globally across all modules (validation.js, network.js, main_chain.js, wallet.js, writer.js, etc.), can breadcrumbs from unrelated operations interleave in ways that corrupt debugging context or cause misdiagnosis of critical issues during incident response?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Non-deterministic ordering] When multiple async operations add breadcrumbs concurrently during unit processing, the ordering depends on event loop scheduling - can this non-determinism obscure the actual causality chain during critical debugging scenarios like investigating double-spend attempts or main chain fork diagnosis?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Log injection] The breadcrumb parameter is concatenated directly into the array at line 15 without sanitization - can an attacker craft malicious unit hashes, addresses, or peer messages containing newline characters, ANSI escape codes, or control characters to corrupt log output or inject fake breadcrumb entries?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Console.log side effects] If console.log() at line 16 is redirected to a network logging service or file with size limits, can an attacker trigger excessive breadcrumb additions to cause log rotation failures, disk exhaustion, or logging service crashes that impair node operation monitoring?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Prototype pollution] If the breadcrumb parameter contains malicious object properties (e.g., __proto__, constructor), can string conversion via Date().toString() + ': ' + breadcrumb trigger prototype pollution or cause unexpected behavior in the JavaScript runtime?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [String coercion vulnerability] The breadcrumb parameter undergoes implicit string concatenation at line 15 - if an attacker passes an object with a malicious toString() method from a compromised peer message or crafted unit, can this execute arbitrary code or cause exceptions during breadcrumb addition?",
  "[File: byteball/ocore/breadcrumbs.js] [Integration: validation.js] [Double-spend detection interference] When validation.js adds breadcrumbs about conflicting units at lines 1141-1142, can the overhead of breadcrumb addition (Date() calls, array operations, console.log) delay critical validation checks enough to allow a time-of-check-time-of-use race condition in double-spend detection?",
  "[File: byteball/ocore/breadcrumbs.js] [Integration: main_chain.js] [Consensus timing impact] Main_chain.js adds breadcrumbs during stability point advancement (lines 1158, 1164) while holding mutex locks - can the breadcrumb addition overhead cause lock contention or delays that impact main chain monotonicity or stability point determination?",
  "[File: byteball/ocore/breadcrumbs.js] [Integration: network.js] [Peer communication timing] Network.js adds breadcrumbs during WebSocket connection establishment (line 449) - can malicious peers trigger connection storms that flood breadcrumbs, causing memory pressure or console.log blocking that delays legitimate peer message processing?",
  "[File: byteball/ocore/breadcrumbs.js] [Integration: writer.js] [Unit writing delays] Writer.js adds breadcrumbs during unit writing operations - if breadcrumb addition fails or hangs (e.g., console.log blocks on a full pipe), can this prevent new units from being written to the DAG, causing temporary network freezing?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Exception handling] The add() function has no try-catch blocks around Date().toString(), string concatenation, array operations, or console.log() - if any of these operations throw exceptions (e.g., out-of-memory, console.log failure), can this crash critical code paths in validation.js or network.js that call add()?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Undefined/null handling] If breadcrumb is undefined, null, or other non-string types, the concatenation at line 15 will coerce to string ('undefined', 'null') - can this obscure actual debugging information or cause confusion when investigating protocol issues?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: get()] [Empty array handling] The get() function returns arrBreadcrumbs even if empty - can code that depends on breadcrumb history for debugging or forensic analysis fail silently or make incorrect assumptions when the array is empty due to recent process restart?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [Persistence across errors] If a critical error occurs (e.g., database corruption, consensus failure), breadcrumbs persist across error recovery attempts - can stale breadcrumbs from pre-error state contaminate post-error debugging and lead to misdiagnosis?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Type validation] The add() function accepts any parameter type without validation - can passing objects, arrays, functions, or circular references as breadcrumb cause memory leaks, infinite loops during string conversion, or exceptions that crash the node?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Large payload handling] If calling code passes extremely large strings as breadcrumbs (e.g., entire unit objects, large arrays of conflicting unit hashes), can this cause memory exhaustion, slow string concatenation, or console.log blocking that impacts protocol performance?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: MAX_LENGTH] [Constant manipulation] While MAX_LENGTH is defined as a var (not const) at line 9, can other modules that require breadcrumbs.js modify this value to bypass the intended limit of 200 entries, causing unbounded memory growth?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Non-deterministic timestamps] The Date().toString() call at line 15 uses system time which may differ across nodes - if breadcrumb content (including timestamps) is ever serialized and compared across nodes, can timestamp differences cause false divergence detection or consensus issues?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [Non-deterministic state] Since breadcrumb accumulation depends on timing of async operations, different nodes may have different breadcrumb histories even when processing identical units - can this non-determinism complicate cross-node debugging or cause confusion during security incident investigation?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Side effect during validation] Breadcrumbs are added during deterministic validation operations in validation.js - while the breadcrumb itself doesn't affect validation outcome, can exceptions or performance issues from breadcrumb addition cause validation to fail inconsistently across nodes?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: get()] [Unused function] The get() function is never called in the codebase based on grep search - if this function is intended for external debugging tools or manual inspection, can unauthorized access to breadcrumb history via this function expose sensitive protocol state to attackers?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [Console.log dependency] The module assumes console.log is available and synchronous - if the Node.js process is started with console redirection or in an environment where console.log is unavailable/async, can this cause exceptions or deadlocks during breadcrumb addition?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [Memory forensics] Since breadcrumbs contain detailed traces of recent protocol operations, can an attacker who gains read access to node memory (e.g., via heap dump, core dump, or side-channel) extract sensitive information about unit validation logic, network topology, or witness operations?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [CPU overhead] Each breadcrumb addition involves Date() creation, toString() conversion, string concatenation, length check, potential shift(), array push(), and console.log() - can this CPU overhead accumulate during high-throughput scenarios (e.g., network sync, validation storms) to cause node performance degradation?",
  "[File: byteball/ocore/breadcrumbs.js] [Function: add()] [I/O blocking] Console.log() may perform blocking I/O if stdout is buffered or redirected to a file - can this cause critical async operations in validation.js, network.js, or main_chain.js to stall while waiting for console writes to complete?",
  "[File: byteball/ocore/breadcrumbs.js] [Global State: arrBreadcrumbs] [GC pressure] Continuously shifting and pushing breadcrumbs creates short-lived string objects that increase garbage collection pressure - can this cause GC pauses during critical operations like main chain advancement or unit validation, leading to network delays?",
  "[File: byteball/ocore/breadcrumbs.js] [Usage: validation.js conflicting units] When validation.js logs 'found conflicting units' breadcrumbs, can an attacker intentionally create units that trigger maximum breadcrumb additions (by crafting units with many conflicting ancestors) to cause DoS via memory exhaustion or console flooding?",
  "[File: byteball/ocore/breadcrumbs.js] [Usage: network.js peer connections] Network.js logs peer connection URLs in breadcrumbs (e.g., 'connected to <url>') - can an attacker operating a malicious peer with specially crafted hostnames or URLs cause injection attacks, log corruption, or information disclosure when these URLs are logged?",
  "[File: byteball/ocore/breadcrumbs.js] [Usage: main_chain.js mutex operations] Main_chain.js adds breadcrumbs while holding write locks - can breadcrumb addition failures or delays (e.g., console.log blocking) cause mutex deadlocks that freeze main chain advancement and trigger total network shutdown?",
  "[File: byteball/ocore/breadcrumbs.js] [Usage: writer.js unit writing] Writer.js logs breadcrumbs during unit writing - if an attacker crafts units that maximize breadcrumb additions during writing, can the accumulated overhead cause unit writing delays that lead to transaction processing delays (1 hour) violating Immunefi medium severity impact?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Input Validation] Can a malicious peer send a catchup request with last_stable_mci = last_known_mci = 0 to bypass the validation check at line 28-29, potentially causing the node to prepare an invalid catchup chain that starts from genesis and creates consensus divergence?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Integer Overflow] Can an attacker send catchupRequest with extremely large last_stable_mci and last_known_mci values (near Number.MAX_SAFE_INTEGER) to cause integer overflow when calculating bTooLong = (last_ball_mci - last_stable_mci > MAX_CATCHUP_CHAIN_LENGTH) at line 65, bypassing the length limit check?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Witness List Manipulation] If catchupRequest.witnesses contains duplicate witness addresses or invalid witness addresses, does the validation at line 30-31 detect this before passing to witnessProof.prepareWitnessProof(), potentially causing the witness proof generation to fail or produce incorrect proofs?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Race Condition] If two peers request catchup chains simultaneously with the same last_stable_mci but different witness lists, can the mutex lock at line 33 prevent race conditions where the prepareCatchupChain operations interleave, potentially causing inconsistent objCatchupChain objects to be returned?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Database Query Race] At line 46-52, the query checks if last_known_mci is stable, but if a new unit is added to the main chain and becomes stable between this check and the witnessProof.prepareWitnessProof() call at line 55, can this cause the catchup chain to become invalid or contain already-stable units that shouldn't be included?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [DOS - Excessive Chain Length] Can a malicious peer request a catchup with last_stable_mci = 0 and last_known_mci = MAX_CATCHUP_CHAIN_LENGTH + 1000000, causing the node to spend excessive CPU and memory preparing a catchup chain that exceeds MAX_CATCHUP_CHAIN_LENGTH, leading to resource exhaustion and network delay?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Proofchain Ball Calculation] When bTooLong is true at line 65 and proofChain.buildProofChainOnMc() is called at line 76, if the buildProofChainOnMc() function fails to populate objCatchupChain.proofchain_balls or populates it incorrectly, does the subsequent code at line 77 safely handle an empty array or out-of-bounds access?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain() - goUp()] [Infinite Recursion] In the goUp() recursive function starting at line 86, if there's a cycle in last_ball_unit references (unit A's last_ball_unit points to unit B, which eventually points back to A), can this cause infinite recursion leading to stack overflow and node crash?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain() - goUp()] [Missing Last Ball] If storage.readJointWithBall() at line 87 returns a joint where objJoint.unit.last_ball_unit is null or undefined, but objUnitProps.main_chain_index > last_stable_mci at line 90, does the recursive call goUp(objJoint.unit.last_ball_unit) crash the node or loop indefinitely?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Mutex Unlock Failure] If an error occurs in any of the async.series callbacks at lines 45-94 but the error is not properly caught, can the mutex unlock at line 103 fail to execute, causing all subsequent prepareCatchupChain calls to deadlock indefinitely and halt catchup operations?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Malicious Empty Array] Can a malicious peer send catchupChain with stable_last_ball_joints as an empty array (bypassing the check at line 117-118 by including exactly one element), causing the processCatchupChain to crash or corrupt the node's database when accessing arrChainBalls[0] at line 211?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Witness Proof Bypass] If witnessProof.processWitnessProof() at line 128-133 is compromised and returns success with fake arrLastBallUnits and assocLastBallByLastBallUnit, can an attacker inject arbitrary stable_last_ball_joints that don't actually follow from the unstable MC joints, causing the node to accept an invalid history?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Proofchain Ball Hash Collision] At line 145, the ball hash is verified using objectHash.getBallHash(), but if an attacker finds a hash collision (two different (unit, parent_balls, skiplist_balls, is_nonserial) tuples producing the same ball hash), can they substitute a malicious unit in the proofchain to corrupt the catchup data?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Proofchain Known Ball Manipulation] In the proofchain validation loop at lines 143-156, assocKnownBalls is populated from assocLastBallByLastBallUnit, then parent_balls and skiplist_balls are added to it. Can an attacker craft a proofchain where ball X references parent ball Y, which is not initially in assocKnownBalls but gets added by a previous ball in the same loop, bypassing the validation at line 147?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [First Stable Joint Mismatch] At line 165-166, the code checks if objFirstStableUnit.unit is in arrLastBallUnits, but if the witnessProof.processWitnessProof() returns an arrLastBallUnits that doesn't properly match the stable_last_ball_joints due to a bug or attack, can this cause the node to accept an inconsistent catchup chain?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Last Ball Reference Chain Break] In the stable joints validation loop at lines 175-191, if objUnit.last_ball_unit is set but objUnit.last_ball is null or doesn't match the expected ball from a previous iteration, does the validation at line 184-185 properly detect this inconsistency, or can an attacker create a catchup chain with broken last_ball references?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Invalid Hash Validation Bypass] At line 180-181, validation.hasValidHashes(objJoint) is called, but if this function only validates unit hash and not ball hash, can an attacker send a joint with correct unit hash but incorrect ball hash, bypassing validation and corrupting the ball chain?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Duplicate Catchup Processing] The mutex lock at line 198 checks if catchup_chain_balls table has any rows at line 200-202. If two peers send identical catchup chains simultaneously and both pass the empty table check before either inserts data, can both insert their chains into catchup_chain_balls, causing duplicate or conflicting catchup data?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [First Chain Ball Stability Race] At lines 210-217, the code checks if arrChainBalls[0] is stable, but if the main chain is being actively updated and the first chain ball becomes unstable between the query and the subsequent operations, can this cause the catchup process to proceed with invalid assumptions?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Genesis Ball Bypass] At line 211-212, if storage.isGenesisBall(arrChainBalls[0]) returns true but the genesis ball in the database is actually corrupted or replaced with a malicious unit, does the catchup process accept this without further validation, potentially forking the entire network?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Main Chain Index Validation Gap] At lines 220-226, the code adjusts arrChainBalls[0] if its MCI is less than last_stable_mci, but if objFirstChainBallProps.main_chain_index is significantly less than last_stable_mci (e.g., by 1000000 MCIs), does replacing it with objLastStableMcUnitProps.ball create a huge gap in the catchup chain?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Second Ball Stability Check Missing] At lines 229-236, the code checks if the second chain ball is stable and returns an error if it is, but what if arrChainBalls has only 2 elements and both are stable? Does the check at line 227 properly handle this edge case?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [SQL Injection in Ball Insert] At line 242-243, arrChainBalls is used to construct SQL VALUES with db.escape(ball), but if an attacker can somehow inject SQL metacharacters into the ball string (which should be a hash), can this lead to SQL injection when the INSERT query is executed?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Mutex Unlock on Error Path] In the error handling at lines 247-250, if an error occurs and unlock() is called at line 248, but then callbacks.ifError(err) at line 249 throws an exception or triggers another async operation, can this cause the mutex to be in an inconsistent state?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [Ball Parameter Type Confusion] At lines 261-264, the code checks if from_ball and to_ball are strings, but if an attacker sends hashTreeRequest with from_ball or to_ball as objects with a custom toString() method that returns valid ball hashes, can this bypass validation and cause unexpected behavior in database queries?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [MCI Ordering Inversion] At line 285-286, the code checks if from_mci >= to_mci and returns an error, but if from_mci == to_mci - 1 (adjacent MCIs), does the hash tree include only a single MCI worth of units, and can this be exploited to create minimal hash trees that lack sufficient data for validation?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [Ball Stability Race Condition] At lines 276-277, the query checks if both balls are stable, but if one of the balls becomes unstable (due to a main chain reorganization) between this check and the subsequent query at lines 289-293, can the hash tree include unstable units that shouldn't be in a stable hash tree?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [Genesis MCI Special Case Exploit] At line 288, if from_mci === 0, the operator is changed to",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [Missing Ball Throw] At line 298, if objBall.ball is null, the code throws an Error, but in an async.eachSeries callback, does throwing an error properly propagate to the error handler, or can this cause unhandled promise rejection and crash the node?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [Parent Ball Query Result Mismatch] At lines 303-309, the code queries parent balls and checks if any parent has no ball at line 306, throwing an error if so. But if a parent unit exists but has null ball due to database corruption, can this throw error repeatedly and prevent hash tree generation for legitimate catchup requests?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [Skiplist Ball Validation Bypass] At lines 310-321, skiplist balls are queried and validated similar to parent balls, but if skiplist_units table contains invalid or circular references, can this cause the hash tree to include incorrect skiplist_balls that break ball hash verification later?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [Large Hash Tree DoS] If an attacker requests a hash tree with from_mci = 1 and to_mci = MAX_CATCHUP_CHAIN_LENGTH, and each MCI contains 1000 units, can this generate a hash tree with millions of balls, causing memory exhaustion when arrBalls is populated and JSON stringified for network transmission?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [Content Hash Nonserial Flag] At lines 299-301, if objBall.content_hash exists, objBall.is_nonserial is set to true, but what if content_hash is set to an empty string or null? Does this incorrectly mark the ball as nonserial, causing ball hash mismatches in processHashTree()?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Array Type Confusion] At line 337-338, the code checks if arrBalls is an array, but if an attacker sends a fake array-like object (e.g., {0: ball1, 1: ball2, length: 2}) that passes Array.isArray(), can subsequent array operations fail or produce unexpected results?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Hash Tree Mutex Lock Timing] The mutex lock at line 339 acquires \\",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Database Transaction Isolation] At line 347, conn.query(\\",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Ball Hash String Type Validation] At line 353-354, the code checks if objBall.ball is a string, but if it's a string containing null bytes, control characters, or extremely long strings (>1MB), can this cause database insertion failures or buffer overflows in later operations?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Genesis Parent Ball Check Bypass] At lines 357-362, genesis units are checked to have no parent_balls, and non-genesis units must have parent_balls array. But if storage.isGenesisUnit() is compromised to return true for a non-genesis unit, can an attacker inject units without parents into the hash tree?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Ball Hash Verification Weakness] At line 363-364, ball hash is verified using objectHash.getBallHash(), but if the is_nonserial parameter is attacker-controlled and incorrectly set, can this cause the hash verification to pass for an invalid ball, allowing malicious units to be inserted?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Storage Global State Pollution] At line 367, storage.assocHashTreeUnitsByBall[objBall.ball] is directly modified as a global in-memory map. If multiple hash trees are processed concurrently (before mutex release), can this cause race conditions where balls from different hash trees get mixed up?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [INSERT IGNORE Race Condition] At line 369, INSERT with getIgnore() is used to insert balls that may already exist. If two processHashTree operations insert the same ball simultaneously in different transactions, can this cause duplicate key errors or inconsistent hash_tree_balls table state?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Skiplist Ball Existence Check] At lines 376-386, skiplist balls are checked to exist in either hash_tree_balls or balls tables. But if a skiplist ball exists in hash_tree_balls but was inserted by a corrupted previous hash tree, can this allow invalid skiplist references to propagate?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Parent Ball Missing in Hash Tree] At lines 391-411, parent balls are checked to exist in hash_tree_balls first, and if not found, queried from balls table. But if a parent ball is missing from both tables due to database corruption, the error at line 401-402 is returned. Can this permanently brick the catchup process if the corruption is not fixed?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Max MCI Calculation Logic] At lines 403-407, max_mci is calculated from parent balls that are on main chain and have MCI > current max_mci. But if all parent balls are off the main chain (is_on_main_chain !== 1), max_mci stays null. Does this properly handle hash trees that branch off the main chain?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Transaction Rollback Incomplete] At lines 415-421, if an error occurs, ROLLBACK is called, but if the ROLLBACK itself fails (e.g., due to database connection loss), does conn.release() at line 417 still execute, or can this leak database connections?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Catchup Chain Element Count] At lines 431-438, the code expects exactly 2 elements in catchup_chain_balls when a hash tree is processed. But if processCatchupChain was called with a very short chain (only 1 stable ball), can rows.length === 1, causing the error at line 437 to incorrectly reject valid hash trees?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Tree Root Verification] At line 442-443, the code verifies that arrBalls[arrBalls.length-1].ball matches rows[1].ball (second chain element). But if arrBalls is processed in reverse order (oldest first) and the attacker reorders the balls, can this verification pass with an incorrect tree root?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Chain Element Deletion Race] At line 445, the oldest chain element (rows[0].ball) is deleted from catchup_chain_balls. If another thread is concurrently reading from catchup_chain_balls to prepare the next hash tree request, can this cause a race condition where the next hash tree references a deleted ball?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Handled Balls Purge Failure] At line 447, purgeHandledBallsFromHashTree() is called within the transaction. If this function encounters an error (e.g., database lock timeout), does the error propagate properly to trigger ROLLBACK, or can partial purge leave the hash_tree_balls table in an inconsistent state?",
  "[File: byteball/ocore/catchup.js] [Function: purgeHandledBallsFromHashTree()] [Handled Balls Query Result] At line 460, the query finds balls that exist in both hash_tree_balls and balls tables (meaning they've been processed and stored). But if the query uses CROSS JOIN without proper indexing, can this be extremely slow for large hash trees, causing the transaction to timeout?",
  "[File: byteball/ocore/catchup.js] [Function: purgeHandledBallsFromHashTree()] [Empty Handled Balls Array] At lines 461-462, if rows.length === 0, the function returns immediately without purging anything. But if hash_tree_balls has 10000 balls and none have been stored to balls yet, does this mean the hash_tree_balls table will keep growing indefinitely until memory is exhausted?",
  "[File: byteball/ocore/catchup.js] [Function: purgeHandledBallsFromHashTree()] [Storage Memory Leak] At lines 464-466, handled balls are deleted from storage.assocHashTreeUnitsByBall in-memory map. But if the delete operation fails silently (e.g., due to prototype pollution), can this cause the map to grow indefinitely and leak memory?",
  "[File: byteball/ocore/catchup.js] [Function: purgeHandledBallsFromHashTree()] [DELETE Query SQL Injection] At line 467, arrHandledBalls is used in a DELETE query with WHERE ball IN(?). If the database driver doesn't properly sanitize array parameters and an attacker controls the ball strings, can this lead to SQL injection deleting unintended rows?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain() & processCatchupChain()] [Catchup Chain Asymmetry] If prepareCatchupChain() includes witness_change_and_definition_joints in the catchup chain but processCatchupChain() processes them through witnessProof.processWitnessProof() which may reject them, can this cause the catchup chain to be partially accepted, leaving the node in an inconsistent state?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain() & readHashTree()] [Chain Ball to Hash Tree Mapping] When processCatchupChain() inserts balls into catchup_chain_balls at line 243, and readHashTree() later retrieves them to determine which hash tree to send, if the member_index ordering doesn't match the last_ball chain ordering, can this cause hash trees to be requested in the wrong sequence?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree() & processHashTree()] [Hash Tree Ball Parent Inconsistency] If readHashTree() includes a ball with parent_balls that reference units outside the [from_mci, to_mci] range, and processHashTree() expects all parent balls to be in hash_tree_balls or balls tables, can this cause processHashTree() to fail with \\",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree() & purgeHandledBallsFromHashTree()] [Purge Timing DoS] If processHashTree() is called repeatedly with small hash trees (e.g., 10 balls each), and each call triggers purgeHandledBallsFromHashTree(), can the frequent DELETE queries cause database lock contention and slow down other critical operations like unit validation and storage?",
  "[File: byteball/ocore/catchup.js] [Function: All functions] [Callback Error Propagation] Throughout the file, callbacks use callbacks.ifError(err) and callbacks.ifOk(data) patterns. If the callback implementation in the calling code (e.g., network.js) doesn't properly handle errors and retries indefinitely, can this cause infinite loops in catchup attempts?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Mutex Key Collision] At line 33, mutex.lock(['prepareCatchupChain']) uses a fixed key for all catchup chain preparations. If multiple peers request catchup chains for different MCI ranges simultaneously, can this mutex cause serialization of all requests, significantly slowing down catchup and creating a DoS vector?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Catchup Chain Mutex Scope] At line 198, mutex.lock([\\",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Hash Tree Mutex Deadlock] At line 339, mutex.lock([\\",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain() & processCatchupChain()] [Database Connection Pool Exhaustion] Both functions perform multiple database queries (lines 46, 207, 229, 243, 269, etc.). If a malicious peer sends many concurrent catchup requests, can this exhaust the database connection pool, preventing legitimate operations like unit storage from acquiring connections?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Transaction Long Duration] At line 347, a transaction is started that can process thousands of balls in async.eachSeries. If this transaction takes 10+ minutes to complete, can this cause database lock timeouts, preventing other operations from modifying hash_tree_balls or balls tables?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Storage AssocHashTreeUnitsByBall Memory] At line 367, storage.assocHashTreeUnitsByBall is populated with ball->unit mappings. If an attacker sends multiple large hash trees (each with 100k balls), can this in-memory map grow to gigabytes, causing memory exhaustion and node crash?",
  "[File: byteball/ocore/catchup.js] [Function: All functions] [Database Query Result Set Size] Throughout the file, database queries like \\",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Witness Proof Poisoning] At line 55-68, witnessProof.prepareWitnessProof() is called with arrWitnesses from the catchup request. If an attacker provides a witness list that's compatible with their own malicious units but incompatible with the main network, can this cause the node to prepare a catchup chain that leads to chain split?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Last Ball Chain Reorganization] In the stable joints validation loop at lines 175-191, the code builds a last_ball chain by following last_ball_unit references. If the main chain has reorganized since the catchup chain was prepared, can this cause the last_ball chain to be inconsistent with the current stable main chain?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Proofchain Gap Attack] At lines 135-161, if catchupChain.proofchain_balls exists, it's validated to connect to assocKnownBalls. But if there's a gap in the proofchain (e.g., missing balls between index i and i+1), does the validation detect this, or can an attacker create a proofchain that jumps over malicious or invalid balls?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree() & processHashTree()] [Hash Tree Content Substitution] If a malicious peer acts as a relay between the requesting node and an honest node, can they intercept the hash tree response from readHashTree(), substitute some balls with malicious versions that have the same parent_balls and skiplist_balls but different content, and have processHashTree() accept it if the ball hashes match?",
  "[File: byteball/ocore/catchup.js] [Function: All catchup functions] [Catchup State Corruption] If a node starts catchup, processes part of a catchup chain, then crashes and restarts, are catchup_chain_balls and hash_tree_balls tables properly cleaned up, or can stale data from the interrupted catchup cause future catchup attempts to fail with \\",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Validation HasValidHashes Weakness] At line 180-181, validation.hasValidHashes(objJoint) is called to verify hashes, but if this function only checks unit.content_hash matches computed hash and doesn't verify ball hash against computed ball hash, can an attacker send joints with valid unit hashes but invalid ball hashes?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Ball Hash Algorithm Confusion] At line 363, objectHash.getBallHash() is called with is_nonserial parameter. If is_nonserial is incorrectly determined (e.g., content_hash check at line 299 fails), can this cause the ball hash verification to use the wrong algorithm, accepting invalid balls?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Unstable MC Joint Trust] At line 60, arrUnstableMcJoints from witnessProof.prepareWitnessProof() are directly assigned to objCatchupChain without additional validation. If prepareWitnessProof is compromised, can it inject malicious unstable MC joints that appear valid but contain double-spends or invalid transactions?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Empty Witness List] At line 30-31, the code checks if arrWitnesses is a nonempty array using ValidationUtils.isNonemptyArray(), but if this utility function only checks length > 0 and doesn't validate that elements are valid witness addresses, can an attacker send an array with null or invalid elements?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Last Ball Unit Null] At lines 63-64, last_ball_unit is assigned from prepareWitnessProof callback. If last_ball_unit is null but last_ball_mci is a valid number, does the subsequent logic at lines 82-93 handle this gracefully, or does goUp(null) crash?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Array Reverse Side Effect] At line 192, arrChainBalls.reverse() is called to reverse the array in-place. If this array is later used elsewhere (e.g., logged or sent to another function), can the reversed order cause confusion or incorrect behavior?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [Zero MCI Range] If from_mci = 0 and to_mci = 0, does the query at lines 289-293 return only genesis unit, and is this a valid hash tree? Or does the check at line 285-286 incorrectly reject this edge case?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Single Ball Hash Tree] If arrBalls contains only one ball (the genesis ball), does the validation at lines 431-443 correctly handle this, or does it expect at least 2 balls to match the 2 catchup chain elements?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Max MCI Null Handling] At lines 426-428, there's a commented-out check for max_mci === null. If max_mci is indeed null (all parent balls are off-chain or genesis), does the subsequent logic at line 442 work correctly when comparing with rows[0].main_chain_index?",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Proof Chain Memory Allocation] At line 76, proofChain.buildProofChainOnMc() populates objCatchupChain.proofchain_balls array. If this function allocates memory for millions of balls (e.g., MCI range of 10M), can this cause memory exhaustion before the function completes?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree()] [Async.eachSeries Performance] At lines 294-329, async.eachSeries processes each ball sequentially, performing 3 database queries per ball (units, parenthoods, skiplist_units). For a hash tree with 100k balls, this is 300k sequential queries. Can this take hours to complete, blocking the response and causing timeout?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [Async.eachSeries Transaction Bloat] At lines 350-452, async.eachSeries processes balls one-by-one within a transaction. For a hash tree with 100k balls, this transaction could take hours and create a massive transaction log, causing database performance degradation and potential disk space exhaustion?",
  "[File: byteball/ocore/catchup.js] [Function: All functions] [Error Message Information Leak] Throughout the file, error messages include detailed information like unit hashes, ball hashes, MCIs, and internal state (e.g., line 148: \\",
  "[File: byteball/ocore/catchup.js] [Function: prepareCatchupChain()] [Storage Module Dependency] At lines 87, 89, storage.readJointWithBall() and storage.readUnitProps() are called. If the storage module has bugs that return inconsistent data (e.g., a joint with unit.last_ball_unit that doesn't exist), can this cause infinite loops or crashes in the goUp() recursion?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [WitnessProof Module Trust] At line 128-130, witnessProof.processWitnessProof() is called with the catchup chain data and witnesses. If this module doesn't properly validate the witness proofs and returns success for invalid proofs, can an attacker craft a catchup chain with fake witness signatures?",
  "[File: byteball/ocore/catchup.js] [Function: readHashTree() & processHashTree()] [ObjectHash Module Dependency] Ball hash verification relies on objectHash.getBallHash() at lines 145, 363. If objectHash module has a bug where it produces different hashes for the same input on different nodes (non-deterministic), can this cause some nodes to reject valid hash trees?",
  "[File: byteball/ocore/catchup.js] [Function: processHashTree()] [ProofChain Module Coordination] At line 76 in prepareCatchupChain(), proofChain.buildProofChainOnMc() builds the proofchain_balls. If this module doesn't coordinate properly with processHashTree()'s expectations (e.g., ball ordering, skiplist inclusion), can this cause verification failures?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain()] [Ball Hash Collision Resistance] At lines 145, 169, 184, ball hashes are compared for equality. If SHA256 (used in objectHash) has collision vulnerabilities in the future, can an attacker create two different balls with the same hash, causing the catchup process to accept the wrong ball?",
  "[File: byteball/ocore/catchup.js] [Function: processCatchupChain() & processHashTree()] [Hash Truncation Risk] If ball hashes are truncated or shortened in storage (e.g., stored as VARCHAR(40) instead of VARCHAR(44) for base64 encoding), can this increase collision probability and allow hash-based validation bypasses?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [SQL Injection - CRITICAL] In the load() function at line 14, the up_to_id parameter is concatenated directly into the SQL query string using string concatenation ('id < '+up_to_id+' ORDER BY') rather than parameterized query placeholders - can an attacker pass a crafted numeric value or exploit JavaScript's type coercion to inject malicious SQL (e.g., up_to_id='999999 OR 1=1 --'), potentially reading all chat messages across all correspondents or executing arbitrary SQL commands, leading to complete database compromise and data exfiltration?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [SQL Injection - CRITICAL] Since the load() function only validates that up_to_id is of type 'number' (line 11-12) but still concatenates it directly into the SQL string (line 14), can an attacker exploit JavaScript's loose typing to pass NaN, Infinity, or -Infinity values that bypass the typeof check but result in malformed SQL queries that cause database errors, potentially leading to denial of service by crashing the database connection or corrupting query results?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [SQL Injection - Type Coercion] Given that JavaScript's typeof operator returns 'number' for NaN, can an attacker pass up_to_id=NaN which would create the SQL string 'id < NaN ORDER BY', potentially causing SQLite to perform unexpected comparisons or return incorrect result sets that leak messages from other correspondents, violating message privacy and cross-correspondent data isolation?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [SQL Injection - Boundary Attack] Can an attacker pass extremely large numeric values for up_to_id (e.g., Number.MAX_SAFE_INTEGER or larger) that, when concatenated into the SQL string, cause integer overflow in SQLite's comparison logic, potentially bypassing the 'id < up_to_id' filter and returning messages that should be excluded, or causing database corruption if the value exceeds SQLite's INTEGER storage limits?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [SQL Syntax Error] The store() function at line 7 uses single quotes around column names in the INSERT statement ('correspondent_address', 'message', 'is_incoming', 'type') - does SQLite interpret these as string literals rather than column identifiers, potentially causing the query to fail or insert data into incorrect columns, leading to data corruption or denial of service if all store() operations fail?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Input Validation] The store() function accepts correspondent_address, message, is_incoming, and type parameters without any validation - can an attacker pass NULL, undefined, or malicious values that violate database constraints (e.g., NULL for NOT NULL columns), causing database errors that crash the application or leave the database in an inconsistent state?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Buffer Overflow/DoS] Since the message parameter is stored in a LONGTEXT column (max ~4GB in SQLite) without any length validation, can an attacker pass extremely large message payloads (e.g., gigabytes of data) that exhaust available disk space, memory, or database connection resources, causing denial of service by preventing legitimate messages from being stored or causing the database file to grow unbounded?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Type Validation] The store() function accepts correspondent_address as a CHAR(33) field but performs no validation that the input is actually 33 characters or matches the expected device address format - can an attacker pass addresses of incorrect length or format that either get truncated/padded by the database, causing message association with wrong correspondents, or violate foreign key constraints causing transaction failures?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Type Validation] The is_incoming parameter is stored as INTEGER(1) (boolean) but the function performs no validation that the value is 0 or 1 - can an attacker pass arbitrary integers (e.g., 999, -1, or non-numeric values) that get stored in the database, potentially breaking application logic that assumes is_incoming is a boolean flag, causing incorrect message display or chat history corruption?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Type Validation] The type parameter defaults to 'text' (line 6) but the database schema defines it as CHAR(15) - can an attacker pass type strings longer than 15 characters that either get silently truncated by SQLite (potentially creating ambiguous or duplicate types), or pass special message types that bypass application-level filtering, leading to execution of unintended message handlers or XSS attacks in message rendering?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Input Validation] The load() function validates up_to_id is a number but performs no bounds checking - can an attacker pass negative values (e.g., -999999) that would make the WHERE clause 'id < -999999' return zero results, or pass 0 to prevent loading any chat history, causing denial of service by making chat history unavailable to legitimate users?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Input Validation] The load() function accepts a limit parameter without any validation or bounds checking - can an attacker pass extremely large limit values (e.g., Number.MAX_SAFE_INTEGER) that cause SQLite to attempt loading millions or billions of rows into memory, causing memory exhaustion, application crash, or severe performance degradation (DoS) for all users sharing the database connection?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Input Validation] Since correspondent_address is not validated in load(), can an attacker pass NULL, undefined, empty string, or SQL wildcards (%, _) that, when used in the WHERE clause, either return no results (DoS) or potentially match multiple correspondent addresses if the database performs pattern matching, causing privacy violation by leaking messages from other users?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Input Validation] The purge() function accepts correspondent_address without any validation - can an attacker pass NULL or undefined values that cause the WHERE clause to become 'correspondent_address IS NULL', potentially deleting all messages that have NULL correspondent_address (if any exist due to data corruption), or causing the query to fail and preventing legitimate purge operations?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Authorization Bypass] The load() function performs no authorization checks to verify the caller has permission to access messages for the specified correspondent_address - can any code within the application (including compromised dependencies or malicious plugins) call load() with arbitrary correspondent addresses to read private chat messages between other users, causing complete breakdown of message privacy and confidentiality?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Authorization Bypass] The store() function performs no authorization checks - can malicious code forge chat messages by calling store() with arbitrary correspondent_address and is_incoming values, potentially impersonating other users in chat histories, injecting fake messages to manipulate users, or creating false evidence of conversations that never occurred?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Authorization Bypass - CRITICAL] The purge() function allows deletion of all messages for a correspondent_address without any authorization check or confirmation - can malicious code or a compromised component call purge() to permanently delete another user's entire chat history, causing irreversible data loss and potential legal/compliance issues if chat records are required for audit or dispute resolution?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Data Loss] Since purge() deletes messages without any backup, soft-delete mechanism, or recovery option, and provides no callback to confirm deletion success or failure, can accidental calls to purge() (e.g., from buggy code or race conditions) cause permanent, unrecoverable loss of important chat data, violating data retention requirements or user expectations of message persistence?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Variable Shadowing - Logic Error] At line 6, the code declares 'var type = type || text' which shadows the type parameter passed to the function - does this cause the function to always use the default 'text' value regardless of what type was actually passed by the caller, breaking support for non-text message types (e.g., 'payment_request', 'file', etc.) and causing all messages to be incorrectly classified, potentially breaking message rendering or filtering logic?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Variable Shadowing - Undefined Behavior] Given the variable shadowing at line 6 where 'var type = type || text', if the caller intentionally passes type=0, type='', or type=false (falsy values), will these be overridden with 'text' due to the || operator, causing legitimate message types to be lost and all messages to default to 'text', breaking chat functionality for special message types?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Error Handling] The store() function calls db.query() without providing any error handling callback or catching exceptions - if the database insert fails (due to constraint violations, disk full, or database corruption), will the error silently disappear, causing messages to be lost without any notification to the user or logging for debugging, leading to unreliable message delivery and potential data loss?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Error Handling] The load() function passes rows directly to the callback (line 15) without checking if the query succeeded or if an error occurred - can database errors (connection timeout, locked database, corrupted table) cause undefined or NULL to be passed to the callback, potentially crashing the calling code if it doesn't expect error conditions, causing application instability?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Error Handling] The purge() function calls db.query() without any callback at all - if the DELETE query fails (database locked, foreign key constraint, or permission error), will the calling code assume the deletion succeeded when it actually failed, causing the application to be in an inconsistent state where the UI shows messages as deleted but they remain in the database?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Error Handling] If the db.query() call in load() throws an exception (before invoking the callback), the error propagates up to the caller but the callback is never invoked - can this cause the calling code to hang indefinitely waiting for the callback, leading to resource leaks (unclosed connections, memory leaks from pending promises) or application freezing?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Race Condition] Since store() performs no transaction management or locking, if two concurrent calls to store() attempt to insert messages for the same correspondent at nearly the same time, can race conditions in the auto-increment ID assignment cause messages to appear out of order in the database relative to their actual arrival time, breaking chronological chat history and causing confusion about message sequences?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Race Condition] If load() is called while store() operations are in progress for the same correspondent_address, can the query return a partially committed set of messages (if database isolation level is READ UNCOMMITTED) or miss messages that were inserted after the query started but before it completed, causing inconsistent chat history views where messages appear and disappear unpredictably?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Race Condition] If purge() is called while load() or store() operations are active for the same correspondent_address, can this cause database lock conflicts, deadlocks, or cause load() to return an empty result set mid-query as rows are deleted, potentially confusing the application state or causing it to think the chat history was never present?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Race Condition - Cascade Delete] Since the chat_messages table has a foreign key with ON DELETE CASCADE to correspondent_devices, if purge() executes concurrently with deletion of the correspondent_device record, can race conditions cause double-deletion attempts, foreign key constraint errors, or leave orphaned messages if the cascade hasn't completed, causing database inconsistency?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Transaction Atomicity] The store() function performs a single INSERT without wrapping it in a transaction - if the application needs to store multiple related messages atomically (e.g., a message and its associated metadata or payment notification), can partial failures cause some messages to be stored while others are not, breaking the atomicity of multi-message operations and leaving the chat state inconsistent?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Transaction Atomicity] The purge() function performs a DELETE without transaction wrapping - if the application logic requires purging messages atomically with other operations (e.g., also deleting the correspondent_devices entry or clearing related state), can partial failures cause messages to be deleted while related data remains, creating orphaned records or inconsistent application state?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Foreign Key Violation] The chat_messages table has a foreign key constraint on correspondent_address referencing correspondent_devices(device_address) - if store() is called with a correspondent_address that doesn't exist in correspondent_devices, will the INSERT fail with a foreign key violation error that is not handled, causing message storage to silently fail and potentially losing messages during device pairing or before correspondent is fully registered?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Cascade Delete Behavior] While purge() explicitly deletes messages, the chat_messages table has 'ON DELETE CASCADE' from correspondent_devices - can this create confusion where messages are deleted through two different code paths (explicit purge vs. cascade from device deletion), potentially causing the calling code to perform redundant operations, miss cleanup tasks, or fail to properly notify the user about data deletion?",
  "[File: byteball/ocore/chat_storage.js] [All Functions] [Foreign Key Enforcement] The sqlite_pool.js file executes 'PRAGMA foreign_keys = 1' to enable foreign key constraints - but if this PRAGMA fails or is disabled in certain environments (older SQLite versions, misconfiguration), will the foreign key constraints be silently ignored, allowing store() to insert messages for non-existent correspondents and creating orphaned data that violates referential integrity?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Performance DoS] The load() query uses 'ORDER BY id DESC' without ensuring an index exists on (correspondent_address, id) - can an attacker repeatedly call load() with large limit values to force full table scans and expensive sorting operations, causing CPU exhaustion and database lock contention that degrades performance for all users, achieving denial of service through resource exhaustion?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Index Coverage] While an index exists on (correspondent_address, id), the query uses 'id < up_to_id' which may not be efficiently served by this index in some SQLite query planner scenarios - can this cause SQLite to choose sub-optimal query plans that scan large portions of the table, causing O(n) query time instead of O(log n), making the application unresponsive when loading messages from correspondents with large chat histories?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Missing Callback] The store() function provides no return value, callback, or promise to indicate success or failure - can calling code never know if a message was successfully stored, making it impossible to implement retry logic, show delivery confirmations to users, or detect database failures, potentially causing silent message loss that users are unaware of?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Callback Signature] The load() function passes rows directly to the callback without any error parameter - how can calling code distinguish between 'query succeeded with zero results' vs. 'query failed', potentially causing it to interpret database errors as empty chat histories and incorrectly showing 'no messages' when there were actually database connection problems?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Missing Callback] The purge() function provides no callback to indicate completion or return the count of deleted rows - can calling code never know if the purge completed successfully or how many messages were deleted, making it impossible to show feedback to users (e.g., 'Deleted 50 messages') or to detect failures where messages were not actually deleted?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Timestamp Integrity] The store() function relies on the database DEFAULT CURRENT_TIMESTAMP for creation_date (line 7 doesn't specify creation_date) - can clock skew on the database server, timezone misconfigurations, or manual time changes cause messages to have incorrect timestamps, potentially showing messages out of chronological order or with future timestamps that break chat history display logic?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Result Set Ordering] The load() function uses 'ORDER BY id DESC' to get newest messages first, but returns them in that order to the callback - does the calling code need to reverse the array to display messages chronologically, and if so, is this consistent across all callers, or can inconsistent handling cause messages to appear in different orders in different parts of the UI?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Pagination State] The load() function uses up_to_id for pagination but doesn't return any continuation token or metadata about whether more messages exist - can calling code inadvertently implement infinite pagination loops by repeatedly calling load() with the same up_to_id if no messages are returned, or fail to show 'Load More' UI when additional messages exist above the oldest loaded message?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Storage Exhaustion] Since store() accepts unlimited message sizes and frequencies without rate limiting or quotas, can an attacker spam store() calls with maximum-size LONGTEXT messages to rapidly exhaust all available disk space on the database server, causing the entire application to fail when the database can no longer accept writes, achieving permanent denial of service until disk space is manually freed?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Query DoS] Can an attacker repeatedly call load() with limit=999999999 and random correspondent_address values to force the database to perform expensive full table scans, holding database locks and consuming CPU resources, making the database unresponsive for legitimate queries and causing cascade failures across all database-dependent application features?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Lock Contention] Since purge() performs DELETE FROM chat_messages WHERE correspondent_address=? without limiting the number of rows, can deleting a correspondent with millions of messages cause long-running DELETE operations that hold database locks, blocking all other queries on the chat_messages table and causing application-wide denial of service until the DELETE completes?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Privacy Isolation] The load() function filters messages by correspondent_address in the WHERE clause, but if there are database index corruption issues or query planner bugs, can messages from different correspondents leak into the result set, causing users to see fragments of other users' private conversations, violating privacy guarantees and potentially exposing sensitive information?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Privacy - Timing Attack] Since load() query performance varies based on the number of messages for a correspondent_address, can an attacker measure query response times to infer how many messages exist in other users' chat histories, potentially revealing metadata about communication patterns and relationship intensity without directly accessing the message content?",
  "[File: byteball/ocore/chat_storage.js] [Module Exports] [API Misuse] The module exports all three functions (store, load, purge) globally without any access control wrapper - can any code in the application or in third-party dependencies import this module and directly call these functions, bypassing any higher-level permission checks or business logic that should gate access to chat storage, creating a privilege escalation vulnerability?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [SQL Injection - CRITICAL] In the load() function at line 14, the up_to_id parameter is concatenated directly into the SQL query string using string concatenation ('id < '+up_to_id+' ORDER BY') rather than parameterized query placeholders - can an attacker pass a crafted numeric value or exploit JavaScript's type coercion to inject malicious SQL (e.g., up_to_id='999999 OR 1=1 --'), potentially reading all chat messages across all correspondents or executing arbitrary SQL commands, leading to complete database compromise and data exfiltration?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [SQL Injection - CRITICAL] Since the load() function only validates that up_to_id is of type 'number' (line 11-12) but still concatenates it directly into the SQL string (line 14), can an attacker exploit JavaScript's loose typing to pass NaN, Infinity, or -Infinity values that bypass the typeof check but result in malformed SQL queries that cause database errors, potentially leading to denial of service by crashing the database connection or corrupting query results?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [SQL Injection - Type Coercion] Given that JavaScript's typeof operator returns 'number' for NaN, can an attacker pass up_to_id=NaN which would create the SQL string 'id < NaN ORDER BY', potentially causing SQLite to perform unexpected comparisons or return incorrect result sets that leak messages from other correspondents, violating message privacy and cross-correspondent data isolation?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [SQL Injection - Boundary Attack] Can an attacker pass extremely large numeric values for up_to_id (e.g., Number.MAX_SAFE_INTEGER or larger) that, when concatenated into the SQL string, cause integer overflow in SQLite's comparison logic, potentially bypassing the 'id < up_to_id' filter and returning messages that should be excluded, or causing database corruption if the value exceeds SQLite's INTEGER storage limits?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [SQL Syntax Error] The store() function at line 7 uses single quotes around column names in the INSERT statement ('correspondent_address', 'message', 'is_incoming', 'type') - does SQLite interpret these as string literals rather than column identifiers, potentially causing the query to fail or insert data into incorrect columns, leading to data corruption or denial of service if all store() operations fail?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Input Validation] The store() function accepts correspondent_address, message, is_incoming, and type parameters without any validation - can an attacker pass NULL, undefined, or malicious values that violate database constraints (e.g., NULL for NOT NULL columns), causing database errors that crash the application or leave the database in an inconsistent state?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Buffer Overflow/DoS] Since the message parameter is stored in a LONGTEXT column (max ~4GB in SQLite) without any length validation, can an attacker pass extremely large message payloads (e.g., gigabytes of data) that exhaust available disk space, memory, or database connection resources, causing denial of service by preventing legitimate messages from being stored or causing the database file to grow unbounded?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Type Validation] The store() function accepts correspondent_address as a CHAR(33) field but performs no validation that the input is actually 33 characters or matches the expected device address format - can an attacker pass addresses of incorrect length or format that either get truncated/padded by the database, causing message association with wrong correspondents, or violate foreign key constraints causing transaction failures?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Type Validation] The is_incoming parameter is stored as INTEGER(1) (boolean) but the function performs no validation that the value is 0 or 1 - can an attacker pass arbitrary integers (e.g., 999, -1, or non-numeric values) that get stored in the database, potentially breaking application logic that assumes is_incoming is a boolean flag, causing incorrect message display or chat history corruption?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Type Validation] The type parameter defaults to 'text' (line 6) but the database schema defines it as CHAR(15) - can an attacker pass type strings longer than 15 characters that either get silently truncated by SQLite (potentially creating ambiguous or duplicate types), or pass special message types that bypass application-level filtering, leading to execution of unintended message handlers or XSS attacks in message rendering?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Input Validation] The load() function validates up_to_id is a number but performs no bounds checking - can an attacker pass negative values (e.g., -999999) that would make the WHERE clause 'id < -999999' return zero results, or pass 0 to prevent loading any chat history, causing denial of service by making chat history unavailable to legitimate users?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Input Validation] The load() function accepts a limit parameter without any validation or bounds checking - can an attacker pass extremely large limit values (e.g., Number.MAX_SAFE_INTEGER) that cause SQLite to attempt loading millions or billions of rows into memory, causing memory exhaustion, application crash, or severe performance degradation (DoS) for all users sharing the database connection?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Input Validation] Since correspondent_address is not validated in load(), can an attacker pass NULL, undefined, empty string, or SQL wildcards (%, _) that, when used in the WHERE clause, either return no results (DoS) or potentially match multiple correspondent addresses if the database performs pattern matching, causing privacy violation by leaking messages from other users?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Input Validation] The purge() function accepts correspondent_address without any validation - can an attacker pass NULL or undefined values that cause the WHERE clause to become 'correspondent_address IS NULL', potentially deleting all messages that have NULL correspondent_address (if any exist due to data corruption), or causing the query to fail and preventing legitimate purge operations?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Authorization Bypass] The load() function performs no authorization checks to verify the caller has permission to access messages for the specified correspondent_address - can any code within the application (including compromised dependencies or malicious plugins) call load() with arbitrary correspondent addresses to read private chat messages between other users, causing complete breakdown of message privacy and confidentiality?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Authorization Bypass] The store() function performs no authorization checks - can malicious code forge chat messages by calling store() with arbitrary correspondent_address and is_incoming values, potentially impersonating other users in chat histories, injecting fake messages to manipulate users, or creating false evidence of conversations that never occurred?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Authorization Bypass - CRITICAL] The purge() function allows deletion of all messages for a correspondent_address without any authorization check or confirmation - can malicious code or a compromised component call purge() to permanently delete another user's entire chat history, causing irreversible data loss and potential legal/compliance issues if chat records are required for audit or dispute resolution?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Data Loss] Since purge() deletes messages without any backup, soft-delete mechanism, or recovery option, and provides no callback to confirm deletion success or failure, can accidental calls to purge() (e.g., from buggy code or race conditions) cause permanent, unrecoverable loss of important chat data, violating data retention requirements or user expectations of message persistence?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Variable Shadowing - Logic Error] At line 6, the code declares 'var type = type || text' which shadows the type parameter passed to the function - does this cause the function to always use the default 'text' value regardless of what type was actually passed by the caller, breaking support for non-text message types (e.g., 'payment_request', 'file', etc.) and causing all messages to be incorrectly classified, potentially breaking message rendering or filtering logic?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Variable Shadowing - Undefined Behavior] Given the variable shadowing at line 6 where 'var type = type || text', if the caller intentionally passes type=0, type='', or type=false (falsy values), will these be overridden with 'text' due to the || operator, causing legitimate message types to be lost and all messages to default to 'text', breaking chat functionality for special message types?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Error Handling] The store() function calls db.query() without providing any error handling callback or catching exceptions - if the database insert fails (due to constraint violations, disk full, or database corruption), will the error silently disappear, causing messages to be lost without any notification to the user or logging for debugging, leading to unreliable message delivery and potential data loss?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Error Handling] The load() function passes rows directly to the callback (line 15) without checking if the query succeeded or if an error occurred - can database errors (connection timeout, locked database, corrupted table) cause undefined or NULL to be passed to the callback, potentially crashing the calling code if it doesn't expect error conditions, causing application instability?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Error Handling] The purge() function calls db.query() without any callback at all - if the DELETE query fails (database locked, foreign key constraint, or permission error), will the calling code assume the deletion succeeded when it actually failed, causing the application to be in an inconsistent state where the UI shows messages as deleted but they remain in the database?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Error Handling] If the db.query() call in load() throws an exception (before invoking the callback), the error propagates up to the caller but the callback is never invoked - can this cause the calling code to hang indefinitely waiting for the callback, leading to resource leaks (unclosed connections, memory leaks from pending promises) or application freezing?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Race Condition] Since store() performs no transaction management or locking, if two concurrent calls to store() attempt to insert messages for the same correspondent at nearly the same time, can race conditions in the auto-increment ID assignment cause messages to appear out of order in the database relative to their actual arrival time, breaking chronological chat history and causing confusion about message sequences?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Race Condition] If load() is called while store() operations are in progress for the same correspondent_address, can the query return a partially committed set of messages (if database isolation level is READ UNCOMMITTED) or miss messages that were inserted after the query started but before it completed, causing inconsistent chat history views where messages appear and disappear unpredictably?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Race Condition] If purge() is called while load() or store() operations are active for the same correspondent_address, can this cause database lock conflicts, deadlocks, or cause load() to return an empty result set mid-query as rows are deleted, potentially confusing the application state or causing it to think the chat history was never present?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Race Condition - Cascade Delete] Since the chat_messages table has a foreign key with ON DELETE CASCADE to correspondent_devices, if purge() executes concurrently with deletion of the correspondent_device record, can race conditions cause double-deletion attempts, foreign key constraint errors, or leave orphaned messages if the cascade hasn't completed, causing database inconsistency?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Transaction Atomicity] The store() function performs a single INSERT without wrapping it in a transaction - if the application needs to store multiple related messages atomically (e.g., a message and its associated metadata or payment notification), can partial failures cause some messages to be stored while others are not, breaking the atomicity of multi-message operations and leaving the chat state inconsistent?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Transaction Atomicity] The purge() function performs a DELETE without transaction wrapping - if the application logic requires purging messages atomically with other operations (e.g., also deleting the correspondent_devices entry or clearing related state), can partial failures cause messages to be deleted while related data remains, creating orphaned records or inconsistent application state?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Foreign Key Violation] The chat_messages table has a foreign key constraint on correspondent_address referencing correspondent_devices(device_address) - if store() is called with a correspondent_address that doesn't exist in correspondent_devices, will the INSERT fail with a foreign key violation error that is not handled, causing message storage to silently fail and potentially losing messages during device pairing or before correspondent is fully registered?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Cascade Delete Behavior] While purge() explicitly deletes messages, the chat_messages table has 'ON DELETE CASCADE' from correspondent_devices - can this create confusion where messages are deleted through two different code paths (explicit purge vs. cascade from device deletion), potentially causing the calling code to perform redundant operations, miss cleanup tasks, or fail to properly notify the user about data deletion?",
  "[File: byteball/ocore/chat_storage.js] [All Functions] [Foreign Key Enforcement] The sqlite_pool.js file executes 'PRAGMA foreign_keys = 1' to enable foreign key constraints - but if this PRAGMA fails or is disabled in certain environments (older SQLite versions, misconfiguration), will the foreign key constraints be silently ignored, allowing store() to insert messages for non-existent correspondents and creating orphaned data that violates referential integrity?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Performance DoS] The load() query uses 'ORDER BY id DESC' without ensuring an index exists on (correspondent_address, id) - can an attacker repeatedly call load() with large limit values to force full table scans and expensive sorting operations, causing CPU exhaustion and database lock contention that degrades performance for all users, achieving denial of service through resource exhaustion?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Index Coverage] While an index exists on (correspondent_address, id), the query uses 'id < up_to_id' which may not be efficiently served by this index in some SQLite query planner scenarios - can this cause SQLite to choose sub-optimal query plans that scan large portions of the table, causing O(n) query time instead of O(log n), making the application unresponsive when loading messages from correspondents with large chat histories?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Missing Callback] The store() function provides no return value, callback, or promise to indicate success or failure - can calling code never know if a message was successfully stored, making it impossible to implement retry logic, show delivery confirmations to users, or detect database failures, potentially causing silent message loss that users are unaware of?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Callback Signature] The load() function passes rows directly to the callback without any error parameter - how can calling code distinguish between 'query succeeded with zero results' vs. 'query failed', potentially causing it to interpret database errors as empty chat histories and incorrectly showing 'no messages' when there were actually database connection problems?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Missing Callback] The purge() function provides no callback to indicate completion or return the count of deleted rows - can calling code never know if the purge completed successfully or how many messages were deleted, making it impossible to show feedback to users (e.g., 'Deleted 50 messages') or to detect failures where messages were not actually deleted?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Timestamp Integrity] The store() function relies on the database DEFAULT CURRENT_TIMESTAMP for creation_date (line 7 doesn't specify creation_date) - can clock skew on the database server, timezone misconfigurations, or manual time changes cause messages to have incorrect timestamps, potentially showing messages out of chronological order or with future timestamps that break chat history display logic?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Result Set Ordering] The load() function uses 'ORDER BY id DESC' to get newest messages first, but returns them in that order to the callback - does the calling code need to reverse the array to display messages chronologically, and if so, is this consistent across all callers, or can inconsistent handling cause messages to appear in different orders in different parts of the UI?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Pagination State] The load() function uses up_to_id for pagination but doesn't return any continuation token or metadata about whether more messages exist - can calling code inadvertently implement infinite pagination loops by repeatedly calling load() with the same up_to_id if no messages are returned, or fail to show 'Load More' UI when additional messages exist above the oldest loaded message?",
  "[File: byteball/ocore/chat_storage.js] [Function: store()] [Storage Exhaustion] Since store() accepts unlimited message sizes and frequencies without rate limiting or quotas, can an attacker spam store() calls with maximum-size LONGTEXT messages to rapidly exhaust all available disk space on the database server, causing the entire application to fail when the database can no longer accept writes, achieving permanent denial of service until disk space is manually freed?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Query DoS] Can an attacker repeatedly call load() with limit=999999999 and random correspondent_address values to force the database to perform expensive full table scans, holding database locks and consuming CPU resources, making the database unresponsive for legitimate queries and causing cascade failures across all database-dependent application features?",
  "[File: byteball/ocore/chat_storage.js] [Function: purge()] [Lock Contention] Since purge() performs DELETE FROM chat_messages WHERE correspondent_address=? without limiting the number of rows, can deleting a correspondent with millions of messages cause long-running DELETE operations that hold database locks, blocking all other queries on the chat_messages table and causing application-wide denial of service until the DELETE completes?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Privacy Isolation] The load() function filters messages by correspondent_address in the WHERE clause, but if there are database index corruption issues or query planner bugs, can messages from different correspondents leak into the result set, causing users to see fragments of other users' private conversations, violating privacy guarantees and potentially exposing sensitive information?",
  "[File: byteball/ocore/chat_storage.js] [Function: load()] [Privacy - Timing Attack] Since load() query performance varies based on the number of messages for a correspondent_address, can an attacker measure query response times to infer how many messages exist in other users' chat histories, potentially revealing metadata about communication patterns and relationship intensity without directly accessing the message content?",
  "[File: byteball/ocore/chat_storage.js] [Module Exports] [API Misuse] The module exports all three functions (store, load, purge) globally without any access control wrapper - can any code in the application or in third-party dependencies import this module and directly call these functions, bypassing any higher-level permission checks or business logic that should gate access to chat storage, creating a privilege escalation vulnerability?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Double-spend via race condition] When inputs.pickDivisibleCoinsForAmount() selects UTXOs at line 495-512, if two concurrent calls to composeJoint() for the same paying_addresses occur before either transaction commits, can both units select and spend the same UTXOs, creating a double-spend that bypasses the mutex lock since the lock is released before validation completes at line 586?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Integer overflow in total_input] At line 503, when _total_input is assigned from pickDivisibleCoinsForAmount(), if an attacker crafts inputs that cause total_input to overflow beyond Number.MAX_SAFE_INTEGER, can the subsequent change calculation at line 530 produce a negative or incorrect change amount, allowing theft of funds?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [UTXO selection bypass via params.inputs] At lines 478-487, if params.inputs is provided directly, the code skips UTXO selection and uses the provided inputs without verifying they are unspent or owned by arrPayingAddresses. Can an attacker pass arbitrary inputs to spend outputs they don't own or that are already spent?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Insufficient input validation on params.input_amount] At line 479-480, when params.inputs is provided, the code requires params.input_amount but doesn't validate it matches the actual sum of params.inputs amounts. Can an attacker provide mismatched values to bypass balance checks?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Race condition in spend_unconfirmed flag] At line 496, the spend_unconfirmed flag is passed to pickDivisibleCoinsForAmount(). If an attacker sends multiple transactions with spend_unconfirmed='all' simultaneously, can they spend the same unconfirmed outputs multiple times before any transaction is validated?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Genesis issue input manipulation] At lines 469-476, for genesis units, an issueInput with serial_number: 1 and amount: constants.TOTAL_WHITEBYTES is created. If an attacker modifies the issueInput.address field in multi-author genesis (line 471), can they redirect the initial coin issuance to an attacker-controlled address?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Target amount calculation overflow] At line 494, target_amount is calculated as total_amount + naked_size + oversize_fee + tps_fee + burn_fee + vote_count_fee. If any of these values are manipulated to be very large, can the sum overflow causing pickDivisibleCoinsForAmount() to select insufficient inputs?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Naked size manipulation via paid_temp_data_fee] At line 492, paid_temp_data_fee is calculated and used to adjust oversize fee calculation at line 493. If an attacker crafts temp_data messages to manipulate paid_temp_data_fee, can they reduce the target_amount and underpay fees?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Headers commission manipulation] At line 464, objUnit.headers_commission is calculated before inputs are selected. If an attacker later adds more authors or modifies the unit structure, can the headers_commission become outdated, causing the unit to be under-feeded when validated?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Payload commission recalculation inconsistency] At lines 465 and 474/483/505, payload_commission is calculated/assigned multiple times. If inputs change the payload size (line 506), but the change isn't reflected in fee calculations, can units be composed with insufficient fees?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [TPS fee calculation race condition] At lines 370-386, TPS fee is calculated based on tps_fees_balance queried from the database. If an attacker sends multiple transactions concurrently before their TPS fee balances are updated, can they bypass TPS fee payment by using stale balance data?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [TPS fee recipient manipulation] At line 374, getTpsFeeRecipients() determines who pays TPS fees based on earned_headers_commission_recipients. Can an attacker manipulate this field to make other addresses pay their TPS fees, or to select recipients with higher tps_fees_balance to reduce their own payment?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [TPS fee share calculation exploit] At lines 376-383, each recipient's TPS fee is calculated as Math.ceil(tps_fee - tps_fees_balance / share). If multiple recipients have sufficient balance, but paid_tps_fee takes the maximum (line 382-383), can an attacker structure recipients to minimize their actual TPS fee payment?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Oversize fee bypass via naked_size manipulation] At line 493, oversize_fee is calculated based on naked_size - paid_temp_data_fee. If an attacker adds temp_data messages after this calculation at line 507-509, can they avoid paying oversize fees for the additional payload?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Max fee ratio bypass] At lines 515-521, the code checks if additional_fees > max_ratio * size_fees. If an attacker sets params.max_fee_ratio to Infinity or a very large number, can they bypass this protection and compose units with excessive fees that other nodes reject?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Vote count fee bypass] At line 466, vote_count_fee is set only if a system_vote_count message exists. If an attacker removes this message after the fee is calculated but before unit finalization, can they avoid paying the SYSTEM_VOTE_COUNT_FEE?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Change calculation underflow] At line 530, change is calculated as total_input - total_amount - all fees. If fees are calculated incorrectly or total_input is manipulated, can change become negative, causing the error check at line 531-537 to fail only for non-send_all transactions, allowing negative change in send_all mode?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Burn fee manipulation] At lines 254-255, burn_fee is added to objUnit if params.burn_fee is provided. Can an attacker set an extremely high burn_fee to make the transaction invalid while consuming UTXO locks, causing a DoS on the paying addresses?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Fee calculation with unconfirmed parent units] When last_ball_mci is determined at line 369, if it's based on unconfirmed parent units that later become invalid, can the fee calculations (which depend on upgrade MCIs like constants.v4UpgradeMci) become incorrect after the parent units are rejected?",
  "[File: byteball/ocore/composer.js] [Function: estimateTpsFee()] [TPS fee estimation inaccuracy] At lines 593-620, estimateTpsFee() returns tps_fee based on a single address's balance (line 617-619). For multi-author units where multiple addresses pay TPS fees, can this underestimate the actual fee, causing composition to fail when the real composeJoint() is called?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Multiple change outputs vulnerability] At lines 211-212, the code throws an error if there are more than one change output. However, what if an attacker modifies arrChangeOutputs array after this check but before the change amount is set at line 539? Can they create multiple change outputs with arbitrary amounts?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [No change output bypass] At lines 213-214, the code throws an error if there are zero change outputs. But if params.outputs is modified by the retrieveMessages callback at lines 447-461, can an attacker remove all change outputs after the initial validation?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Change output address manipulation] At lines 208-214, arrChangeOutputs is filtered based on output.amount === 0. If an attacker provides an output with amount = 0 but later modifies it, or provides negative amounts that get filtered incorrectly, can they bypass change output validation?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Change output sorting attack] At line 540, outputs are sorted using sortOutputs(). If the sorting function has vulnerabilities (line 35-38 compares addresses lexicographically), can an attacker craft addresses that sort unexpectedly, causing the change output to not be in the expected position?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Zero change handling in send_all mode] At lines 531-537, if change <= 0 in send_all mode, it returns NOT_ENOUGH_FUNDS error. But what happens if change is exactly 0? Is this a valid state, and can it cause the change output (which expects amount > 0 after assignment at line 539) to have 0 amount, causing validation failures?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Change output asset mismatch] The change output at line 539 is assigned an amount in the base asset. If the transaction involves multiple assets, how is the change for non-base assets handled? Can an attacker exploit this to lose non-base asset change or steal it?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Unstable predecessor bypass] At lines 325-344, checkForUnstablePredecessors() queries for unstable definition changes and non-serial sequences. If an attacker times their transaction to reference a parent unit right before a definition change stabilizes, can they bypass this check and include an unstable definition in their unit?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Definition change race condition] At line 330-340, the query checks for definition changes with main_chain_index > last_ball_mci OR NULL. If a definition change is added to a unit after last_ball_mci is determined but before the unit is composed, can the check miss it, allowing unstable definitions?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Parent unit manipulation in light mode] At lines 346-354, for light clients, parent_units, last_ball, and last_ball_unit are taken directly from lightProps provided by the light vendor. Can a malicious light vendor provide fake parent units that don't exist or last_ball values that fork the chain?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Last ball MCI manipulation] At line 369, last_ball_mci is set based on parentComposer.pickParentUnitsAndLastBall(). If an attacker controls some parent units and delays their propagation, can they influence the last_ball_mci to manipulate fee calculations or bypass upgrade checks?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Primary AA trigger counting exploit] At lines 371-372, the code queries aa_addresses to count primary AA triggers. If an attacker repeatedly adds and removes AA addresses during composition, can they cause a race condition that miscounts triggers, affecting max_aa_responses and TPS fee calculations?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Timestamp manipulation] At lines 321, 351, and 356, objUnit.timestamp is set based on Date.now() or lightProps.timestamp. Can an attacker manipulate the system clock or light vendor response to set timestamps far in the future or past, affecting parent selection and potentially causing validation failures?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Genesis timestamp bypass] At line 321, for genesis units with witnesses and v4UpgradeMci === 0, timestamp is set to Math.round(Date.now() / 1000). Otherwise it's set to 1561049490. Can an attacker exploit this branching to create genesis units with controlled timestamps?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Parent unit non-existence] The code at lines 357-389 calls parentComposer.pickParentUnitsAndLastBall() but doesn't validate that the returned parent units actually exist in the database before using them at line 366. Can this cause composed units to reference non-existent parents?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Last ball unit mismatch] At lines 368-369, both last_ball and last_ball_unit are set. If these two values are inconsistent (last_ball_unit doesn't hash to last_ball), can the composed unit pass initial checks but fail validation later, causing wasted resources?",
  "[File: byteball/ocore/composer.js] [Function: composeAuthorsForAddresses()] [Definition disclosure bypass] At lines 866-872 and 894-906, the code decides whether to include the address definition based on whether the address has been used before and if there's a definition change. Can an attacker avoid including their definition by creating units in a specific sequence, allowing them to later claim a different definition?",
  "[File: byteball/ocore/composer.js] [Function: composeAuthorsForAddresses()] [Authentifier placeholder length mismatch] At lines 879-882, authentifiers are filled with placeholder dashes based on assocLengthsBySigningPaths. If the signer returns a signature of different length than expected, can this cause the unit hash to change after signing, invalidating all signatures?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Signature replacement attack] At lines 543-588, signatures are added after the unit structure is finalized. If the signer.sign() callback at line 551-559 or signer.readPrivateKey() at line 562-567 is compromised, can an attacker replace signatures with invalid ones after the unit hash is calculated?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Multisig refusal DoS] At lines 555-556, if a cosigner returns '[refused]', the entire composition fails with error. Can a malicious cosigner repeatedly refuse to sign, causing DoS on all other participants' funds that are locked by the mutex?",
  "[File: byteball/ocore/composer.js] [Function: composeAuthorsForAddresses()] [Definition change timing] At lines 894-906, the code queries for the last stable definition change and checks if the definition is in the database. If a definition change occurs between the query and the unit being composed, can the wrong definition be included or omitted?",
  "[File: byteball/ocore/composer.js] [Function: composeAuthorsForAddresses()] [First message definition requirement] At lines 891-892, if no previous messages exist from an address, setDefinition() is called unconditionally. Can an attacker exploit this by sending many first-time messages to bloat units with redundant definitions?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Author ordering manipulation] At line 218, arrFromAddresses is sorted. If the sorting is inconsistent with how validation.js orders authors, can composed units be rejected? Can an attacker exploit different sorting algorithms to create units that pass composition but fail validation?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Signing path manipulation] At lines 548-549, the code iterates over Object.keys(author.authentifiers). If an attacker controls the signer and returns authentifiers with unexpected paths, can they cause signatures to be placed on wrong paths, bypassing definition requirements?",
  "[File: byteball/ocore/composer.js] [Function: composeAuthorsForAddresses()] [Sequence='good' requirement bypass] At line 887, the query only considers units with sequence='good'. If an attacker's first transaction has sequence='final-bad' or 'temp-bad', will setDefinition() be called, revealing their definition when it shouldn't be?",
  "[File: byteball/ocore/composer.js] [Function: composeAuthorsForAddresses()] [Stability check bypass for definitions] At line 884, the and_stable condition checks if last_ball_mci < constants.unstableInitialDefinitionUpgradeMci. Can an attacker compose units at the exact upgrade boundary to bypass stability checks on initial definitions?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Witness list vs witness_list_unit inconsistency] At lines 427-432 (light mode) and 435-444 (full node mode), the code sets either objUnit.witnesses or objUnit.witness_list_unit. Can an attacker exploit the branching logic to set both fields or neither field, causing validation failures?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Witness address reference check bypass] At lines 435-437, storage.determineIfWitnessAddressDefinitionsHaveReferences() checks if witness addresses have references. If this check has race conditions or can be bypassed, can an attacker use witnesses with references, violating the protocol?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Witness list from params vs opList inconsistency] At lines 133-147, witness list is obtained either from storage.getOpList() (post-v4) or params.witnesses (pre-v4) or myWitnesses.readMyWitnesses(). Can an attacker exploit the different code paths to use an incompatible witness list?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Genesis witness list manipulation] At lines 256-267, for genesis units with bGenesis && params.witnesses, system_vote messages for op_list are added. Can an attacker manipulate params.witnesses to vote for their own witnesses in the genesis unit, gaining control over consensus?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Witness list sorting attack] At line 261, params.witnesses.sort() is called. If the witnesses are not sorted consistently with how they're stored elsewhere, can this cause witness compatibility failures in descendant units?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [FindWitnessListUnit race condition] At line 438-444, storage.findWitnessListUnit() is called to find a unit with the same witness list. If multiple concurrent units are being composed with the same witnesses, can they all fail to find a witness_list_unit and redundantly include the full witness list?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Payload hash collision] At line 408, payload_hash is calculated for non-payment messages using objectHash.getBase64Hash(getPayloadForHash(message), bVersion2). Can an attacker craft two different payloads that hash to the same value by exploiting getPayloadForHash() logic at lines 622-628 which removes temp_data.data?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [retrieveMessages callback manipulation] At lines 447-461, fnRetrieveMessages callback can add additional messages to objUnit.messages. Can a malicious callback add messages that violate protocol rules, bypass fee calculations, or include malicious payloads that aren't properly validated?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Private payload association attack] At lines 457-459, assocMorePrivatePayloads from retrieveMessages are merged into assocPrivatePayloads. Can an attacker return private payloads with payload_hash keys that overwrite existing private payloads, causing data loss or confusion?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Message app field manipulation] At line 403-404, the code checks if message.app === 'payment' to skip payload_hash calculation. Can an attacker craft non-payment messages with app='payment' to bypass payload_hash validation?",
  "[File: byteball/ocore/composer.js] [Function: createTextMessage()] [Text message payload hash upgrade boundary] At line 44, the payload_hash for text messages uses storage.getMinRetrievableMci() >= constants.timestampUpgradeMci to determine the hash version. Can an attacker create text messages at the upgrade boundary that hash differently on different nodes, causing consensus failures?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Payment message payload_hash placeholder] At line 223, objPaymentMessage.payload_hash is set to hash_placeholder. At line 541, it's recalculated. Can an attacker interfere with this recalculation or cause the placeholder to remain, creating an invalid unit?",
  "[File: byteball/ocore/composer.js] [Function: getPayloadForHash()] [Temp data manipulation] At lines 622-628, for temp_data messages, the data field is deleted from the payload before hashing. Can an attacker exploit this to create two units with different temp_data.data but identical payload_hash, causing storage confusion?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Message ordering attack] The order of messages in objUnit.messages array affects the unit hash. Can an attacker manipulate message ordering (via retrieveMessages at line 456 or initial params.messages) to create intentional hash collisions or bypass validation?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Version downgrade attack] At lines 392-398, the unit version is determined based on last_ball_mci vs various upgrade MCIs. Can an attacker manipulate last_ball_mci to use an older version, bypassing new validation rules?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [TPS fee field inconsistency at v4 boundary] At lines 399-400, the code throws an error if last_ball_mci >= constants.v4UpgradeMci but tps_fee is not a number. Can an attacker compose units right at the upgrade boundary where this check might be inconsistent across nodes?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Timestamp upgrade MCI boundary confusion] At line 392, bVersion2 is determined by comparing last_ball_mci with constants.timestampUpgradeMci. If nodes have different values for this constant, can they compose units with different versions, causing rejection?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Version field not updated for genesis] At line 393-398, version is conditionally updated, but the initial version is set at line 241. For genesis units, can the version field remain at the wrong value if last_ball_mci is 0?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Payload hash version mismatch] At line 408, payload_hash for non-payment messages uses bVersion2, but at line 541, payment message payload_hash uses objUnit.version !== constants.versionWithoutTimestamp. Can these two checks diverge, causing inconsistent hashing?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Mutex lock scope mismatch] At line 289, mutex locks are acquired for 'c-'+from_address keys. But the actual operations span multiple async steps until line 586. Can operations after the database COMMIT at line 524 but before lock release at line 586 cause race conditions with other transactions?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Lock not released on error] At line 278-285, handleError() calls unlock_callback(). But what if an error occurs before unlock_callback is assigned at line 290? Can this cause permanent deadlock on the locked addresses?",
  "[File: byteball/ocore/composer.js] [Function: getSavingCallbacks()] [Double unlock vulnerability] At lines 724-728, combined_unlock() calls both validate_and_save_unlock() and composer_unlock(). If either of these throws an error, can the other unlock be skipped, causing deadlock? Or can combined_unlock() be called twice, causing double-unlock?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Transaction commit before lock release] At line 524, the database transaction is committed, but the mutex lock is not released until line 586 (via unlock_callback in ifOk callback). Can this extended lock duration cause DoS if an attacker sends many transactions that pass composition but fail validation?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Lock ordering deadlock] At line 289, locks are acquired in the order of arrFromAddresses.map(). If two transactions with overlapping addresses lock them in different orders, can this cause classic deadlock?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Connection pool exhaustion] At lines 312-315, a database connection is taken from the pool and held until line 525. If many concurrent composeJoint() calls occur, can they exhaust the connection pool, causing deadlock or long delays?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Light vendor response manipulation] At lines 301-305, the light vendor response is checked for required fields but not thoroughly validated. Can a malicious light vendor return parent_units that don't exist, or last_stable_mc_ball values that fork the chain?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Light vendor TPS fee manipulation] At line 353, lightProps.tps_fee is used directly if provided. Can a malicious light vendor return an artificially low tps_fee, causing the composed unit to underpay and be rejected by full nodes?",
  "[File: byteball/ocore/composer.js] [Function: postJointToLightVendorIfNecessaryAndSave()] [Light vendor acceptance bypass] At lines 802-814, light clients post units to the light vendor and only save if response is 'accepted'. Can a malicious light vendor return 'accepted' for invalid units, causing the light client to store and relay invalid data?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Light vendor witness_list_unit manipulation] At line 428-431, if lightProps.witness_list_unit is provided, it's used directly. Can a malicious light vendor provide a fake witness_list_unit that references a non-existent unit or witnesses that differ from the actual arrWitnesses?",
  "[File: byteball/ocore/composer.js] [Function: estimateTpsFee()] [Light vendor TPS fee estimation mismatch] At lines 598-606, light clients request TPS fee from the light vendor. If the vendor returns a different value than what the actual composeJoint() would calculate, can this cause composition failures after user confirms based on estimate?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Light mode timestamp trust] At line 351, light clients use lightProps.timestamp if provided, otherwise Date.now(). Can a malicious light vendor return timestamps far in the past or future to manipulate parent selection or validation?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Light mode output_addresses leak] At line 300, from_addresses and output_addresses are sent to the light vendor. Does this leak privacy about who is sending to whom? Can a malicious light vendor use this to track users or censor transactions?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Light mode max_aa_responses manipulation] At line 300, max_aa_responses is sent to light vendor and affects TPS fee calculation. Can a malicious light vendor ignore this and return incorrect TPS fees to cause transaction failures?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Genesis system vote injection] At lines 256-267, if bGenesis && params.witnesses, system_vote and system_vote_count messages are added. Can an attacker who gains access to setGenesis() create genesis units with malicious system votes to control protocol parameters?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Genesis issue input address assignment] At lines 470-472, for multi-author genesis, issueInput.address is set to params.witnesses[0] or arrWitnesses[0]. Can an attacker manipulate this to issue coins to their own address in genesis?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Genesis ball calculation] At lines 579-580, for genesis units, objJoint.ball is calculated as objectHash.getBallHash(objUnit.unit). Can an attacker exploit this to create multiple genesis units with different balls, forking the chain from the start?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Genesis witness requirement bypass] At line 256, system votes are only added if bGenesis && params.witnesses. If params.witnesses is empty or undefined for genesis, can the genesis unit be created without proper witness voting, causing consensus failures?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Genesis timestamp manipulation v4] At line 321, for genesis with v4UpgradeMci === 0 and params.witnesses, timestamp uses Date.now()/1000. Can this allow different genesis timestamps on different nodes, breaking consensus?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Genesis last_ball_mci set to zero] At line 319, last_ball_mci = 0 for genesis. Can operations that depend on last_ball_mci being non-zero (like stability checks) fail or behave unexpectedly for genesis units?",
  "[File: byteball/ocore/composer.js] [Function: readSortedFundedAddresses()] [issued_by_definer_only bypass] At lines 673-677, if an asset is issued_by_definer_only and the definer_address is in arrAvailableAddresses, only that address is returned. Can an attacker modify arrAvailableAddresses after this check to include non-definer addresses, allowing them to spend issued_by_definer_only assets they don't own?",
  "[File: byteball/ocore/composer.js] [Function: readSortedFundedAddresses()] [Asset info race condition] At line 673, storage.readAssetInfo() is called to check asset properties. If the asset definition is changed between this read and when the transaction is validated, can the wrong issuance rules be applied?",
  "[File: byteball/ocore/composer.js] [Function: readSortedFundedAddresses()] [Non-existent asset handling] At lines 674-675, if asset doesn't exist, an error is thrown. But what if the asset is created between the check and when the transaction is processed? Can this cause unnecessary transaction failures?",
  "[File: byteball/ocore/composer.js] [Function: readSortedFundedAddresses()] [Asset balance query timing] At lines 656-662, the query for funded addresses includes conditions on sequence='good' and is_spent=0. If an input becomes spent between the query and when the transaction is composed, can a double-spend occur?",
  "[File: byteball/ocore/composer.js] [Function: readSortedFundedAddresses()] [Order by manipulation] At line 654, the ORDER BY clause uses SUM(amount)>estimated_amount DESC to prioritize addresses. Can an attacker exploit this by controlling multiple addresses with specific balances to ensure certain addresses are selected first for malicious purposes?",
  "[File: byteball/ocore/composer.js] [Function: filterMostFundedAddresses()] [Estimated amount overflow] At lines 634-646, if estimated_amount + MAX_FEE overflows at line 642, can the accumulated_amount check fail to break the loop, causing all addresses to be returned instead of a minimal set?",
  "[File: byteball/ocore/composer.js] [Function: readSortedFundedAddresses()] [Definition chash unstable bypass] At line 666, the subquery checks for unstable addresses with definition_chash IS NOT NULL AND definition_chash != address. Can an attacker time their transaction to use an address right before its definition becomes stable, bypassing this check?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Additional fees check timing] At lines 515-521, the additional fees check occurs after async input selection. If params.max_fee_ratio or conf.max_fee_ratio changes between estimation and final check, can the check be bypassed or incorrectly enforced?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Division by zero in max_fee_ratio] At line 519, if size_fees (headers_commission + payload_commission) is zero for some edge case unit, can the comparison additional_fees > max_ratio * size_fees cause division by zero or infinity issues?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Oversize fee recalculation] Oversize fee is calculated at lines 484-486, 493, and 507-509. If these calculations produce different results due to unit structure changes, which value is used for the final check at line 517? Can inconsistency cause under-feeing?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [TPS fee balance query race] At line 378, tps_fees_balance is queried for a specific mci. If the balance is updated by another transaction at the same mci between the query and commit, can the TPS fee calculation be based on stale data?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Negative TPS fee exploit] At line 381, addr_tps_fee is calculated as Math.ceil(tps_fee - tps_fees_balance / share). If tps_fees_balance is very large, can addr_tps_fee become negative, and then be set to paid_tps_fee at line 382-383, causing negative fees?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Paid temp data fee calculation] At line 492, paid_temp_data_fee is calculated but not validated. Can an attacker craft temp_data messages that cause getPaidTempDataFee() to return incorrect values, manipulating oversize fee calculations?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Minimal mode recursion depth] At lines 167-190, when params.minimal is true, trySubset() recursively tries adding more paying addresses. Can an attacker provide a very long arrCandidatePayingAddresses list to cause stack overflow or excessive recursion?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [MAX_AUTHORS_PER_UNIT check placement] At lines 172-173, the check for MAX_AUTHORS_PER_UNIT happens in trySubset(). Can an attacker bypass this by not using minimal mode, or by manipulating the count to exactly equal MAX_AUTHORS_PER_UNIT?",
  "[File: byteball/ocore/composer.js] [Function: composeJoint()] [Minimal mode params modification] At lines 174-176, try_params is created with _.clone(params), then minimal is deleted. Is this a shallow clone? Can nested objects in params be shared between iterations, causing unintended state mutations?",
  "[File: byteball/ocore/conf.js] [Function: mergeExports()] [Configuration Injection] Can an attacker place a malicious conf.js in the app root directory to override critical security parameters like MAX_TOLERATED_INVALID_RATIO or WS_PROTOCOL, causing the node to accept invalid units or downgrade to insecure ws:// protocol on mainnet, leading to network split or man-in-the-middle attacks?",
  "[File: byteball/ocore/conf.js] [Function: mergeExports()] [Prototype Pollution] Does the mergeExports() function at lines 6-9 validate that properties being merged do not include __proto__, constructor, or prototype keys, which could pollute the Object prototype and affect all modules loading this conf, potentially causing consensus failure or code execution?",
  "[File: byteball/ocore/conf.js] [Lines 98-104] [Path Traversal] When loading custom conf.js from appRootDir + '/conf.js', can an attacker manipulate the appRootDir path (e.g., via symlinks or directory traversal in desktopApp.getAppRootDir()) to load arbitrary JavaScript files, achieving remote code execution?",
  "[File: byteball/ocore/conf.js] [Lines 112-118] [Arbitrary File Read] When loading conf.json from appDataDir + '/conf.json', does the code validate that appDataDir points to the intended user directory, or can path traversal allow reading sensitive files (e.g., /etc/passwd, private keys) which are then merged into exports, leaking secrets?",
  "[File: byteball/ocore/conf.js] [Lines 98-104] [Code Injection via require()] The code uses require(appRootDir + '/conf.js') without validating that the file is safe JavaScript. Can an attacker who gains write access to the app root directory inject malicious code that executes during node startup, potentially stealing wallet keys or corrupting the database?",
  "[File: byteball/ocore/conf.js] [Lines 112-118] [JSON Parsing Vulnerabilities] While conf.json is loaded via require() (which parses JSON), can an attacker craft a malicious JSON file with deeply nested objects or circular references that cause memory exhaustion or crashes during parsing, leading to node unavailability?",
  "[File: byteball/ocore/conf.js] [Function: mergeExports()] [Configuration Override Race Condition] If multiple modules simultaneously call require('ocore/conf.js') and attempt to override properties via direct assignment (line 82-85 pattern), can race conditions cause non-deterministic configuration across different nodes, leading to network split?",
  "[File: byteball/ocore/conf.js] [Lines 93-96] [Package.json Tampering] The code loads appPackageJson = require(appRootDir + '/package.json') and uses its name/version as exports.program and exports.program_version. Can an attacker tamper with package.json to inject malicious program names that break compatibility checks in network.js or cause logging/telemetry corruption?",
  "[File: byteball/ocore/conf.js] [Lines 122-131] [Database Configuration Override] After merging custom configs, default database settings are applied if still unset. Can an attacker provide a partial conf.json that sets exports.storage = 'mysql' but omits database.user, causing the node to connect to MySQL as default user 'byteball', potentially accessing wrong database or triggering permission errors that halt the node?",
  "[File: byteball/ocore/conf.js] [Lines 68-71] [Forced Configuration for Cordova] When bCordova is detected, the code forces exports.storage = 'sqlite' and exports.bLight = true. Can an attacker spoof the Cordova environment (by setting window.cordova in a desktop app) to force light mode on a full node, causing it to not validate units fully and accept invalid DAG history?",
  "[File: byteball/ocore/conf.js] [Lines 52] [Protocol Downgrade Attack] The WS_PROTOCOL is set to 'ws://' if process.env.devnet is truthy, otherwise 'wss://'. Can an attacker manipulate the environment variable (e.g., via .env file injection or process spawn) to force ws:// on mainnet, exposing all peer communications to man-in-the-middle attacks and allowing unit injection or censorship?",
  "[File: byteball/ocore/conf.js] [Lines 54-55] [Connection Limit DoS] MAX_INBOUND_CONNECTIONS and MAX_OUTBOUND_CONNECTIONS are both set to 100. Can an attacker override these via custom conf to set MAX_INBOUND_CONNECTIONS = Infinity or Number.MAX_SAFE_INTEGER, causing the node to accept unlimited connections and run out of file descriptors or memory, leading to crash and network unavailability?",
  "[File: byteball/ocore/conf.js] [Line 56] [Invalid Joint Ratio Manipulation] MAX_TOLERATED_INVALID_RATIO = 0.1 means peers sending >10% invalid joints are banned. Can an attacker set this to 1.0 (100%) via conf override, causing the node to never ban malicious peers who flood it with invalid units, leading to resource exhaustion and failure to sync with honest peers?",
  "[File: byteball/ocore/conf.js] [Line 57] [Peer Discovery Attack] MIN_COUNT_GOOD_PEERS = 10 determines when the node requests peer lists from other peers. Can an attacker set this to 0 via conf override, causing the node to never discover new peers and remain isolated if its hardcoded peers go offline, leading to network partition?",
  "[File: byteball/ocore/conf.js] [Line 17] [Port Binding DoS] exports.port is set to null by default (no incoming connections). If an attacker overrides this to a privileged port (e.g., 80, 443) or a port already in use, does the node crash on startup or gracefully handle the error? Crash-on-startup attacks can prevent node recovery after restarts.",
  "[File: byteball/ocore/conf.js] [Lines 41-46] [SOCKS Proxy Hijacking] If socksHost, socksPort, socksUsername, socksPassword are set via conf override, can an attacker specify a malicious SOCKS proxy that logs all peer communications, modifies units in transit, or selectively drops critical units (e.g., witness heartbeats), causing consensus divergence?",
  "[File: byteball/ocore/conf.js] [Line 49] [HTTP Proxy Injection] If httpsProxy is set to an attacker-controlled proxy (e.g., 'http://malicious-proxy:3128'), can the attacker intercept TLS connections to peers, inject fake units, or strip witness proofs from light client requests, causing the node to accept invalid history?",
  "[File: byteball/ocore/conf.js] [Line 59] [Peer Request Manipulation] exports.bWantNewPeers = true enables peer discovery. Can an attacker set this to false via conf override on a subset of nodes, partitioning the network into isolated clusters that don't share peers, causing divergent DAGs when witness voting differs across clusters?",
  "[File: byteball/ocore/conf.js] [Line 62] [Unpair Request Ignore] exports.bIgnoreUnpairRequests = false by default. Can an attacker set this to true on victim nodes, preventing them from removing malicious paired devices that send spam or invalid units, leading to resource exhaustion or wallet corruption?",
  "[File: byteball/ocore/conf.js] [Lines 122-127] [MySQL Connection Exhaustion] For MySQL storage, exports.database.max_connections defaults to 1. Can an attacker override this to 1000+ connections, causing the node to open excessive database connections that exhaust MySQL server resources or hit per-user connection limits, leading to database unavailability and node crash?",
  "[File: byteball/ocore/conf.js] [Lines 124-126] [MySQL Credential Injection] Default MySQL credentials are database.name='byteball', database.user='byteball', database.host='localhost'. Can an attacker override database.host to point to a malicious MySQL server that returns fake DAG data (e.g., modified units or balances), causing the node to accept invalid history and diverge from network consensus?",
  "[File: byteball/ocore/conf.js] [Lines 128-131] [SQLite File Path Manipulation] For SQLite, database.filename defaults to 'byteball-light.sqlite' or 'byteball.sqlite'. Can an attacker override this to an absolute path (e.g., '/tmp/malicious.db' or '../../../etc/shadow') to cause the node to read/write arbitrary files, potentially corrupting system files or leaking sensitive data?",
  "[File: byteball/ocore/conf.js] [Lines 128-131] [SQLite Database Substitution] Can an attacker replace the SQLite database file specified in database.filename with a pre-crafted malicious database containing fake units, modified balances, or incorrect witness lists, causing the node to operate on corrupted state and reject valid units from honest peers?",
  "[File: byteball/ocore/conf.js] [Line 67] [Storage Engine Switch Attack] exports.storage defaults to 'sqlite'. Can an attacker override this to 'mysql' on a node that was previously running SQLite, causing the node to attempt MySQL connection without valid credentials, crash, and lose sync with the network until manually reconfigured?",
  "[File: byteball/ocore/conf.js] [Lines 68-71] [Cordova Detection Bypass] The code detects Cordova via typeof window === 'object' && window && window.cordova. Can an attacker running a desktop app create a fake window.cordova object to trick the node into light mode and SQLite storage, bypassing full node validation and accepting invalid units from malicious light servers?",
  "[File: byteball/ocore/conf.js] [Line 74] [Updatable Asset Registry Manipulation] exports.updatableAssetRegistries = ['O6H6ZIFI57X3PLTYHOCVYPP5A553CYFQ'] specifies a single registry address. Can an attacker override this array to add malicious registry addresses or remove the legitimate one, causing asset metadata queries to fail or return fake asset information that misleads users about asset properties?",
  "[File: byteball/ocore/conf.js] [Line 74] [Asset Registry Collision] If an attacker creates a custom conf that appends their own asset registry address to updatableAssetRegistries, can they inject fake asset definitions that override legitimate assets, causing the node to display incorrect decimals, names, or caps for existing assets?",
  "[File: byteball/ocore/conf.js] [Line 3] [Singleton Bypass] The file requires './enforce_singleton.js' to prevent multiple instances. Can an attacker bypass this by deleting node_modules cache or using dynamic require() with modified paths, causing multiple conf.js instances with different configurations to coexist, leading to non-deterministic behavior and consensus divergence?",
  "[File: byteball/ocore/conf.js] [Line 4] [Constants Loading Order] The file requires './constants.js' to force loading .env before app-root conf.js. Can an attacker manipulate the require order by modifying Node.js require.cache to load app-root conf.js first, overriding critical environment variables (e.g., devnet flag) before constants are loaded, causing protocol mismatch?",
  "[File: byteball/ocore/conf.js] [Lines 82-86] [Direct Export Modification Race] The comments suggest modules can modify conf at runtime via 'var conf = require(\\",
  "[File: byteball/ocore/conf.js] [Lines 82-86] [Late Configuration Override] If a module modifies conf properties after network.js, storage.js, or validation.js have already read them, can this cause inconsistent state where network module uses old connection limits but new units are validated with new parameters, leading to unit rejection and network partition?",
  "[File: byteball/ocore/conf.js] [Line 11-12] [ExplicitStart Override] The commented-out exports.explicitStart = true suggests network.start() must be called explicitly. Can an attacker enable this via conf override but fail to call network.start(), causing the node to never connect to peers while appearing to run normally, resulting in stale DAG state and missed transactions?",
  "[File: byteball/ocore/conf.js] [Line 28] [Hub Mode Exploitation] exports.bServeAsHub is commented out (default false). Can an attacker enable this on a malicious node to advertise itself as a hub, then serve fake witness proofs or censored unit history to light clients that connect, causing them to accept invalid transactions or miss important units?",
  "[File: byteball/ocore/conf.js] [Line 31] [Forced Light Mode Attack] exports.bLight is commented out (default false for full node). Can an attacker enable this via conf override on a full node, causing it to skip unit validation, accept invalid units from light servers, and then propagate these invalid units to other full nodes, corrupting the network?",
  "[File: byteball/ocore/conf.js] [Lines 31, 70] [Light Mode Inconsistency] Light mode can be set via exports.bLight = true in conf override OR automatically when Cordova is detected. Can this dual-source configuration cause confusion where a node believes it's in full mode (conf says false) but operates in light mode (Cordova detected), leading to validation bypasses?",
  "[File: byteball/ocore/conf.js] [Line 25] [MyUrl Spoofing] exports.myUrl is commented out but used by network.js for peer announcements. Can an attacker set this to a malicious URL (e.g., 'wss://phishing-site.com/bb') causing other nodes to connect to the attacker's server instead of the legitimate node, enabling man-in-the-middle attacks on peer connections?",
  "[File: byteball/ocore/conf.js] [Lines 33-39] [Bug Report Hijacking] exports.bug_sink_url specifies where crash reports and errors are sent. Can an attacker override this to their own server, causing all error reports (which may contain sensitive data like unit hashes, addresses, or partial keys) to be exfiltrated, enabling targeted attacks on users experiencing specific bugs?",
  "[File: byteball/ocore/conf.js] [Line 38] [Email Header Injection] exports.bug_sink_email and bugs_from_email are used for sending error reports via email. Can an attacker inject CRLF characters or malicious email headers into these fields (e.g., 'attacker@evil.com\\nBcc: spam-list@spam.com') to spam users or inject malicious content into error report emails?",
  "[File: byteball/ocore/conf.js] [Line 22] [Port Reuse Attack] exports.portReuse is commented out but if enabled, allows reusing an existing socket port. Can an attacker enable this and bind multiple nodes to the same port, causing connection race conditions where some peer requests go to the wrong node, leading to confused unit propagation or consensus failure?",
  "[File: byteball/ocore/conf.js] [All exports] [Network.js Dependency] If network.js reads MAX_INBOUND_CONNECTIONS, MAX_OUTBOUND_CONNECTIONS, and MAX_TOLERATED_INVALID_RATIO from conf.js before validation.js initializes, can a race condition cause network module to accept connections from peers that send invalid units before validation rules are loaded, allowing early DoS attacks?",
  "[File: byteball/ocore/conf.js] [All exports] [Storage.js Dependency] If storage.js reads database configuration from conf.js but database credentials are overridden later via runtime conf modification, can this cause storage module to connect to the wrong database mid-execution, corrupting DAG state or causing unit writes to fail?",
  "[File: byteball/ocore/conf.js] [Line 52] [Network.js Protocol Check] Does network.js validate that WS_PROTOCOL matches the expected protocol for the network (livenet must be wss://, testnet can be ws://)? If conf.js allows ws:// on livenet via environment variable manipulation, does network.js reject connections or silently accept insecure connections?",
  "[File: byteball/ocore/conf.js] [Lines 54-57] [Validation.js Parameter Mismatch] If validation.js and network.js both read MAX_TOLERATED_INVALID_RATIO but at different times, can a runtime conf modification cause validation to use 0.1 while network uses 0.5, leading to inconsistent peer banning where validation rejects units but network keeps the peer connection alive?",
  "[File: byteball/ocore/conf.js] [Line 52] [Environment Variable Injection] WS_PROTOCOL depends on process.env.devnet. Can an attacker who gains access to the system set a persistent environment variable (e.g., via .bashrc, systemd service file, or Docker ENV) to force devnet mode on a production node, causing it to use ws:// and accept connections from insecure peers?",
  "[File: byteball/ocore/conf.js] [Line 52] [Devnet Flag Persistence] If a node is started with process.env.devnet=true for testing, then restarted without the flag, does the node correctly switch back to wss:// or does cached configuration persist, causing the node to continue using insecure protocol after restart?",
  "[File: byteball/ocore/conf.js] [Lines 122-131] [MySQL/SQLite Confusion] If a node is configured with exports.storage = 'mysql' but database.filename is also set (SQLite parameter), does the database initialization logic in db.js or storage.js detect this inconsistency, or can it cause the node to attempt opening both databases simultaneously, leading to corrupted state or crashes?",
  "[File: byteball/ocore/conf.js] [Lines 128-131] [Light/Full Database Mismatch] SQLite filename defaults to 'byteball-light.sqlite' if exports.bLight is true, else 'byteball.sqlite'. If bLight is toggled at runtime via conf modification after database connection is established, can this cause the node to write full-node data to light database or vice versa, corrupting the schema or indexes?",
  "[File: byteball/ocore/conf.js] [Lines 98-118] [Configuration Source Priority] If both appRootDir/conf.js and appDataDir/conf.json exist and set conflicting values for the same property (e.g., MAX_INBOUND_CONNECTIONS), which takes precedence? Can an attacker exploit this priority to override security-critical settings set by the app developer via user conf.json injection?",
  "[File: byteball/ocore/conf.js] [Lines 99-104] [JavaScript Code Execution] App root conf.js is loaded via require(), executing arbitrary JavaScript. Can an attacker who compromises the app root directory inject a malicious conf.js that executes code to steal private keys, modify other config files, or establish backdoors, even if the node never explicitly calls require on that file?",
  "[File: byteball/ocore/conf.js] [Lines 113-117] [JSON Injection via conf.json] While conf.json is safer than conf.js (no code execution), can an attacker inject JSON with prototype pollution payloads (e.g., {\\",
  "[File: byteball/ocore/conf.js] [Lines 102-104] [Fail-Open Config Loading] When loading app root conf.js fails (catch block prints 'not using app root conf' but continues), can an attacker deliberately cause this load to fail (e.g., by introducing syntax errors) to prevent security-hardening configurations from being applied, leaving the node with default insecure settings?",
  "[File: byteball/ocore/conf.js] [Lines 115-118] [Fail-Open User Config] Similarly, if user conf.json load fails, the node continues with defaults. Can an attacker corrupt the conf.json file (e.g., via partial write or disk error) to force fallback to defaults, bypassing user-specified connection limits or witness lists?",
  "[File: byteball/ocore/conf.js] [No witness configuration] This file does not set witness lists directly, but are witness lists validated against conf settings elsewhere? Can an attacker override witness-related configs in conf.js to force the node to use incompatible witness lists, causing permanent chain split from the main network?",
  "[File: byteball/ocore/conf.js] [Lines 41-49] [Proxy-Based Network Partition] If an attacker configures socksHost or httpsProxy to a selective proxy that only forwards connections to attacker-controlled peers, can this isolate the victim node into an attacker-controlled network partition where fake units are confirmed via fake witnesses, causing the victim to accept invalid transaction history?",
  "[File: byteball/ocore/conf.js] [Lines 54-59] [Connection Limit Eclipse Attack] By setting MAX_OUTBOUND_CONNECTIONS = 1 via conf override, can an attacker force the victim node to connect to only one outbound peer (the attacker), then control all information the victim receives, enabling censorship of valid units, injection of fake units, or denial of witness proofs?",
  "[File: byteball/ocore/conf.js] [Line 56] [Zero Invalid Ratio] Can MAX_TOLERATED_INVALID_RATIO be set to 0 via conf override, causing the node to ban any peer that sends even a single invalid unit (possibly due to propagation race conditions or temporary validation delays), leading to network fragmentation where all peers ban each other?",
  "[File: byteball/ocore/conf.js] [Line 56] [Negative Invalid Ratio] Does the code validate that MAX_TOLERATED_INVALID_RATIO is in range [0, 1]? Can an attacker set it to -1 or 2.5, causing undefined behavior in network.js peer banning logic, potentially allowing malicious peers to never get banned or all peers to be banned immediately?",
  "[File: byteball/ocore/conf.js] [Lines 54-55] [Zero Connection Limits] Can MAX_INBOUND_CONNECTIONS or MAX_OUTBOUND_CONNECTIONS be set to 0 via conf override, causing the node to reject all peer connections and become isolated from the network, unable to sync new units or propagate transactions?",
  "[File: byteball/ocore/conf.js] [Lines 54-55] [Negative Connection Limits] Does the code validate that connection limits are positive integers? Can setting them to negative values cause integer underflow in connection counting logic, potentially allowing unlimited connections despite the negative limit?",
  "[File: byteball/ocore/conf.js] [Line 57] [Excessive MIN_COUNT_GOOD_PEERS] Can MIN_COUNT_GOOD_PEERS be set to an extremely high value (e.g., 1000000) via conf override, causing the node to constantly request peer lists and never be satisfied with its peer count, leading to excessive network traffic and resource exhaustion?",
  "[File: byteball/ocore/conf.js] [Lines 122-131] [Missing Database Configuration] If exports.storage = 'mysql' but none of the database.* properties are set (no defaults applied due to override priority), does the database connection fail gracefully or cause the node to crash with unhandled errors during initialization?",
  "[File: byteball/ocore/conf.js] [Line 130] [SQLite Filename Collision] If multiple nodes (e.g., full node and light wallet) run on the same system with default SQLite filenames, can they both attempt to write to the same database file, causing lock contention, corrupted writes, or inconsistent state?",
  "[File: byteball/ocore/conf.js] [Function: mergeExports()] [Type Confusion] Does mergeExports() validate that merged properties match expected types (e.g., MAX_INBOUND_CONNECTIONS should be number, not string)? Can type confusion cause parseInt() failures or comparison bugs in modules that read these configs, leading to logic errors?",
  "[File: byteball/ocore/conf.js] [Function: mergeExports()] [Overwriting Functions] Can an attacker's conf.js override exports.mergeExports itself with a malicious function, causing subsequent merge operations to execute attacker code or skip security-critical configurations?",
  "[File: byteball/ocore/conf.js] [Lines 93-96] [Program Name Injection] exports.program and exports.program_version are read from package.json. Can an attacker inject extremely long strings (megabytes) into package.json name/version fields, causing memory exhaustion when these are logged, transmitted in network protocol headers, or stored in databases?",
  "[File: byteball/ocore/conf.js] [All exports] [Configuration Tampering Detection] Does the system include any integrity checks (checksums, signatures) to detect if conf.js, conf.json, or package.json have been tampered with? Without such checks, can attackers persistently modify configurations without detection, maintaining long-term compromise?",
  "[File: byteball/ocore/conf.js] [Lines 98-118] [TOCTOU Configuration Race] Between the time conf.js/conf.json files are checked for existence (require()) and when they are loaded, can an attacker replace them with malicious versions, exploiting a time-of-check-time-of-use race condition to inject configurations?",
  "[File: byteball/ocore/conf.js] [Line 74] [Empty Asset Registry Array] Can exports.updatableAssetRegistries be overridden to an empty array [], causing asset registry queries to fail and all asset metadata lookups to return undefined, potentially breaking asset transfers or causing incorrect fee calculations?",
  "[File: byteball/ocore/conf.js] [Line 74] [Duplicate Asset Registries] If updatableAssetRegistries contains duplicate addresses (e.g., ['ADDR1', 'ADDR1']), does the asset metadata lookup logic handle this correctly, or can it cause duplicate queries, cache inconsistencies, or double-processing of registry updates?",
  "[File: byteball/ocore/conf.js] [Lines 68-71] [Spoofed Cordova Environment] Can an attacker create a fake browser environment with window.cordova defined in a Node.js process (e.g., using jsdom or similar), tricking the configuration logic into enabling light mode and SQLite when running on a server, potentially causing validation bypasses?",
  "[File: byteball/ocore/constants.js] [Line 13: COUNT_WITNESSES] [Consensus Configuration Injection] Can an attacker exploit the environment variable `process.env.COUNT_WITNESSES` to override the witness count to a non-standard value (e.g., 1 or 100) on a subset of nodes, causing those nodes to apply different consensus rules and permanently diverge from the main network?",
  "[File: byteball/ocore/constants.js] [Line 15: TOTAL_WHITEBYTES] [Supply Manipulation via Environment] If `process.env.TOTAL_WHITEBYTES` is set to a value different from the default 1e15 on some nodes, will validation of total supply limits diverge between nodes, potentially allowing inflation attacks where one subset accepts units that mint excess bytes while others reject them?",
  "[File: byteball/ocore/constants.js] [Line 17: COUNT_MC_BALLS_FOR_PAID_WITNESSING] [Witness Payment Divergence] Can manipulating `process.env.COUNT_MC_BALLS_FOR_PAID_WITNESSING` to different values across nodes cause disagreement on when witness payments should be issued, leading to consensus failure where some nodes accept payment units while others reject them as premature?",
  "[File: byteball/ocore/constants.js] [Line 35: GENESIS_UNIT] [Genesis Unit Substitution Attack] If an attacker sets `process.env.GENESIS_UNIT` to a different base64 hash before node startup, will the node bootstrap from an entirely different genesis unit, creating a shadow network that appears valid but is incompatible with the real Obyte network?",
  "[File: byteball/ocore/constants.js] [Line 36: BLACKBYTES_ASSET] [Private Asset ID Confusion] Can setting `process.env.BLACKBYTES_ASSET` to a fake asset ID cause nodes to misidentify the canonical blackbytes asset, potentially allowing an attacker to create a counterfeit private asset that some nodes treat as genuine blackbytes?",
  "[File: byteball/ocore/constants.js] [Line 57: MAX_COMPLEXITY] [AA Complexity Limit Bypass] If `process.env.MAX_COMPLEXITY` is set to a higher value on victim nodes, can an attacker submit AA definitions with complexity exceeding the network standard (100), causing victim nodes to accept and execute expensive formulas while other nodes reject them, leading to state divergence?",
  "[File: byteball/ocore/constants.js] [Line 58: MAX_UNIT_LENGTH] [Unit Size Limit Manipulation] Can an attacker exploit mismatched `process.env.MAX_UNIT_LENGTH` values (default 5MB) to submit units larger than the network standard, causing nodes with higher limits to accept oversized units that trigger memory exhaustion on nodes enforcing the standard limit?",
  "[File: byteball/ocore/constants.js] [Line 66: MAX_OPS] [AA Operation Limit Divergence] If different nodes have different `process.env.MAX_OPS` values (default 2000), will AA formula execution with operation counts near the boundary produce divergent results, where some nodes accept the AA response while others reject it for exceeding operation limits?",
  "[File: byteball/ocore/constants.js] [Line 67: MAX_RESPONSES_PER_PRIMARY_TRIGGER] [AA Response Limit Bypass] Can manipulating `process.env.MAX_RESPONSES_PER_PRIMARY_TRIGGER` allow an attacker to trigger more than 10 secondary AA responses on victim nodes, causing excessive state updates and potential DoS while other nodes cap responses at 10?",
  "[File: byteball/ocore/constants.js] [Line 70: MIN_BYTES_BOUNCE_FEE] [Bounce Fee Manipulation Attack] If `process.env.MIN_BYTES_BOUNCE_FEE` is set to 0 or 1 on some nodes instead of the default 10000, can an attacker exploit this to create AA bounce responses with insufficient fees, causing nodes with standard settings to reject the bounces and diverge on AA execution outcomes?",
  "[File: byteball/ocore/constants.js] [Line 14: MAX_WITNESS_LIST_MUTATIONS] [Witness List Change Attack] The constant MAX_WITNESS_LIST_MUTATIONS is hardcoded to 1, but is this enforced in validation.js? Can an attacker craft a unit with 2+ witness changes compared to parent units, bypassing this limit and causing consensus confusion about which witness list applies?",
  "[File: byteball/ocore/constants.js] [Line 16: MAJORITY_OF_WITNESSES calculation] [Majority Calculation Integer Overflow] The formula `(exports.COUNT_WITNESSES%2===0) ? (exports.COUNT_WITNESSES/2+1) : Math.ceil(exports.COUNT_WITNESSES/2)` - if COUNT_WITNESSES is manipulated to Number.MAX_SAFE_INTEGER, can this calculation overflow and produce an incorrect majority threshold that breaks stability determination?",
  "[File: byteball/ocore/constants.js] [Lines 13-16: COUNT_WITNESSES vs MAJORITY_OF_WITNESSES] [Witness Majority Inconsistency] If COUNT_WITNESSES is 12 but MAJORITY_OF_WITNESSES is manually misconfigured to 5 or 10 instead of 7, will main chain advancement and stability determination produce incorrect results, potentially finalizing unstable units?",
  "[File: byteball/ocore/constants.js] [Lines 112-113: Devnet COUNT_WITNESSES=1] [Single Witness Consensus Failure] In devnet mode where COUNT_WITNESSES=1 and MAJORITY_OF_WITNESSES=1, does this single-witness configuration eliminate Byzantine fault tolerance, allowing any attack on the single witness to cause total network failure without consensus recovery?",
  "[File: byteball/ocore/constants.js] [Line 21: bTestnet flag] [Testnet/Mainnet Confusion Attack] If the testnet flag is accidentally or maliciously toggled (e.g., via environment variable manipulation), can a node running mainnet code accept testnet genesis units and vice versa, creating a bridge between incompatible networks?",
  "[File: byteball/ocore/constants.js] [Lines 24-25: version and alt] [Network Identifier Collision] The version is '4.0' or '4.0t' and alt is '1' or '2' - if these values are manipulated to match across testnet/mainnet, can units from one network be replayed on the other network, potentially causing double-spends or consensus confusion?",
  "[File: byteball/ocore/constants.js] [Line 27: supported_versions array] [Version Downgrade Attack] The supported_versions list includes old versions like '1.0', '2.0', '3.0' - can an attacker craft units claiming to be version '1.0' that exploit historical vulnerabilities fixed in later versions, and will current nodes accept these retrograde units?",
  "[File: byteball/ocore/constants.js] [Lines 28-30: Version-specific constants] [Version Boundary Confusion] Constants like versionWithoutTimestamp='1.0' and versionWithoutKeySizes='2.0' suggest validation rules change per version - can an attacker exploit boundaries where a unit is valid under one version interpretation but invalid under another, causing validation divergence?",
  "[File: byteball/ocore/constants.js] [Lines 100-114: Devnet overrides] [Devnet Genesis Collision] The devnet sets different GENESIS_UNIT and BLACKBYTES_ASSET values - if these devnet constants accidentally match production hashes due to collision, can devnet units contaminate the production network or vice versa?",
  "[File: byteball/ocore/constants.js] [Lines 117-136: Upgrade MCI reset for devnet/custom genesis] [Upgrade Timing Bypass] When process.env.devnet or process.env.GENESIS_UNIT is set, all upgrade MCIs are reset to 0, activating all features immediately - can this be exploited in production to bypass upgrade timing and execute protocol features before the network is ready?",
  "[File: byteball/ocore/constants.js] [Line 43: MAX_AUTHORS_PER_UNIT=16] [Multi-Author Signature Verification DoS] With 16 authors maximum per unit, each requiring signature verification, can an attacker flood the network with units having 16 authors and complex multi-sig definitions, causing signature verification to consume excessive CPU and delay unit processing beyond 1 hour threshold?",
  "[File: byteball/ocore/constants.js] [Line 44: MAX_PARENTS_PER_UNIT=16] [Parent Validation DoS] Can an attacker create units with exactly 16 parent units, each requiring database lookups and DAG validation, causing validation logic to perform 16x database queries per unit and creating a DoS bottleneck during network catchup?",
  "[File: byteball/ocore/constants.js] [Line 45: MAX_MESSAGES_PER_UNIT=128] [Message Validation Amplification] With 128 messages per unit, if each message requires validation (payments, AA triggers, definitions), can an attacker craft units with 128 complex messages to amplify validation cost 128x, delaying transaction confirmation for >1 hour?",
  "[File: byteball/ocore/constants.js] [Line 46: MAX_SPEND_PROOFS_PER_MESSAGE=128] [Private Payment Verification DoS] Private payments require spend proof validation - with 128 spend proofs per message and 128 messages per unit, can an attacker create units with 16,384 total spend proofs, causing cryptographic verification to exhaust node resources?",
  "[File: byteball/ocore/constants.js] [Line 47: MAX_INPUTS_PER_PAYMENT_MESSAGE=128] [Input Validation Computational Explosion] With 128 inputs per message, each requiring database lookup to verify unspent status and ownership, can an attacker create payment messages with 128 inputs to amplify database queries and cause validation delays?",
  "[File: byteball/ocore/constants.js] [Line 48: MAX_OUTPUTS_PER_PAYMENT_MESSAGE=128] [Output Storage DoS] With 128 outputs per message and 128 messages per unit, an attacker can create 16,384 outputs per unit - does this cause database storage or indexing bottlenecks when processing high-output units?",
  "[File: byteball/ocore/constants.js] [Line 49: MAX_CHOICES_PER_POLL=128] [Poll Validation Complexity] Can an attacker exploit MAX_CHOICES_PER_POLL=128 to create polls with 128 choices, where validation must check choice uniqueness and format, causing O(n) validation complexity and delaying unit acceptance?",
  "[File: byteball/ocore/constants.js] [Line 50: MAX_CHOICE_LENGTH=64] [Poll Choice Validation Bypass] If MAX_CHOICE_LENGTH=64 is not strictly enforced, can an attacker submit poll choices exceeding 64 bytes, potentially causing buffer overruns or string handling vulnerabilities in downstream poll processing code?",
  "[File: byteball/ocore/constants.js] [Line 51: MAX_DENOMINATIONS_PER_ASSET_DEFINITION=64] [Denomination Validation Amplification] For indivisible assets with 64 denominations, each requiring validation and storage, can an attacker issue assets with maximum denominations to amplify validation costs and slow down asset issuance processing?",
  "[File: byteball/ocore/constants.js] [Line 52: MAX_ATTESTORS_PER_ASSET=64] [Attestor Verification DoS] If an asset definition includes 64 attestors, each requiring address validation and attestation checks, can this create a validation bottleneck where asset transfers require 64x attestor verifications per transaction?",
  "[File: byteball/ocore/constants.js] [Line 53: MAX_DATA_FEED_NAME_LENGTH=64] [Data Feed Name Validation Bypass] Can an attacker craft data feed names exactly at the 64-byte boundary with special characters or encoding tricks to bypass downstream validation or cause string parsing errors in AA formulas that read feed names?",
  "[File: byteball/ocore/constants.js] [Line 54: MAX_DATA_FEED_VALUE_LENGTH=64] [Data Feed Value Injection] With data feed values limited to 64 bytes, but potentially read by AAs as strings, numbers, or JSON, can an attacker craft payloads like '{",
  "[File: byteball/ocore/constants.js] [Line 55: MAX_AUTHENTIFIER_LENGTH=4096] [Authentifier Validation Resource Exhaustion] With authentifiers up to 4KB in size (e.g., large multi-sig scripts or complex definitions), can an attacker create units with maximum-size authentifiers for all 16 authors (64KB total), causing memory allocation spikes during validation?",
  "[File: byteball/ocore/constants.js] [Line 56: MAX_CAP=9e15] [Asset Cap Overflow Attack] The MAX_CAP of 9e15 is close to JavaScript's MAX_SAFE_INTEGER (9007199254740991) - can operations involving asset caps cause integer overflow when combined with other large numbers, potentially bypassing cap enforcement?",
  "[File: byteball/ocore/constants.js] [Line 58: MAX_UNIT_LENGTH=5e6] [5MB Unit Processing Bottleneck] Can an attacker submit units approaching the 5MB limit with valid structure, causing JSON parsing, validation, and database insertion to consume excessive time and delay confirmation of other units for >1 hour?",
  "[File: byteball/ocore/constants.js] [Line 38: HASH_LENGTH=44] [Hash Length Validation Bypass] If hash validation only checks for 44-character length without verifying base64 validity, can an attacker submit invalid base64 hashes (e.g., with special characters) that pass length checks but fail later processing, causing validation inconsistencies?",
  "[File: byteball/ocore/constants.js] [Line 39: PUBKEY_LENGTH=44] [Public Key Length Enforcement Weakness] Is PUBKEY_LENGTH=44 enforced before cryptographic operations, or can an attacker submit shorter/longer public keys that cause signature verification to fail silently or produce false positives?",
  "[File: byteball/ocore/constants.js] [Line 40: SIG_LENGTH=88] [Signature Length Malleability] With SIG_LENGTH=88, can an attacker pad or truncate signatures to exactly 88 bytes while maintaining some validation properties, potentially exploiting signature malleability to create alternative valid signatures for the same unit?",
  "[File: byteball/ocore/constants.js] [Line 63: MAX_AA_STRING_LENGTH=4096] [AA String Memory Exhaustion] Can an attacker craft AA formulas with multiple 4096-byte string literals, potentially combined in operations, to cause string concatenation to exceed memory limits and crash the formula evaluation engine?",
  "[File: byteball/ocore/constants.js] [Line 64: MAX_STATE_VAR_NAME_LENGTH=128] [State Variable Name Collision Attack] With 128-character state variable names, can an attacker create state variables with names differing only in the 127th character, causing confusion or collision in state storage that leads to incorrect state reads/writes?",
  "[File: byteball/ocore/constants.js] [Line 65: MAX_STATE_VAR_VALUE_LENGTH=1024] [State Value Serialization Issues] If state values are stored as JSON or other serialized format, can the 1024-byte limit be bypassed through encoding tricks (e.g., unicode escapes that expand during deserialization)?",
  "[File: byteball/ocore/constants.js] [Line 66: MAX_OPS=2000] [Operation Count Boundary Exploit] At exactly 2000 operations, can an attacker craft formulas that perform expensive operations (e.g., cryptographic functions) as the 1999th and 2000th ops, causing execution to consume maximum time while staying under the limit?",
  "[File: byteball/ocore/constants.js] [Line 67: MAX_RESPONSES_PER_PRIMARY_TRIGGER=10] [Secondary Trigger Cascade Amplification] If each of 10 secondary AA responses can itself trigger up to 10 more AAs, does this create a potential cascade of 10^n responses that bypasses the per-trigger limit through chaining?",
  "[File: byteball/ocore/constants.js] [Line 68: MAX_RESPONSE_VARS_LENGTH=4000] [Response Variable Size Attack] Can an attacker craft AA responses that store 4000 bytes in response variables, and if these are later read by another AA, does this amplify storage and retrieval costs across cascaded AA executions?",
  "[File: byteball/ocore/constants.js] [Line 57: MAX_COMPLEXITY=100] [Complexity Calculation Gaming] How is formula complexity calculated to reach MAX_COMPLEXITY=100? Can an attacker craft formulas that appear simple (low complexity score) but contain exponentially expensive operations (e.g., nested loops with 100 iterations each)?",
  "[File: byteball/ocore/constants.js] [Line 70: MIN_BYTES_BOUNCE_FEE=10000] [Bounce Fee Bypass via Rounding] If bounce fee calculation involves division or rounding, can an attacker craft AA triggers where computed bounce fees fall slightly below 10000 bytes due to rounding errors, allowing bounces with insufficient fees?",
  "[File: byteball/ocore/constants.js] [Line 71: SYSTEM_VOTE_COUNT_FEE=1e9] [Vote Fee Overflow] The SYSTEM_VOTE_COUNT_FEE of 1 billion bytes - can operations involving this fee (e.g., calculating total fees for multiple votes) cause integer overflow when combined with other fee calculations?",
  "[File: byteball/ocore/constants.js] [Line 72: SYSTEM_VOTE_MIN_SHARE=0.1] [Vote Share Calculation Precision Loss] With MIN_SHARE=0.1 (10%), are vote share calculations using floating-point arithmetic vulnerable to precision loss that allows votes with slightly under 10% share to be accepted?",
  "[File: byteball/ocore/constants.js] [Line 73: TEMP_DATA_PURGE_TIMEOUT=24*3600] [Temporary Data Race Condition] If temporary data is purged after exactly 24 hours, can an attacker exploit timing races where data is accessed during the purge window, causing read-after-delete errors or stale data to be used in validation?",
  "[File: byteball/ocore/constants.js] [Line 74: TEMP_DATA_PRICE=0.5] [Fractional Fee Calculation Exploit] With temporary data costing 0.5 bytes per byte, can attackers exploit rounding in fee calculations to store data at effectively lower cost than intended (e.g., storing 1 byte costs 0 after rounding down)?",
  "[File: byteball/ocore/constants.js] [Lines 139-144: Textcoin fee calculations] [Textcoin Fee Calculation Dependency on Version Length] The formulas like `772 + (exports.version.length - 3)` depend on version string length - if version string is manipulated to abnormal length, can this cause fee calculations to become negative or overflow?",
  "[File: byteball/ocore/constants.js] [Line 143: TEXTCOIN_ASSET_CLAIM_BASE_MSG_FEE calculation] [Compound Fee Addition Overflow] The fee `157 + 101 + 1` is calculated at runtime - if these constants are modified through environment variables or code manipulation, can their sum overflow and wrap to negative values?",
  "[File: byteball/ocore/constants.js] [Lines 76-78: minCoreVersion constants] [Version String Comparison Vulnerability] Are version strings like '0.4.0' compared as strings or parsed as semver? Can an attacker run version '0.4.0a' or '0.4.00' to bypass minimum version checks through string comparison quirks?",
  "[File: byteball/ocore/constants.js] [Line 80: lastBallStableInParentsUpgradeMci] [Upgrade MCI Boundary Race] At MCI=1300000 on mainnet (or 0 on testnet), does the last ball stability rule change? Can units submitted exactly at this MCI boundary be validated differently by nodes that have/haven't crossed the threshold, causing temporary consensus divergence?",
  "[File: byteball/ocore/constants.js] [Line 81: witnessedLevelMustNotRetreatUpgradeMci] [Witnessed Level Validation Fork] At MCI=1400000, witnessed level retreat validation changes - can an attacker submit units with retreating witnessed levels just before/after this boundary, exploiting the upgrade timing to cause chain splits?",
  "[File: byteball/ocore/constants.js] [Line 82: skipEvaluationOfUnusedNestedAddressUpgradeMci] [Definition Evaluation Optimization Attack] After MCI=1400000, unused nested addresses are skipped during evaluation - can an attacker craft address definitions that behave differently under the old vs new evaluation rules, causing validation divergence during the upgrade window?",
  "[File: byteball/ocore/constants.js] [Line 83: spendUnconfirmedUpgradeMci] [Unconfirmed Output Spending Race] The MCI=2909000 upgrade allows spending unconfirmed outputs - can an attacker exploit the upgrade boundary by double-spending unconfirmed outputs where some nodes allow it (post-upgrade) while others reject it (pre-upgrade)?",
  "[File: byteball/ocore/constants.js] [Line 84: branchedMinMcWlUpgradeMci] [Branched Main Chain Witness Level Attack] At MCI=2909000, branched MC witness level calculation changes - can this cause disagreement on which branch is the main chain during the upgrade, potentially causing temporary chain splits?",
  "[File: byteball/ocore/constants.js] [Line 85: otherAddressInDefinitionUpgradeMci] [Address Definition Reference Attack] After MCI=2909000, address definitions can reference other addresses - can an attacker create circular address definition references that cause infinite loops or stack overflows during definition evaluation?",
  "[File: byteball/ocore/constants.js] [Line 86: attestedInDefinitionUpgradeMci] [Attestation Validation Upgrade Fork] At MCI=2909000, attestation-based address definitions are enabled - can an attacker exploit this by creating units with attested definitions that are valid post-upgrade but were submitted pre-upgrade, causing validation inconsistency?",
  "[File: byteball/ocore/constants.js] [Line 87: altBranchByBestParentUpgradeMci] [Alternative Branch Selection Fork] At MCI=3009824, the alternative branch selection algorithm changes - can units submitted during this transition be assigned to different branches by different nodes, causing main chain disagreement?",
  "[File: byteball/ocore/constants.js] [Line 88: anyDefinitionChangeUpgradeMci] [Definition Change Validation Relaxation] After MCI=4229100, any definition change is allowed - does this remove restrictions that previously prevented malicious definition changes, potentially allowing attackers to brick addresses or steal funds through definition manipulation?",
  "[File: byteball/ocore/constants.js] [Line 89: formulaUpgradeMci] [AA Formula Feature Activation] At MCI=5210000, AA formulas are enabled - can attackers who pre-deployed AA definitions before this MCI exploit timing to trigger formulas before validators are ready, causing incorrect execution or state corruption?",
  "[File: byteball/ocore/constants.js] [Line 90: witnessedLevelMustNotRetreatFromAllParentsUpgradeMci] [Witness Level Retreat Multi-Parent Check] At MCI=5210000, witness level must not retreat from ANY parent (not just one) - can this stricter rule cause previously valid units to become invalid, potentially orphaning branches of the DAG?",
  "[File: byteball/ocore/constants.js] [Line 91: timestampUpgradeMci] [Timestamp Validation Rule Change] At MCI=5210000, timestamp validation changes - can attackers exploit differences in timestamp acceptance windows to create units with timestamps that are valid pre-upgrade but invalid post-upgrade, causing validation divergence?",
  "[File: byteball/ocore/constants.js] [Line 92: aaStorageSizeUpgradeMci] [AA Storage Size Limit Enforcement] At MCI=5210000, AA storage size limits are enforced - do existing AAs with oversized state get grandfathered in, or can this cause previously valid state updates to fail, potentially locking funds in AAs?",
  "[File: byteball/ocore/constants.js] [Line 93: aa2UpgradeMci] [AA Version 2 Compatibility] At MCI=5494000, AA version 2 features activate - are AAs explicitly versioned, or can formulas written for v1 behave differently under v2 semantics, causing non-deterministic execution across the upgrade boundary?",
  "[File: byteball/ocore/constants.js] [Line 94: unstableInitialDefinitionUpgradeMci] [Initial Definition Stability Attack] At MCI=5494000, initial definitions can be unstable - can an attacker create an address with an unstable definition, spend from it before stabilization, then cause the definition to change, effectively allowing unauthorized spending?",
  "[File: byteball/ocore/constants.js] [Line 95: includeKeySizesUpgradeMci] [Key Size Inclusion Validation Fork] At MCI=5530000, key sizes are included in validation - does this change unit hash calculation? Can units with identical content produce different hashes pre/post upgrade, causing hash-based lookups to fail?",
  "[File: byteball/ocore/constants.js] [Line 96: aa3UpgradeMci] [AA Version 3 Breaking Changes] At MCI=7810000, AA version 3 activates - what breaking changes are introduced? Can formulas that worked in v2 fail or behave differently in v3, causing state divergence for AAs that transition during the upgrade?",
  "[File: byteball/ocore/constants.js] [Line 97: v4UpgradeMci] [Protocol Version 4 Comprehensive Fork] At MCI=10968000, protocol v4 activates - as a major version upgrade, can this introduce multiple simultaneous validation changes that compound to cause consensus failures if nodes upgrade asynchronously?",
  "[File: byteball/ocore/constants.js] [Lines 43-48: MAX_AUTHORS  MAX_MESSAGES  MAX_INPUTS/OUTPUTS] [Validation Complexity Amplification Attack] Can an attacker craft a unit with 16 authors, 128 messages, and 128 inputs per message (16128128 = 262,144 total inputs) to cause O(n) or O(n) validation complexity that freezes the network?",
  "[File: byteball/ocore/constants.js] [Lines 56-58: MAX_CAP vs MAX_UNIT_LENGTH] [Asset Issuance Size Attack] If an asset with MAX_CAP=9e15 is issued in a unit approaching MAX_UNIT_LENGTH=5MB, can the large unit size cause processing delays while still being considered valid, creating a DoS vector through oversized issuance units?",
  "[File: byteball/ocore/constants.js] [Lines 57 & 66: MAX_COMPLEXITY vs MAX_OPS] [Formula Complexity Dual-Limit Bypass] Are MAX_COMPLEXITY=100 and MAX_OPS=2000 enforced independently? Can an attacker craft a formula with complexity=99 but 1999 operations, each being expensive (e.g., crypto functions), to bypass both limits individually while causing excessive execution time?",
  "[File: byteball/ocore/constants.js] [Lines 63-65: MAX_AA_STRING_LENGTH vs MAX_STATE_VAR_VALUE_LENGTH] [AA State String Size Mismatch] If AA formulas can create 4096-byte strings but state variables are limited to 1024 bytes, what happens when an AA tries to store an oversized string? Does it silently truncate, throw an error causing a bounce, or corrupt state?",
  "[File: byteball/ocore/constants.js] [Lines 16 & 113: MAJORITY_OF_WITNESSES recalculation in devnet] [Devnet Majority Calculation Override Risk] In devnet mode, MAJORITY_OF_WITNESSES is recalculated after COUNT_WITNESSES is set to 1 - if this recalculation is missed or incorrect, can the majority threshold be wrong, breaking consensus even in dev environments?",
  "[File: byteball/ocore/constants.js] [Line 11: Number.MAX_SAFE_INTEGER polyfill] [Safe Integer Polyfill Failure] If the JavaScript environment doesn't define Number.MAX_SAFE_INTEGER and the polyfill sets it to 9007199254740991, but the actual environment's integer precision is lower (e.g., 32-bit systems), can this cause silent integer truncation bugs?",
  "[File: byteball/ocore/constants.js] [Line 35-36: Genesis unit and blackbytes asset conditional assignment] [Genesis Configuration Race Condition] If both testnet and devnet flags are set simultaneously, which genesis unit takes precedence? Can this ambiguity cause nodes to initialize with mismatched genesis configurations?",
  "[File: byteball/ocore/constants.js] [Line 109-110: Devnet genesis changes with version/alt changes] [Devnet Genesis Instability] The comment 'THIS CHANGES WITH EVERY UNIT VERSION / ALT CHANGE!!!' suggests devnet genesis is unstable - can this cause devnet nodes to fork repeatedly as version strings change during development?",
  "[File: byteball/ocore/constants.js] [Line 147: lightHistoryTooLargeErrorMessage] [Error Message Information Leak] The error message 'your history is too large, consider switching to a full client' - does this reveal information about user transaction history size that could be exploited for privacy attacks or targeted DoS?",
  "[File: byteball/ocore/constants.js] [Lines 80-97: Testnet upgrade MCIs significantly lower than mainnet] [Testnet Upgrade Testing Inadequacy] Testnet upgrade MCIs (e.g., 684000 for witnessedLevelMustNotRetreatUpgradeMci) are much lower than mainnet (1400000) - does this mean testnet may not adequately test upgrade timing issues that manifest at higher MCI values due to state accumulation?",
  "[File: byteball/ocore/constants.js] [Lines 27-31: Testnet version suffixes] [Version Suffix Parsing Ambiguity] Testnet versions end in 't' (e.g., '4.0t') - can this cause string comparison issues where version checks fail to properly distinguish between '4.0' and '4.0t', potentially allowing cross-network unit replay?",
  "[File: byteball/ocore/constants.js] [Line 15: TOTAL_WHITEBYTES=1e15] [Total Supply Near JavaScript Integer Limit] With TOTAL_WHITEBYTES=1e15 close to MAX_SAFE_INTEGER=9007199254740991, can operations involving total supply (e.g., balance aggregations) overflow when combined with other large numbers like asset caps or fees?",
  "[File: byteball/ocore/constants.js] [Line 18: EMERGENCY_OP_LIST_CHANGE_TIMEOUT=3*24*3600] [Emergency Timeout Calculation Overflow] The timeout is calculated as 3*24*3600 (3 days in seconds) - if this calculation is performed in a context where integers are 32-bit, can it overflow and produce a negative or wrapped timeout value?",
  "[File: byteball/ocore/constants.js] [Line 19: EMERGENCY_COUNT_MIN_VOTE_AGE=3600] [Vote Age Race Condition] If vote age is exactly 3600 seconds (1 hour), can attackers exploit clock skew between nodes to submit votes that are valid on some nodes (clock ahead) but rejected on others (clock behind), causing vote counting disagreement?",
  "[File: byteball/ocore/constants.js] [Line 13: COUNT_WITNESSES] [Consensus Configuration Injection] Can an attacker exploit the environment variable `process.env.COUNT_WITNESSES` to override the witness count to a non-standard value (e.g., 1 or 100) on a subset of nodes, causing those nodes to apply different consensus rules and permanently diverge from the main network?",
  "[File: byteball/ocore/constants.js] [Line 15: TOTAL_WHITEBYTES] [Supply Manipulation via Environment] If `process.env.TOTAL_WHITEBYTES` is set to a value different from the default 1e15 on some nodes, will validation of total supply limits diverge between nodes, potentially allowing inflation attacks where one subset accepts units that mint excess bytes while others reject them?",
  "[File: byteball/ocore/constants.js] [Line 17: COUNT_MC_BALLS_FOR_PAID_WITNESSING] [Witness Payment Divergence] Can manipulating `process.env.COUNT_MC_BALLS_FOR_PAID_WITNESSING` to different values across nodes cause disagreement on when witness payments should be issued, leading to consensus failure where some nodes accept payment units while others reject them as premature?",
  "[File: byteball/ocore/constants.js] [Line 35: GENESIS_UNIT] [Genesis Unit Substitution Attack] If an attacker sets `process.env.GENESIS_UNIT` to a different base64 hash before node startup, will the node bootstrap from an entirely different genesis unit, creating a shadow network that appears valid but is incompatible with the real Obyte network?",
  "[File: byteball/ocore/constants.js] [Line 36: BLACKBYTES_ASSET] [Private Asset ID Confusion] Can setting `process.env.BLACKBYTES_ASSET` to a fake asset ID cause nodes to misidentify the canonical blackbytes asset, potentially allowing an attacker to create a counterfeit private asset that some nodes treat as genuine blackbytes?",
  "[File: byteball/ocore/constants.js] [Line 57: MAX_COMPLEXITY] [AA Complexity Limit Bypass] If `process.env.MAX_COMPLEXITY` is set to a higher value on victim nodes, can an attacker submit AA definitions with complexity exceeding the network standard (100), causing victim nodes to accept and execute expensive formulas while other nodes reject them, leading to state divergence?",
  "[File: byteball/ocore/constants.js] [Line 58: MAX_UNIT_LENGTH] [Unit Size Limit Manipulation] Can an attacker exploit mismatched `process.env.MAX_UNIT_LENGTH` values (default 5MB) to submit units larger than the network standard, causing nodes with higher limits to accept oversized units that trigger memory exhaustion on nodes enforcing the standard limit?",
  "[File: byteball/ocore/constants.js] [Line 66: MAX_OPS] [AA Operation Limit Divergence] If different nodes have different `process.env.MAX_OPS` values (default 2000), will AA formula execution with operation counts near the boundary produce divergent results, where some nodes accept the AA response while others reject it for exceeding operation limits?",
  "[File: byteball/ocore/constants.js] [Line 67: MAX_RESPONSES_PER_PRIMARY_TRIGGER] [AA Response Limit Bypass] Can manipulating `process.env.MAX_RESPONSES_PER_PRIMARY_TRIGGER` allow an attacker to trigger more than 10 secondary AA responses on victim nodes, causing excessive state updates and potential DoS while other nodes cap responses at 10?",
  "[File: byteball/ocore/constants.js] [Line 70: MIN_BYTES_BOUNCE_FEE] [Bounce Fee Manipulation Attack] If `process.env.MIN_BYTES_BOUNCE_FEE` is set to 0 or 1 on some nodes instead of the default 10000, can an attacker exploit this to create AA bounce responses with insufficient fees, causing nodes with standard settings to reject the bounces and diverge on AA execution outcomes?",
  "[File: byteball/ocore/constants.js] [Line 14: MAX_WITNESS_LIST_MUTATIONS] [Witness List Change Attack] The constant MAX_WITNESS_LIST_MUTATIONS is hardcoded to 1, but is this enforced in validation.js? Can an attacker craft a unit with 2+ witness changes compared to parent units, bypassing this limit and causing consensus confusion about which witness list applies?",
  "[File: byteball/ocore/constants.js] [Line 16: MAJORITY_OF_WITNESSES calculation] [Majority Calculation Integer Overflow] The formula `(exports.COUNT_WITNESSES%2===0) ? (exports.COUNT_WITNESSES/2+1) : Math.ceil(exports.COUNT_WITNESSES/2)` - if COUNT_WITNESSES is manipulated to Number.MAX_SAFE_INTEGER, can this calculation overflow and produce an incorrect majority threshold that breaks stability determination?",
  "[File: byteball/ocore/constants.js] [Lines 13-16: COUNT_WITNESSES vs MAJORITY_OF_WITNESSES] [Witness Majority Inconsistency] If COUNT_WITNESSES is 12 but MAJORITY_OF_WITNESSES is manually misconfigured to 5 or 10 instead of 7, will main chain advancement and stability determination produce incorrect results, potentially finalizing unstable units?",
  "[File: byteball/ocore/constants.js] [Lines 112-113: Devnet COUNT_WITNESSES=1] [Single Witness Consensus Failure] In devnet mode where COUNT_WITNESSES=1 and MAJORITY_OF_WITNESSES=1, does this single-witness configuration eliminate Byzantine fault tolerance, allowing any attack on the single witness to cause total network failure without consensus recovery?",
  "[File: byteball/ocore/constants.js] [Line 21: bTestnet flag] [Testnet/Mainnet Confusion Attack] If the testnet flag is accidentally or maliciously toggled (e.g., via environment variable manipulation), can a node running mainnet code accept testnet genesis units and vice versa, creating a bridge between incompatible networks?",
  "[File: byteball/ocore/constants.js] [Lines 24-25: version and alt] [Network Identifier Collision] The version is '4.0' or '4.0t' and alt is '1' or '2' - if these values are manipulated to match across testnet/mainnet, can units from one network be replayed on the other network, potentially causing double-spends or consensus confusion?",
  "[File: byteball/ocore/constants.js] [Line 27: supported_versions array] [Version Downgrade Attack] The supported_versions list includes old versions like '1.0', '2.0', '3.0' - can an attacker craft units claiming to be version '1.0' that exploit historical vulnerabilities fixed in later versions, and will current nodes accept these retrograde units?",
  "[File: byteball/ocore/constants.js] [Lines 28-30: Version-specific constants] [Version Boundary Confusion] Constants like versionWithoutTimestamp='1.0' and versionWithoutKeySizes='2.0' suggest validation rules change per version - can an attacker exploit boundaries where a unit is valid under one version interpretation but invalid under another, causing validation divergence?",
  "[File: byteball/ocore/constants.js] [Lines 100-114: Devnet overrides] [Devnet Genesis Collision] The devnet sets different GENESIS_UNIT and BLACKBYTES_ASSET values - if these devnet constants accidentally match production hashes due to collision, can devnet units contaminate the production network or vice versa?",
  "[File: byteball/ocore/constants.js] [Lines 117-136: Upgrade MCI reset for devnet/custom genesis] [Upgrade Timing Bypass] When process.env.devnet or process.env.GENESIS_UNIT is set, all upgrade MCIs are reset to 0, activating all features immediately - can this be exploited in production to bypass upgrade timing and execute protocol features before the network is ready?",
  "[File: byteball/ocore/constants.js] [Line 43: MAX_AUTHORS_PER_UNIT=16] [Multi-Author Signature Verification DoS] With 16 authors maximum per unit, each requiring signature verification, can an attacker flood the network with units having 16 authors and complex multi-sig definitions, causing signature verification to consume excessive CPU and delay unit processing beyond 1 hour threshold?",
  "[File: byteball/ocore/constants.js] [Line 44: MAX_PARENTS_PER_UNIT=16] [Parent Validation DoS] Can an attacker create units with exactly 16 parent units, each requiring database lookups and DAG validation, causing validation logic to perform 16x database queries per unit and creating a DoS bottleneck during network catchup?",
  "[File: byteball/ocore/constants.js] [Line 45: MAX_MESSAGES_PER_UNIT=128] [Message Validation Amplification] With 128 messages per unit, if each message requires validation (payments, AA triggers, definitions), can an attacker craft units with 128 complex messages to amplify validation cost 128x, delaying transaction confirmation for >1 hour?",
  "[File: byteball/ocore/constants.js] [Line 46: MAX_SPEND_PROOFS_PER_MESSAGE=128] [Private Payment Verification DoS] Private payments require spend proof validation - with 128 spend proofs per message and 128 messages per unit, can an attacker create units with 16,384 total spend proofs, causing cryptographic verification to exhaust node resources?",
  "[File: byteball/ocore/constants.js] [Line 47: MAX_INPUTS_PER_PAYMENT_MESSAGE=128] [Input Validation Computational Explosion] With 128 inputs per message, each requiring database lookup to verify unspent status and ownership, can an attacker create payment messages with 128 inputs to amplify database queries and cause validation delays?",
  "[File: byteball/ocore/constants.js] [Line 48: MAX_OUTPUTS_PER_PAYMENT_MESSAGE=128] [Output Storage DoS] With 128 outputs per message and 128 messages per unit, an attacker can create 16,384 outputs per unit - does this cause database storage or indexing bottlenecks when processing high-output units?",
  "[File: byteball/ocore/constants.js] [Line 49: MAX_CHOICES_PER_POLL=128] [Poll Validation Complexity] Can an attacker exploit MAX_CHOICES_PER_POLL=128 to create polls with 128 choices, where validation must check choice uniqueness and format, causing O(n) validation complexity and delaying unit acceptance?",
  "[File: byteball/ocore/constants.js] [Line 50: MAX_CHOICE_LENGTH=64] [Poll Choice Validation Bypass] If MAX_CHOICE_LENGTH=64 is not strictly enforced, can an attacker submit poll choices exceeding 64 bytes, potentially causing buffer overruns or string handling vulnerabilities in downstream poll processing code?",
  "[File: byteball/ocore/constants.js] [Line 51: MAX_DENOMINATIONS_PER_ASSET_DEFINITION=64] [Denomination Validation Amplification] For indivisible assets with 64 denominations, each requiring validation and storage, can an attacker issue assets with maximum denominations to amplify validation costs and slow down asset issuance processing?",
  "[File: byteball/ocore/constants.js] [Line 52: MAX_ATTESTORS_PER_ASSET=64] [Attestor Verification DoS] If an asset definition includes 64 attestors, each requiring address validation and attestation checks, can this create a validation bottleneck where asset transfers require 64x attestor verifications per transaction?",
  "[File: byteball/ocore/constants.js] [Line 53: MAX_DATA_FEED_NAME_LENGTH=64] [Data Feed Name Validation Bypass] Can an attacker craft data feed names exactly at the 64-byte boundary with special characters or encoding tricks to bypass downstream validation or cause string parsing errors in AA formulas that read feed names?",
  "[File: byteball/ocore/constants.js] [Line 54: MAX_DATA_FEED_VALUE_LENGTH=64] [Data Feed Value Injection] With data feed values limited to 64 bytes, but potentially read by AAs as strings, numbers, or JSON, can an attacker craft payloads like '{",
  "[File: byteball/ocore/constants.js] [Line 55: MAX_AUTHENTIFIER_LENGTH=4096] [Authentifier Validation Resource Exhaustion] With authentifiers up to 4KB in size (e.g., large multi-sig scripts or complex definitions), can an attacker create units with maximum-size authentifiers for all 16 authors (64KB total), causing memory allocation spikes during validation?",
  "[File: byteball/ocore/constants.js] [Line 56: MAX_CAP=9e15] [Asset Cap Overflow Attack] The MAX_CAP of 9e15 is close to JavaScript's MAX_SAFE_INTEGER (9007199254740991) - can operations involving asset caps cause integer overflow when combined with other large numbers, potentially bypassing cap enforcement?",
  "[File: byteball/ocore/constants.js] [Line 58: MAX_UNIT_LENGTH=5e6] [5MB Unit Processing Bottleneck] Can an attacker submit units approaching the 5MB limit with valid structure, causing JSON parsing, validation, and database insertion to consume excessive time and delay confirmation of other units for >1 hour?",
  "[File: byteball/ocore/constants.js] [Line 38: HASH_LENGTH=44] [Hash Length Validation Bypass] If hash validation only checks for 44-character length without verifying base64 validity, can an attacker submit invalid base64 hashes (e.g., with special characters) that pass length checks but fail later processing, causing validation inconsistencies?",
  "[File: byteball/ocore/constants.js] [Line 39: PUBKEY_LENGTH=44] [Public Key Length Enforcement Weakness] Is PUBKEY_LENGTH=44 enforced before cryptographic operations, or can an attacker submit shorter/longer public keys that cause signature verification to fail silently or produce false positives?",
  "[File: byteball/ocore/constants.js] [Line 40: SIG_LENGTH=88] [Signature Length Malleability] With SIG_LENGTH=88, can an attacker pad or truncate signatures to exactly 88 bytes while maintaining some validation properties, potentially exploiting signature malleability to create alternative valid signatures for the same unit?",
  "[File: byteball/ocore/constants.js] [Line 63: MAX_AA_STRING_LENGTH=4096] [AA String Memory Exhaustion] Can an attacker craft AA formulas with multiple 4096-byte string literals, potentially combined in operations, to cause string concatenation to exceed memory limits and crash the formula evaluation engine?",
  "[File: byteball/ocore/constants.js] [Line 64: MAX_STATE_VAR_NAME_LENGTH=128] [State Variable Name Collision Attack] With 128-character state variable names, can an attacker create state variables with names differing only in the 127th character, causing confusion or collision in state storage that leads to incorrect state reads/writes?",
  "[File: byteball/ocore/constants.js] [Line 65: MAX_STATE_VAR_VALUE_LENGTH=1024] [State Value Serialization Issues] If state values are stored as JSON or other serialized format, can the 1024-byte limit be bypassed through encoding tricks (e.g., unicode escapes that expand during deserialization)?",
  "[File: byteball/ocore/constants.js] [Line 66: MAX_OPS=2000] [Operation Count Boundary Exploit] At exactly 2000 operations, can an attacker craft formulas that perform expensive operations (e.g., cryptographic functions) as the 1999th and 2000th ops, causing execution to consume maximum time while staying under the limit?",
  "[File: byteball/ocore/constants.js] [Line 67: MAX_RESPONSES_PER_PRIMARY_TRIGGER=10] [Secondary Trigger Cascade Amplification] If each of 10 secondary AA responses can itself trigger up to 10 more AAs, does this create a potential cascade of 10^n responses that bypasses the per-trigger limit through chaining?",
  "[File: byteball/ocore/constants.js] [Line 68: MAX_RESPONSE_VARS_LENGTH=4000] [Response Variable Size Attack] Can an attacker craft AA responses that store 4000 bytes in response variables, and if these are later read by another AA, does this amplify storage and retrieval costs across cascaded AA executions?",
  "[File: byteball/ocore/constants.js] [Line 57: MAX_COMPLEXITY=100] [Complexity Calculation Gaming] How is formula complexity calculated to reach MAX_COMPLEXITY=100? Can an attacker craft formulas that appear simple (low complexity score) but contain exponentially expensive operations (e.g., nested loops with 100 iterations each)?",
  "[File: byteball/ocore/constants.js] [Line 70: MIN_BYTES_BOUNCE_FEE=10000] [Bounce Fee Bypass via Rounding] If bounce fee calculation involves division or rounding, can an attacker craft AA triggers where computed bounce fees fall slightly below 10000 bytes due to rounding errors, allowing bounces with insufficient fees?",
  "[File: byteball/ocore/constants.js] [Line 71: SYSTEM_VOTE_COUNT_FEE=1e9] [Vote Fee Overflow] The SYSTEM_VOTE_COUNT_FEE of 1 billion bytes - can operations involving this fee (e.g., calculating total fees for multiple votes) cause integer overflow when combined with other fee calculations?",
  "[File: byteball/ocore/constants.js] [Line 72: SYSTEM_VOTE_MIN_SHARE=0.1] [Vote Share Calculation Precision Loss] With MIN_SHARE=0.1 (10%), are vote share calculations using floating-point arithmetic vulnerable to precision loss that allows votes with slightly under 10% share to be accepted?",
  "[File: byteball/ocore/constants.js] [Line 73: TEMP_DATA_PURGE_TIMEOUT=24*3600] [Temporary Data Race Condition] If temporary data is purged after exactly 24 hours, can an attacker exploit timing races where data is accessed during the purge window, causing read-after-delete errors or stale data to be used in validation?",
  "[File: byteball/ocore/constants.js] [Line 74: TEMP_DATA_PRICE=0.5] [Fractional Fee Calculation Exploit] With temporary data costing 0.5 bytes per byte, can attackers exploit rounding in fee calculations to store data at effectively lower cost than intended (e.g., storing 1 byte costs 0 after rounding down)?",
  "[File: byteball/ocore/constants.js] [Lines 139-144: Textcoin fee calculations] [Textcoin Fee Calculation Dependency on Version Length] The formulas like `772 + (exports.version.length - 3)` depend on version string length - if version string is manipulated to abnormal length, can this cause fee calculations to become negative or overflow?",
  "[File: byteball/ocore/constants.js] [Line 143: TEXTCOIN_ASSET_CLAIM_BASE_MSG_FEE calculation] [Compound Fee Addition Overflow] The fee `157 + 101 + 1` is calculated at runtime - if these constants are modified through environment variables or code manipulation, can their sum overflow and wrap to negative values?",
  "[File: byteball/ocore/constants.js] [Lines 76-78: minCoreVersion constants] [Version String Comparison Vulnerability] Are version strings like '0.4.0' compared as strings or parsed as semver? Can an attacker run version '0.4.0a' or '0.4.00' to bypass minimum version checks through string comparison quirks?",
  "[File: byteball/ocore/constants.js] [Line 80: lastBallStableInParentsUpgradeMci] [Upgrade MCI Boundary Race] At MCI=1300000 on mainnet (or 0 on testnet), does the last ball stability rule change? Can units submitted exactly at this MCI boundary be validated differently by nodes that have/haven't crossed the threshold, causing temporary consensus divergence?",
  "[File: byteball/ocore/constants.js] [Line 81: witnessedLevelMustNotRetreatUpgradeMci] [Witnessed Level Validation Fork] At MCI=1400000, witnessed level retreat validation changes - can an attacker submit units with retreating witnessed levels just before/after this boundary, exploiting the upgrade timing to cause chain splits?",
  "[File: byteball/ocore/constants.js] [Line 82: skipEvaluationOfUnusedNestedAddressUpgradeMci] [Definition Evaluation Optimization Attack] After MCI=1400000, unused nested addresses are skipped during evaluation - can an attacker craft address definitions that behave differently under the old vs new evaluation rules, causing validation divergence during the upgrade window?",
  "[File: byteball/ocore/constants.js] [Line 83: spendUnconfirmedUpgradeMci] [Unconfirmed Output Spending Race] The MCI=2909000 upgrade allows spending unconfirmed outputs - can an attacker exploit the upgrade boundary by double-spending unconfirmed outputs where some nodes allow it (post-upgrade) while others reject it (pre-upgrade)?",
  "[File: byteball/ocore/constants.js] [Line 84: branchedMinMcWlUpgradeMci] [Branched Main Chain Witness Level Attack] At MCI=2909000, branched MC witness level calculation changes - can this cause disagreement on which branch is the main chain during the upgrade, potentially causing temporary chain splits?",
  "[File: byteball/ocore/constants.js] [Line 85: otherAddressInDefinitionUpgradeMci] [Address Definition Reference Attack] After MCI=2909000, address definitions can reference other addresses - can an attacker create circular address definition references that cause infinite loops or stack overflows during definition evaluation?",
  "[File: byteball/ocore/constants.js] [Line 86: attestedInDefinitionUpgradeMci] [Attestation Validation Upgrade Fork] At MCI=2909000, attestation-based address definitions are enabled - can an attacker exploit this by creating units with attested definitions that are valid post-upgrade but were submitted pre-upgrade, causing validation inconsistency?",
  "[File: byteball/ocore/constants.js] [Line 87: altBranchByBestParentUpgradeMci] [Alternative Branch Selection Fork] At MCI=3009824, the alternative branch selection algorithm changes - can units submitted during this transition be assigned to different branches by different nodes, causing main chain disagreement?",
  "[File: byteball/ocore/constants.js] [Line 88: anyDefinitionChangeUpgradeMci] [Definition Change Validation Relaxation] After MCI=4229100, any definition change is allowed - does this remove restrictions that previously prevented malicious definition changes, potentially allowing attackers to brick addresses or steal funds through definition manipulation?",
  "[File: byteball/ocore/constants.js] [Line 89: formulaUpgradeMci] [AA Formula Feature Activation] At MCI=5210000, AA formulas are enabled - can attackers who pre-deployed AA definitions before this MCI exploit timing to trigger formulas before validators are ready, causing incorrect execution or state corruption?",
  "[File: byteball/ocore/constants.js] [Line 90: witnessedLevelMustNotRetreatFromAllParentsUpgradeMci] [Witness Level Retreat Multi-Parent Check] At MCI=5210000, witness level must not retreat from ANY parent (not just one) - can this stricter rule cause previously valid units to become invalid, potentially orphaning branches of the DAG?",
  "[File: byteball/ocore/constants.js] [Line 91: timestampUpgradeMci] [Timestamp Validation Rule Change] At MCI=5210000, timestamp validation changes - can attackers exploit differences in timestamp acceptance windows to create units with timestamps that are valid pre-upgrade but invalid post-upgrade, causing validation divergence?",
  "[File: byteball/ocore/constants.js] [Line 92: aaStorageSizeUpgradeMci] [AA Storage Size Limit Enforcement] At MCI=5210000, AA storage size limits are enforced - do existing AAs with oversized state get grandfathered in, or can this cause previously valid state updates to fail, potentially locking funds in AAs?",
  "[File: byteball/ocore/constants.js] [Line 93: aa2UpgradeMci] [AA Version 2 Compatibility] At MCI=5494000, AA version 2 features activate - are AAs explicitly versioned, or can formulas written for v1 behave differently under v2 semantics, causing non-deterministic execution across the upgrade boundary?",
  "[File: byteball/ocore/constants.js] [Line 94: unstableInitialDefinitionUpgradeMci] [Initial Definition Stability Attack] At MCI=5494000, initial definitions can be unstable - can an attacker create an address with an unstable definition, spend from it before stabilization, then cause the definition to change, effectively allowing unauthorized spending?",
  "[File: byteball/ocore/constants.js] [Line 95: includeKeySizesUpgradeMci] [Key Size Inclusion Validation Fork] At MCI=5530000, key sizes are included in validation - does this change unit hash calculation? Can units with identical content produce different hashes pre/post upgrade, causing hash-based lookups to fail?",
  "[File: byteball/ocore/constants.js] [Line 96: aa3UpgradeMci] [AA Version 3 Breaking Changes] At MCI=7810000, AA version 3 activates - what breaking changes are introduced? Can formulas that worked in v2 fail or behave differently in v3, causing state divergence for AAs that transition during the upgrade?",
  "[File: byteball/ocore/constants.js] [Line 97: v4UpgradeMci] [Protocol Version 4 Comprehensive Fork] At MCI=10968000, protocol v4 activates - as a major version upgrade, can this introduce multiple simultaneous validation changes that compound to cause consensus failures if nodes upgrade asynchronously?",
  "[File: byteball/ocore/constants.js] [Lines 43-48: MAX_AUTHORS  MAX_MESSAGES  MAX_INPUTS/OUTPUTS] [Validation Complexity Amplification Attack] Can an attacker craft a unit with 16 authors, 128 messages, and 128 inputs per message (16128128 = 262,144 total inputs) to cause O(n) or O(n) validation complexity that freezes the network?",
  "[File: byteball/ocore/constants.js] [Lines 56-58: MAX_CAP vs MAX_UNIT_LENGTH] [Asset Issuance Size Attack] If an asset with MAX_CAP=9e15 is issued in a unit approaching MAX_UNIT_LENGTH=5MB, can the large unit size cause processing delays while still being considered valid, creating a DoS vector through oversized issuance units?",
  "[File: byteball/ocore/constants.js] [Lines 57 & 66: MAX_COMPLEXITY vs MAX_OPS] [Formula Complexity Dual-Limit Bypass] Are MAX_COMPLEXITY=100 and MAX_OPS=2000 enforced independently? Can an attacker craft a formula with complexity=99 but 1999 operations, each being expensive (e.g., crypto functions), to bypass both limits individually while causing excessive execution time?",
  "[File: byteball/ocore/constants.js] [Lines 63-65: MAX_AA_STRING_LENGTH vs MAX_STATE_VAR_VALUE_LENGTH] [AA State String Size Mismatch] If AA formulas can create 4096-byte strings but state variables are limited to 1024 bytes, what happens when an AA tries to store an oversized string? Does it silently truncate, throw an error causing a bounce, or corrupt state?",
  "[File: byteball/ocore/constants.js] [Lines 16 & 113: MAJORITY_OF_WITNESSES recalculation in devnet] [Devnet Majority Calculation Override Risk] In devnet mode, MAJORITY_OF_WITNESSES is recalculated after COUNT_WITNESSES is set to 1 - if this recalculation is missed or incorrect, can the majority threshold be wrong, breaking consensus even in dev environments?",
  "[File: byteball/ocore/constants.js] [Line 11: Number.MAX_SAFE_INTEGER polyfill] [Safe Integer Polyfill Failure] If the JavaScript environment doesn't define Number.MAX_SAFE_INTEGER and the polyfill sets it to 9007199254740991, but the actual environment's integer precision is lower (e.g., 32-bit systems), can this cause silent integer truncation bugs?",
  "[File: byteball/ocore/constants.js] [Line 35-36: Genesis unit and blackbytes asset conditional assignment] [Genesis Configuration Race Condition] If both testnet and devnet flags are set simultaneously, which genesis unit takes precedence? Can this ambiguity cause nodes to initialize with mismatched genesis configurations?",
  "[File: byteball/ocore/constants.js] [Line 109-110: Devnet genesis changes with version/alt changes] [Devnet Genesis Instability] The comment 'THIS CHANGES WITH EVERY UNIT VERSION / ALT CHANGE!!!' suggests devnet genesis is unstable - can this cause devnet nodes to fork repeatedly as version strings change during development?",
  "[File: byteball/ocore/constants.js] [Line 147: lightHistoryTooLargeErrorMessage] [Error Message Information Leak] The error message 'your history is too large, consider switching to a full client' - does this reveal information about user transaction history size that could be exploited for privacy attacks or targeted DoS?",
  "[File: byteball/ocore/constants.js] [Lines 80-97: Testnet upgrade MCIs significantly lower than mainnet] [Testnet Upgrade Testing Inadequacy] Testnet upgrade MCIs (e.g., 684000 for witnessedLevelMustNotRetreatUpgradeMci) are much lower than mainnet (1400000) - does this mean testnet may not adequately test upgrade timing issues that manifest at higher MCI values due to state accumulation?",
  "[File: byteball/ocore/constants.js] [Lines 27-31: Testnet version suffixes] [Version Suffix Parsing Ambiguity] Testnet versions end in 't' (e.g., '4.0t') - can this cause string comparison issues where version checks fail to properly distinguish between '4.0' and '4.0t', potentially allowing cross-network unit replay?",
  "[File: byteball/ocore/constants.js] [Line 15: TOTAL_WHITEBYTES=1e15] [Total Supply Near JavaScript Integer Limit] With TOTAL_WHITEBYTES=1e15 close to MAX_SAFE_INTEGER=9007199254740991, can operations involving total supply (e.g., balance aggregations) overflow when combined with other large numbers like asset caps or fees?",
  "[File: byteball/ocore/constants.js] [Line 18: EMERGENCY_OP_LIST_CHANGE_TIMEOUT=3*24*3600] [Emergency Timeout Calculation Overflow] The timeout is calculated as 3*24*3600 (3 days in seconds) - if this calculation is performed in a context where integers are 32-bit, can it overflow and produce a negative or wrapped timeout value?",
  "[File: byteball/ocore/constants.js] [Line 19: EMERGENCY_COUNT_MIN_VOTE_AGE=3600] [Vote Age Race Condition] If vote age is exactly 3600 seconds (1 hour), can attackers exploit clock skew between nodes to submit votes that are valid on some nodes (clock ahead) but rejected on others (clock behind), causing vote counting disagreement?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Race condition on unstable messages] If two AA units posting conflicting data feed values are being processed concurrently and both iterate through storage.assocUnstableMessages simultaneously (lines 26-79), can a TOCTOU race cause non-deterministic evaluation where different nodes observe different feed states, leading to AA execution divergence and permanent chain split?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Unstable unit cache inconsistency] When checking storage.assocUnstableUnits[unit] || storage.assocStableUnits[unit] (line 27), if a unit transitions from unstable to stable between the two lookups, can the function miss the unit entirely or read stale metadata, causing incorrect data feed existence checks in AA formulas?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Concurrent unstable message modification] During iteration over storage.assocUnstableMessages (lines 197-223), if main_chain.js simultaneously moves messages to stable state and deletes them from assocUnstableMessages, can the iterator become invalid or skip entries, causing AA to miss valid data feeds and produce incorrect results?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Non-atomic unit property reads] When reading objUnit.latest_included_mc_index, objUnit.level, and objUnit.bAA across multiple unstable units (lines 27-35), if these properties are being updated concurrently by writer.js during unit storage, can inconsistent reads cause incorrect MCI filtering or AA detection?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Candidate selection race] When multiple AAs post data feeds concurrently and arrCandidates is being populated (lines 197-223), if the unstable unit set changes between candidate collection and sorting, can the sorting logic (lines 237-246) fail or produce non-deterministic ordering across nodes?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Type confusion in equality check] At line 44, the comparison 'value === feed_value || value.toString() === feed_value.toString()' treats numbers and their string representations as equal - can an attacker post a feed with string '123' that matches queries for numeric 123, bypassing type-specific validation in AA formulas and causing incorrect price oracle comparisons?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Inequality operator type inconsistency] Lines 48-50 check inequality using 'value.toString() !== feed_value.toString()' after converting both to strings - can this allow '123' != 123.0 to return false when the AA formula expects strict type checking, causing logic errors in conditional payouts?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Mixed type comparison vulnerability] When comparing numeric and string types (lines 53-75), if one value is number and another is string '123abc', the relationSatisfied() function (lines 17-24) will perform JavaScript type coercion - can this cause '100' > 99 to evaluate unexpectedly and break AA price threshold logic?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [String-to-number conversion ambiguity] Lines 58-59 convert strings to numbers using string_utils.toNumber(value, bLimitedPrecision) - if bLimitedPrecision changes based on max_mci crossing aa2UpgradeMci boundary (line 14), can the same string convert to different numbers on different nodes, causing non-deterministic AA execution?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Type coercion in feed value extraction] Line 216 uses string_utils.getFeedValue(feed_value, bLimitedPrecision) which may convert strings to numbers - if an oracle posts '1e20' before the upgrade and '1e20' after, can the different precision modes (line 190) cause the value to be read as number vs string, breaking AA state consistency?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Incomparable type handling] Lines 75-76 comment 'else they are incomparable e.g. abc > 123' but don't explicitly handle this case - can an attacker craft feeds with mixed types that cause relationSatisfied() to throw or return undefined, triggering AA bounces for legitimate users?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Key prefix injection] The key_prefix construction (line 123) concatenates 'df\\\\n'+address+'\\\\n'+feed_name+'\\\\n'+prefixed_value using newlines as delimiters - if an attacker controls a feed_name containing newlines, can they inject additional key components and query arbitrary data feeds from other addresses?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Lexicographic encoding attack] When encoding numbers using string_utils.encodeDoubleInLexicograpicOrder(float) (lines 109, 118), if the encoding has edge cases for special values like NaN, Infinity, or -0, can an attacker post feeds with these values that sort incorrectly in the KV store and break range queries?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Range query boundary manipulation] The >= operator query (lines 132-134) uses 'gte: key_prefix' and 'lt: type+\\\\r' as boundaries - can an attacker craft a prefixed_value that equals the boundary condition, causing the range to include/exclude unexpected entries?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [MCI encoding wraparound] Line 121 encodes MCI as (0xFFFFFFFF - mci).toString(16) for reverse ordering - if min_mci or max_mci exceed 0xFFFFFFFF (4.2 billion), can integer overflow cause incorrect MCI range filtering and allow reading feeds from wrong time periods?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [String vs numeric type prefix collision] Lines 109-115 prefix numeric values with 'n\\\\n' and strings with 's\\\\n' - can an attacker post a string feed starting with 'n\\\\n' that collides with numeric encoding and appears in both string and numeric queries?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Inequality decomposition vulnerability] Lines 96-102 decompose '!=' into '>' OR '<' queries - if both queries find different feed values within the MCI range, can the function incorrectly return true even when the feed value actually equals the query value at a specific MCI?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedByAddress()] [Key prefix ambiguity] When value===null, the key_prefix is 'dfv\\\\n'+address+'\\\\n'+feed_name (line 272) vs 'df\\\\n'+address+'\\\\n'+feed_name+'\\\\n'+prefixed_value (line 285) - can this prefix difference be exploited to query feeds from a different namespace?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Stream premature destruction] Line 168 calls stream.destroy() when bFound becomes true to terminate iteration early - if the stream's 'end' event (line 182) was already emitted before destroy(), can onEnd() be called twice, violating the bOnEndCalled check (line 175)?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Stream error handling DoS] Lines 183-185 throw an Error on stream errors, crashing the node - can an attacker corrupt the KV store to trigger stream errors during data feed queries, causing all nodes querying that oracle to crash and halt the network?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Unbounded stream iteration] For inequality queries (lines 132-147), if an oracle has posted millions of feed values, the stream iterates all matching entries (line 159-170) - can an attacker query 'feed_value > 0' against a prolific oracle to cause excessive memory usage and DoS the node?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedByAddress()] [Stream limit bypass] Line 290 sets 'limit: bAbortIfSeveral ? 2 : 1' to limit results, but line 292's handleData still processes all data events before checking objResult.value - can a malformed KV store emit more than 'limit' events, causing unexpected memory usage?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Stream resource leak] If stream.destroy() is called (line 168) but the stream fails to actually terminate and continues emitting 'data' events, can handleData (line 181) continue processing entries after bFound=true, wasting CPU?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Candidate sorting non-determinism] Lines 237-246 sort candidates by latest_included_mc_index and level, throwing Error if two candidates have identical values - if two unstable AA units have exactly the same latest_included_mc_index and level, does the Error cause AA execution to fail on all nodes or can some nodes process them in different order?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Timestamp-dependent behavior] Line 367 passes 'Math.round(Date.now() / 1000)' as timestamp parameter - if nodes have clock skew, can this cause different data feed query results across nodes, leading to divergent AA execution?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Iteration order non-determinism] Line 26 iterates 'for (var unit in storage.assocUnstableMessages)' - if JavaScript object key iteration order is non-deterministic across Node.js versions, can different nodes evaluate data feed existence in different order and get different bFound results when multiple conflicting feeds exist?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Precision mode boundary race] Lines 14, 106, 190, 268 check 'max_mci < constants.aa2UpgradeMci' to determine bLimitedPrecision - if an AA executes exactly at the upgrade MCI boundary, can different nodes use different precision modes based on whether they've marked that MCI as stable yet?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Float comparison non-determinism] Line 54 uses relationSatisfied() for numeric comparisons - if float values are subject to rounding errors (e.g., 0.1 + 0.2 !== 0.3), can identical oracle feeds compare differently across nodes with different CPU architectures?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Oracle count bypass] Line 330 checks 'if (oracles.length > 10)' but allows exactly 10 oracles - can an attacker craft an AA that queries 10 malicious oracles simultaneously, each posting millions of feed values, to DoS nodes during query execution?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Feed name validation bypass] Lines 332-334 check feed_name is non-empty string but don't validate contents - can an attacker use feed_name with special characters like newlines, null bytes, or extremely long strings to break KV store key construction?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Min_mci negative value] Line 344 validates min_mci is non-negative integer but doesn't check upper bound - can setting min_mci=0xFFFFFFFF cause MCI encoding (line 121) to produce '00000000', making the query range invalid?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Feed_value validation gap] Lines 336-340 validate feed_value with isValidValue() but this only checks basic types (line 384-386) - can an attacker pass an object or array as feed_value that bypasses validation but causes errors during KV query construction?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Ifnone parameter type confusion] Lines 365-366 validate ifnone with isValidValue() but line 378 returns params.ifnone directly preserving its type - can an attacker set ifnone=false to make an AA interpret missing feeds as boolean false instead of aborting, breaking conditional logic?",
  "[File: byteball/ocore/data_feeds.js] [Function: isValidValue()] [Incomplete type validation] Lines 384-386 accept string, boolean, or number but don't check for null, undefined, NaN, or Infinity - can these special values bypass validation and cause errors in downstream feed processing?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [MCI range off-by-one] Lines 32-33 check 'latest_included_mc_index < min_mci || latest_included_mc_index > max_mci' using strict inequalities - can an oracle posting at exactly min_mci or max_mci be incorrectly excluded from queries?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Reversed MCI encoding confusion] Lines 121-122 encode MCIs in reverse order (0xFFFFFFFF - mci) for efficient sorting - can min_mci > max_mci in the encoded form cause queries to return empty results even when valid feeds exist?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [MCI boundary race condition] When checking 'if (mci >= min_mci && mci <= max_mci)' (line 165) after reading from KV store, if the unit's actual MCI is later corrected by main chain reorg, can stale MCI values in KV store cause incorrect feed inclusion?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Latest_included_mc_index manipulation] Lines 203-204 filter unstable units by 'objUnit.latest_included_mc_index < min_mci || latest_included_mc_index > max_mci' - if an attacker posts an unstable AA unit with manipulated latest_included_mc_index, can it bypass MCI filtering before being rejected?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Upgrade MCI boundary precision attack] Line 14 checks 'max_mci < constants.aa2UpgradeMci' to determine precision mode - if an attacker queries with max_mci exactly equal to aa2UpgradeMci-1, can they force limited precision mode and make string '1.234567890123456789' truncate differently than queries with max_mci=aa2UpgradeMci?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Author address intersection bypass] Line 34 checks '_.intersection(arrAddresses, objUnit.author_addresses).length === 0' to filter by oracle - if an unstable unit has multiple authors including both legitimate oracle and attacker, can the intersection match and allow attacker to inject fake feed data?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Multiple oracle address spoofing] Lines 205-206 use same intersection check - if an AA queries oracles=['alice', 'bob'] and attacker creates unit co-authored by alice and attacker, can attacker's feed values be treated as if posted by alice alone?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Oracle address validation timing] Lines 328-329 validate oracle addresses but after accepting the array - can an attacker pass a very large array of addresses (e.g., 1 million entries before the length check on line 330) to cause memory exhaustion?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Empty arrAddresses handling] If arrAddresses is empty array [], line 34's intersection will always be empty (length 0) causing all units to be skipped - can this cause all data feed queries to return false even when feeds exist, breaking AA logic?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Missing payload validation] Lines 37-42 access message.payload[feed_name] without validating payload structure - if an oracle posts malformed data_feed message with payload=null or payload=undefined, can accessing payload[feed_name] throw and crash the node?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Feed value type inconsistency] Lines 214-216 check value equality but don't validate feed_value type matches expected type - can an oracle post feed_name='price' with boolean value true that matches query for value=1 due to type coercion?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [HasOwnProperty bypass] Lines 40, 211 use ValidationUtils.hasOwnProperty(payload, feed_name) - if payload is constructed with Object.create(null), can __proto__ poisoning allow attacker to inject arbitrary feed values?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Data value extraction from KV] Line 305 parses 'arrParts[0]' from data.value.split('\\\\n') without validating array length - if KV store is corrupted and data.value has no newlines, can arrParts[0] be undefined and cause errors?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedByAddress()] [Value decoding from key] Line 300 calls string_utils.getValueFromDataFeedKey(data.key) - if the key format is corrupted, can decoding throw errors that crash the stream handler?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Early return bypassing DB query] Lines 80-81 return early if bFound=true from unstable messages without querying stable DB feeds - can an attacker post unstable AA unit with fake feed that causes AA to execute incorrectly before the unstable unit is rejected?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Callback double invocation] If both stream.destroy() (line 168) and stream 'end' event (line 182) trigger onEnd(), the bOnEndCalled check (line 175) throws Error - can this Error propagate to async.eachSeries and cause the entire data feed query to fail?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Async.eachSeries error propagation] Lines 255-264 use async.eachSeries but the callback at line 260 receives 'err' only if aborted - if readDataFeedByAddress throws Error instead of calling callback, can the iteration hang indefinitely?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Multiple callback invocation] Lines 367-381 call cb() multiple times in different branches - if execution reaches multiple return statements due to async timing, can the callback be invoked more than once, causing AA formula evaluation errors?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Inequality operator recursive callback] Lines 97-101 recursively call dataFeedByAddressExists for '!=' decomposition - if max recursion depth is reached, can this cause stack overflow?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Zero value handling] When comparing numeric values, line 54 checks 'typeof value === number && typeof feed_value === number' - can posting feed_value=0 or value=0 cause division by zero or other edge cases in downstream AA formulas?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Negative zero comparison] JavaScript distinguishes +0 and -0 but line 44's equality check may not - can an oracle post -0 that doesn't match queries for +0, breaking AA price feed logic that expects zero equality?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Float encoding edge cases] Line 109 calls encodeDoubleInLexicograpicOrder(float) which handles -0 specially - if an oracle posts both +0 and -0 as separate feeds, can queries for 0 match both, causing duplicate detection issues?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Very large number handling] If feed_value or value is Number.MAX_VALUE or larger, can arithmetic comparisons (lines 54, 66) overflow or lose precision, causing incorrect inequality checks?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Empty string feed name] If feed_name is empty string '', line 123's key_prefix becomes 'df\\\\n'+address+'\\\\n\\\\n'+prefixed_value - can the double newline cause key parsing ambiguity?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Boolean feed values] Lines 384-386 accept boolean values, but can an oracle post feed_value=false that AA formulas misinterpret as absence of feed (falsy value)?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Ifseveral abort with unstable] Lines 233-235 set bAbortedBecauseOfSeveral=true when multiple unstable candidates exist and ifseveral='abort' - can an attacker post multiple conflicting unstable AA feeds to force legitimate AAs to abort execution?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedByAddress()] [Ifseveral last mode ambiguity] Lines 298-299 check 'ifseveral === last && mci > objResult.mci' to select latest feed - if two feeds have identical MCI, which one is selected and is it deterministic across nodes?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedByAddress()] [Abort check after limit] Line 290 sets limit=2 for abort mode but line 293 checks 'objResult.value !== undefined' - if exactly 2 feeds exist, does the function always abort even when it should select the first?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Ifseveral validation bypass] Lines 348-351 validate ifseveral is 'abort' or 'last' but default is 'last' (line 347) - can attacker pass ifseveral=null to bypass validation but still use default?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Mixed stable/unstable with ifseveral] If unstable messages contain 1 candidate and stable DB contains 1 candidate, and ifseveral='abort', does the function abort or does it only check within each source separately (lines 224-253)?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [What=unit return] Lines 371-372 return objResult.unit when what='unit' - if the unit doesn't exist in storage anymore (deleted or garbage collected), can returning a stale unit hash cause AA to reference non-existent units?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Type parameter conversion] Lines 373-374 check 'if (type === string)' and convert value.toString() - can this lose precision for very large numbers or create ambiguity between numeric 123 and string '123' in AA logic?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [What parameter validation] Lines 354-357 validate 'what' is 'unit' or 'value' but don't handle what=null or what=undefined - can passing undefined bypass validation but cause errors at line 371?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [ObjResult structure mutation] Lines 192-193 initialize objResult with specific fields, but lines 226-228, 249-251 mutate it - if multiple addresses are queried (line 255), can the objResult from first address leak into second address query?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [bAA flag bypass] Lines 30-31 check 'if (!objUnit.bAA) continue' to skip non-AA unstable units - can an attacker post a regular unstable data_feed unit that bypasses this check because bAA parameter (line 12) is false, but still affects the query?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [bIncludeAllUnstable flag] Lines 194, 201 check bIncludeAllUnstable to include non-AA unstable units - if unstable_opts='all_unstable', can unvalidated unstable units from malicious peers be included in feed queries before being rejected?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Unstable vs stable priority] Lines 195-253 check unstable messages first, then 255-264 query stable DB - if both contain same feed, which takes priority and is this consistent across nodes?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Early return from unstable check] Line 81 returns immediately when bFound=true from unstable check without querying DB - can this cause different results if the unstable unit is later rejected and DB query would have returned false?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [toNumber precision inconsistency] Lines 107, 277 call string_utils.toNumber(value, bLimitedPrecision) - if the toNumber function has bugs in handling scientific notation (e.g., '1e309'), can it return null when it should return Infinity or vice versa, causing feed queries to fail?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [encodeDoubleInLexicograpicOrder overflow] Line 109 encodes doubles to hex - if the encoding doesn't handle subnormal numbers or denormalized floats correctly, can feeds with very small values like 1e-308 be stored with incorrect sort order?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [encodeMci padding error] Line 121 calls string_utils.encodeMci(min_mci) - if encodeMci doesn't properly zero-pad to 8 hex characters, can MCIs sort incorrectly in KV store?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [getMciFromDataFeedKey parsing] Line 164 extracts MCI using string_utils.getMciFromDataFeedKey(data) - if the key format is malformed, can parsing return wrong MCI and include/exclude feeds incorrectly?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedByAddress()] [getFeedValue conversion] Line 305 calls string_utils.getFeedValue(arrParts[0], bLimitedPrecision) - if this conversion is inconsistent with the encoding at storage time, can feeds be stored as numbers but read as strings?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Unstable message iteration DoS] Lines 26-79 iterate all units in storage.assocUnstableMessages without limit - can an attacker flood the network with unstable AA units to make this iteration extremely slow, causing AA execution timeouts?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Inequality query DoS] For queries like 'feed_value > 0', lines 136-138 scan all values from 0 to maximum in KV store - can an oracle with millions of historical feeds cause this scan to take minutes, making AA execution unacceptably slow?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Multiple oracle query cascade] Lines 255-264 query each oracle in arrAddresses sequentially via async.eachSeries - if AA queries 10 oracles and each takes 10 seconds, can total query time exceed AA execution timeout?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Message iteration per unit] Line 36 calls forEach on storage.assocUnstableMessages[unit] - if an unstable unit contains maximum 128 messages (per MAX_MESSAGES_PER_UNIT), can iterating all messages for all unstable units cause O(n*m) complexity?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Console.log in hot path] Lines 89, 167, 177 call console.log during every feed query - can excessive logging slow down AA execution or fill disk with logs?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Identical MCI and level collision] Lines 242-246 throw Error if two candidates have identical latest_included_mc_index and level - can this legitimately occur when two AAs post feeds in the same round, causing all nodes to fail AA execution?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Level-based tiebreaker reliability] Line 243 uses objUnit.level as secondary sort key - if unit level calculation has edge cases or bugs, can sort order be non-deterministic?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Single candidate early return] Lines 224-230 return immediately if arrCandidates.length === 1 and ifseveral='last' - does this skip the stable DB query (lines 255-264) even if the DB might have a more recent stable feed?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Array sort mutability] Line 237 calls arrCandidates.sort() which mutates the array in place - if arrCandidates is shared across multiple queries due to reference aliasing, can sorting affect concurrent queries?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Missing unit Error throw] Lines 29, 200 throw Error 'unstable unit X not in assoc' - does this crash the entire AA execution or is it caught somewhere, and can attacker trigger this by racing unit storage and query?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Unknown relation Error] Line 23 throws Error for unknown relation - if relation parameter is corrupted or injection occurs, does this throw propagate to AA formula evaluation and cause bounce?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Double onEnd Error] Line 175 throws Error 'second call of onEnd' if bOnEndCalled is already true - can this happen legitimately due to stream events, and does it crash the node?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [Error callback inconsistency] Lines 325-366 return cb(error_message) for validation failures but lines 369-380 return cb(error_message) or cb(null, result) - if callback expects different signatures, can this cause undefined behavior?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Stream error throw] Line 184 throws Error on stream errors rather than calling handleResult - can this bypass the async.eachSeries error handling and leave the iteration in undefined state?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedExists()] [Storage module state consistency] Lines 26-28 access storage.assocUnstableMessages and storage.assocUnstableUnits - if storage.js has race conditions in populating these structures, can queries see inconsistent state?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Constants.aa2UpgradeMci trust] Lines 14, 106, 190, 268 rely on constants.aa2UpgradeMci being accurate - if this constant is wrong in config or if devnet sets it to 0 (line 131), can precision mode be incorrect?",
  "[File: byteball/ocore/data_feeds.js] [Function: dataFeedByAddressExists()] [Kvstore.createKeyStream dependency] Line 180 uses kvstore.createKeyStream - if kvstore.js (RocksDB wrapper) has bugs in stream implementation, can corrupt data be returned?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [ValidationUtils.isValidAddress trust] Line 328 validates addresses using ValidationUtils.isValidAddress - if this function has false positives, can invalid addresses be queried?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Main_chain.js MCI assignment race] Lines 32, 203 filter by objUnit.latest_included_mc_index - if main_chain.js updates this field concurrently, can queries see partially updated MCI values?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [Value=null special case] Lines 271-272 handle value===null separately with different key prefix - if an oracle posts feed_value=null (JSON null), can it be queried using value=null parameter?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValueByParams()] [feed_value optional parameter] Lines 336-340 check 'if (feed_value in params)' - can attacker pass params={feed_value: undefined} that passes the 'in' check but fails isValidValue()?",
  "[File: byteball/ocore/data_feeds.js] [Function: readDataFeedValue()] [ObjResult.value undefine\n\n### Citations\n\n**File:** data_feeds.js (L1-390)\n```javascript\n/*jslint node: true */",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Complexity Bypass] Can an attacker craft a deeply nested definition with alternating 'or' and 'and' operators that increments complexity only once per level but requires exponential evaluation time, causing nodes to hang while staying under MAX_COMPLEXITY limit, leading to network DoS?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Op Count Manipulation] If an attacker creates a definition with multiple 'in data feed' operators referencing many oracle addresses, does the complexity increment per address (line 389) correctly prevent exceeding MAX_OPS, or can the attacker bypass this by using multiple operators with arrAddresses.length-1 increments to cause integer overflow in count_ops?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Complexity Race Condition] Since complexity and count_ops are shared variables across async recursive calls, can two parallel evaluate() branches racing to increment these counters cause one branch to exceed limits while the other succeeds, leading to non-deterministic validation results across nodes?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Formula Complexity Inheritance] When evaluating a 'formula' operator, the formula parser updates complexity and count_ops variables, but does the parent validateDefinition check these updated values against MAX_COMPLEXITY/MAX_OPS again after formula validation returns, or can a formula consume the entire budget leaving no room for outer definition checks?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Async Complexity Check] The complexity check occurs at line 100 before async operations, but if an async operation (e.g., database query for 'definition template') takes long enough for another evaluate() call to increment complexity beyond MAX_COMPLEXITY, can both branches proceed past the check causing total complexity to exceed 2*MAX_COMPLEXITY?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'address' case] [Infinite Loop via Circular References] If address A's definition references address B, and address B's definition references address A (either directly or through a chain), does the evaluate() function detect this cycle before stack overflow, or can an attacker permanently freeze validation by submitting a unit that triggers infinite recursion?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'address' case] [Definition Redefinition Attack] When evaluating an 'address' operator, if the inner address was redefined via definition_chg after the outer definition was created but before last_ball_mci, does the validation use the new or old definition, and can an attacker exploit timing to make a previously-valid outer definition become invalid, permanently freezing funds locked in that definition?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - needToEvaluateNestedAddress()] [Nested Evaluation Skip Bypass] The optimization at lines 88-94 skips evaluating nested addresses if no authentifiers match the path, but can an attacker craft a definition where the skipped nested address contains a complexity bomb that would exceed MAX_COMPLEXITY, allowing the definition to pass validation but fail when actually used with matching authentifiers?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'address' case] [Definition Not Found Race] At lines 715-720, if an inner address definition is not found in storage but is being defined in the current unit, the code filters objUnit.authors for a matching definition, but if multiple authors define the same address with different definitions in the same unit, does the code properly reject this or can it non-deterministically pick one definition?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'address' case] [Path Authentication Bypass] The pathIncludesOneOfAuthentifiers check at line 708 determines if the nested address should be evaluated, but can an attacker provide authentifiers for a parent path that don't match the nested address path, causing the validation to skip signature checks for the nested address entirely?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'definition template' case] [Template Unit Not Stable] The query at lines 293-294 requires the template unit to be stable (is_stable=1), but does this check prevent an attacker from creating a unit that references a template from a unit that appears stable locally but is not stable globally due to network partition, causing different nodes to use different templates?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'definition template' case] [Template Payload Parsing] At line 300, the template payload is parsed with JSON.parse() without validation, so if the template unit contains malformed JSON or non-array template payload, can this cause JSON.parse() to throw an exception that isn't caught, crashing the validation and causing network DoS?",
  "[File: byteball/ocore/definition.js] [Function: replaceInTemplate()] [Parameter Type Confusion] The replaceInVar function at lines 1289-1291 allows params[name] to be string or number, but when replacing a variable in the template, does this preserve type safety? Can an attacker pass a number where a string address is expected, causing validation to incorrectly accept an invalid definition?",
  "[File: byteball/ocore/definition.js] [Function: replaceInTemplate()] [Missing Variable Exception Handling] If a template references a variable name that isn't provided in params, NoVarException is thrown at line 1339, but in validateAuthentifiers() at line 742, is this exception properly caught and converted to a validation failure, or can it bubble up and crash the node?",
  "[File: byteball/ocore/definition.js] [Function: replaceInTemplate() - replaceInVar()] [Nested Object Mutation] The function mutates nested objects in-place at lines 1343-1347 after cloning the template, but if the same template is being evaluated concurrently by multiple units on different validation threads, can race conditions in the cloneDeep or assignField operations cause one evaluation to see partially-mutated template data from another?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'definition template' case] [Template Complexity Accumulation] When replaceInTemplate fills a template and then evaluate() is called recursively on the filled template, does the complexity from evaluating the inner definition get added to the outer definition's complexity counter? If not, can an attacker nest templates to create exponential complexity that bypasses MAX_COMPLEXITY per template?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'sig' case] [Placeholder Signature Acceptance] At line 684, if objValidationState.bUnsigned is true and signature[0] === '-', the signature is accepted without verification, but can an attacker set bUnsigned inappropriately (e.g., through a race condition or by exploiting other validation logic) to bypass signature checks on a real unit?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'sig' case] [Fatal Error Silent Failure] At line 687, if signature verification fails, fatal_error is set but the function returns cb(false) instead of cb(fatal_error), so the error message is stored but not immediately returned; later at line 1318, fatal_error is checked, but can async race conditions cause fatal_error to be overwritten by a later failing signature before line 1318 is reached?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'hash' case] [Hash Preimage Time-of-Check-Time-of-Use] At line 699, the code verifies that the SHA256 hash of assocAuthentifiers[path] matches args.hash, but if assocAuthentifiers is mutable and modified between this check and when arrUsedPaths is verified at line 1320, can an attacker pass validation with one preimage but have a different preimage recorded in arrUsedPaths?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers()] [Unused Authentifiers Check Bypass] At lines 1320-1321, the code checks that all provided authentifiers are used by comparing arrUsedPaths.length with Object.keys(assocAuthentifiers).length, but if an attacker provides duplicate authentifiers at different paths (e.g., 'r.0' and 'r.1' with the same signature), can this cause arrUsedPaths to have fewer unique entries than assocAuthentifiers, allowing unused authentifiers to slip through?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate()] [Path Computation Inconsistency] Throughout the recursive evaluate() function, paths are constructed by concatenating parent path with '.'+index (e.g., lines 600, 620, 640), but if the validateDefinition() and validateAuthentifiers() functions use different path construction logic, can an attacker craft authentifiers that match paths in validateAuthentifiers but not in validateDefinition, bypassing signature requirements?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - getFilterError()] [Private Asset Self-Reference] At lines 52-53, if bAssetCondition is true and filter.asset === 'this asset' and objValidationState.bDefiningPrivateAsset is true, an error is returned, but does this check prevent all forms of circular reference where a private asset condition indirectly references itself through other definitions?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - getFilterError()] [Asset Condition Address Reference] At lines 62-63, asset conditions cannot reference 'this address' or 'other address', but can an attacker use 'definition template' or nested 'address' operators within an asset condition to indirectly reference these special addresses, bypassing the restriction?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Asset Condition Operation Restrictions] Multiple operators (sig, hash, address, in merkle) check bAssetCondition and return errors if true (lines 218-219, 233-234, 250-251, 419-420), but is this list complete? Can an attacker use other operators like 'cosigned by' or 'formula' in an asset condition that shouldn't be allowed, causing non-deterministic asset condition evaluation?",
  "[File: byteball/ocore/definition.js] [Function: evaluateAssetCondition()] [Authentifier Parameter Confusion] At line 582, evaluateAssetCondition calls validateAuthentifiers with address=null and assocAuthentifiers=null, but the bAssetCondition flag is determined at line 1301 by checking if assocAuthentifiers is null; if evaluateAssetCondition is called with non-null assocAuthentifiers by mistake, would this bypass asset condition restrictions?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - determineIfAnyOfAssetsIsPrivate()] [Private Asset Check Race] At lines 80-86, the function queries the database to check if any assets are private, but if an asset's is_private flag is changed between this query and when the definition is actually used, can this cause different nodes to evaluate the same definition differently, leading to consensus failure?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'in data feed' case] [Oracle Address Array Manipulation] At lines 384-388, the function validates that all addresses in arrAddresses are valid and adds complexity for each address, but can an attacker provide the same oracle address multiple times in arrAddresses to either exhaust complexity or cause duplicate database queries, leading to DoS?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'in data feed' case] [Data Feed Value Type Coercion] The commented-out code at lines 864-923 shows complex logic for comparing string vs numeric feed values, but the actual implementation at line 863 calls dataFeeds.dataFeedExists; can an attacker exploit type coercion differences between the old and new implementations by providing feed values that compare differently under string vs numeric comparison?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'in data feed' case] [Min MCI Validation] At line 410-411, if min_mci is provided, it must be a non-negative integer, but is there a maximum value check? Can an attacker set min_mci to a very large value (e.g., Number.MAX_SAFE_INTEGER) that would cause all current data feeds to be excluded, making the condition impossible to satisfy and permanently freezing funds?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'in data feed' case] [Time-of-Check Time-of-Use for Data Feeds] At line 863, dataFeedExists is called with objValidationState.last_ball_mci, but if a new stable ball is added between when objValidationState was captured and when this check executes, can different nodes see different data feed availability, causing non-deterministic validation results?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'in data feed' case] [Feed Name Length DoS] At line 396, feed_name.length is checked against MAX_DATA_FEED_NAME_LENGTH, but is there a check on the number of distinct feed_name values used across all 'in data feed' operators in a single definition? Can an attacker create thousands of 'or' branches each checking a different feed name, causing database index thrashing?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'in merkle' case] [Merkle Proof Missing Authentifier] At lines 929-931, if assocAuthentifiers[path] is missing, the function returns cb(false) without setting fatal_error, but should this be treated as a fatal error like bad signature/hash? Can an attacker exploit this distinction to bypass merkle proof requirements?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'in merkle' case] [Merkle Proof Deserialization Attack] At line 937, serialized_proof is deserialized via merkle.deserializeMerkleProof without validation; if the deserialization function has vulnerabilities (buffer overflow, prototype pollution), can an attacker crash the node or execute arbitrary code by providing a malicious serialized proof?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'in merkle' case] [Merkle Root Collision] At lines 939-942, if the merkle proof is invalid, fatal_error is set, but the code then checks if the merkle root exists in data feeds; if an attacker finds a collision where two different elements produce the same merkle root, can they prove membership of an element not actually in the feed?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'in merkle' case] [Element Format Validation Bypass] At lines 441-442, the element must match a specific regex pattern, but the regex allows many special characters; can an attacker craft an element string that matches the regex but causes injection attacks in downstream systems that use this element (e.g., SQL injection if element is used in queries)?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'in merkle' case] [Negation Restriction] At line 415, 'in merkle' cannot be negated, but the validateDefinition code doesn't enforce this recursively; can an attacker nest 'in merkle' inside a 'not' operator at a different level (e.g., ['not', ['or', [['in merkle', ...], ['other']]]]) to bypass the restriction?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - getFilterError()] [Filter Amount Validation] At lines 66-73, amount, amount_at_least, and amount_at_most are validated as positive integers, but there's no check for maximum values; can an attacker specify amount_at_most as Number.MAX_SAFE_INTEGER, causing arithmetic overflow when summing amounts in the 'sum' operator evaluation?",
  "[File: byteball/ocore/definition.js] [Function: evaluateFilter()] [Input Address Augmentation Missing] At lines 1192-1204, when evaluating inputs, the code expects augmented_input to have an address field, but if augmentMessages() fails to populate this field for some input types, can the filter incorrectly match or skip inputs, causing 'has' operators to return wrong results?",
  "[File: byteball/ocore/definition.js] [Function: evaluateFilter()] [This Address vs Other Address Ambiguity] At lines 1193-1199 and 1219-1225, 'this address' refers to the address parameter passed to validateAuthentifiers, but in nested definitions evaluated via 'address' operator, does 'this address' refer to the outer or inner address? Can an attacker exploit this ambiguity to bypass address-based filters?",
  "[File: byteball/ocore/definition.js] [Function: augmentMessages()] [Input Type Assumption] At lines 1269-1292, the function augments inputs by querying the database for transfer outputs, but if an input.type is explicitly set to something unexpected (not 'issue' or 'transfer'), does the code handle this gracefully? Can an attacker cause inputs to be incorrectly augmented, leading to wrong filter evaluation?",
  "[File: byteball/ocore/definition.js] [Function: augmentMessages()] [Concurrent Augmentation Race] At lines 1141-1146, augmentMessagesAndContinue checks if objValidationState.arrAugmentedMessages exists and skips augmentation if so, but if two parallel evaluation branches both enter augmentMessages simultaneously, can they both proceed to augment, causing duplicate queries and non-deterministic objValidationState.arrAugmentedMessages values?",
  "[File: byteball/ocore/definition.js] [Function: evaluateFilter()] [Message Index vs Payload Index Confusion] Throughout evaluateFilter (lines 1162-1248), the code iterates over objUnit.messages and payload.inputs/outputs, but when accessing augmented_input at line 1191, it uses objValidationState.arrAugmentedMessages[i].payload.inputs[j]; if objUnit.messages contains non-payment messages, does the index alignment break, causing wrong augmented input to be accessed?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'has'/'has one' case] [Op Parameter Handling] At lines 1024-1032, 'has' and 'has one' call augmentMessagesAndEvaluateFilter, but the result is passed to cb(res) without checking the second parameter arrFoundObjects; if evaluateFilter returns true with an empty arrFoundObjects (which shouldn't happen but could due to bugs), would downstream 'has equal' or 'sum' operators mishandle this?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'has equal' case] [Equal Fields Comparison Type Safety] At line 1046, the code compares arrFirstObjects[i][field] !== arrSecondObjects[j][field] for equality, but if one field is a number and the other is a string representation of that number, does JavaScript's !== operator cause false inequality? Can an attacker exploit this to make 'has one equal' return false when it should be true, freezing funds?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'sum' case] [Sum Arithmetic Overflow] At lines 1062-1065, amounts are summed in a regular JavaScript number, but if amounts are very large positive integers near Number.MAX_SAFE_INTEGER, can the sum exceed this limit and wrap around or lose precision, causing 'sum' with equals/at_least/at_most checks to return wrong results?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'has equal'/'has one equal' case] [Search Criteria Asset Privacy] At lines 508-523, the code collects assets from search_criteria filters and checks if any are private, but if filter.asset is 'base' or 'this asset' in an asset condition, the asset is not added to arrAssets; can an attacker craft search_criteria that references private assets indirectly through 'this asset', bypassing the privacy check?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'sum' case] [Sum Mutually Exclusive Constraints] At line 543, the code checks that equals and at_least/at_most are not used together, but there's no check preventing at_least > at_most; if an attacker sets at_least=100 and at_most=50, does the validation accept this impossible constraint, and would evaluation return false or true when sum is in [50, 100]?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'timestamp' case] [Timestamp Comparison Type] At lines 959-970, timestamp comparisons use objValidationState.last_ball_timestamp directly with relation operators, but if last_ball_timestamp is undefined or null (due to validation state initialization bugs), does JavaScript coercion cause unexpected comparison results, making timestamp checks always pass or always fail?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'mci' case] [MCI Boundary Conditions] At lines 973-984, MCI comparisons are performed, but there's no validation that mci (from args[1]) is within a reasonable range; can an attacker specify mci as a negative number or NaN, causing comparison operators to behave unexpectedly and bypassing MCI-based time locks?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'age' case] [Age Calculation Integer Overflow] At line 1013, the SQL query checks if objValidationState.last_ball_mci - age is greater/less than main_chain_index, but if age is negative or extremely large, can this cause integer overflow in SQLite/MySQL, returning wrong results and allowing premature spending of time-locked funds?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'age' case] [Age Source Unit Collection] At lines 1005-1006, the code collects arrSrcUnits only from inputs with input.address === address, but if an attacker transfers funds from address A to address A (self-transfer), does the age check measure the age of the self-transfer unit or the original source unit? Can this be exploited to reset time locks?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'age' case] [Age Query SQL Injection] At line 1013, the SQL query concatenates objValidationState.last_ball_mci - age and relation directly into the query string; if relation comes from untrusted input (which it doesn't in normal flow, but could due to bugs), can an attacker inject SQL to manipulate the age check result?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - augmentMessagesAndContinue()] [Age Evaluation Without Augmentation] At lines 992-1021, the 'age' operator requires augmentMessagesAndContinue to populate input addresses, but if augmentation fails or is skipped due to race conditions, the code at line 1009 checks if arrSrcUnits.length === 0 and returns false; can this cause legitimate age-locked definitions to fail validation non-deterministically?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'seen address' case] [Seen Address MCI Window] At lines 751-758, the query checks for address in unit_authors with main_chain_index <= last_ball_mci and is_stable=1, but if an address was used in an unstable unit that becomes stable right after objValidationState.last_ball_mci is captured, can different nodes see different 'seen address' results, causing consensus divergence?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'seen definition change' case] [Definition Change 'any' Wildcard] At line 770, if new_definition_chash === 'any', the SQL where clause is empty string, matching all definition changes for the address; can an attacker exploit this by creating a definition that checks 'seen definition change' with 'any' and then immediately changing their own definition in the same unit, making the condition trivially true?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'attested' case] [Attestation Oracle Trust] At lines 827-837, the code calls storage.filterAttestedAddresses to check if attested_address is attested by any of arrAttestors, but if the attestation system has vulnerabilities (e.g., attestations can be revoked but are still counted), can an attacker use expired/revoked attestations to bypass attestation requirements?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'seen address' case] [Address Validation Only] At lines 316-321, 'seen address' only validates that args is a valid address, but doesn't check if the address was actually seen; can an attacker create a definition with 'seen address' for an address that never existed, and would this definition pass validation but fail during authentication, permanently freezing funds?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'attested' case] [Attestor Count Limit] At lines 352-356, the code validates that each address in arrAttestors is valid, but there's no limit on arrAttestors.length; can an attacker specify thousands of attestor addresses to cause DoS through excessive database queries when storage.filterAttestedAddresses is called?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'cosigned by' case] [Author Address Lookup Race] At lines 843-845, the code checks if cosigner_address is in objUnit.authors, but if objUnit.authors is modified concurrently (e.g., by another validation thread), can the indexOf check see an inconsistent state, causing non-deterministic cosigner verification results?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'cosigned by' case] [Negation Not Prevented] At line 362, the code checks if bInNegation is true and returns an error for 'cosigned by', but this check is inconsistent with other operators like 'hash' which also can't be negated; can an attacker nest 'cosigned by' in a 'not' at a higher level to bypass the restriction?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'cosigned by' case] [Cosigner Definition Validation] When a cosigner_address is found in objUnit.authors, is the cosigner's own definition validated to ensure the cosigner authorized this unit? If the cosigner is a multi-sig address and only some signers signed, does this count as cosigning, or does the full cosigner definition need to be satisfied?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'not' case] [Fatal Error Propagation in Negation] At line 851, 'not' inverts the result of evaluate(args), but if evaluate(args) sets fatal_error, does cb2(!not_res) propagate this fatal_error correctly, or does the negation logic mask signature/hash verification failures, allowing invalid signatures to be accepted?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'not' case] [Double Negation Complexity] At line 369, 'not' calls evaluate(args, path, true, cb) with bInNegation=true, but if args itself contains another 'not', does bInNegation get set back to false, and does this double-negation consume double complexity? Can an attacker nest many 'not' operators to multiply complexity?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Negation Path Prefix] Throughout evaluate(), bInNegation is passed recursively but only checked for specific operators (sig, hash, address, in merkle, cosigned by); are there other operators that should not be negatable? Can an attacker negate 'formula' or 'definition template' operators to cause unexpected behavior?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'or'/'and' case] [Signature Count Logic] At lines 124-125, the code counts options_with_sig, and for 'or' returns true only if all options have signatures, while for 'and' returns true if at least one option has signature; but in validateAuthentifiers' evaluate(), 'or' at line 594 returns true if any option is true, while 'and' at line 614 requires all to be true; is this asymmetry between validation and authentication correct, or can it cause definitions that pass validation but always fail authentication?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'or' case] [Short-Circuit Evaluation Prevention] At lines 596-608, the code uses async.eachSeries to evaluate all 'or' options even after one returns true (res = res || arg_res), but the comment at line 603 says 'check all members even if required minimum already found'; is this to prevent timing attacks or signature verification bypass? Can an attacker exploit the fact that all branches are checked to cause DoS via expensive operations in unneeded branches?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'r of set' case] [Required vs Set Length Edge Case] At lines 146-147, required must be <= set.length, but there's a commented-out check at lines 148-151 preventing required === set.length; if required === set.length, doesn't this make 'r of set' equivalent to 'and'? Can an attacker use this to bypass complexity checks that might treat 'and' differently?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'r of set' case] [Required Count Exact Matching] At lines 634-649, the code counts how many set options return true and checks count >= args.required, but validateDefinition at lines 169-170 checks if args.required > count_options_without_sig; if required equals count_options_without_sig + 1, can this create an edge case where validation passes but authentication always fails because not enough options have signatures?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'weighted and' case] [Weight Overflow] At line 195, total_weight accumulates arg.weight for each set element, but if an attacker provides many elements with weight close to Number.MAX_SAFE_INTEGER, can total_weight overflow, causing the check at line 207 (args.required > total_weight) to incorrectly pass?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'weighted and' case] [Weight Accumulation Race] At lines 655-670, weight is accumulated across async operations, and multiple branches may increment weight concurrently; if JavaScript's number addition is not atomic (which it should be, but implementation bugs could exist), can race conditions cause weight to be computed incorrectly?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'formula' case] [Formula MCI Gate] At line 553, formulas are not allowed before constants.formulaUpgradeMci, but if objValidationState.last_ball_mci is exactly equal to formulaUpgradeMci, are formulas allowed? Can an attacker exploit an off-by-one error in this comparison to use formulas before they should be activated?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'formula' case] [Formula Trigger Data Selection] At lines 1101-1103, the code uses the first 'data' message as trigger.data and ignores subsequent ones, but if an attacker includes multiple data messages in different orders in their unit, can they cause different nodes to pick different data messages if message iteration order is not deterministic?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'formula' case] [Formula Result Type Coercion] At lines 1116-1124, the formula result is coerced to boolean using various checks (typeof === 'boolean', !!result for string, !result.eq(0) for Decimal), but what if the formula returns an object, array, or undefined? Would line 1123 return cb2(false), and is this the correct behavior, or should these be treated as errors?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'formula' case] [Formula Message Augmentation Decision] At lines 1131-1138, augmentMessagesOrIgnore decides whether to augment based on whether the formula contains 'input' (tested via regex /input/.test(formula)), but if the formula is an object or array, does .test() work correctly? Can an attacker craft a formula that uses inputs without triggering augmentation, causing incorrect formula evaluation?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'formula' case] [Formula Address Parameter] At line 1111, the address parameter is passed to formulaParser.evaluate, but in nested address definitions, does 'address' refer to the correct (inner or outer) address? Can an attacker exploit address context confusion in formula evaluation to bypass restrictions?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'has definition change' case] [Definition Change Message Lookup] At lines 1085-1094, the code searches objUnit.messages for 'address_definition_change' messages, but if message.payload is null or undefined, does line 1088 cause an exception? Can an attacker include malformed definition_change messages to crash validation?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'has definition change' case] [Default Address for Definition Change] At line 1092, if message.payload.address is not specified, it defaults to objUnit.authors[0].address, but what if objUnit.authors is empty or authors[0] is undefined? Can this cause an exception or incorrect address comparison?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'has definition change' case] [This Address Resolution Timing] At lines 1081-1084, 'this address' is resolved to the address parameter, but if this evaluation happens inside a nested 'address' operator where address has changed, can the wrong address be used for comparison, causing 'has definition change' to return incorrect results?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'seen' case] [Seen Input Type Validation] At line 786, the code checks filter.what is 'input' or 'output', but if it's neither (due to validation bypass), line 787 would use an invalid table name in SQL query; is there proper error handling, or would this cause a database exception that crashes the node?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Complexity Bypass] Can an attacker craft a deeply nested definition with alternating 'or' and 'and' operators that increments complexity only once per level but requires exponential evaluation time, causing nodes to hang while staying under MAX_COMPLEXITY limit, leading to network DoS?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Op Count Manipulation] If an attacker creates a definition with multiple 'in data feed' operators referencing many oracle addresses, does the complexity increment per address (line 389) correctly prevent exceeding MAX_OPS, or can the attacker bypass this by using multiple operators with arrAddresses.length-1 increments to cause integer overflow in count_ops?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Complexity Race Condition] Since complexity and count_ops are shared variables across async recursive calls, can two parallel evaluate() branches racing to increment these counters cause one branch to exceed limits while the other succeeds, leading to non-deterministic validation results across nodes?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Formula Complexity Inheritance] When evaluating a 'formula' operator, the formula parser updates complexity and count_ops variables, but does the parent validateDefinition check these updated values against MAX_COMPLEXITY/MAX_OPS again after formula validation returns, or can a formula consume the entire budget leaving no room for outer definition checks?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Async Complexity Check] The complexity check occurs at line 100 before async operations, but if an async operation (e.g., database query for 'definition template') takes long enough for another evaluate() call to increment complexity beyond MAX_COMPLEXITY, can both branches proceed past the check causing total complexity to exceed 2*MAX_COMPLEXITY?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'address' case] [Infinite Loop via Circular References] If address A's definition references address B, and address B's definition references address A (either directly or through a chain), does the evaluate() function detect this cycle before stack overflow, or can an attacker permanently freeze validation by submitting a unit that triggers infinite recursion?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'address' case] [Definition Redefinition Attack] When evaluating an 'address' operator, if the inner address was redefined via definition_chg after the outer definition was created but before last_ball_mci, does the validation use the new or old definition, and can an attacker exploit timing to make a previously-valid outer definition become invalid, permanently freezing funds locked in that definition?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - needToEvaluateNestedAddress()] [Nested Evaluation Skip Bypass] The optimization at lines 88-94 skips evaluating nested addresses if no authentifiers match the path, but can an attacker craft a definition where the skipped nested address contains a complexity bomb that would exceed MAX_COMPLEXITY, allowing the definition to pass validation but fail when actually used with matching authentifiers?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'address' case] [Definition Not Found Race] At lines 715-720, if an inner address definition is not found in storage but is being defined in the current unit, the code filters objUnit.authors for a matching definition, but if multiple authors define the same address with different definitions in the same unit, does the code properly reject this or can it non-deterministically pick one definition?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'address' case] [Path Authentication Bypass] The pathIncludesOneOfAuthentifiers check at line 708 determines if the nested address should be evaluated, but can an attacker provide authentifiers for a parent path that don't match the nested address path, causing the validation to skip signature checks for the nested address entirely?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'definition template' case] [Template Unit Not Stable] The query at lines 293-294 requires the template unit to be stable (is_stable=1), but does this check prevent an attacker from creating a unit that references a template from a unit that appears stable locally but is not stable globally due to network partition, causing different nodes to use different templates?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'definition template' case] [Template Payload Parsing] At line 300, the template payload is parsed with JSON.parse() without validation, so if the template unit contains malformed JSON or non-array template payload, can this cause JSON.parse() to throw an exception that isn't caught, crashing the validation and causing network DoS?",
  "[File: byteball/ocore/definition.js] [Function: replaceInTemplate()] [Parameter Type Confusion] The replaceInVar function at lines 1289-1291 allows params[name] to be string or number, but when replacing a variable in the template, does this preserve type safety? Can an attacker pass a number where a string address is expected, causing validation to incorrectly accept an invalid definition?",
  "[File: byteball/ocore/definition.js] [Function: replaceInTemplate()] [Missing Variable Exception Handling] If a template references a variable name that isn't provided in params, NoVarException is thrown at line 1339, but in validateAuthentifiers() at line 742, is this exception properly caught and converted to a validation failure, or can it bubble up and crash the node?",
  "[File: byteball/ocore/definition.js] [Function: replaceInTemplate() - replaceInVar()] [Nested Object Mutation] The function mutates nested objects in-place at lines 1343-1347 after cloning the template, but if the same template is being evaluated concurrently by multiple units on different validation threads, can race conditions in the cloneDeep or assignField operations cause one evaluation to see partially-mutated template data from another?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'definition template' case] [Template Complexity Accumulation] When replaceInTemplate fills a template and then evaluate() is called recursively on the filled template, does the complexity from evaluating the inner definition get added to the outer definition's complexity counter? If not, can an attacker nest templates to create exponential complexity that bypasses MAX_COMPLEXITY per template?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'sig' case] [Placeholder Signature Acceptance] At line 684, if objValidationState.bUnsigned is true and signature[0] === '-', the signature is accepted without verification, but can an attacker set bUnsigned inappropriately (e.g., through a race condition or by exploiting other validation logic) to bypass signature checks on a real unit?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'sig' case] [Fatal Error Silent Failure] At line 687, if signature verification fails, fatal_error is set but the function returns cb(false) instead of cb(fatal_error), so the error message is stored but not immediately returned; later at line 1318, fatal_error is checked, but can async race conditions cause fatal_error to be overwritten by a later failing signature before line 1318 is reached?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'hash' case] [Hash Preimage Time-of-Check-Time-of-Use] At line 699, the code verifies that the SHA256 hash of assocAuthentifiers[path] matches args.hash, but if assocAuthentifiers is mutable and modified between this check and when arrUsedPaths is verified at line 1320, can an attacker pass validation with one preimage but have a different preimage recorded in arrUsedPaths?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers()] [Unused Authentifiers Check Bypass] At lines 1320-1321, the code checks that all provided authentifiers are used by comparing arrUsedPaths.length with Object.keys(assocAuthentifiers).length, but if an attacker provides duplicate authentifiers at different paths (e.g., 'r.0' and 'r.1' with the same signature), can this cause arrUsedPaths to have fewer unique entries than assocAuthentifiers, allowing unused authentifiers to slip through?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate()] [Path Computation Inconsistency] Throughout the recursive evaluate() function, paths are constructed by concatenating parent path with '.'+index (e.g., lines 600, 620, 640), but if the validateDefinition() and validateAuthentifiers() functions use different path construction logic, can an attacker craft authentifiers that match paths in validateAuthentifiers but not in validateDefinition, bypassing signature requirements?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - getFilterError()] [Private Asset Self-Reference] At lines 52-53, if bAssetCondition is true and filter.asset === 'this asset' and objValidationState.bDefiningPrivateAsset is true, an error is returned, but does this check prevent all forms of circular reference where a private asset condition indirectly references itself through other definitions?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - getFilterError()] [Asset Condition Address Reference] At lines 62-63, asset conditions cannot reference 'this address' or 'other address', but can an attacker use 'definition template' or nested 'address' operators within an asset condition to indirectly reference these special addresses, bypassing the restriction?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Asset Condition Operation Restrictions] Multiple operators (sig, hash, address, in merkle) check bAssetCondition and return errors if true (lines 218-219, 233-234, 250-251, 419-420), but is this list complete? Can an attacker use other operators like 'cosigned by' or 'formula' in an asset condition that shouldn't be allowed, causing non-deterministic asset condition evaluation?",
  "[File: byteball/ocore/definition.js] [Function: evaluateAssetCondition()] [Authentifier Parameter Confusion] At line 582, evaluateAssetCondition calls validateAuthentifiers with address=null and assocAuthentifiers=null, but the bAssetCondition flag is determined at line 1301 by checking if assocAuthentifiers is null; if evaluateAssetCondition is called with non-null assocAuthentifiers by mistake, would this bypass asset condition restrictions?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - determineIfAnyOfAssetsIsPrivate()] [Private Asset Check Race] At lines 80-86, the function queries the database to check if any assets are private, but if an asset's is_private flag is changed between this query and when the definition is actually used, can this cause different nodes to evaluate the same definition differently, leading to consensus failure?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'in data feed' case] [Oracle Address Array Manipulation] At lines 384-388, the function validates that all addresses in arrAddresses are valid and adds complexity for each address, but can an attacker provide the same oracle address multiple times in arrAddresses to either exhaust complexity or cause duplicate database queries, leading to DoS?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'in data feed' case] [Data Feed Value Type Coercion] The commented-out code at lines 864-923 shows complex logic for comparing string vs numeric feed values, but the actual implementation at line 863 calls dataFeeds.dataFeedExists; can an attacker exploit type coercion differences between the old and new implementations by providing feed values that compare differently under string vs numeric comparison?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'in data feed' case] [Min MCI Validation] At line 410-411, if min_mci is provided, it must be a non-negative integer, but is there a maximum value check? Can an attacker set min_mci to a very large value (e.g., Number.MAX_SAFE_INTEGER) that would cause all current data feeds to be excluded, making the condition impossible to satisfy and permanently freezing funds?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'in data feed' case] [Time-of-Check Time-of-Use for Data Feeds] At line 863, dataFeedExists is called with objValidationState.last_ball_mci, but if a new stable ball is added between when objValidationState was captured and when this check executes, can different nodes see different data feed availability, causing non-deterministic validation results?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'in data feed' case] [Feed Name Length DoS] At line 396, feed_name.length is checked against MAX_DATA_FEED_NAME_LENGTH, but is there a check on the number of distinct feed_name values used across all 'in data feed' operators in a single definition? Can an attacker create thousands of 'or' branches each checking a different feed name, causing database index thrashing?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'in merkle' case] [Merkle Proof Missing Authentifier] At lines 929-931, if assocAuthentifiers[path] is missing, the function returns cb(false) without setting fatal_error, but should this be treated as a fatal error like bad signature/hash? Can an attacker exploit this distinction to bypass merkle proof requirements?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'in merkle' case] [Merkle Proof Deserialization Attack] At line 937, serialized_proof is deserialized via merkle.deserializeMerkleProof without validation; if the deserialization function has vulnerabilities (buffer overflow, prototype pollution), can an attacker crash the node or execute arbitrary code by providing a malicious serialized proof?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'in merkle' case] [Merkle Root Collision] At lines 939-942, if the merkle proof is invalid, fatal_error is set, but the code then checks if the merkle root exists in data feeds; if an attacker finds a collision where two different elements produce the same merkle root, can they prove membership of an element not actually in the feed?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'in merkle' case] [Element Format Validation Bypass] At lines 441-442, the element must match a specific regex pattern, but the regex allows many special characters; can an attacker craft an element string that matches the regex but causes injection attacks in downstream systems that use this element (e.g., SQL injection if element is used in queries)?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'in merkle' case] [Negation Restriction] At line 415, 'in merkle' cannot be negated, but the validateDefinition code doesn't enforce this recursively; can an attacker nest 'in merkle' inside a 'not' operator at a different level (e.g., ['not', ['or', [['in merkle', ...], ['other']]]]) to bypass the restriction?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - getFilterError()] [Filter Amount Validation] At lines 66-73, amount, amount_at_least, and amount_at_most are validated as positive integers, but there's no check for maximum values; can an attacker specify amount_at_most as Number.MAX_SAFE_INTEGER, causing arithmetic overflow when summing amounts in the 'sum' operator evaluation?",
  "[File: byteball/ocore/definition.js] [Function: evaluateFilter()] [Input Address Augmentation Missing] At lines 1192-1204, when evaluating inputs, the code expects augmented_input to have an address field, but if augmentMessages() fails to populate this field for some input types, can the filter incorrectly match or skip inputs, causing 'has' operators to return wrong results?",
  "[File: byteball/ocore/definition.js] [Function: evaluateFilter()] [This Address vs Other Address Ambiguity] At lines 1193-1199 and 1219-1225, 'this address' refers to the address parameter passed to validateAuthentifiers, but in nested definitions evaluated via 'address' operator, does 'this address' refer to the outer or inner address? Can an attacker exploit this ambiguity to bypass address-based filters?",
  "[File: byteball/ocore/definition.js] [Function: augmentMessages()] [Input Type Assumption] At lines 1269-1292, the function augments inputs by querying the database for transfer outputs, but if an input.type is explicitly set to something unexpected (not 'issue' or 'transfer'), does the code handle this gracefully? Can an attacker cause inputs to be incorrectly augmented, leading to wrong filter evaluation?",
  "[File: byteball/ocore/definition.js] [Function: augmentMessages()] [Concurrent Augmentation Race] At lines 1141-1146, augmentMessagesAndContinue checks if objValidationState.arrAugmentedMessages exists and skips augmentation if so, but if two parallel evaluation branches both enter augmentMessages simultaneously, can they both proceed to augment, causing duplicate queries and non-deterministic objValidationState.arrAugmentedMessages values?",
  "[File: byteball/ocore/definition.js] [Function: evaluateFilter()] [Message Index vs Payload Index Confusion] Throughout evaluateFilter (lines 1162-1248), the code iterates over objUnit.messages and payload.inputs/outputs, but when accessing augmented_input at line 1191, it uses objValidationState.arrAugmentedMessages[i].payload.inputs[j]; if objUnit.messages contains non-payment messages, does the index alignment break, causing wrong augmented input to be accessed?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'has'/'has one' case] [Op Parameter Handling] At lines 1024-1032, 'has' and 'has one' call augmentMessagesAndEvaluateFilter, but the result is passed to cb(res) without checking the second parameter arrFoundObjects; if evaluateFilter returns true with an empty arrFoundObjects (which shouldn't happen but could due to bugs), would downstream 'has equal' or 'sum' operators mishandle this?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'has equal' case] [Equal Fields Comparison Type Safety] At line 1046, the code compares arrFirstObjects[i][field] !== arrSecondObjects[j][field] for equality, but if one field is a number and the other is a string representation of that number, does JavaScript's !== operator cause false inequality? Can an attacker exploit this to make 'has one equal' return false when it should be true, freezing funds?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'sum' case] [Sum Arithmetic Overflow] At lines 1062-1065, amounts are summed in a regular JavaScript number, but if amounts are very large positive integers near Number.MAX_SAFE_INTEGER, can the sum exceed this limit and wrap around or lose precision, causing 'sum' with equals/at_least/at_most checks to return wrong results?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'has equal'/'has one equal' case] [Search Criteria Asset Privacy] At lines 508-523, the code collects assets from search_criteria filters and checks if any are private, but if filter.asset is 'base' or 'this asset' in an asset condition, the asset is not added to arrAssets; can an attacker craft search_criteria that references private assets indirectly through 'this asset', bypassing the privacy check?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'sum' case] [Sum Mutually Exclusive Constraints] At line 543, the code checks that equals and at_least/at_most are not used together, but there's no check preventing at_least > at_most; if an attacker sets at_least=100 and at_most=50, does the validation accept this impossible constraint, and would evaluation return false or true when sum is in [50, 100]?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'timestamp' case] [Timestamp Comparison Type] At lines 959-970, timestamp comparisons use objValidationState.last_ball_timestamp directly with relation operators, but if last_ball_timestamp is undefined or null (due to validation state initialization bugs), does JavaScript coercion cause unexpected comparison results, making timestamp checks always pass or always fail?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'mci' case] [MCI Boundary Conditions] At lines 973-984, MCI comparisons are performed, but there's no validation that mci (from args[1]) is within a reasonable range; can an attacker specify mci as a negative number or NaN, causing comparison operators to behave unexpectedly and bypassing MCI-based time locks?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'age' case] [Age Calculation Integer Overflow] At line 1013, the SQL query checks if objValidationState.last_ball_mci - age is greater/less than main_chain_index, but if age is negative or extremely large, can this cause integer overflow in SQLite/MySQL, returning wrong results and allowing premature spending of time-locked funds?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'age' case] [Age Source Unit Collection] At lines 1005-1006, the code collects arrSrcUnits only from inputs with input.address === address, but if an attacker transfers funds from address A to address A (self-transfer), does the age check measure the age of the self-transfer unit or the original source unit? Can this be exploited to reset time locks?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'age' case] [Age Query SQL Injection] At line 1013, the SQL query concatenates objValidationState.last_ball_mci - age and relation directly into the query string; if relation comes from untrusted input (which it doesn't in normal flow, but could due to bugs), can an attacker inject SQL to manipulate the age check result?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - augmentMessagesAndContinue()] [Age Evaluation Without Augmentation] At lines 992-1021, the 'age' operator requires augmentMessagesAndContinue to populate input addresses, but if augmentation fails or is skipped due to race conditions, the code at line 1009 checks if arrSrcUnits.length === 0 and returns false; can this cause legitimate age-locked definitions to fail validation non-deterministically?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'seen address' case] [Seen Address MCI Window] At lines 751-758, the query checks for address in unit_authors with main_chain_index <= last_ball_mci and is_stable=1, but if an address was used in an unstable unit that becomes stable right after objValidationState.last_ball_mci is captured, can different nodes see different 'seen address' results, causing consensus divergence?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'seen definition change' case] [Definition Change 'any' Wildcard] At line 770, if new_definition_chash === 'any', the SQL where clause is empty string, matching all definition changes for the address; can an attacker exploit this by creating a definition that checks 'seen definition change' with 'any' and then immediately changing their own definition in the same unit, making the condition trivially true?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'attested' case] [Attestation Oracle Trust] At lines 827-837, the code calls storage.filterAttestedAddresses to check if attested_address is attested by any of arrAttestors, but if the attestation system has vulnerabilities (e.g., attestations can be revoked but are still counted), can an attacker use expired/revoked attestations to bypass attestation requirements?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'seen address' case] [Address Validation Only] At lines 316-321, 'seen address' only validates that args is a valid address, but doesn't check if the address was actually seen; can an attacker create a definition with 'seen address' for an address that never existed, and would this definition pass validation but fail during authentication, permanently freezing funds?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'attested' case] [Attestor Count Limit] At lines 352-356, the code validates that each address in arrAttestors is valid, but there's no limit on arrAttestors.length; can an attacker specify thousands of attestor addresses to cause DoS through excessive database queries when storage.filterAttestedAddresses is called?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'cosigned by' case] [Author Address Lookup Race] At lines 843-845, the code checks if cosigner_address is in objUnit.authors, but if objUnit.authors is modified concurrently (e.g., by another validation thread), can the indexOf check see an inconsistent state, causing non-deterministic cosigner verification results?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'cosigned by' case] [Negation Not Prevented] At line 362, the code checks if bInNegation is true and returns an error for 'cosigned by', but this check is inconsistent with other operators like 'hash' which also can't be negated; can an attacker nest 'cosigned by' in a 'not' at a higher level to bypass the restriction?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'cosigned by' case] [Cosigner Definition Validation] When a cosigner_address is found in objUnit.authors, is the cosigner's own definition validated to ensure the cosigner authorized this unit? If the cosigner is a multi-sig address and only some signers signed, does this count as cosigning, or does the full cosigner definition need to be satisfied?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'not' case] [Fatal Error Propagation in Negation] At line 851, 'not' inverts the result of evaluate(args), but if evaluate(args) sets fatal_error, does cb2(!not_res) propagate this fatal_error correctly, or does the negation logic mask signature/hash verification failures, allowing invalid signatures to be accepted?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'not' case] [Double Negation Complexity] At line 369, 'not' calls evaluate(args, path, true, cb) with bInNegation=true, but if args itself contains another 'not', does bInNegation get set back to false, and does this double-negation consume double complexity? Can an attacker nest many 'not' operators to multiply complexity?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate()] [Negation Path Prefix] Throughout evaluate(), bInNegation is passed recursively but only checked for specific operators (sig, hash, address, in merkle, cosigned by); are there other operators that should not be negatable? Can an attacker negate 'formula' or 'definition template' operators to cause unexpected behavior?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'or'/'and' case] [Signature Count Logic] At lines 124-125, the code counts options_with_sig, and for 'or' returns true only if all options have signatures, while for 'and' returns true if at least one option has signature; but in validateAuthentifiers' evaluate(), 'or' at line 594 returns true if any option is true, while 'and' at line 614 requires all to be true; is this asymmetry between validation and authentication correct, or can it cause definitions that pass validation but always fail authentication?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'or' case] [Short-Circuit Evaluation Prevention] At lines 596-608, the code uses async.eachSeries to evaluate all 'or' options even after one returns true (res = res || arg_res), but the comment at line 603 says 'check all members even if required minimum already found'; is this to prevent timing attacks or signature verification bypass? Can an attacker exploit the fact that all branches are checked to cause DoS via expensive operations in unneeded branches?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'r of set' case] [Required vs Set Length Edge Case] At lines 146-147, required must be <= set.length, but there's a commented-out check at lines 148-151 preventing required === set.length; if required === set.length, doesn't this make 'r of set' equivalent to 'and'? Can an attacker use this to bypass complexity checks that might treat 'and' differently?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'r of set' case] [Required Count Exact Matching] At lines 634-649, the code counts how many set options return true and checks count >= args.required, but validateDefinition at lines 169-170 checks if args.required > count_options_without_sig; if required equals count_options_without_sig + 1, can this create an edge case where validation passes but authentication always fails because not enough options have signatures?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'weighted and' case] [Weight Overflow] At line 195, total_weight accumulates arg.weight for each set element, but if an attacker provides many elements with weight close to Number.MAX_SAFE_INTEGER, can total_weight overflow, causing the check at line 207 (args.required > total_weight) to incorrectly pass?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'weighted and' case] [Weight Accumulation Race] At lines 655-670, weight is accumulated across async operations, and multiple branches may increment weight concurrently; if JavaScript's number addition is not atomic (which it should be, but implementation bugs could exist), can race conditions cause weight to be computed incorrectly?",
  "[File: byteball/ocore/definition.js] [Function: validateDefinition() - evaluate() 'formula' case] [Formula MCI Gate] At line 553, formulas are not allowed before constants.formulaUpgradeMci, but if objValidationState.last_ball_mci is exactly equal to formulaUpgradeMci, are formulas allowed? Can an attacker exploit an off-by-one error in this comparison to use formulas before they should be activated?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'formula' case] [Formula Trigger Data Selection] At lines 1101-1103, the code uses the first 'data' message as trigger.data and ignores subsequent ones, but if an attacker includes multiple data messages in different orders in their unit, can they cause different nodes to pick different data messages if message iteration order is not deterministic?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'formula' case] [Formula Result Type Coercion] At lines 1116-1124, the formula result is coerced to boolean using various checks (typeof === 'boolean', !!result for string, !result.eq(0) for Decimal), but what if the formula returns an object, array, or undefined? Would line 1123 return cb2(false), and is this the correct behavior, or should these be treated as errors?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'formula' case] [Formula Message Augmentation Decision] At lines 1131-1138, augmentMessagesOrIgnore decides whether to augment based on whether the formula contains 'input' (tested via regex /input/.test(formula)), but if the formula is an object or array, does .test() work correctly? Can an attacker craft a formula that uses inputs without triggering augmentation, causing incorrect formula evaluation?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'formula' case] [Formula Address Parameter] At line 1111, the address parameter is passed to formulaParser.evaluate, but in nested address definitions, does 'address' refer to the correct (inner or outer) address? Can an attacker exploit address context confusion in formula evaluation to bypass restrictions?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'has definition change' case] [Definition Change Message Lookup] At lines 1085-1094, the code searches objUnit.messages for 'address_definition_change' messages, but if message.payload is null or undefined, does line 1088 cause an exception? Can an attacker include malformed definition_change messages to crash validation?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'has definition change' case] [Default Address for Definition Change] At line 1092, if message.payload.address is not specified, it defaults to objUnit.authors[0].address, but what if objUnit.authors is empty or authors[0] is undefined? Can this cause an exception or incorrect address comparison?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'has definition change' case] [This Address Resolution Timing] At lines 1081-1084, 'this address' is resolved to the address parameter, but if this evaluation happens inside a nested 'address' operator where address has changed, can the wrong address be used for comparison, causing 'has definition change' to return incorrect results?",
  "[File: byteball/ocore/definition.js] [Function: validateAuthentifiers() - evaluate() 'seen' case] [Seen Input Type Validation] At line 786, the code checks filter.what is 'input' or 'output', but if it's neither (due to validation bypass), line 787 would use an invalid table name in SQL query; is there proper error handling, or would this cause a database exception that crashes the node?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppsDataDir()] [Platform Spoofing] Can an attacker manipulate process.platform to return an unexpected value (e.g., through environment variable injection in Node.js forks or child processes), causing the function to throw an 'unknown platform' error and preventing the application from initializing, resulting in a denial of service that blocks all wallet operations and transaction processing?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppsDataDir()] [Environment Variable Manipulation] If an attacker can control the APPDATA environment variable on Windows systems (e.g., through a malicious installer or privilege escalation), can they redirect the application data directory to an attacker-controlled location, allowing them to replace wallet files, private keys, or database files with malicious versions that could lead to direct theft of funds?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppsDataDir()] [Environment Variable Injection - Linux] On Linux systems, if process.env.HOME is undefined, contains null bytes, or points to a non-existent directory, does the function properly validate this before concatenating '/.config', or could this cause undefined behavior when other modules attempt to access the data directory, potentially preventing wallet.js from loading user wallets and causing permanent freezing of funds?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppsDataDir()] [Path Traversal via Environment] Can an attacker set HOME='/tmp/../../../root' or APPDATA='C:\\\\..\\\\..\\\\Windows\\\\System32' to cause path traversal, allowing the application to read/write files outside the intended user directory, potentially overwriting critical system files or accessing other users' wallet data in multi-user systems?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppsDataDir()] [Symbolic Link Attack] If an attacker creates a symbolic link at the expected APPDATA or HOME/.config location pointing to a sensitive system directory before the application starts, will the application follow the symlink and potentially corrupt system files or expose sensitive data, causing system-wide instability that could halt the node?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppsDataDir()] [macOS Library Path Injection] On macOS, if process.env.HOME contains special characters, whitespace, or path traversal sequences like '../', does the concatenation with '/Library/Application Support' properly sanitize these inputs, or could this result in writing wallet databases to unintended locations where they could be accessed by other users or processes?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppsDataDir()] [Null Byte Injection] If process.env.APPDATA or process.env.HOME contains null bytes (\\\\x00), could this truncate the path string in the underlying filesystem operations, causing the application to write data to an unexpected location (e.g., 'C:\\\\Users\\\\Victim\\\\AppData' becomes 'C:\\\\Users\\\\Victim'), potentially exposing sensitive wallet data to all processes running under that user?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppsDataDir()] [Windows Path Length Limit] On Windows systems with APPDATA paths exceeding 260 characters (MAX_PATH), does the function handle this gracefully, or could this cause file system operations in storage.js, sqlite_pool.js, or wallet.js to fail silently, resulting in users being unable to access their wallets and causing permanent freezing of funds?",
  "[File: byteball/ocore/desktop_app.js] [Function: getPackageJsonDir()] [Infinite Recursion DoS] If the function is called with a start_dir on a deeply nested filesystem path (e.g., 1000+ directories deep) where no package.json exists, will the recursive calls exhaust the call stack, causing a stack overflow that crashes the Node.js process and results in a total network shutdown for that node, preventing it from confirming new transactions?",
  "[File: byteball/ocore/desktop_app.js] [Function: getPackageJsonDir()] [Race Condition in fs.accessSync] Between the fs.accessSync() check at line 19 and the return of start_dir at line 20, can an attacker delete or modify the package.json file (e.g., in a multi-process environment or through filesystem race conditions), causing subsequent require() calls in getAppName() to fail or load malicious JSON, potentially allowing code execution through crafted package.json content?",
  "[File: byteball/ocore/desktop_app.js] [Function: getPackageJsonDir()] [Symbolic Link Directory Traversal] If an attacker places a symbolic link in the directory hierarchy that points to a sensitive system directory (e.g., /etc or C:\\\\Windows\\\\System32), will path.dirname() follow the symlink during recursive traversal, potentially causing the function to return a system directory as the 'app root', leading to conf.js loading configuration from attacker-controlled locations?",
  "[File: byteball/ocore/desktop_app.js] [Function: getPackageJsonDir()] [Root Directory Detection Bypass] On Windows systems with UNC paths (\\\\\\\\server\\\\share) or mounted network drives, does the root detection logic at line 24 correctly handle these paths, or could an attacker craft a path that bypasses the '/' and '\\\\w:[/\\\\]$' checks, causing infinite recursion that exhausts system resources and prevents the node from processing any transactions?",
  "[File: byteball/ocore/desktop_app.js] [Function: getPackageJsonDir()] [TOCTOU Vulnerability] The function uses fs.accessSync() to check file existence, then later getAppName() uses require() to load the same file. Is there proper locking or atomic operations to prevent a Time-of-Check-Time-of-Use (TOCTOU) attack where an attacker swaps package.json between the check and the require(), potentially injecting malicious configuration that could redirect database paths or modify protocol constants?",
  "[File: byteball/ocore/desktop_app.js] [Function: getPackageJsonDir()] [Error Message Information Disclosure] When the function throws 'no package.json found' at line 25, does this error propagate to user-facing interfaces or logs that could expose the complete directory structure being traversed, potentially leaking sensitive information about the system layout to attackers monitoring error logs?",
  "[File: byteball/ocore/desktop_app.js] [Function: getPackageJsonDir()] [Windows Drive Letter Case Sensitivity] The Windows root detection regex at line 24 uses '\\\\w' which matches alphanumeric characters, but does it properly handle edge cases like '\\\\' separators vs '/' separators in mixed paths, or could an attacker craft a path like 'C:/some/path' (forward slash on Windows) that bypasses the root check and causes infinite recursion?",
  "[File: byteball/ocore/desktop_app.js] [Function: getPackageJsonDir()] [Exception Handling During Recursion] If fs.accessSync() throws an exception for reasons other than ENOENT (e.g., EPERM due to permission issues, ELOOP due to symlink loops, or ENAMETOOLONG), the catch block at line 22 treats all exceptions equally. Could this cause the function to incorrectly traverse into restricted directories or miss legitimate package.json files, leading to incorrect app root detection that breaks database initialization in db.js?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppRootDir()] [process.mainModule Undefined] In certain Node.js execution contexts (e.g., REPL, eval(), or when loaded as a library), process.mainModule can be undefined. The function checks for this at line 35 but falls back to __dirname-based logic. Could an attacker deliberately run the application in a context where process.mainModule is undefined and __dirname is inside a deeply nested node_modules, causing the fallback logic to return an incorrect app root that breaks configuration loading in conf.js?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppRootDir()] [mainModule.paths Manipulation] At line 36, the function accesses process.mainModule.paths[0]. If an attacker can manipulate Node.js module resolution paths (e.g., through NODE_PATH environment variable or require() monkey-patching), could they cause paths[0] to point to an attacker-controlled directory, leading to malicious package.json being loaded and potentially allowing code execution through crafted configuration?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppRootDir()] [node_modules Path Splitting Vulnerability] The fallback logic at line 40 splits __dirname by 'node_modules' path separator. On Windows systems, could an attacker create a directory structure like 'C:\\\\malicious\\\\node_modules\\\\subdir\\\\node_modules\\\\ocore' to confuse the split logic, causing arrParts.length to be > 1 and returning 'C:\\\\malicious' as the app root, which might contain malicious configuration files?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppRootDir()] [Non-deterministic Path Resolution] If the application is executed from different working directories or through different symlinks pointing to the same code, will getAppRootDir() return consistent results across all nodes in the network? Non-deterministic app root detection could cause different nodes to load different conf.js configurations, leading to consensus divergence and unintended permanent chain split requiring hard fork.",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppRootDir()] [Cross-Platform Path Separator Issues] The node_modules detection at line 40 uses path.sep which should be platform-aware, but are there edge cases where mixed path separators (/ and \\\\ on Windows) could cause the split to fail, resulting in incorrect app root detection that prevents proper database initialization and causes the node to fail at startup?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppRootDir()] [Electron/Packaged App Context] In packaged Electron applications or Node.js executables created with pkg or nexe, process.mainModule and __dirname may point to unexpected locations (e.g., inside .asar archives or temporary directories). Does the function handle these edge cases correctly, or could this cause the app to fail to locate its data directory, preventing wallet.js from accessing user funds and causing permanent freezing of funds?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppName()] [require() Injection] At line 52, the function uses require(appDir + '/package.json'). If an attacker can control appDir through manipulation of getAppRootDir() logic, could they cause require() to load a malicious JavaScript file disguised as package.json (e.g., package.json.js), leading to arbitrary code execution when the module is required?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppName()] [Package.json Parsing Vulnerability] The function accesses .name property directly without validating package.json structure. If an attacker can replace package.json with a malformed file (e.g., name is an object, array, or contains path traversal sequences like '../../../malicious'), does this cause crashes or allow path traversal in getAppDataDir(), potentially corrupting database files or wallet data?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppName()] [Console.log Information Disclosure] Line 51 logs the app directory to console, which may expose sensitive path information in production environments. If logs are captured by monitoring systems or accessible to attackers through log injection vulnerabilities, could this leak information about system architecture that aids in crafting more sophisticated attacks against the node?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppName()] [Missing Name Field Handling] If package.json exists but doesn't contain a 'name' field, accessing .name at line 52 will return undefined. When this undefined value is concatenated with '/' in getAppDataDir() at line 57, does it create a path like '/path/to/appdata/undefined', potentially causing collisions between different Obyte applications sharing the same data directory and corrupting each other's databases?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppName()] [Special Characters in App Name] If package.json contains a name with special filesystem characters (e.g., '..', '/', '\\\\', ':', '*', '?', '<', '>', '|'), will these be sanitized before being used in path construction at getAppDataDir(), or could this allow path traversal or invalid directory names that cause filesystem operations to fail and prevent the node from storing wallet data?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppName()] [require() Cache Poisoning] Node.js caches required modules in require.cache. If an attacker can cause a malicious package.json to be loaded first, will subsequent calls to getAppName() return the cached malicious name, potentially persisting the attack across multiple module loads and causing persistent corruption of data directory paths?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppDataDir()] [Path Traversal via App Name] At line 57, the function concatenates getAppsDataDir() + '/' + getAppName() without sanitization. If getAppName() returns a value like '../../malicious' (through manipulated package.json), can this cause path traversal out of the intended app data directory, potentially overwriting system configuration files or accessing other users' data in multi-user systems?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppDataDir()] [Directory Existence Validation] The function constructs a path but doesn't verify if the directory exists or is writable. If the directory doesn't exist and subsequent code in storage.js or sqlite_pool.js attempts to write files without checking, could this cause silent failures where wallet data or database updates are lost, leading to permanent freezing of funds when users can't access their updated wallet states?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppDataDir()] [Race Condition in Directory Creation] If multiple Obyte processes or threads call getAppDataDir() simultaneously and attempt to create the directory, is there proper locking to prevent race conditions? Could concurrent directory creation attempts cause filesystem corruption or permission issues that prevent one of the processes from accessing the database, leading to consensus divergence?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppDataDir()] [Permission Issues] If the returned directory path points to a location where the current user doesn't have write permissions (e.g., due to system policy or previous ownership by another user), will the application detect this early and fail gracefully, or will it attempt to write wallet/database files and fail silently, causing permanent data loss?",
  "[File: byteball/ocore/desktop_app.js] [Integration: conf.js] When conf.js uses getAppDataDir() to determine the data directory at startup, if desktop_app.js returns an inconsistent path due to race conditions or environment changes between application restarts, could this cause the node to use different database files on subsequent runs, leading to loss of wallet state and permanent freezing of funds?",
  "[File: byteball/ocore/desktop_app.js] [Integration: db.js/sqlite_pool.js] If the path returned by getAppDataDir() contains non-ASCII characters or special Unicode sequences that SQLite cannot handle, will the database initialization fail silently, causing the node to operate without persistent storage and lose all wallet data on restart, resulting in permanent freezing of funds?",
  "[File: byteball/ocore/desktop_app.js] [Integration: wallet.js] When wallet.js stores private keys in files within the directory returned by getAppDataDir(), if an attacker can manipulate this path to point to a world-readable directory or network share, could private keys be exposed to other users or network attackers, allowing direct theft of funds?",
  "[File: byteball/ocore/desktop_app.js] [Integration: storage.js] If storage.js caches the result of getAppDataDir() at module load time but the underlying environment variables change during runtime (e.g., in long-running processes), could this cause newly created files to go to different locations than expected, fragmenting the database across multiple directories and corrupting the DAG structure?",
  "[File: byteball/ocore/desktop_app.js] [Integration: Multiple App Instances] If a user runs multiple Obyte applications (e.g., light wallet + full node) with different package.json names but the names differ only in case (e.g., 'obyte' vs 'Obyte'), and the filesystem is case-insensitive (e.g., Windows, macOS default), will both apps use the same data directory, causing database corruption and potential double-spending or fund loss?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppsDataDir()] [Uncaught Exception Handling] If process.platform returns an unexpected value due to a Node.js bug or modification, the throw Error at line 11 will create an uncaught exception. Is this exception properly caught by higher-level error handlers, or will it crash the entire Node.js process, causing a denial of service that prevents the node from confirming new transactions?",
  "[File: byteball/ocore/desktop_app.js] [Function: getPackageJsonDir()] [Deep Recursion Memory Exhaustion] Even if stack overflow doesn't occur, can an attacker trigger recursion through hundreds of directories, causing excessive memory allocation for stack frames and path strings, eventually leading to memory exhaustion (V8 heap limit) that crashes the node and causes temporary freezing of network transactions?",
  "[File: byteball/ocore/desktop_app.js] [Function: getPackageJsonDir()] [Circular Symlink Handling] If the filesystem contains circular symbolic links (e.g., dir1 -> dir2 -> dir1), will the recursive traversal detect this and terminate, or will it loop indefinitely, causing 100% CPU usage and denial of service that delays transaction processing for at least 1 hour?",
  "[File: byteball/ocore/desktop_app.js] [Function: getAppRootDir()] [Empty paths Array] If process.mainModule.paths is an empty array, accessing paths[0] at line 36 will return undefined, which is then passed to path.dirname(). Does path.dirname(undefined) throw an exception or return an unexpected value that could cause incorrect app root detection and subsequent configuration loading failures?",
  "[File: byteball/ocore/desktop_app.js] [Global State Consistency] The module exports functions that depend on process.env and process.mainModule, which are global state. If other modules modify these globals (e.g., through monkey-patching or environment manipulation), could this cause non-deterministic behavior where different calls to getAppDataDir() return different values, leading to database corruption?",
  "[File: byteball/ocore/desktop_app.js] [Trust Model: File System Integrity] The module assumes the filesystem is trustworthy and that paths resolved will remain stable. In containerized or virtualized environments where filesystem mounts can change, could runtime changes to the filesystem layout cause the application to lose access to its data directory mid-execution, corrupting partially-written database transactions?",
  "[File: byteball/ocore/desktop_app.js] [Trust Model: Process Environment] The module trusts process.env variables to be benign. In shared hosting or multi-tenant environments, if other processes can modify environment variables of running Node.js processes (e.g., through /proc filesystem manipulation on Linux), could an attacker redirect the data directory to capture wallet files or inject malicious configuration?",
  "[File: byteball/ocore/desktop_app.js] [Trust Model: Node.js Module System] The module assumes require() and the Node.js module system are uncompromised. If an attacker can inject code into Node.js's module resolution path (e.g., through NODE_OPTIONS environment variable or module preloading), could they intercept the require() call at line 52 to inject malicious code that executes with the privileges of the Obyte node?",
  "[File: byteball/ocore/desktop_app.js] [Platform: Windows] On Windows, if the APPDATA variable points to a path with trailing backslashes (e.g., 'C:\\\\Users\\\\User\\\\AppData\\\\'), will the concatenation at getAppDataDir() create double slashes, potentially causing path normalization issues in subsequent filesystem operations that could prevent database writes?",
  "[File: byteball/ocore/desktop_app.js] [Platform: Linux] On Linux systems with HOME pointing to a directory with restricted permissions (e.g., mode 000), will subsequent attempts to create ~/.config/appname fail in a way that prevents the application from starting, causing a denial of service for that user's node and preventing participation in the network?",
  "[File: byteball/ocore/desktop_app.js] [Platform: macOS] On macOS, if the application is run in a sandboxed environment (e.g., Mac App Store sandbox), does the path construction properly handle the redirected Library/Application Support directory, or could sandbox restrictions cause the app to write to temporary locations that are deleted on restart, losing all wallet data?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateDivisiblePrivatePayment()] [Asset validation bypass] Can an attacker submit a private payment with payload.asset that is not exactly HASH_LENGTH (44 characters), bypassing the validation at line 84-85 if the check only validates string length but not actual hash format, potentially causing consensus divergence when different nodes interpret malformed asset IDs differently?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateDivisiblePrivatePayment()] [Empty inputs exploitation] If payload.inputs is an empty array (length 0), does the validation at line 86-87 catch this before the spend proof loop at lines 98-156 attempts to process it, or can an attacker create a private payment with zero inputs that still passes validation and creates outputs, violating balance conservation?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateSpendProofs()] [Spend proof ordering attack] The spend proofs are validated by comparing against database rows ordered by spend_proof at line 142, but the arrSpendProofs array is not explicitly sorted (line 140 is commented out). Can an attacker craft inputs in a specific order such that the spend_proof comparison at lines 147-149 succeeds even with mismatched spend_proofs, allowing unauthorized spending of outputs?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateSpendProofs()] [Issue input spend proof forgery] For issue-type inputs at lines 101-110, the spend_proof is computed from input.amount, input.address, and input.serial_number without verifying these values against any issuer authorization. Can an attacker issue unlimited amounts of a private asset by crafting arbitrary issue inputs with fake serial numbers, causing inflation?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateSpendProofs()] [Transfer input SQL injection] At lines 113-115, the query selects from outputs using input.unit, input.message_index, and input.output_index without validating these are properly escaped integers. Can an attacker inject SQL through malformed input fields to bypass the output existence check or retrieve incorrect output data, leading to spend proof validation bypass?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateSpendProofs()] [Spend proof count mismatch] The validation at line 145-146 checks that rows.length === arrSpendProofs.length, but if a malicious unit stores duplicate spend_proofs in the database (identical spend_proof values), could this check pass while actual input count differs, allowing an attacker to hide extra inputs or outputs?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateSpendProofs()] [Address mismatch in spend proofs] At lines 148-149, both address and spend_proof are compared, but if the database query at line 142 can return rows in different order than arrSpendProofs due to non-deterministic sorting of identical spend_proof values, can this cause valid private payments to fail validation on some nodes but succeed on others, leading to chain split?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateSpendProofs()] [Missing asset check in transfer inputs] When querying outputs at line 114, the query filters by asset (payload.asset), but if a malicious private payment references outputs of a different asset and the spend_proof somehow validates, can this bypass the asset type check and allow cross-asset spending?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateSpendProofs()] [Blinding value tampering] The spend_proof for transfer inputs includes src_output.blinding at line 127, which comes from the database. If an attacker can modify the blinding value in the outputs table (e.g., through a prior race condition), can they generate valid spend_proofs for outputs they don't own, stealing funds?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateDivisiblePrivatePayment()] [Payment validation bypass] After spend proof validation at line 159, the code calls validation.validatePayment() at line 161, but if validatePayment returns success even with input-output balance mismatch (due to bugs in validation.js), can attackers create private payments that inflate asset supply without detection?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [Output insertion race condition] At lines 32-38, outputs are inserted in a loop without transaction isolation guarantees. If two private payments referencing the same unit but different message_index are processed concurrently, can both insert outputs with conflicting output_index values, causing database constraint violations or duplicate outputs?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [Amount overflow in output insertion] The output.amount is parsed with parseInt() at line 36 without bounds checking. Can an attacker specify output.amount as a string exceeding JavaScript's safe integer range (2^53-1), causing parseInt to truncate the value and create outputs with incorrect amounts, violating balance conservation?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [Blinding value validation] Output.blinding is inserted directly into the database at line 36 without validating its format or length. Can an attacker supply malformed blinding values (e.g., non-base64, wrong length) that cause spend_proof mismatches in future transactions, permanently freezing funds?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [Input address resolution SQL injection] At lines 52-54, when arrAuthorAddresses.length > 1, a SQL query is constructed to find the address from outputs. If arrAuthorAddresses contains malicious values (e.g., SQL keywords or quotes), can this enable SQL injection to return arbitrary addresses, allowing unauthorized spending?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [Issue input address defaulting] For issue-type inputs at lines 46-47, if input.address is not provided, it defaults to arrAuthorAddresses[0]. Can an attacker create a multi-author unit where arrAuthorAddresses[0] is a controlled address, allowing them to issue assets on behalf of other co-authors without proper authorization?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [is_unique field manipulation] The is_unique field is set to 1 for stable units and null for unstable units at line 56. If a unit's stability status changes after insertion (e.g., becomes orphaned), does the is_unique field get updated? Can stale is_unique values cause incorrect validation of subsequent transactions?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [Serial number validation bypass] Input.serial_number is inserted at line 64 without validation. Can an attacker specify arbitrary or duplicate serial_numbers for issue-type inputs, creating multiple units that claim to issue the same serial, causing consensus failure when nodes disagree on which issuance is valid?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [Transfer input double-spend prevention] At lines 66-70, the code marks src outputs as spent with is_spent=1, but if the UPDATE query at line 68 uses weak isolation levels, can two concurrent transactions both mark the same output as spent before either commits, allowing a double-spend to succeed?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [Async.series error handling] The arrQueries are executed with async.series at line 72, which stops on first error but doesn't rollback prior queries. If query N fails after queries 1..N-1 succeeded, can this leave the database in an inconsistent state with partial outputs/inputs inserted, corrupting the UTXO set?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [Missing transaction atomicity] The function receives a conn parameter but doesn't verify it's part of a transaction. If called with a non-transactional connection, can the multi-step database operations at lines 32-71 be interrupted mid-execution by crashes or errors, permanently corrupting the database state?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeDivisibleAssetPaymentJoint()] [Parameter validation bypass] At lines 174-186, the function throws errors for incompatible param combinations, but these are thrown synchronously. If a caller wraps this in try-catch and retries with modified params, can they bypass the mutual exclusivity checks and create a payment with both to_address and asset_outputs, causing undefined behavior?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeDivisibleAssetPaymentJoint()] [Empty fee_paying_addresses] The validation at line 189-190 checks for non-empty fee_paying_addresses, but if the array contains empty strings or whitespace, does this pass validation but fail later when trying to select UTXOs, causing transaction composition to stall indefinitely?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeDivisibleAssetPaymentJoint()] [Change address validation] At lines 193-196, the code checks if base_outputs or outputs_by_asset.base contain amount:0 outputs to avoid duplicate change outputs. If an attacker specifies multiple outputs with amount:0 to different addresses, can they bypass this check and cause the change to be split or sent to unintended addresses?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeDivisibleAssetPaymentJoint()] [Base output manipulation] At lines 197-201, arrBaseOutputs is constructed from fee_paying_addresses[0] as change address, then concatenated with params.base_outputs. If params.base_outputs contains an output to fee_paying_addresses[0] with amount > 0, can this create duplicate outputs to the same address, confusing change calculation?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeDivisibleAssetPaymentJoint()] [outputs_by_asset iteration] At lines 208-210, the code iterates over params.outputs_by_asset with 'for (var a in ...)' without hasOwnProperty check. Can an attacker pollute the prototype of outputs_by_asset to inject additional assets, causing unintended asset transfers or fee calculation errors?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Fixed denominations asset bypass] At lines 231-232, if objAsset.fixed_denominations is true, the callback returns an error. However, this check occurs after asset loading. Can an attacker race to issue new units spending fixed-denomination outputs before this check executes, creating invalid transactions that are already broadcast?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Non-transferrable asset definer check] At lines 234-235, for non-transferrable assets, the code checks if params.to_address === objAsset.definer_address OR definer is in arrAssetPayingAddresses. Can an attacker set params.change_address to a different address than definer, causing the change output to violate transferability restrictions and making funds unspendable?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [cosigned_by_definer bypass] At lines 236-237, the check for cosigned_by_definer looks in arrPayingAddresses and params.signing_addresses. If params.signing_addresses is undefined and definer is not in arrPayingAddresses, but definer was added to signing_addresses after this check, can the transaction succeed without definer's signature, violating the cosigning requirement?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Attested addresses check timing] At lines 238-239, if objAsset.spender_attested is true but arrAttestedAddresses.length === 0, an error is returned. However, this check only applies when !conf.bLight. Can light clients compose payments that violate attestation requirements, causing full nodes to reject these units and creating network inconsistency?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Target amount calculation overflow] At line 241, target_amount is calculated by reducing over payment.outputs with accumulator + output.amount. If multiple outputs have amounts near MAX_SAFE_INTEGER, can this sum overflow, causing pickDivisibleCoinsForAmount to select insufficient inputs and create an invalid payment?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Insufficient inputs handling] At lines 246-247, if pickDivisibleCoinsForAmount returns null (insufficient funds), an error with code 'NOT_ENOUGH_FUNDS' is returned. But if arrInputsWithProofs is an empty array (not null), does the code proceed to create a payment with zero inputs, violating balance conservation?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Change calculation underflow] At line 249, change is calculated as total_input - target_amount. If target_amount was inflated due to prior overflow, can change become negative? If JavaScript coerces negative change to a large positive value when compared with 0 at line 250, can this create outputs with astronomical amounts?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Change address validation] At line 251, the change output uses params.change_address without validating it's a valid Obyte address. Can an attacker specify a malformed change_address that passes initial checks but causes unit validation to fail after the unit is composed, wasting fees and locking the UTXO set?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Private asset blinding generation] At lines 254-255, for private assets, blinding is generated with composer.generateBlinding(). If generateBlinding() has weak entropy or collisions, can two outputs have identical blinding values, causing spend_proof collisions that make one output unspendable?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Output sorting non-determinism] At line 256, outputs are sorted with composer.sortOutputs. If this function has non-deterministic behavior (e.g., depends on object iteration order), can different nodes produce different output orderings, causing payload_hash mismatches and validation failures?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Payload hash version handling] At line 265, payload_hash is computed with a version flag based on last_ball_mci >= constants.timestampUpgradeMci. If last_ball_mci is obtained from a stale cache or races with a witness level update, can different nodes compute different payload_hashes for identical payloads, causing unit validation divergence?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Private payload association] At line 270, private_payload is stored in assocPrivatePayloads[objMessage.payload_hash]. If two messages in the same unit have identical payload_hashes (due to hash collision or bug), does the second assignment overwrite the first, causing loss of one private payload and making outputs unspendable?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Spend proofs ordering] At line 268, spend_proofs are mapped from arrInputsWithProofs. If the order of spend_proofs doesn't match the order of inputs in the payload at line 259, can this cause validateSpendProofs() to fail even for valid private payments?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Async.eachSeries error propagation] At lines 225-285, async.eachSeries processes arrAssetPayments sequentially. If an early payment fails but the error callback is delayed (e.g., due to async DB operations), can later payments in the series execute and add messages to the array before the error is detected, creating a partially constructed unit?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks()] [Mutex deadlock] At line 309, a mutex.lock('handleJoint') is acquired. If validation.validate() at line 314 internally acquires the same or a conflicting lock and waits indefinitely, can this cause a deadlock where the combined_unlock at lines 310-313 is never called, freezing all future unit handling?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks()] [Unlock ordering] The combined_unlock function at lines 310-313 calls validate_and_save_unlock() before composer_unlock(). If composer_unlock() holds resources that validate_and_save_unlock() needs to release its mutex, can this incorrect unlock ordering cause resource leaks or corruption?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks().ifOk()] [Validation error not unlocking composer] At lines 315-318, if ifUnitError is triggered, combined_unlock() is called but validation_unlock() is not. If validation.validate() has already acquired validation-internal locks before returning error, can these locks remain held forever, blocking future validations?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks().ifOk()] [Unexpected validation paths throw] At lines 320-330, several unexpected validation outcomes (ifJointError, ifTransientError, ifNeedHashTree, ifNeedParentUnits) throw errors without calling combined_unlock(). Can these thrown errors bypass the unlock, causing permanent mutex locks that halt all transaction processing?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks().ifOk()] [Sequence validation bypass] At lines 334-338, if objValidationState.sequence !== 'good', the unit is rejected. However, if objValidationState.sequence can be manipulated (e.g., through validation.js bugs), can attackers force acceptance of units with bad sequence, allowing double-spends or DAG corruption?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks().ifOk()] [Private payload version mismatch] At line 345, payload_hash is recomputed using objUnit.version !== constants.versionWithoutTimestamp. If objUnit.version was tampered with between composition and validation, can this produce a different payload_hash than the one stored in assocPrivatePayloads at line 270, causing private payload lookup to fail and validation to break?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks().ifOk()] [Message index retrieval failure] At line 346, message_index is obtained via composer.getMessageIndexByPayloadHash(). If this function returns -1 or undefined (e.g., payload_hash not found in unit), does the code handle this gracefully or proceed to create objPrivateElement with invalid message_index, corrupting the database?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks().ifOk()] [PreCommitCallback error handling] At lines 352-359, validateAndSaveDivisiblePrivatePayment is called in preCommitCallback. If this function calls cb(err) but writer.saveJoint at line 378 has already begun committing, can this cause a partial commit where the unit is saved but private payment data is not, making outputs unspendable?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks().ifOk()] [Non-private preCommitCb bypass] At lines 362-366, if not private but callbacks.preCommitCb is defined, it's used as preCommitCallback. If callbacks.preCommitCb fails asynchronously after writer.saveJoint has committed the unit, can this leave the unit in the database without the expected pre-commit side effects?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks().ifOk()] [Light vendor posting failure] At lines 369-376, composer.postJointToLightVendorIfNecessaryAndSave attempts to post to light vendor before saving. If the post succeeds but the save callback is never invoked due to a bug, can this cause light clients to see a unit that full nodes never save, creating network divergence?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks().ifOk()] [SaveJoint error recovery] At line 381, writer.saveJoint calls onDone with err parameter. If err is not null but validation_unlock() and combined_unlock() are called anyway at lines 383-384, can releasing these locks while the unit is in an error state allow other threads to proceed with invalid assumptions about database state?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks().ifOk()] [Private chains construction] At line 385, arrChains is constructed as [[objPrivateElement]] for private payments. If objPrivateElement is undefined due to prior errors in private payload processing, can this pass null or undefined to callbacks.ifOk at line 386, causing downstream errors in payment chain handling?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeMinimalDivisibleAssetPaymentJoint()] [Address validation bypass] At lines 409-412, the function checks for non-empty available_paying_addresses and available_fee_paying_addresses, but doesn't validate these are well-formed addresses. Can an attacker pass invalid addresses that cause composer.readSortedFundedAddresses to return empty arrays even when funds exist, leading to false 'not enough funds' errors?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeMinimalDivisibleAssetPaymentJoint()] [Asset null interpretation] At line 413, composer.readSortedFundedAddresses is called with params.asset, but at line 421, it's called with null for base currency. If params.asset is explicitly null (not undefined), can this be confused with base currency query, causing incorrect UTXO selection?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeMinimalDivisibleAssetPaymentJoint()] [Uncapped asset issuance bypass] At lines 415-418, if arrFundedPayingAddresses is empty but available_paying_addresses.length === 1, the address is used anyway (assumed to be issuing). Can an attacker exploit this special case to issue unlimited amounts of an asset that should be capped by providing a single unfunded address?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeMinimalDivisibleAssetPaymentJoint()] [TYPICAL_FEE constant staleness] At line 404, TYPICAL_FEE is hardcoded to 1000 bytes. If network fee dynamics change (e.g., due to congestion or protocol upgrade), can this constant become too low, causing composeMinimalDivisibleAssetPaymentJoint to underestimate required bytes and compose underfunded transactions that fail validation?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeMinimalDivisibleAssetPaymentJoint()] [Spend_unconfirmed inconsistency] At line 421, spend_unconfirmed defaults to 'own' if not specified, but at line 413 it uses params.spend_unconfirmed || conf.spend_unconfirmed || 'own'. Can this inconsistency cause different UTXO selection for asset coins vs fee coins, leading to situations where asset UTXOs are available but fee UTXOs are not (or vice versa), causing composition to fail unnecessarily?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeMinimalDivisibleAssetPaymentJoint()] [Funded addresses race condition] Between readSortedFundedAddresses calls at lines 413 and 421, the funded status of addresses can change (e.g., due to concurrent transactions). Can this race cause the minimal parameter calculation at lines 424-429 to use stale funded address lists, resulting in composed units that are invalid by the time they're broadcast?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeMinimalDivisibleAssetPaymentJoint()] [Minimal params mutation] At lines 424-429, params is cloned and modified. If the original params object is used elsewhere concurrently (e.g., in a retry loop), can modifications to minimal_params affect the original params through shared object references, causing unintended side effects?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeAndSaveMinimalDivisibleAssetPaymentJoint()] [Callback wrapping overhead] At line 438, getSavingCallbacks wraps params.callbacks. If params.callbacks itself is already a wrapped callback from a prior operation, can deep callback nesting cause stack overflow or make error handling impossible to trace through multiple wrapper layers?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeDivisibleAssetPaymentJoint()] [storage.loadAssetWithListOfAttestedAuthors race condition] At line 228, loadAssetWithListOfAttestedAuthors is called with last_ball_mci. If last_ball_mci advances between when it's captured and when this function executes, can objAsset properties (is_transferrable, cosigned_by_definer, arrAttestedAddresses) reflect a different protocol state, causing validation to pass in composition but fail in validation.validate()?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeDivisibleAssetPaymentJoint()] [inputs.pickDivisibleCoinsForAmount non-determinism] At lines 242-243, pickDivisibleCoinsForAmount is called to select inputs. If this function has non-deterministic UTXO selection (e.g., random tiebreaking), can two nodes composing identical payments select different inputs, causing different unit hashes and breaking synchronization?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks()] [validation.validate assumptions violation] At line 314, validation.validate is called assuming it will eventually call one of the callback functions. If validation.validate can hang indefinitely (e.g., waiting for missing parent units), can the mutex acquired at line 309 remain locked forever, halting all transaction processing on the node?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks()] [writer.saveJoint atomicity] At line 378, writer.saveJoint is expected to atomically save the unit and execute preCommitCallback. If writer.saveJoint has bugs that cause partial saves (e.g., unit saved but preCommitCallback not executed), can this violate the assumption at line 385 that arrChains is valid when callbacks.ifOk is invoked?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeDivisibleAssetPaymentJoint()] [composer.composeJoint paying_addresses union] At line 212, paying_addresses is set to _.union(params.paying_addresses, params.fee_paying_addresses). If these arrays contain duplicate addresses, does the union operation preserve all duplicates or deduplicate them? Can deduplication cause fee calculation errors if the same address is counted twice in one path but once in another?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateDivisiblePrivatePayment()] [validation.initPrivatePaymentValidationState side effects] At line 89, initPrivatePaymentValidationState is called before spend proof validation. If this function modifies global state or database state that affects subsequent spend proof queries at lines 113-115, can this create order-dependent validation results leading to consensus failure?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateDivisiblePrivatePayment()] [validation.validatePayment input/output checks] At line 161, validatePayment is called to check balance conservation. If validatePayment has bugs that allow sum(inputs) < sum(outputs) for private payments (e.g., due to blinding calculations), can attackers inflate asset supply without detection in divisible_asset.js?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks()] [composer.postJointToLightVendorIfNecessaryAndSave light-only assumption] At line 369, postJointToLightVendorIfNecessaryAndSave is called with onLightError callback at line 371. The comment says 'light only', but if a full node accidentally triggers this path, can the error handling at lines 372-375 cause full nodes to skip saving valid units, creating network inconsistency?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSavePrivatePaymentChain()] [Single element assumption] At line 18, there's a comment 'we always have only one element' and the function directly processes arrPrivateElements[0]. If a caller violates this assumption and passes a multi-element array, does the code silently ignore subsequent elements, or can processing only the first element leave the payment chain in an inconsistent state?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeDivisibleAssetPaymentJoint()] [Empty arrAssetPayments] After constructing arrAssetPayments at lines 202-210, if all three conditions (to_address, asset_outputs, outputs_by_asset) somehow result in an empty array, does composer.composeJoint at line 211 handle messages being an empty array, or can this cause it to create a unit with no payment messages, wasting fees?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateDivisiblePrivatePayment()] [Unknown input type handling] At line 135, if input.type is neither 'issue' nor undefined (transfer), the callback returns 'unknown input type: '+input.type. Can an attacker craft an input with a novel type (e.g., 'steal') that passes validation.js checks but is rejected here, causing validation divergence between modules?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateSpendProofs()] [Database query timeout] At lines 141-153, the spend_proofs query doesn't have explicit timeout handling. If the database is under load and the query takes minutes to execute, can this block the validation callback indefinitely, causing all private payment validation to stall and halting the network?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Multiple asset payments failure handling] At line 280, if any asset payment in arrAssetPayments fails (returns err), onDone(err) is called at line 282. But if some messages were already added to the messages array before the error, does composer.composeJoint at line 211 discard these partially-constructed messages, or can they leak into the final unit?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeAndSaveDivisibleAssetPaymentJoint()] [compose_only flag inconsistency] At line 400, if params.compose_only is true, getNonsavingCallbacks is used instead of getSavingCallbacks. Can an attacker set compose_only=false initially, then modify it to true after validation but before saving, causing the unit to skip saving but still consume UTXOs?",
  "[File: byteball/ocore/divisible_asset.js] [Function: composeMinimalDivisibleAssetPaymentJoint()] [Empty available_fee_paying_addresses after filtering] At line 421, if all addresses in available_fee_paying_addresses are unfunded, the callback at lines 422-423 returns an error. But what if the error callback itself throws an exception? Can this cause the entire composition operation to crash without cleaning up locked resources?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks()] [objJoint mutation between validation and saving] Between validation.validate at line 314 and writer.saveJoint at line 378, objJoint is passed to multiple functions. If any of these functions mutate objJoint (e.g., adding timestamps, modifying witnesses), can the saved unit differ from the validated unit, causing hash mismatches?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [is_transferrable change output bypass] At lines 234-235, the code checks that for non-transferrable assets, either to_address is the definer or definer is in paying addresses. But the change output at line 251 goes to params.change_address without checking if it equals definer_address. Can an attacker transfer non-transferrable assets to themselves via change outputs, bypassing transferability restrictions?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [cosigned_by_definer signing_addresses undefined] At line 236, if params.signing_addresses is undefined (not provided), the check arrPayingAddresses.concat(params.signing_addresses || []) effectively only checks arrPayingAddresses. Can an attacker compose a payment without providing signing_addresses, causing the definer cosigning requirement to be under-enforced?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [spender_attested light client bypass] At lines 238-239, the attestation check only runs when !conf.bLight. Can a malicious light client compose and broadcast payments of attested-spender assets without having any attested authors, causing full nodes to reject these units and creating a network split between light and full nodes?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Asset property caching] The objAsset loaded at line 228 is used for validation at lines 231-239. If the asset definition changes between load and validation (e.g., definer changes is_transferrable via protocol upgrade), can stale objAsset properties cause validation to use outdated rules, accepting payments that should be rejected?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [Private asset output visibility] For private assets, outputs are inserted into the outputs table at lines 32-38, but the output.address and output.amount are stored in cleartext. Can observers query the database to deanonymize private payment recipients and amounts, defeating the privacy guarantees of private assets?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [parseInt silent truncation] At line 36, output.amount is parsed with parseInt() without a radix parameter. If output.amount is a string like '1e10' or '0x1000', can parseInt parse it incorrectly (as decimal 1 or hexadecimal 4096), creating outputs with amounts that don't match the intended transfer?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Accumulator overflow in reduce] At line 241, payment.outputs.reduce starts with accumulator:0 and adds output.amount. If output.amount values are near MAX_SAFE_INTEGER and there are multiple outputs, can the accumulator overflow MAX_SAFE_INTEGER without detection, causing target_amount to wrap around and become small, making pickDivisibleCoinsForAmount return insufficient inputs?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Negative change exploitation] At line 249, change = total_input - target_amount. If target_amount > total_input due to bugs in pickDivisibleCoinsForAmount or target_amount calculation, change becomes negative. Does the check at line 250 (change > 0) prevent negative changes from being added as outputs, or can negative values pass through and cause integer underflow in the database?",
  "[File: byteball/ocore/divisible_asset.js] [Function: retrieveMessages()] [Change amount bounds] If change at line 249 is exactly 1 (smallest divisible unit), does this create a valid change output at line 251, or are there minimum output thresholds that cause 1-byte outputs to be rejected, permanently burning the remaining change?",
  "[File: byteball/ocore/divisible_asset.js] [Function: getSavingCallbacks()] [Mutex unlock before validation complete] At lines 335-337, if objValidationState.sequence !== 'good', validation_unlock() is called at line 335 before combined_unlock() at line 336. If validation_unlock() allows other threads to start validating while combined_unlock() is still in progress, can this cause overlapping validation of dependent units, leading to inconsistent validation states?",
  "[File: byteball/ocore/divisible_asset.js] [Function: validateAndSaveDivisiblePrivatePayment()] [TOCTOU in output spending] At lines 66-70, the code checks if type === 'transfer' and then marks outputs as spent. If another transaction spending the same output executes between the check and the UPDATE, can both transactions mark the output as spent, causing a double-spend that both see as valid?",
  "[File: byteball/ocore/enforce_singleton.js] [Global variable tampering] Can an attacker delete or modify `global._bOcoreLoaded` before the singleton check executes, allowing multiple ocore instances to load and potentially causing state divergence in critical modules like event_bus.js, conf.js, or mutex.js, leading to consensus failures or network partition?",
  "[File: byteball/ocore/enforce_singleton.js] [Race condition during module loading] If two separate Node.js threads or worker processes simultaneously require ocore modules before line 7 executes, can both pass the check at line 4 before either sets `global._bOcoreLoaded = true`, resulting in multiple ocore instances that could cause non-deterministic AA execution or main chain calculation divergence?",
  "[File: byteball/ocore/enforce_singleton.js] [Error handling DoS] If an attacker triggers the Error thrown at line 5 during critical operations (e.g., during unit validation or network sync), will the uncaught exception crash the entire node process, causing network-wide transaction delays exceeding 1 hour or enabling a DoS attack against witness nodes?",
  "[File: byteball/ocore/enforce_singleton.js] [Module cache poisoning] Can an attacker manipulate Node.js's `require.cache` to delete or replace the enforce_singleton.js module after initial load, then re-require ocore modules to bypass the singleton check and load duplicate instances that diverge in state (e.g., different witness lists or MC calculations)?",
  "[File: byteball/ocore/enforce_singleton.js] [VM context bypass] If ocore is loaded in multiple Node.js VM contexts (vm.runInNewContext), each context has its own `global` object - does this allow an attacker to instantiate multiple isolated ocore instances that could process the same units differently, causing chain splits when nodes disagree on unit validity?",
  "[File: byteball/ocore/enforce_singleton.js] [Worker thread isolation] In Node.js worker_threads, each worker has a separate `global` object - can an attacker exploit this by loading ocore in multiple workers, causing each worker to maintain divergent DAG state, witness proofs, or AA state variables, leading to inconsistent validation results?",
  "[File: byteball/ocore/enforce_singleton.js] [Cluster fork safety] When using Node.js cluster module, each forked process has its own memory space - does the singleton check prevent accidental ocore duplication within a single process but fail to protect against cross-process state divergence if multiple cluster workers validate the same unit differently?",
  "[File: byteball/ocore/enforce_singleton.js] [Property descriptor attack] Can an attacker use Object.defineProperty to make `global._bOcoreLoaded` non-configurable or read-only before line 7 executes, then attempt to load ocore again, causing the assignment at line 7 to silently fail in strict mode or throw an error in newer Node.js versions?",
  "[File: byteball/ocore/enforce_singleton.js] [Prototype pollution] If an attacker pollutes Object.prototype or global's prototype chain with a `_bOcoreLoaded` property set to false, could this cause the check at line 4 to pass even after legitimate ocore load, allowing duplicate loading that breaks mutex.js lock tracking or event_bus.js listener consistency?",
  "[File: byteball/ocore/enforce_singleton.js] [Delete operator bypass] After ocore loads, can an attacker execute `delete global._bOcoreLoaded` to reset the singleton flag, then re-require any ocore module, successfully loading a second instance that could have different configuration (conf.js) or event listeners (event_bus.js), causing undefined behavior?",
  "[File: byteball/ocore/enforce_singleton.js] [Symbol property bypass] Can an attacker define a Symbol-keyed property on global with a similar name, then manipulate require.cache to load a modified enforce_singleton.js that checks Symbol properties instead of string keys, bypassing the singleton protection entirely?",
  "[File: byteball/ocore/enforce_singleton.js] [Getter/setter manipulation] If an attacker defines a getter for `global._bOcoreLoaded` that always returns false, could this cause the check at line 4 to always pass, allowing infinite ocore re-loading attempts that exhaust memory or create race conditions in critical modules like storage.js or validation.js?",
  "[File: byteball/ocore/enforce_singleton.js] [Frozen global object] If an attacker calls Object.freeze(global) before ocore loads, the assignment at line 7 will fail silently (in non-strict mode) or throw TypeError (in strict mode with line 2's 'use strict') - does this prevent ocore from initializing properly, causing all nodes to fail startup and creating a network-wide outage?",
  "[File: byteball/ocore/enforce_singleton.js] [Sealed global object] If an attacker calls Object.seal(global) before ocore loads and `_bOcoreLoaded` doesn't already exist on global, can the assignment at line 7 fail, preventing the singleton flag from being set and allowing subsequent ocore loads to bypass protection?",
  "[File: byteball/ocore/enforce_singleton.js] [Non-strict mode behavior] Although line 2 declares 'use strict', if a calling module disables strict mode, can the error thrown at line 5 be caught and ignored more easily, or can silent failures in property assignment at line 7 occur without detection?",
  "[File: byteball/ocore/enforce_singleton.js] [Error message information disclosure] The error message at line 5 reveals implementation details ('multiple copies of ocore') and suggests a remediation ('npm dedupe') - could an attacker use this information to infer the system is using npm (not yarn/pnpm), has dependency conflicts, or is running specific Node.js versions, aiding in targeted attacks?",
  "[File: byteball/ocore/enforce_singleton.js] [Timing side-channel] Can an attacker measure the execution time difference between first ocore load (setting `global._bOcoreLoaded`) and subsequent failed loads (throwing error at line 5) to detect whether ocore is already loaded, potentially revealing information about node state or initialization sequence?",
  "[File: byteball/ocore/enforce_singleton.js] [Missing property existence check] The code only checks truthiness of `global._bOcoreLoaded` at line 4 - if an attacker sets this property to a truthy non-boolean value (e.g., object, array, function), could this cause unexpected type coercion issues in other ocore modules that might check this flag?",
  "[File: byteball/ocore/enforce_singleton.js] [Module resolution attack] Can an attacker manipulate NODE_PATH or package.json to cause different versions of ocore to be resolved by different require() calls, with each version having its own enforce_singleton.js that sets the same `global._bOcoreLoaded` flag, creating version conflicts that break protocol compatibility?",
  "[File: byteball/ocore/enforce_singleton.js] [Dependency confusion] If an attacker publishes a malicious 'ocore' package to npm with higher version number, can they bypass the singleton check by having their malicious version loaded first, set `global._bOcoreLoaded = true`, then prevent the legitimate ocore from loading, effectively hijacking the entire node?",
  "[File: byteball/ocore/enforce_singleton.js] [Circular dependency bypass] If an attacker creates circular dependencies between ocore modules that include enforce_singleton.js, could the module loading order cause some modules to load before the singleton check executes, resulting in partial state initialization across multiple instances?",
  "[File: byteball/ocore/enforce_singleton.js] [Module wrapper manipulation] Can an attacker monkey-patch Node.js's internal Module._load or Module.prototype.require functions to intercept the loading of enforce_singleton.js and skip its execution or manipulate the global variable, allowing multiple ocore instances?",
  "[File: byteball/ocore/enforce_singleton.js] [Exception handling bypass] If the error thrown at line 5 is caught by a try-catch block in a parent module (e.g., if conf.js wraps its require in try-catch), could the second ocore instance partially initialize before failing, leaving corrupt global state in mutex.js or event_bus.js?",
  "[File: byteball/ocore/enforce_singleton.js] [Memory exhaustion via error loop] Can an attacker repeatedly attempt to require ocore modules after the singleton check fails, causing the error at line 5 to be thrown thousands of times per second, eventually exhausting memory with error stack traces or overwhelming error logging systems?",
  "[File: byteball/ocore/enforce_singleton.js] [Process exit code manipulation] When the error at line 5 is thrown during node startup and not caught, Node.js will exit with non-zero code - could an attacker exploit this to prevent witness nodes from starting up after legitimate maintenance restarts, causing network instability or transaction processing delays?",
  "[File: byteball/ocore/enforce_singleton.js] [Global namespace pollution] By using a generic property name `_bOcoreLoaded` on the global object without namespacing, could this conflict with other libraries or application code that coincidentally uses the same property name, either causing false-positive singleton detections or allowing bypass if another library sets this property?",
  "[File: byteball/ocore/enforce_singleton.js] [Lack of cryptographic binding] The singleton flag is a simple boolean - can an attacker who gains code execution in the Node.js process trivially set `global._bOcoreLoaded = false` and reload ocore, whereas a cryptographically signed or tamper-evident flag would provide stronger protection?",
  "[File: byteball/ocore/enforce_singleton.js] [Missing module identity verification] The check doesn't verify that the already-loaded ocore is the authentic version - if an attacker loads a malicious ocore fork first that sets `_bOcoreLoaded = true`, will the legitimate ocore check at line 4 pass and fail to load, leaving the system running entirely on malicious code?",
  "[File: byteball/ocore/enforce_singleton.js] [Insufficient error context] The error at line 5 doesn't include details about which module triggered the duplicate load or the call stack - does this make debugging legitimate issues (like accidental duplicate dependencies in package.json) more difficult, potentially causing operators to disable the check entirely?",
  "[File: byteball/ocore/enforce_singleton.js] [No version checking] If an attacker manipulates dependencies to load two different versions of ocore sequentially, the first version sets `_bOcoreLoaded`, then the second version's singleton check passes because it uses the same flag name - could this cause protocol incompatibilities if the two versions have different validation rules or consensus logic?",
  "[File: byteball/ocore/enforce_singleton.js] [Event_bus singleton dependency] Since event_bus.js requires enforce_singleton.js and exports a single EventEmitter instance, if the singleton check fails, could this cause multiple EventEmitter instances to be created across different ocore copies, leading to missed events for critical operations like new unit notifications or MC updates?",
  "[File: byteball/ocore/enforce_singleton.js] [Mutex state divergence] Since mutex.js requires enforce_singleton.js and maintains global lock state in arrQueuedJobs and arrLockedKeyArrays, if multiple ocore instances load, could concurrent transactions acquire the same logical locks in different mutex instances, allowing race conditions in unit composition or AA execution?",
  "[File: byteball/ocore/enforce_singleton.js] [Conf.js configuration inconsistency] Since conf.js requires enforce_singleton.js and loads protocol configuration, if the singleton check is bypassed, could different parts of the application load different configurations (e.g., different witness lists, port numbers, or database paths), causing unpredictable behavior or database corruption?",
  "[File: byteball/ocore/enforce_singleton.js] [Hot reload vulnerability] In development or debugging scenarios where module reloading is used (e.g., nodemon, hot module replacement), does the singleton check prevent legitimate reloads, forcing developers to bypass it, which could accidentally remain disabled in production?",
  "[File: byteball/ocore/enforce_singleton.js] [Container orchestration issues] In containerized deployments where multiple container instances might share volumes or network namespaces, could improper volume mounting cause multiple containers to interfere with each other's `global._bOcoreLoaded` check if somehow sharing Node.js processes?",
  "[File: byteball/ocore/enforce_singleton.js] [Test environment bypass] In unit testing scenarios where tests might need to reload ocore modules with different configurations between tests, does the singleton check force test frameworks to use workarounds (like process forking) that might hide concurrency bugs that only appear in production?",
  "[File: byteball/ocore/enforce_singleton.js] [REPL exploitation] If an attacker gains access to a Node.js REPL session on a running ocore node, can they execute `delete global._bOcoreLoaded` followed by `require('ocore/event_bus')` to load duplicate critical modules, potentially creating parallel event processing pipelines that corrupt state?",
  "[File: byteball/ocore/enforce_singleton.js] [Dynamic import bypass] With ES6 dynamic imports (import() expressions), can an attacker bypass the singleton check if they use import() instead of require(), as these might not trigger the CommonJS require hooks that enforce_singleton.js relies on?",
  "[File: byteball/ocore/enforce_singleton.js] [Subresource integrity missing] The singleton check doesn't verify the integrity (hash) of the loaded ocore modules - if an attacker performs a supply chain attack by modifying ocore files on disk after installation, will the singleton check still pass, allowing compromised code to run?",
  "[File: byteball/ocore/enforce_singleton.js] [Process inspection vulnerability] Can an attacker use Node.js process inspection tools (like node --inspect) to attach a debugger, pause execution at line 4, modify `global._bOcoreLoaded` in the debugger, then resume execution to bypass the singleton check?",
  "[File: byteball/ocore/enforce_singleton.js] [Insufficient startup validation] The singleton check occurs at module load time but doesn't validate that critical subsequent initializations (database connections, network setup, witness list loading) also remain singletons - could an attacker cause multiple initialization attempts that corrupt shared resources?",
  "[File: byteball/ocore/enforce_singleton.js] [Graceful degradation failure] When the error at line 5 is thrown, it provides no graceful degradation or recovery mechanism - if the duplicate load is due to a legitimate bug (like circular dependency resolution order change in a new Node.js version), will the system fail catastrophically with no fallback?",
  "[File: byteball/ocore/enforce_singleton.js] [Global variable tampering] Can an attacker delete or modify `global._bOcoreLoaded` before the singleton check executes, allowing multiple ocore instances to load and potentially causing state divergence in critical modules like event_bus.js, conf.js, or mutex.js, leading to consensus failures or network partition?",
  "[File: byteball/ocore/enforce_singleton.js] [Race condition during module loading] If two separate Node.js threads or worker processes simultaneously require ocore modules before line 7 executes, can both pass the check at line 4 before either sets `global._bOcoreLoaded = true`, resulting in multiple ocore instances that could cause non-deterministic AA execution or main chain calculation divergence?",
  "[File: byteball/ocore/enforce_singleton.js] [Error handling DoS] If an attacker triggers the Error thrown at line 5 during critical operations (e.g., during unit validation or network sync), will the uncaught exception crash the entire node process, causing network-wide transaction delays exceeding 1 hour or enabling a DoS attack against witness nodes?",
  "[File: byteball/ocore/enforce_singleton.js] [Module cache poisoning] Can an attacker manipulate Node.js's `require.cache` to delete or replace the enforce_singleton.js module after initial load, then re-require ocore modules to bypass the singleton check and load duplicate instances that diverge in state (e.g., different witness lists or MC calculations)?",
  "[File: byteball/ocore/enforce_singleton.js] [VM context bypass] If ocore is loaded in multiple Node.js VM contexts (vm.runInNewContext), each context has its own `global` object - does this allow an attacker to instantiate multiple isolated ocore instances that could process the same units differently, causing chain splits when nodes disagree on unit validity?",
  "[File: byteball/ocore/enforce_singleton.js] [Worker thread isolation] In Node.js worker_threads, each worker has a separate `global` object - can an attacker exploit this by loading ocore in multiple workers, causing each worker to maintain divergent DAG state, witness proofs, or AA state variables, leading to inconsistent validation results?",
  "[File: byteball/ocore/enforce_singleton.js] [Cluster fork safety] When using Node.js cluster module, each forked process has its own memory space - does the singleton check prevent accidental ocore duplication within a single process but fail to protect against cross-process state divergence if multiple cluster workers validate the same unit differently?",
  "[File: byteball/ocore/enforce_singleton.js] [Property descriptor attack] Can an attacker use Object.defineProperty to make `global._bOcoreLoaded` non-configurable or read-only before line 7 executes, then attempt to load ocore again, causing the assignment at line 7 to silently fail in strict mode or throw an error in newer Node.js versions?",
  "[File: byteball/ocore/enforce_singleton.js] [Prototype pollution] If an attacker pollutes Object.prototype or global's prototype chain with a `_bOcoreLoaded` property set to false, could this cause the check at line 4 to pass even after legitimate ocore load, allowing duplicate loading that breaks mutex.js lock tracking or event_bus.js listener consistency?",
  "[File: byteball/ocore/enforce_singleton.js] [Delete operator bypass] After ocore loads, can an attacker execute `delete global._bOcoreLoaded` to reset the singleton flag, then re-require any ocore module, successfully loading a second instance that could have different configuration (conf.js) or event listeners (event_bus.js), causing undefined behavior?",
  "[File: byteball/ocore/enforce_singleton.js] [Symbol property bypass] Can an attacker define a Symbol-keyed property on global with a similar name, then manipulate require.cache to load a modified enforce_singleton.js that checks Symbol properties instead of string keys, bypassing the singleton protection entirely?",
  "[File: byteball/ocore/enforce_singleton.js] [Getter/setter manipulation] If an attacker defines a getter for `global._bOcoreLoaded` that always returns false, could this cause the check at line 4 to always pass, allowing infinite ocore re-loading attempts that exhaust memory or create race conditions in critical modules like storage.js or validation.js?",
  "[File: byteball/ocore/enforce_singleton.js] [Frozen global object] If an attacker calls Object.freeze(global) before ocore loads, the assignment at line 7 will fail silently (in non-strict mode) or throw TypeError (in strict mode with line 2's 'use strict') - does this prevent ocore from initializing properly, causing all nodes to fail startup and creating a network-wide outage?",
  "[File: byteball/ocore/enforce_singleton.js] [Sealed global object] If an attacker calls Object.seal(global) before ocore loads and `_bOcoreLoaded` doesn't already exist on global, can the assignment at line 7 fail, preventing the singleton flag from being set and allowing subsequent ocore loads to bypass protection?",
  "[File: byteball/ocore/enforce_singleton.js] [Non-strict mode behavior] Although line 2 declares 'use strict', if a calling module disables strict mode, can the error thrown at line 5 be caught and ignored more easily, or can silent failures in property assignment at line 7 occur without detection?",
  "[File: byteball/ocore/enforce_singleton.js] [Error message information disclosure] The error message at line 5 reveals implementation details ('multiple copies of ocore') and suggests a remediation ('npm dedupe') - could an attacker use this information to infer the system is using npm (not yarn/pnpm), has dependency conflicts, or is running specific Node.js versions, aiding in targeted attacks?",
  "[File: byteball/ocore/enforce_singleton.js] [Timing side-channel] Can an attacker measure the execution time difference between first ocore load (setting `global._bOcoreLoaded`) and subsequent failed loads (throwing error at line 5) to detect whether ocore is already loaded, potentially revealing information about node state or initialization sequence?",
  "[File: byteball/ocore/enforce_singleton.js] [Missing property existence check] The code only checks truthiness of `global._bOcoreLoaded` at line 4 - if an attacker sets this property to a truthy non-boolean value (e.g., object, array, function), could this cause unexpected type coercion issues in other ocore modules that might check this flag?",
  "[File: byteball/ocore/enforce_singleton.js] [Module resolution attack] Can an attacker manipulate NODE_PATH or package.json to cause different versions of ocore to be resolved by different require() calls, with each version having its own enforce_singleton.js that sets the same `global._bOcoreLoaded` flag, creating version conflicts that break protocol compatibility?",
  "[File: byteball/ocore/enforce_singleton.js] [Dependency confusion] If an attacker publishes a malicious 'ocore' package to npm with higher version number, can they bypass the singleton check by having their malicious version loaded first, set `global._bOcoreLoaded = true`, then prevent the legitimate ocore from loading, effectively hijacking the entire node?",
  "[File: byteball/ocore/enforce_singleton.js] [Circular dependency bypass] If an attacker creates circular dependencies between ocore modules that include enforce_singleton.js, could the module loading order cause some modules to load before the singleton check executes, resulting in partial state initialization across multiple instances?",
  "[File: byteball/ocore/enforce_singleton.js] [Module wrapper manipulation] Can an attacker monkey-patch Node.js's internal Module._load or Module.prototype.require functions to intercept the loading of enforce_singleton.js and skip its execution or manipulate the global variable, allowing multiple ocore instances?",
  "[File: byteball/ocore/enforce_singleton.js] [Exception handling bypass] If the error thrown at line 5 is caught by a try-catch block in a parent module (e.g., if conf.js wraps its require in try-catch), could the second ocore instance partially initialize before failing, leaving corrupt global state in mutex.js or event_bus.js?",
  "[File: byteball/ocore/enforce_singleton.js] [Memory exhaustion via error loop] Can an attacker repeatedly attempt to require ocore modules after the singleton check fails, causing the error at line 5 to be thrown thousands of times per second, eventually exhausting memory with error stack traces or overwhelming error logging systems?",
  "[File: byteball/ocore/enforce_singleton.js] [Process exit code manipulation] When the error at line 5 is thrown during node startup and not caught, Node.js will exit with non-zero code - could an attacker exploit this to prevent witness nodes from starting up after legitimate maintenance restarts, causing network instability or transaction processing delays?",
  "[File: byteball/ocore/enforce_singleton.js] [Global namespace pollution] By using a generic property name `_bOcoreLoaded` on the global object without namespacing, could this conflict with other libraries or application code that coincidentally uses the same property name, either causing false-positive singleton detections or allowing bypass if another library sets this property?",
  "[File: byteball/ocore/enforce_singleton.js] [Lack of cryptographic binding] The singleton flag is a simple boolean - can an attacker who gains code execution in the Node.js process trivially set `global._bOcoreLoaded = false` and reload ocore, whereas a cryptographically signed or tamper-evident flag would provide stronger protection?",
  "[File: byteball/ocore/enforce_singleton.js] [Missing module identity verification] The check doesn't verify that the already-loaded ocore is the authentic version - if an attacker loads a malicious ocore fork first that sets `_bOcoreLoaded = true`, will the legitimate ocore check at line 4 pass and fail to load, leaving the system running entirely on malicious code?",
  "[File: byteball/ocore/enforce_singleton.js] [Insufficient error context] The error at line 5 doesn't include details about which module triggered the duplicate load or the call stack - does this make debugging legitimate issues (like accidental duplicate dependencies in package.json) more difficult, potentially causing operators to disable the check entirely?",
  "[File: byteball/ocore/enforce_singleton.js] [No version checking] If an attacker manipulates dependencies to load two different versions of ocore sequentially, the first version sets `_bOcoreLoaded`, then the second version's singleton check passes because it uses the same flag name - could this cause protocol incompatibilities if the two versions have different validation rules or consensus logic?",
  "[File: byteball/ocore/enforce_singleton.js] [Event_bus singleton dependency] Since event_bus.js requires enforce_singleton.js and exports a single EventEmitter instance, if the singleton check fails, could this cause multiple EventEmitter instances to be created across different ocore copies, leading to missed events for critical operations like new unit notifications or MC updates?",
  "[File: byteball/ocore/enforce_singleton.js] [Mutex state divergence] Since mutex.js requires enforce_singleton.js and maintains global lock state in arrQueuedJobs and arrLockedKeyArrays, if multiple ocore instances load, could concurrent transactions acquire the same logical locks in different mutex instances, allowing race conditions in unit composition or AA execution?",
  "[File: byteball/ocore/enforce_singleton.js] [Conf.js configuration inconsistency] Since conf.js requires enforce_singleton.js and loads protocol configuration, if the singleton check is bypassed, could different parts of the application load different configurations (e.g., different witness lists, port numbers, or database paths), causing unpredictable behavior or database corruption?",
  "[File: byteball/ocore/enforce_singleton.js] [Hot reload vulnerability] In development or debugging scenarios where module reloading is used (e.g., nodemon, hot module replacement), does the singleton check prevent legitimate reloads, forcing developers to bypass it, which could accidentally remain disabled in production?",
  "[File: byteball/ocore/enforce_singleton.js] [Container orchestration issues] In containerized deployments where multiple container instances might share volumes or network namespaces, could improper volume mounting cause multiple containers to interfere with each other's `global._bOcoreLoaded` check if somehow sharing Node.js processes?",
  "[File: byteball/ocore/enforce_singleton.js] [Test environment bypass] In unit testing scenarios where tests might need to reload ocore modules with different configurations between tests, does the singleton check force test frameworks to use workarounds (like process forking) that might hide concurrency bugs that only appear in production?",
  "[File: byteball/ocore/enforce_singleton.js] [REPL exploitation] If an attacker gains access to a Node.js REPL session on a running ocore node, can they execute `delete global._bOcoreLoaded` followed by `require('ocore/event_bus')` to load duplicate critical modules, potentially creating parallel event processing pipelines that corrupt state?",
  "[File: byteball/ocore/enforce_singleton.js] [Dynamic import bypass] With ES6 dynamic imports (import() expressions), can an attacker bypass the singleton check if they use import() instead of require(), as these might not trigger the CommonJS require hooks that enforce_singleton.js relies on?",
  "[File: byteball/ocore/enforce_singleton.js] [Subresource integrity missing] The singleton check doesn't verify the integrity (hash) of the loaded ocore modules - if an attacker performs a supply chain attack by modifying ocore files on disk after installation, will the singleton check still pass, allowing compromised code to run?",
  "[File: byteball/ocore/enforce_singleton.js] [Process inspection vulnerability] Can an attacker use Node.js process inspection tools (like node --inspect) to attach a debugger, pause execution at line 4, modify `global._bOcoreLoaded` in the debugger, then resume execution to bypass the singleton check?",
  "[File: byteball/ocore/enforce_singleton.js] [Insufficient startup validation] The singleton check occurs at module load time but doesn't validate that critical subsequent initializations (database connections, network setup, witness list loading) also remain singletons - could an attacker cause multiple initialization attempts that corrupt shared resources?",
  "[File: byteball/ocore/enforce_singleton.js] [Graceful degradation failure] When the error at line 5 is thrown, it provides no graceful degradation or recovery mechanism - if the duplicate load is due to a legitimate bug (like circular dependency resolution order change in a new Node.js version), will the system fail catastrophically with no fallback?",
  "[File: byteball/ocore/event_bus.js] [Module loading] [Singleton bypass] Can an attacker create multiple instances of the event bus by manipulating the global._bOcoreLoaded flag or by loading ocore through different module resolution paths (e.g., symlinks, npm link), causing event handlers to register on different EventEmitter instances and leading to missed critical events like 'mci_became_stable' that could result in consensus divergence?",
  "[File: byteball/ocore/event_bus.js] [Module initialization] [Race condition] If multiple modules simultaneously require event_bus.js before enforce_singleton.js completes execution, can they each create separate EventEmitter instances before the global flag is set, causing event subscribers in some modules to never receive critical events (like 'new_joint' or 'aa_definition_saved'), potentially leading to network halt or fund freezing?",
  "[File: byteball/ocore/event_bus.js] [Singleton enforcement] [Global state pollution] Can an attacker deliberately delete or modify global._bOcoreLoaded after initialization to bypass singleton enforcement on subsequent requires, allowing creation of parallel event buses that cause some nodes to process events (like unit validation or main chain updates) on different timelines, leading to permanent chain split?",
  "[File: byteball/ocore/event_bus.js] [setMaxListeners(40)] [Denial of Service] Can an attacker trigger registration of 40+ event listeners for the same event name (e.g., by creating 40+ wallet instances, AA definitions, or device pairings) to exceed the maxListeners limit set on line 8, causing Node.js to emit warnings, degrade performance, or silently fail to register critical listeners for 'mci_became_stable' events, potentially halting consensus updates for >24 hours?",
  "[File: byteball/ocore/event_bus.js] [setMaxListeners(40)] [Listener exhaustion] If network.js registers listeners for each connected peer and an attacker opens 40+ WebSocket connections, can they exhaust the listener limit for events like 'new_joint' or 'validated-{unit}', preventing legitimate peers from receiving unit broadcasts and causing network partition or transaction delay >1 hour?",
  "[File: byteball/ocore/event_bus.js] [setMaxListeners(40)] [AA cascade DoS] Can an attacker create a chain of 40+ Autonomous Agents where each AA triggers the next via secondary triggers, causing each AA to register listeners on event_bus (e.g., for 'aa_response' or 'aa_execution' events), exceeding the 40 listener limit and blocking new AA executions, potentially permanently freezing funds locked in subsequent AAs?",
  "[File: byteball/ocore/event_bus.js] [setMaxListeners(40)] [Per-event limit bypass] Since the 40 listener limit applies globally to the EventEmitter instance rather than per-event-name, can an attacker register listeners across many different event names (e.g., 'validated-unit1', 'validated-unit2', etc.) to consume the limit, preventing registration of critical single-use listeners like eventBus.once('mci_became_stable') used in wallet operations, causing transaction composition failures?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter memory] [Memory leak] Given that very few places in the codebase call eventBus.removeListener() or removeAllListeners(), can long-running nodes accumulate thousands of orphaned event listeners (e.g., from completed wallet operations using .once(), closed network connections, or finished AA executions), eventually consuming all available memory and causing the node to crash, resulting in network halt?",
  "[File: byteball/ocore/event_bus.js] [Listener registration] [Memory exhaustion] Can an attacker repeatedly trigger operations that register event listeners without cleanup (e.g., by continuously sending trigger units to an AA that registers listeners for oracle data feeds, or by repeatedly initiating device pairing), accumulating listeners until the node runs out of memory and crashes, causing >24 hour network outage for that node?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Listener leak from exceptions] If an event handler throws an exception before completing cleanup (e.g., before calling eventBus.removeListener()), does the listener remain registered forever, and can an attacker repeatedly trigger such exceptions (e.g., by sending malformed units that crash validation handlers) to accumulate leak thousands of listeners and exhaust memory?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Event ordering non-determinism] Since EventEmitter fires listeners in registration order but different nodes may load modules in different sequences (due to filesystem differences, npm version variations, or concurrent requires), can two nodes process the same 'mci_became_stable' event with handlers executing in different orders, leading to non-deterministic state updates (e.g., different AA state variable values) and permanent chain split?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter.emit()] [Race condition with DB commits] When main_chain.js emits 'mci_became_stable' from inside a database transaction (as seen in network.js handler that uses mutex.lock to wait for write completion), can a listener execute before the transaction commits, reading stale data (e.g., old last_ball_mci) and making incorrect decisions like broadcasting invalid witness proofs to light clients, allowing light clients to accept invalid history?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Synchronous emission race] Can multiple modules simultaneously call eventBus.emit() for different events (e.g., 'new_joint' from network.js and 'mci_became_stable' from main_chain.js) in a way that their synchronous handler chains interleave, causing one handler's state modifications (e.g., updating assocUnstableMessages in storage.js) to be visible to another handler mid-execution, leading to inconsistent state and validation errors?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [process.nextTick timing] Some emitters (like storage.js line 939 and main_chain.js line 1635) wrap eventBus.emit() in process.nextTick() to avoid synchronous execution, but others emit directly - can this inconsistency cause timing-dependent bugs where a handler registered for event A expects event B to have already been processed, but due to nextTick delays, event B's handlers haven't run yet, causing incorrect behavior (e.g., wallet composing transaction before AA definition is marked as saved)?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Handler registration timing] If module X emits an event before module Y has loaded and registered its listener, will Y's handler never execute for that emission, and can an attacker exploit this by sending units early in the node startup process (e.g., during catchup) before all handlers are registered, causing some critical validations or state updates to be skipped and allowing invalid units into the DAG?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Reentrancy in event handlers] Can a handler for event A emit event B, whose handler emits event A again, creating a reentrant call chain, and if this happens with critical events like 'mci_became_stable'  'aa_response'  'new_joint'  'mci_became_stable', does this cause stack overflow, infinite loops, or double-processing of the same MCI, leading to node crash or consensus failure?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Recursive event emission] If an AA triggers a secondary AA which triggers the original AA in a cycle, and each trigger emits events like 'aa_request' and 'aa_response', can this create unbounded recursion in event handlers, consuming stack space until the node crashes with 'Maximum call stack size exceeded', causing network halt for that node and potential fund freezing if the AA sequence was part of a withdrawal process?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Stack depth in handler chains] If 40 different modules each register handlers for the same event (approaching the maxListeners limit), and one of these handlers has a bug causing it to run slowly or block, does this cause the entire synchronous handler chain to block, preventing subsequent handlers from executing and causing critical operations (like network unit propagation or consensus updates) to stall for >1 hour?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Uncaught exceptions in handlers] If an event handler throws an uncaught exception, does Node.js's EventEmitter continue executing remaining handlers or stop the chain, and can an attacker craft units that trigger exceptions in early handlers (e.g., validation.js) to prevent later critical handlers (e.g., storage.js, network.js) from executing, causing units to be validated but not stored or broadcast, leading to DAG corruption?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter error event] Does the event bus have a handler for the special 'error' event, and if an emitter calls eventBus.emit('error', err) without a registered handler, will Node.js throw an unhandled error and crash the entire process, and can an attacker trigger this by causing errors in deeply nested operations (e.g., AA formula evaluation errors) to cascade into unhandled 'error' events, causing network-wide node crashes?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Handler exception propagation] When a handler for 'nonfatal_error' itself throws an exception, does this create an error-handling loop or cause the exception to go unhandled, and can an attacker exploit this by triggering scenarios where error handlers fail (e.g., by corrupting the storage layer that error handlers try to log to), causing the node to crash without proper error reporting?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Silent handler failures] If an event handler returns or completes without error but fails to perform its critical operation (e.g., network.js handler for 'new_joint' fails to broadcast due to network partition, or storage.js handler fails to persist due to database lock), does the emitter have any way to detect this failure, or does the system incorrectly assume the event was handled successfully, leading to incomplete state updates and divergence?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Event name typos] Since event names are strings with no compile-time checking, can a typo in event emission or listener registration (e.g., emitting 'mci_became_stabel' instead of 'mci_became_stable', or listening to 'new-joint' vs 'new_joint') cause critical handlers to never execute, and can an attacker exploit this by studying the codebase for such typos to understand which protocol operations will fail, allowing them to craft attacks that exploit the missing functionality?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Dynamic event names] For events with dynamic names like 'validated-{unit}' where {unit} is a unit hash, can an attacker craft unit hashes containing special characters or escape sequences that cause event name collisions or regex injection in handlers that pattern-match event names, potentially allowing one unit's validation event to trigger handlers intended for a different unit?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Event namespace pollution] Can an attacker register listeners for event names they discover through reconnaissance (e.g., by analyzing network traffic, memory dumps, or open-source code) but that are intended to be internal-only, allowing them to observe sensitive events (like 'aa_definition_saved' with private AA logic, 'system_var_vote' with governance data, or unit validation results) and front-run transactions or manipulate protocol behavior?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [mci_became_stable event] If the 'mci_became_stable' event emitted by main_chain.js is dropped, delayed, or processed out of order due to event bus issues (listener limit reached, handler exception, reentrancy), can this cause some nodes to advance their stability point while others don't, leading to disagreement on which units are stable and causing permanent chain split requiring hard fork?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [mci_became_stable duplication] Can the 'mci_became_stable' event be emitted multiple times for the same MCI (e.g., due to reentrancy, retry logic, or database replay), causing handlers to double-process stability updates, potentially double-spending outputs marked as stable, crediting AA state variables twice, or notifying light clients of duplicate stability, leading to fund loss or consensus divergence?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [new_joint event ordering] When multiple 'new_joint' events are emitted rapidly (e.g., during catchup or under high network load), if handlers don't complete before the next emission, can this cause joints to be processed out of topological order (child before parent), breaking DAG invariants like parent existence checks or witness level calculations and causing validation to accept invalid units?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [aa_definition_saved timing] If storage.js emits 'aa_definition_saved' before the database transaction commits (despite the process.nextTick wrapper), can aa_composer.js receive the event and attempt to compose a trigger for the AA before its definition is actually persisted, causing the trigger composition to fail or reference a non-existent AA, potentially freezing funds sent to that AA address?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Module load order dependency] If wallet.js registers a handler for 'mci_became_stable' before network.js does, but wallet's handler expects network to have already notified light clients (which network's handler does), can this ordering dependency cause wallet to proceed with transaction confirmation before light clients are informed, leading to double-spend attempts where the wallet composes a conflicting transaction before light clients see the first one as stable?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Circular event dependencies] Can module A's handler for event X emit event Y, and module B's handler for event Y emit event X, creating a circular dependency that causes infinite event emission loops, stack overflow, or deadlock if handlers acquire locks, and can an attacker trigger this by crafting units that activate both event chains simultaneously (e.g., an AA trigger that also changes an address definition)?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Handler interdependencies] If writer.js emits 'system_var_vote' and multiple handlers (e.g., in arbiter_contract.js and paid_witnessing.js) respond by modifying shared state (like witness lists or payment schedules), but these handlers have implicit ordering requirements not enforced by the event bus, can race conditions cause incorrect state updates, potentially allowing attackers to manipulate witness voting or payment distributions?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Async handler ordering] If a handler for 'new_joint' is async (returns a Promise or uses callbacks) and doesn't block the event emission, can subsequent events be processed before the async handler completes, and can an attacker exploit this by sending a sequence of units where unit B's validation depends on unit A's handler completing, but the event bus processes B's events before A's async handler finishes, causing B to be incorrectly accepted?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Callback hell in handlers] If handlers use nested callbacks (common pattern in the codebase) and one callback fails to execute due to error or timing issue, can this cause partial completion of critical operations like storing a unit but not updating balances, or broadcasting a unit but not marking it as sent, leading to state inconsistencies that allow double-spends or fund freezing?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Promise rejection in handlers] If a handler returns a rejected Promise or throws in an async function, does the EventEmitter handle this gracefully or does it go unhandled, and if unhandled, will Node.js's unhandledRejection event terminate the process (in future Node.js versions), causing unexpected node shutdowns and network halt?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Synchronous handler blocking] If an attacker crafts a unit that causes an event handler to execute a CPU-intensive operation synchronously (e.g., validation of a large multi-sig with 100 signatures, or AA formula with complex cryptographic operations), can this block the entire event loop, preventing all other events from being processed and effectively halting the node for >1 hour?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Event flood DoS] Can an attacker flood the network with units that each trigger multiple event emissions (e.g., a unit with 100 messages each emitting separate events, or units that cascade through AAs triggering 'aa_response' events recursively), overwhelming the event bus and causing the event queue to grow unbounded, exhausting memory and crashing the node?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Handler registration DoS] Can an attacker repeatedly perform actions that register new event listeners (e.g., opening and closing WebSocket connections, creating and destroying wallet instances, or registering and unregistering AA observers) at a rate faster than garbage collection can clean them up, gradually consuming memory until the node crashes, causing >24 hour downtime?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Non-deterministic handler execution] Since JavaScript object property iteration order can vary across Node.js versions (though now standardized to insertion order), and if event bus internals rely on object iteration for any operations, can different Node.js versions process event handlers in different orders, causing non-deterministic state updates and chain split between nodes running different Node.js versions?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Platform-specific timing] Can differences in event loop scheduling between different operating systems (Linux vs Windows vs macOS) cause events wrapped in process.nextTick() to be processed in different orders relative to I/O operations (like database writes), leading to subtle timing-dependent bugs where nodes on different platforms diverge in state (e.g., different AA state variable values after the same triggers)?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Clock skew in event timing] If handlers rely on timestamps (e.g., Date.now()) when processing events, and different nodes have clock skew, can this cause deterministic operations (like AA formula evaluation using `timestamp` keyword) to produce different results on different nodes, leading to state divergence and permanent chain split?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Database transaction boundaries] When events are emitted from inside database transactions (as seen with 'mci_became_stable'), if handlers make additional database queries or modifications, are these guaranteed to see the committed state of the emitting transaction, or can they read uncommitted data or have their changes rolled back if the outer transaction fails, leading to inconsistent state between event bus and database?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Mutex interaction] If a handler acquires a mutex lock (common pattern in validation and storage operations) and then emits another event whose handler also needs that lock, does this cause deadlock, and can an attacker craft units that deliberately trigger such deadlock scenarios to halt validation or storage operations for >24 hours?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Network I/O in handlers] If event handlers perform synchronous network I/O (e.g., broadcasting to peers, querying oracles, or forwarding to hubs), can network latency or timeouts block the event loop, preventing other events from being processed, and can an attacker exploit this by controlling a peer/oracle that responds slowly to specific requests, effectively DoSing the event bus and halting protocol operations?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Light client notification timing] When network.js handles 'mci_became_stable' to notify light clients (via notifyWatchersAboutStableJoints), if the event is processed before the database transaction commits due to race conditions, can light clients be notified of stability before the full node's database actually reflects this, allowing light clients to receive witness proofs for units that the full node might later roll back (if transaction fails), potentially allowing light clients to accept invalid history?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Hub message relay via events] If device.js emits events like 'message_for_light' to be relayed to hub connections, and multiple handlers process the same event for different hubs, can a malicious handler intercept, modify, or drop messages intended for light clients, allowing attackers to censor transactions, feed false data to light wallets, or conduct targeted phishing attacks?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [AA state race conditions] When aa_composer.js emits AA-related events like 'aa_response' or 'aa_definition_saved', if multiple AAs are being triggered simultaneously and their events interleave, can this cause race conditions in reading/writing AA state variables stored in the kvstore, leading to lost updates, incorrect balances, or state corruption that permanently freezes funds locked in affected AAs?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Secondary trigger ordering] When an AA triggers secondary AAs in cascade, and each trigger emits events that spawn new triggers, if the event bus doesn't enforce deterministic ordering of these nested trigger events, can different nodes process the cascade in different orders, causing AAs to see different execution sequences and produce different final states, leading to permanent chain split?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [AA bounce event handling] If an AA execution fails and storage.js needs to emit a 'bounce' event to notify systems to refund inputs, but the event is lost or not handled due to listener limit or handler exception, can this cause the bounce to never be created, permanently locking the user's funds in a failed AA state with no way to recover them?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter instance] [Global state corruption] Since the event bus is a singleton global object, if any module gains the ability to modify its internal state (e.g., through prototype pollution, accessing private properties via Object.getOwnPropertyDescriptor, or exploiting vulnerabilities in Node.js EventEmitter), can an attacker corrupt the listener list, disable specific handlers (like validation or consensus), or inject malicious handlers that steal data or manipulate protocol behavior?",
  "[File: byteball/ocore/event_bus.js] [EventEmitter] [Prototype pollution] Can an attacker exploit JavaScript prototype pollution vulnerabilities in any module that interacts with event_bus to modify EventEmitter.prototype or event bus instance properties, potentially disabling event emission, bypassing security checks in handlers, or injecting code that executes when any event is emitted, allowing complete compromise of the node?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Race Condition] If calcHeadersCommissions() is called simultaneously from multiple main chain stabilization processes (e.g., during rapid block confirmations), can the global max_spendable_mci variable become corrupted or inconsistent, causing duplicate commission distributions or skipped MCIs?",
  "[File: byteball/ocore/headers_commission.js] [Function: resetMaxSpendableMci()] [State Management] If resetMaxSpendableMci() is called during an active calcHeadersCommissions() execution, can this cause max_spendable_mci to be null when the final UPDATE query executes at line 239, resulting in incorrect commission calculations on subsequent invocations?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Reentrancy] If the onDone callback triggers another calcHeadersCommissions() invocation before max_spendable_mci is updated at line 239, can this cause the same MCI range to be processed twice, creating duplicate entries in headers_commission_contributions?",
  "[File: byteball/ocore/headers_commission.js] [Function: initMaxSpendableMci()] [Initialization Race] If initMaxSpendableMci() is called concurrently from multiple threads/processes during node startup, can multiple initializations race and cause max_spendable_mci to be set incorrectly?",
  "[File: byteball/ocore/headers_commission.js] [Function: getWinnerInfo()] [Hash Collision] If two child units produce identical SHA1 hashes when concatenated with their next_mc_unit (line 251), does the sort at line 253 produce deterministic ordering, or could different nodes pick different winners causing a permanent chain split?",
  "[File: byteball/ocore/headers_commission.js] [Function: getWinnerInfo()] [Winner Manipulation] Can an attacker who controls the next_mc_unit selection (by posting a unit at the right MCI) manipulate the SHA1 hash calculation at line 251 to ensure their child unit wins headers commissions from targeted parent units?",
  "[File: byteball/ocore/headers_commission.js] [Function: getWinnerInfo()] [Empty Array] If arrChildren is empty when getWinnerInfo() is called, does the function return undefined, and could this cause a crash or incorrect commission distribution in the calling code at line 145?",
  "[File: byteball/ocore/headers_commission.js] [Function: getWinnerInfo()] [Non-deterministic Sort] If the JavaScript sort function at line 253 is not stable across different Node.js versions or operating systems when hashes are equal, could this cause different nodes to select different winners and diverge?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [SQL Injection] At line 155, strWinnerUnitsList is constructed using db.escape() on unit hashes, but if db.escape() has a bug or doesn't properly handle all edge cases, could an attacker craft a malicious unit hash that breaks out of the SQL string and injects arbitrary SQL?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [MySQL Query Complexity] The MySQL query at lines 31-64 uses a subquery (best_child_sql) that includes SHA1 concatenation and sorting - if an attacker creates thousands of child units for a single parent, could this cause severe performance degradation (>1 day delay) due to O(n) complexity?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Index Usage] The query at lines 41-46 filters by chunits.main_chain_index-punits.main_chain_index<=1 - does this prevent index usage on main_chain_index, causing full table scans that could delay transaction processing for >1 hour when the DAG is large?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Rounding Loss] At line 51, headers commissions are rounded using ROUND() before being summed - if a unit wins commissions from many parent units with small shares (e.g., 1% of 10 bytes = 0.1 bytes), could repeated rounding down cause the winner to lose significant funds compared to rounding after summing?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Precision Mismatch] At lines 181 and 200, JavaScript's Math.round() is used for share calculations (share/100.0) - could floating-point precision errors cause different nodes to calculate slightly different amounts, leading to consensus divergence when spending these outputs?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Share Sum] If earned_headers_commission_recipients has shares that don't sum to exactly 100 (due to manual database manipulation or a bug elsewhere), does line 181 distribute more or less than the full headers_commission, violating balance conservation?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Zero Amount] If rounding at line 181 or 200 produces an amount of 0, is this zero-value entry still inserted into headers_commission_contributions, potentially bloating the database and causing the unit to pay commission to an address that receives nothing?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Transaction Atomicity] The async.series at lines 21-243 performs three separate INSERT/SELECT operations without explicit transaction boundaries - if the node crashes between line 210 (INSERT contributions) and line 221 (INSERT outputs), could headers_commission_contributions have entries without corresponding headers_commission_outputs, breaking the accounting?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Partial Commits] If the database connection is lost between the two UNION ALL queries at lines 32-64, could only the first batch of commissions (single authors) be committed while multi-recipient commissions are lost, causing incorrect distribution?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Duplicate Prevention] At line 48, the query checks that earned_headers_commission_recipients has 0 rows for single-author units - if two calcHeadersCommissions() calls process the same MCI concurrently, could both pass this check and insert duplicate contributions?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Stability Bypass] At lines 39, 44, 45, 63, and 81, the query filters for is_stable=1 - if a bug in main_chain.js marks units as stable prematurely, could commissions be distributed before the units are truly finalized, and could these units later become invalid if they're reorged?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Sequence Filter] The queries use +chunits.sequence='good' and +punits.sequence='good' with a unary + operator - does this force type conversion, and could a unit with sequence='temp-bad' or 'final-bad' bypass this check if the database stores it as an integer?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [MCI Constraint] At line 42, the query requires chunits.main_chain_index-punits.main_chain_index<=1 - if punits is at MCI 100 and chunits is at MCI 102, does this unit fail to receive commission even though it legitimately references the parent, potentially causing commission loss?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Memory Corruption] At lines 88-113, assocChildrenInfosRAM is built from storage.assocStableUnitsByMci - if this in-memory structure is corrupted or stale (e.g., not updated after a reorg), could the commission calculation diverge from the database query result, causing throwError at line 138?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [bFaster Mode Risk] When conf.bFaster is true, the code uses only in-memory data (line 189) without validating against the database - if storage.assocStableUnits is missing entries or has wrong data, could nodes running in bFaster mode distribute commissions incorrectly and diverge from nodes using the database?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [RAM Validation] At lines 128-138, the code validates that assocChildrenInfos matches assocChildrenInfosRAM - if this validation fails, throwError() is called, but this only triggers in non-bFaster mode - could a bug go undetected in production nodes running bFaster=true?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Storage Dependency] At line 88, the code directly accesses storage.assocStableUnitsByMci[since_mc_index+1] - if this property is undefined or null due to a race condition in storage.js, does the filter() call at line 88 throw an exception, crashing the commission calculation?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Genesis Commission Loss] At lines 91-93, if since_mc_index is 0 (genesis), the code returns early without processing commissions - does this mean the genesis unit's headers_commission is permanently lost, and was this intentional or a bug?",
  "[File: byteball/ocore/headers_commission.js] [Function: initMaxSpendableMci()] [Genesis Default] At line 259, if headers_commission_outputs is empty, max_spendable_mci is set to 0 with a comment 'should be -1' - if max_spendable_mci=0 is used in subsequent queries, could this cause the genesis unit (MCI 0) to be reprocessed, creating duplicate entries?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [First Invocation] At lines 15-16, if max_spendable_mci is null, initMaxSpendableMci() is called recursively - if the database has no entries in headers_commission_outputs, max_spendable_mci becomes 0, but does the recursive call at line 16 then process MCI 0 immediately, potentially duplicating genesis commission processing?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Empty Winners] At lines 152-154, if arrWinnerUnits.length is 0 (no valid children found), the code returns early - but could this leave since_mc_index unprocessed, causing the next invocation to skip forward and miss commissions for this MCI?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [MCI Gap Validation] At lines 229-232, the code validates that contributions only exist for since_mc_index+1 (or since_mc_index=0 case) - but if units at multiple MCIs become stable simultaneously, could this validation fail and throw an error, halting commission processing?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Missing Next MC Unit] At lines 97-98, if next_mc_unit_props is not found, throwError() is called - could an attacker craft a DAG structure where a stable unit at MCI X has no corresponding main chain unit at MCI X+1, causing all commission calculations to fail?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Multi-Author Check] At line 47, the MySQL query checks (SELECT COUNT(*) FROM unit_authors WHERE unit=chunits.unit)=1 to identify single-author units - if a unit has 0 authors (which should be impossible but might exist due to a bug), does it fall through to the second UNION query at line 50 and fail to receive commissions?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Recipient Validation] At lines 178-182, objUnit.earned_headers_commission_recipients is accessed without checking if objUnit exists in storage.assocStableUnits - if the winner unit is missing from the in-memory cache, could this cause a null pointer exception?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Share Overflow] If earned_headers_commission_recipients contains a share value >100 (due to database corruption or a bug), does line 181 distribute more than the full_amount, creating inflation?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Address Mismatch] At lines 179-182, the code iterates over objUnit.earned_headers_commission_recipients which comes from in-memory storage - if this differs from the database query result at lines 156-170, could commissions be distributed to wrong addresses?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Primary Key Violation] At line 210, headers_commission_contributions are inserted with PRIMARY KEY (unit, address) - if the same (payer_unit, address) pair appears twice in arrValues (due to a bug in the winner selection), does the INSERT fail, rolling back the entire commission calculation?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Foreign Key Cascade] The headers_commission_contributions table has a FOREIGN KEY to units(unit) - if a payer_unit is somehow deleted or invalidated after being marked stable, could this cause cascading deletes that remove commission records?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Amount Overflow] At lines 182, 202, if full_amount * share / 100.0 exceeds the BIGINT limit (2^63-1), could Math.round() produce an incorrect result or cause the INSERT to fail?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Database Locks] The queries at lines 31-64 and 70-83 perform complex JOINs on units, parenthoods, and unit_authors tables - if these tables are locked by concurrent transactions, could the commission calculation deadlock or timeout, delaying MC stabilization for >1 hour?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Read Skew] Between the SELECT query at lines 70-83 (finding candidate children) and the INSERT query at line 210 (recording winners), could another transaction modify the units or parenthoods tables, causing the commission distribution to be inconsistent with the final DAG state?",
  "[File: byteball/ocore/headers_commission.js] [Function: getMaxSpendableMciForLastBallMci()] [Outdated Value] At line 270, the function returns last_ball_mci - 1 without consulting the current max_spendable_mci - if calcHeadersCommissions() hasn't been called recently, could this return an outdated value, allowing inputs to spend not-yet-distributed commissions?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [SHA1 Availability] The MySQL query at line 28 uses SHA1(CONCAT(alt_child_units.unit, next_mc_units.unit)) for winner selection, while SQLite (lines 69-217) computes SHA1 in JavaScript - could the different implementations (MySQL's native SHA1 vs Node.js crypto.createHash) produce different results for edge case inputs, causing MySQL and SQLite nodes to diverge?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Query Performance] The SQLite code path (lines 70-216) fetches all candidate children into memory and processes them in JavaScript, while MySQL does it in SQL - if there are thousands of children, could the SQLite path use excessive memory or CPU, while MySQL completes quickly, causing SQLite nodes to lag behind?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Unary Plus Operator] At lines 27, 40, 43, 58, 61, 78, 80, the queries use + before column names (e.g., +chunits.sequence) - is this operator handled identically by MySQL and SQLite, or could it cause different type coercion behavior?",
  "[File: byteball/ocore/headers_commission.js] [Function: throwError()] [Browser vs Node] At lines 276-279, throwError() throws an Error in Node.js but emits 'nonfatal_error' in browser environments - if the headers commission calculation runs in a browser context (e.g., light client), could critical errors be silently ignored, corrupting the local state?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Callback Error Propagation] The onDone callback is called at line 243 without any error parameter - if one of the async.series steps fails silently (e.g., database query timeout), could onDone be invoked as if the calculation succeeded, causing main_chain.js to proceed with corrupted commission data?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Query Failure] At lines 66, 212, and 226, database queries invoke callbacks without checking for errors - if a query fails (e.g., due to disk full or syntax error), does the callback execute anyway with undefined or empty results, causing silent corruption?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [SUM Aggregation] At line 222, headers_commission_outputs aggregates amounts using SUM(amount) grouped by (main_chain_index, address) - if the same (MCI, address) pair receives commissions from multiple parent units, is the SUM performed correctly, or could overflow occur for addresses receiving large total commissions?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Cross Join] At line 222, the query uses CROSS JOIN between units and headers_commission_contributions USING(unit) - is this semantically equivalent to INNER JOIN, or could the CROSS JOIN produce cartesian product if USING(unit) doesn't function as expected?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Group By Determinism] At line 224, the GROUP BY aggregates by main_chain_index and address - if the units table has multiple rows with the same unit hash (which should be impossible), could the aggregation be performed multiple times, inflating commission outputs?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Best Child Query] The MySQL query at lines 24-29 selects the 'best child' using SHA1 ordering with LIMIT 1 - if multiple children have identical SHA1 hashes, does LIMIT 1 return a consistent result across queries, or could different executions return different children?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Sequence Filter] At line 27, the best_child_sql filters for sequence='good' - if a unit's sequence changes from 'good' to 'temp-bad' after being selected as best child, could this cause the parent query at line 46 to fail the EXISTS check, skipping commission distribution?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [MCI Distance] At line 27, the best_child_sql requires alt_child_units.main_chain_index-punits.main_chain_index<=1 - if a child is at the same MCI as its parent (distance 0), does it compete for headers commission, and could this cause incorrect commission flows?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Parent Existence] At lines 36 and 54, the queries join parenthoods to connect child and parent units - if a parenthood record exists but the parent_unit is not in the units table (due to data corruption), does the query fail or skip the entry?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Child Multiplicity] If a single child unit references the same parent unit multiple times in the parenthoods table (which should be prevented by primary key but might exist due to bugs), could the child receive the parent's commission multiple times?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Orphan Children] At line 102, the code filters children by checking if parent.unit is in child.parent_units array - if a child has parent_units = null or an empty array, does it fail to receive commissions even though a parenthood record exists?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Storage.assocStableUnits Missing] At line 175, the code accesses storage.assocStableUnits[child_unit] - if this unit was recently marked stable but hasn't been added to the in-memory cache yet, could the access return undefined, causing line 178 to fail?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Author Addresses Missing] At line 185, the code accesses objUnit.author_addresses[0] assuming it exists - if a unit has no authors (which should be impossible), does this throw an exception or insert an undefined address?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [MCI Property] At lines 104-105, the code accesses storage.assocStableUnitsByMci[parent.main_chain_index] and [parent.main_chain_index+1] - if these properties don't exist (e.g., due to archiving or pruning), does the filter() call throw or return empty arrays?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [MCI Increment] At line 19, since_mc_index is set to max_spendable_mci, and the queries filter for main_chain_index>since_mc_index - if max_spendable_mci is updated in another thread between line 19 and the query execution, could the same MCI be processed twice or skipped?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Callback Delay] If the onDone callback at line 243 is invoked after a long delay (e.g., due to system load), could max_spendable_mci become stale, causing the next calcHeadersCommissions() invocation to reprocess the same range?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Early Return] At line 154, if no winners are found, the callback cb() is invoked immediately without updating max_spendable_mci - could this cause max_spendable_mci to remain at the old value, causing the same MCI to be queried repeatedly in an infinite loop?",
  "[File: byteball/ocore/headers_commission.js] [Function: getMaxSpendableMciForLastBallMci()] [Spending Window] At line 270, the function returns last_ball_mci - 1 as the maximum spendable MCI - if a unit at MCI X tries to spend commission outputs from MCI X-1 before calcHeadersCommissions() has processed MCI X-1, could the validation fail even though the commissions are legitimately earned?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [is_spent Flag] The headers_commission_outputs table has an is_spent column but this file never updates it - if commission outputs are spent but is_spent remains 0, could the same commission be spent multiple times in different units?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Output Uniqueness] At line 359 of the SQL schema, headers_commission_outputs has PRIMARY KEY (main_chain_index, address) - if the same address wins commissions from multiple parent units at the same MCI, are the amounts correctly summed at line 222, or could earlier amounts be overwritten?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Next MC Unit Filter] At lines 38 and 56, the queries join next_mc_units with is_on_main_chain=1 and main_chain_index=punits.main_chain_index+1 - if there is no main chain unit at MCI X+1 (e.g., due to a gap or reorg), does the query return no results, causing commissions for MCI X to be permanently lost?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Stability Requirements] At lines 39, 44, 45, 63, and 81, all units must be stable - if a parent unit is marked stable but one of its children is not yet stable, does the child fail to compete for commissions, even though it will become stable later?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Filter Consistency] The SQLite query at line 82 filters chunits.main_chain_index-punits.main_chain_index<=1 but doesn't filter in the parenthoods join - could this allow non-direct children (grandchildren, etc.) to incorrectly appear in the results?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Array Join] At line 210, arrValues.join(', ') creates the INSERT statement - if arrValues contains elements with embedded quotes or special characters (which shouldn't happen but could if unit hashes are malformed), could this break the SQL syntax?",
  "[File: byteball/ocore/headers_commission.js] [Function: getWinnerInfo()] [Array Mutation] At lines 250-253, the function mutates the arrChildren array by adding a hash property and sorting it - if the caller reuses this array, could the mutation cause unexpected behavior in subsequent code?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Map Iteration] At lines 143-149, the code iterates over assocChildrenInfos using for..in - if Object.prototype has been polluted with additional properties (e.g., by malicious npm package), could this cause extra iterations and incorrect commission distribution?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Array Sorting] At lines 132-136, the code sorts children arrays before comparing assocChildrenInfos and assocChildrenInfosRAM - if the sort order is not stable (same hashes produce different orders), could valid data be flagged as inconsistent, triggering throwError unnecessarily?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Deep Equality] At line 128, _.isEqual() performs deep equality checking - if one of the objects contains circular references or special objects (e.g., Buffer), could _.isEqual() behave unexpectedly or cause performance issues?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Error Message] At line 138, if validation fails, throwError() is called with a JSON.stringify() of potentially large objects - could this cause out-of-memory errors if assocChildrenInfos contains thousands of units?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [bFaster Mode Divergence] At lines 114, 189, and 227, the code branches based on conf.bFaster - if different nodes have different bFaster settings, could they calculate different commission distributions, causing consensus divergence?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Storage Mode] At line 23, the code checks conf.storage === 'mysql' - if a node switches storage backends (e.g., migrating from SQLite to MySQL), could the different code paths produce different results for the same inputs?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Validation Skipping] At line 227, validation is skipped when conf.bFaster is true - could this allow bugs in the in-memory data structures to go undetected in production, only to surface later when bFaster is disabled?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Memory Usage] At lines 87-113, the SQLite code path builds assocChildrenInfosRAM entirely in memory from storage.assocStableUnitsByMci - if the DAG has thousands of units at a single MCI, could this consume excessive memory and cause the node to crash?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Query Result Size] At lines 70-83, the SQLite query fetches all children of all parent units at since_mc_index without pagination - if there are millions of parenthood relationships, could the rows array at line 85 exhaust available memory?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Object Accumulation] At lines 142-149, assocWonAmounts accumulates winning amounts for all child units - if the same child unit wins commissions from thousands of parents, could this nested object structure become excessively large?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Loose Equality] At line 122, the code uses !== for comparison - if assocChildrenInfos[payer_unit].headers_commission is a string (due to database query returning strings) while row.headers_commission is a number, could this comparison incorrectly trigger an error?",
  "[File: byteball/ocore/headers_commission.js] [Function: getWinnerInfo()] [Hash Comparison] At line 253, the sort compares string hashes using < operator - is this lexicographic comparison, and could it produce different ordering than numeric comparison if the hashes are interpreted as numbers?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Null vs Zero] At line 259, max_spendable_mci is set to 0 if the query returns null - could downstream code incorrectly treat 0 (genesis) as null (uninitialized), causing logic errors?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Storage Module Race] At lines 88-113, the code relies on storage.assocStableUnitsByMci being populated correctly - if storage.js has a bug that causes units to be missing or incorrectly indexed, could commission calculation fail or distribute to wrong addresses?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Database Query Builder] The code uses conn.query() and conn.cquery() without validating the connection state - if the database connection is closed or broken, do these queries throw exceptions, silently fail, or hang indefinitely?",
  "[File: byteball/ocore/headers_commission.js] [Function: throwError()] [Event Bus Dependency] At line 274, throwError() requires event_bus.js - if this module fails to load or the event bus is not initialized, could the error handling itself crash?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Zero Commission] If a parent unit has headers_commission=0 (e.g., a free unit), is it still processed by the queries at lines 31-64, wasting resources, or is there early filtering to skip zero-commission units?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Negative MCI] If since_mc_index is somehow negative (due to a bug in initialization), could the queries at lines 41, 59, 79, 223 return incorrect results or cause database errors?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Large MCI Gap] If max_spendable_mci is 100 but the next stable MCI is 200 (due to network issues causing a long delay), does calcHeadersCommissions() process all 100 MCIs in a single invocation, potentially causing timeout or excessive resource usage?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Index Selection] At line 222, the query joins units and headers_commission_contributions using CROSS JOIN USING(unit) - does the query optimizer use the proper index, or could this cause a full table scan on the units table?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Subquery Performance] The MySQL query at line 46 uses a subquery (best_child_sql) in the WHERE clause - is this subquery executed once per row, causing O(n) complexity, or is it optimized to execute once and cached?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [UNION ALL Cost] At lines 32-64, the query uses UNION ALL to combine single-author and multi-author commissions - if the database doesn't optimize this correctly, could both branches scan the same tables, doubling query time?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Callback Order] The async.series at line 21 executes three steps sequentially - if step 2 (line 219) or step 3 (line 237) is slow, could this delay the onDone callback, blocking main chain stabilization and causing transaction delays >1 hour?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Missing Callback] At line 66, the MySQL query callback invokes cb() without parameters - if the calling code in async.series expects an error parameter, could null/undefined be misinterpreted?",
  "[File: byteball/ocore/headers_commission.js] [Function: calcHeadersCommissions()] [Early Exit] At line 16, if max_spendable_mci is null, initMaxSpendableMci() is called with a callback that recursively calls calcHeadersCommissions() - could this recursion cause stack overflow if there are many rapid invocations?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validatePrivatePayment()] [Spend Proof Bypass] If an attacker crafts two private payments with identical spend_proof values but different input amounts by manipulating the blinding factor, can they bypass the spend proof uniqueness check in the spend_proofs table and double-spend the same output in different private payment chains?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validatePrivatePayment()] [Address Mismatch] In the spend proof validation at lines 35-38, if objPrevPrivateElement.output.address differs from the spend_proof_address, the function returns an error. Can an attacker bypass this by providing a crafted objPrevPrivateElement with a matching address but invalid output data, allowing unauthorized spending?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validatePrivatePayment()] [Input Unit Inclusion] The validateSourceOutput() function at lines 44-52 checks if input.unit is included before objPrivateElement.unit. Can an attacker exploit a race condition where they submit a private payment referencing an input unit that gets orphaned after validation but before storage, causing permanent fund loss?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validatePrivatePayment()] [Light Client Bypass] At line 45, if conf.bLight is true, the function skips the graph.determineIfIncluded() check. Can a malicious light client vendor return false linkproofs, allowing the client to accept private payments with input units that are not actually included in the DAG?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validatePrivatePayment()] [Output Hash Collision] At lines 72-73, the function validates that objectHash.getBase64Hash(objPrivateElement.output) matches our_hidden_output.output_hash. Can an attacker find a SHA256 collision or exploit hash truncation to create two different outputs with the same output_hash, allowing them to substitute recipient addresses?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validatePrivatePayment()] [Serial Number Reuse] For issue inputs at lines 130-142, the spend_proof includes serial_number to prevent duplicates. If max_issued_serial_number is not properly incremented atomically, can two concurrent issuances use the same serial_number, creating duplicate spend proofs and breaking uniqueness?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validatePrivatePayment()] [Author Verification Bypass] At line 146, the function checks if input_address is among unit authors. Can an attacker exploit multi-authored units by providing an input_address that matches one author while using signatures from different authors to bypass ownership checks?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validatePrivatePayment()] [Amount Substitution] In the spend proof calculation at lines 105-113 for transfers, the amount comes from prev_hidden_output.amount. Can an attacker manipulate objPrevPrivateElement to provide a false amount, creating a spend proof that validates but represents incorrect value, leading to inflation?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: parsePrivatePaymentChain()] [Chain Integrity] The function validates chains in reverse chronological order (line 171). If an attacker provides arrPrivateElements with elements out of order or with broken references, can they cause the chain validation to pass incorrectly, allowing invalid payment chains to be accepted?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: parsePrivatePaymentChain()] [Asset Consistency] At lines 189-192, the function checks that all elements have the same asset and denomination. Can an attacker exploit a race condition where they modify the issuePrivateElement after initial validation but before chain validation completes, causing mixed-asset chains?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: parsePrivatePaymentChain()] [Reference Validation] Lines 196-201 verify that each element correctly references the previous element's unit, message_index, and output_index. Can an attacker create a circular chain where element A references B, B references C, and C references A, causing infinite loops or validation bypass?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: parsePrivatePaymentChain()] [Stability Flag Manipulation] The function sets objPrivateElement.bStable based on validation results (lines 206-209). If an unstable private payment later becomes stable, but the chain was already processed as unstable, can this cause inconsistent is_serial flags and allow double-spending?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validateAndSavePrivatePaymentChain()] [Atomic Insertion] At lines 237-249, inputs are inserted with INSERT IGNORE. If two concurrent transactions try to insert the same input (double-spend attempt), can both pass the INSERT IGNORE without detecting the conflict, allowing the double-spend to be stored?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validateAndSavePrivatePaymentChain()] [is_unique Flag Race] Lines 235 and 252 set is_unique and is_serial to NULL for unstable units. Can an attacker exploit the window between validation and stability update to spend an output twice: once while unstable (is_unique=NULL) and again after it becomes stable (is_unique=1)?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validateAndSavePrivatePaymentChain()] [Output Update Condition] At line 271, outputs are updated with WHERE is_spent=0. If an output was already marked as spent by a concurrent transaction, this update will fail silently. Can this cause outputs to remain hidden (address/blinding not revealed) and become permanently unspendable?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validateAndSavePrivatePaymentChain()] [Change Output Marking] At line 266, is_spent is set to 1 for all outputs except the final one (i===0). Can an attacker manipulate the array order to mark the wrong output as unspent, freezing funds in change outputs?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: validateAndSavePrivatePaymentChain()] [Query Array Execution] The function builds arrQueries and executes them with async.series at line 275. If one query fails partway through, are the previous queries rolled back, or can partial state be committed to the database causing corruption?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: updateIndivisibleOutputsThatWereReceivedUnstable()] [Recursive Update Loop] The goUp() function at lines 321-362 recursively traverses the chain upward. Can an attacker create a very deep chain (thousands of transfers) that causes stack overflow or excessive recursion, crashing nodes that try to update stability?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: updateIndivisibleOutputsThatWereReceivedUnstable()] [Sequence Check] At lines 348-349, the function throws an error if is_serial=1 but sequence!='good'. Can this be triggered by a valid unit with sequence='temp-bad' that later becomes 'good', causing nodes to crash during stability updates and preventing network progression?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: updateIndivisibleOutputsThatWereReceivedUnstable()] [is_serial Flag Override] At lines 354-355, if a parent output is non-serial (sequence!='good'), the function sets is_serial=0 for the entire chain. Can an attacker exploit this by creating one bad unit in a chain to mark all descendant outputs as non-serial, preventing legitimate transfers?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: updateIndivisibleOutputsThatWereReceivedUnstable()] [Index Hint SQLite] At line 307, the query uses 'INDEXED BY outputsIsSerial' for SQLite. If this index is missing or corrupted, will the query fail or perform a full table scan? Can an attacker cause index corruption to DoS the stability update process?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: updateIndivisibleOutputsThatWereReceivedUnstable()] [Multiple Input Assumption] At lines 329-332, the function throws an error if it finds 0 or >1 inputs. Can an attacker craft a unit with multiple inputs spending different outputs of the same message to bypass this check and corrupt the stability tracking?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: updateIndivisibleOutputsThatWereReceivedUnstable()] [Root Detection] At line 334, reaching the root (src_unit === null) causes the function to return early. Can an attacker forge a unit with src_unit=null that's not actually an issue transaction, tricking the update logic into treating transfers as issues?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: updateIndivisibleOutputsThatWereReceivedUnstable()] [Concurrent Update Race] The function is called within updateIndivisibleOutputsThatWereReceivedUnstable but modifies database state. If two nodes update the same unstable output simultaneously, can they set different is_serial values causing network divergence?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Amount Validation] At lines 379-380, the function throws an error if amount is not a positive integer. But what if amount is a very large number (near MAX_SAFE_INTEGER)? Can accumulated_amount overflow when adding multiple coins, wrapping to negative and bypassing the sufficient funds check?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Confirmation Condition Injection] At lines 391-402, the confirmation_condition is built using string concatenation with last_ball_mci. Can an attacker provide a malicious last_ball_mci value that injects SQL, bypassing security checks or extracting sensitive data?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Spend Unconfirmed 'own' Logic] At lines 395-400, the 'own' mode allows spending unconfirmed outputs from my_addresses or shared_addresses. Can an attacker who compromises a shared_address spend unconfirmed outputs from that address multiple times before any transaction confirms?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Denomination Selection] The query at lines 432-434 orders by denomination DESC. Can an attacker manipulate denominations to cause the function to always pick the largest denomination, creating excessive change outputs and bloating the chain?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Output ID Exclusion] At line 433, outputs are excluded using 'output_id NOT IN(?)'. If arrOutputIds becomes very large (thousands of entries), can this cause database query performance degradation or timeout, causing DoS?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Unstable Contradiction Check] At lines 442-443, the function throws an error if a row is marked unstable but spend_unconfirmed='none'. Can this condition ever be triggered in production, and if so, does it crash the node or just fail the transaction?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Change Amount Calculation] At lines 451-454, if row.amount > remaining_amount + tolerance_plus, change is calculated. Can an attacker provide tolerance_plus values that cause the Math.floor calculation to underflow, creating more outputs than inputs and inflating supply?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Spend Proof Private Asset] At lines 466-474, spend proofs are created for private assets. If row.blinding is NULL or invalid, will objectHash.getBase64Hash() produce deterministic but incorrect spend proofs, allowing duplicate spend proofs from different outputs?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Message Limit] At line 487, the function returns an error if arrPayloadsWithProofs.length >= constants.MAX_MESSAGES_PER_UNIT - 1. Can an attacker force this condition by using minimum denomination coins, causing all legitimate large payments to fail?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Accumulated Amount Check] At line 485, the function checks if accumulated_amount is within tolerance. Can an attacker exploit precision loss in floating-point arithmetic (if any) to make this check pass with insufficient funds?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: pickIndivisibleCoinsForAmount()] [Auto-Destroy Filtering] At lines 575-579, if objAsset.auto_destroy is set, the definer_address is removed from spendable addresses. Can an attacker exploit this to permanently lock funds in the definer_address by setting auto_destroy after issuance?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: issueNextCoin()] [Cap Enforcement] At line 505, the can_issue_condition checks 'max_issued_serial_number=0' for capped assets. Can an attacker issue coins with serial_number=0 multiple times if the UPDATE at line 522 fails to execute, bypassing the cap limit?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: issueNextCoin()] [Serial Number Increment Race] At lines 518-522, serial_number is set to max_issued_serial_number+1, then the database is updated with max_issued_serial_number=max_issued_serial_number+1. Can two concurrent issuances both read the same max value and increment to the same serial_number, creating duplicate serials?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: issueNextCoin()] [count_coins Validation] At lines 515-516, the function throws an error if !!row.count_coins !== !!objAsset.cap. Can an attacker manipulate asset definitions to have mismatched cap and count_coins values, causing issuance failures that lock the asset?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: issueNextCoin()] [Issue Amount Overflow] At line 520, issue_amount = count_coins_to_issue * denomination. For large denominations or count_coins values, can this multiplication overflow causing wrapping to small or negative values, allowing massive inflation?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: issueNextCoin()] [Issuer Address Determination] At line 504, issuer_address is determined based on issued_by_definer_only. Can an attacker provide arrAddresses[0] as a malicious address when issued_by_definer_only=false, issuing coins to themselves instead of the legitimate definer?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: issueNextCoin()] [Denomination Floor Division] At lines 519 and 535, Math.floor is used with division. Can an attacker provide tolerance_plus values that cause rounding errors, issuing more coins than requested and exceeding caps?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: issueNextCoin()] [Spend Proof Serial Collision] At lines 548-554, the spend proof for issue includes serial_number to avoid duplicates. But if two different denominations have the same serial_number (issued in parallel), can they produce duplicate spend proofs?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: issueNextCoin()] [Recursive Issuance Loop] At line 567, after issuing, the function calls pickNextCoin again. Can an attacker craft inputs that cause infinite recursion between pickNextCoin and issueNextCoin, causing stack overflow and node crash?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: buildPrivateElementsChain()] [Output Hiding] At lines 608-612, hidden_payload is created by deleting address and blinding from outputs. Can an attacker provide a payload where some outputs already lack these fields, causing inconsistent hidden payloads that don't match stored output_hash values?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: buildPrivateElementsChain()] [Input Query Single Row Assumption] At lines 631-634, the function throws an error if in_rows.length !== 1. Can an attacker craft a unit with 0 inputs or multiple inputs that causes this error, preventing legitimate chain reconstruction and freezing private funds?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: buildPrivateElementsChain()] [Asset Mismatch Detection] At lines 638-641, the function validates asset and denomination match. Can an attacker exploit a race condition where asset properties are modified between chain elements, causing validation to pass but creating invalid chains?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: buildPrivateElementsChain()] [Multi-Author Address Injection] At lines 652-653, if count_authors > 1, input.address is added to the input object. Can an attacker manipulate unit authorship to inject arbitrary addresses into inputs, bypassing ownership checks?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: buildPrivateElementsChain()] [Output Index Consistency] At line 668, the function looks for output where o.output_index === _output_index. If outputs are not properly ordered or have gaps in output_index, can this cause output.address to remain unset (line 677) and throw an error, blocking valid chain reconstruction?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: buildPrivateElementsChain()] [Recursion Depth] The readPayloadAndGoUp function calls itself recursively at line 694. For very long chains (thousands of transfers), can this exceed JavaScript's call stack limit causing uncaught exceptions and node crashes?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: buildPrivateElementsChain()] [Array Push Order] At line 691, new elements are pushed to arrPrivateElements. If the chain traversal encounters branching (multiple paths), can elements be added in the wrong order causing validation failures?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeIndivisibleAssetPaymentJoint()] [Parameter Validation] At lines 709-712, the function checks for mutually exclusive parameters (to_address/amount vs asset_outputs). Can an attacker provide both sets of parameters with conflicting values, causing undefined behavior in payment composition?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeIndivisibleAssetPaymentJoint()] [Base Output Construction] At line 715, arrBaseOutputs starts with a 0-amount output to fee_paying_addresses[0]. Can an attacker manipulate this to create dust outputs or outputs with invalid amounts that violate validation rules?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeIndivisibleAssetPaymentJoint()] [Address Union] At line 719, paying_addresses and fee_paying_addresses are unioned. Can an attacker provide overlapping addresses that cause double-counting of available funds or unexpected signing requirements?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeIndivisibleAssetPaymentJoint()] [Asset Loading Race] At lines 730-732, storage.loadAssetWithListOfAttestedAuthors is called. Can an attacker submit transactions while asset properties are being modified, causing non-deterministic behavior based on timing?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeIndivisibleAssetPaymentJoint()] [Transferability Check] At line 735, the function checks if asset is transferrable and definer_address is present. Can an attacker bypass non-transferrable restrictions by using multi-authored units where definer_address is among paying_addresses but not signing?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeIndivisibleAssetPaymentJoint()] [Cosign Requirement] At line 737, if cosigned_by_definer is set, definer_address must be in paying or signing addresses. Can an attacker compose a valid payment without the definer's signature by manipulating the signing_addresses array?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeIndivisibleAssetPaymentJoint()] [Attestation Bypass] At lines 739-740, the function checks spender_attested. Can an attacker who obtained attestation for one address use that attestation to spend from other addresses in a multi-authored unit?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeIndivisibleAssetPaymentJoint()] [Private Output Hash] At lines 762-764, output_hash is calculated for private assets. If the output.address or output.blinding contains special characters or null bytes, can this produce colliding hashes allowing output substitution?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeIndivisibleAssetPaymentJoint()] [Payload Hash Timing] At line 760, bJsonBased depends on last_ball_mci >= constants.timestampUpgradeMci. Can an attacker submit payments at the exact MCI boundary causing different nodes to use different hash algorithms, leading to network divergence?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeIndivisibleAssetPaymentJoint()] [Message Shuffling] At line 788, messages are shuffled using shuffleArray. Can an attacker analyze the randomization to deanonymize private payments or exploit deterministic shuffling in tests to predict message order?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: getSavingCallbacks()] [Mutex Lock Acquisition] At line 816, a mutex lock is acquired. If validation takes a very long time (complex multi-output private payment), can this lock timeout or be held indefinitely, preventing other transactions from being processed?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: getSavingCallbacks()] [Combined Unlock Order] At lines 817-820, combined_unlock calls both validate_and_save_unlock and composer_unlock. If one fails, can this leave the other lock held causing deadlock?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: getSavingCallbacks()] [Sequence Validation] At lines 841-844, the function rejects units with sequence !== 'good'. Can an attacker force a unit to have sequence='temp-bad' temporarily by manipulating parent selection, causing legitimate transactions to fail?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: getSavingCallbacks()] [PreCommit Callback Failure] At lines 850 and 887-889, if bPreCommitCallbackFailed is set, the error is returned at line 939. Can an attacker cause preCommitCallback to fail (e.g., by corrupting private chains) after validation passes, causing funds to be locked in limbo?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: getSavingCallbacks()] [Chain Building Loop] At lines 854-883, the function iterates over assocPrivatePayloads and builds chains. If buildPrivateElementsChain takes extremely long for deep chains, can this cause transaction timeout or allow an attacker to DoS the network?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: getSavingCallbacks()] [Recipient Chain Filtering] At line 873, chains are filtered by output.address === to_address. Can an attacker provide multiple outputs with the same to_address to cause duplicate chains in arrRecipientChains, confusing downstream consumers?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: getSavingCallbacks()] [Light Client Posting] At lines 904-914, light clients post to vendor before saving. If the vendor accepts but local saving fails, can this cause the unit to be broadcast to the network but not stored locally, causing wallet inconsistency?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: getSavingCallbacks()] [PreCommitCb Injection] At line 918, if callbacks.preCommitCb is provided, it's called with conn, objJoint, and chains. Can an attacker inject a malicious callback that modifies the connection or joint data before final commit?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: getSavingCallbacks()] [Validation Unlock Timing] At line 936, validation_unlock is called after writer.saveJoint. If saveJoint takes a very long time (database bottleneck), can this hold the validation lock preventing other units from being validated?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: restorePrivateChains()] [Denomination Mismatch] At lines 989-990, the function checks denomination and asset match. Can an attacker exploit database corruption where stored denomination differs from queried denomination, causing chain restoration to fail and freeze funds?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: restorePrivateChains()] [Transfer-Only Limitation] At lines 991-992, the function throws an error for non-transfer inputs (issues). Can this prevent restoration of chains that include the original issue transaction, making newly issued coins unspendable until first transfer?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: restorePrivateChains()] [Output Visibility Check] At lines 1006-1007, the function throws an error if all outputs are hidden. Can an attacker create a unit where outputs exist but both address and blinding are NULL, permanently hiding those outputs and freezing funds?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: restorePrivateChains()] [Payload Hash Verification] At lines 1014-1016, the restored payload_hash must match the stored row.payload_hash. Can an attacker exploit version differences (versionWithoutTimestamp) to create payloads that hash differently on different nodes, causing chain restoration to fail non-deterministically?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: restorePrivateChains()] [Output Loop Skip] At lines 1020-1021, outputs without address or blinding are skipped. Can an attacker manipulate the database to mark outputs as revealed (address/blinding present) without actually having the private data, causing restoration to skip valid outputs?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: restorePrivateChains()] [Array Population] At lines 1026-1028, chains are added to either arrRecipientChains or arrCosignerChains. Can duplicate outputs (same address in multiple messages) cause the same chain to be added multiple times, confusing wallet balance calculations?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: readAddressesFundedInAsset()] [Definition Change Exclusion] At lines 1062-1065, addresses with unstable definition changes are excluded. Can an attacker submit definition_chg units to temporarily prevent addresses from being used in payments, causing DoS for specific users?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: readAddressesFundedInAsset()] [Denomination Filtering] At line 1071, outputs with denomination > remaining_amount are skipped. Can an attacker issue assets with only very large denominations, making it impossible to compose small payments and effectively bricking the asset?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: readAddressesFundedInAsset()] [Amount Calculation] At line 1074, used_amount is calculated with min(row.amount, denomination * floor(remaining/denomination)). Can this calculation underflow or produce negative values for edge cases, causing incorrect address selection?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: readAddressesFundedInAsset()] [Early Exit] At lines 1076-1077, the loop breaks when remaining_amount === 0. Can an attacker provide exact amounts that cause early exit before all eligible addresses are considered, biasing address selection?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: readFundedAddresses()] [Fee Address Validation] At lines 1094-1099, the function reads fee paying addresses. If arrFundedFeePayingAddresses is empty, an error is thrown. Can an attacker drain all fee paying addresses to prevent any indivisible asset transactions, causing network-wide DoS for that asset?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: readFundedAddresses()] [Typical Fee Constant] At line 1085, TYPICAL_FEE is hardcoded to 3000. If actual fees exceed this (large units), can the function select insufficient addresses for fees, causing transactions to fail validation with insufficient fee errors?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeMinimalIndivisibleAssetPaymentJoint()] [Target Amount Calculation] At lines 1111-1117, target_amount is calculated from either amount or asset_outputs. Can an attacker provide asset_outputs with amounts that sum to zero or overflow, causing the function to select no inputs or incorrect inputs?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeMinimalIndivisibleAssetPaymentJoint()] [Unfunded Address Error] At lines 1121-1122, if arrFundedPayingAddresses is empty, a generic error is returned. Can this be exploited to enumerate which addresses have funds by trying payments with different address sets?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: composeMinimalIndivisibleAssetPaymentJoint()] [Parameter Deletion] At lines 1124-1125, available_paying_addresses and available_fee_paying_addresses are deleted from params. Can this cause issues if the original params object is reused, leading to unexpected behavior in retry logic?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Database Transaction Scope] The file uses conn.addQuery and conn.query extensively, but are all operations properly wrapped in database transactions? Can concurrent operations interleave queries in unexpected ways causing race conditions?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Error Handling Consistency] Different functions use callbacks.ifError, throw Error, and return cb(err). Can inconsistent error handling cause some errors to crash the node while others are silently ignored?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Private vs Public Asset Logic] Many functions have separate code paths for objAsset.is_private. Can an attacker flip the is_private flag after validation to execute the wrong code path during saving?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Denomination Validation] The file assumes denominations are powers of 10 or other specific values. Can an attacker define assets with invalid denominations (e.g., prime numbers, zero, negative) that break the coin selection logic?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Blinding Entropy] For private assets, blinding factors are generated using composer.generateBlinding(). If this uses weak randomness, can an attacker predict blinding factors to deanonymize private payments?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Serial Number Overflow] Serial numbers are incremented indefinitely (lines 518, 522). For long-lived assets, can serial_number exceed JavaScript's MAX_SAFE_INTEGER, causing precision loss and duplicate serials?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Asset Cap Type Confusion] The code checks !!objAsset.cap (line 515). Can an attacker define an asset with cap='0' (string) or cap=false to bypass cap checks while appearing to have a cap?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Output_index Array Indexing] Many functions use payload.outputs[output_index] without bounds checking. Can an attacker provide output_index >= outputs.length to cause array out-of-bounds access, returning undefined and bypassing validation?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Message Index Validation] The code frequently uses message_index from user input. Can an attacker provide negative or very large message_index values to access unintended messages or cause database query errors?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Tolerance Parameter Abuse] Functions accept tolerance_plus and tolerance_minus parameters. Can an attacker provide MAX_SAFE_INTEGER for tolerance to force selection of all available coins, bloating units and causing DoS?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Change Address Validation] The change_address parameter is passed by user but not validated. Can an attacker provide an invalid or non-owned address as change_address, causing funds to be sent to uncontrolled addresses?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Spend Unconfirmed Setting] The spend_unconfirmed parameter defaults to conf.spend_unconfirmed || 'own'. Can an attacker modify conf.spend_unconfirmed globally to enable spending of all unconfirmed outputs network-wide?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Asset Definition Modification] The code loads asset properties dynamically using storage.loadAssetWithListOfAttestedAuthors. Can an attacker modify asset properties (is_private, fixed_denominations, cap) between load and use, causing non-deterministic behavior?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Multi-Message Payment Ordering] When creating multiple messages for one payment (lines 755-786), messages are shuffled. Can this shuffling be exploited to cause different nodes to process messages in different orders, causing validation divergence?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Count Authors Check] The code queries count_authors from unit_authors table. Can an attacker create units with zero authors or manipulate the table to return incorrect counts, bypassing multi-author validation?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Issue vs Transfer Type] Input type is determined by presence/absence of src_unit. Can an attacker craft database entries where src_unit is NULL but other fields indicate transfer, causing type confusion?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Output Hash Preimage] For private assets, output_hash is calculated from address+blinding. Can an attacker find two different (address, blinding) pairs that produce the same output_hash, allowing output substitution in private payments?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Profiler Side Effects] The code uses profiler.start() and profiler.stop() extensively. Can enabling profiling cause timing-based attacks where attackers measure operation duration to infer private information like balance amounts?",
  "[File: byteball/ocore/indivisible_asset.js] [Function: Multiple] [Lodash Clone Depth] The code uses _.cloneDeep() for payloads (lines 154, 607, 765, 868, 1009). Can an attacker provide deeply nested objects that cause excessive memory allocation or stack overflow during cloning?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [SQL Injection] In lines 54-62, the function constructs SQL INSERT statements using string interpolation with `'${address}'`, `'${strOPs}'`, and other variables directly embedded in the query string without parameterization - can an attacker who controls the preloaded voter addresses or system parameter values inject malicious SQL to corrupt the system_votes, op_votes, or numerical_votes tables?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [SQL Injection] The INSERT query on line 62 concatenates `values.join(', ')` where values are constructed using template literals with unescaped `address` and `op` variables - if an attacker can influence the arrPreloadedVoters or arrOPs arrays through constants.js manipulation, can they execute arbitrary SQL commands during initialization?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [SQL Injection] Lines 71-78 insert into system_vars table using direct string interpolation of `strOPs` and numerical values without prepared statements - can a malformed op_list value in constants.js containing SQL metacharacters cause injection attacks during bootstrap?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Transaction Atomicity] The function checks if system_vars table is populated on line 7-8 without holding a database lock, then begins a transaction on line 33 - can two nodes simultaneously calling initSystemVarVotes() both detect empty tables and both attempt to insert initial votes, causing primary key constraint violations or duplicate vote records?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Race Condition] Between the check on line 7 (`SELECT 1 FROM system_vars LIMIT 1`) and the BEGIN transaction on line 33, another process could initialize the tables - can this race condition cause duplicate initialization attempts that corrupt the voting state or cause transaction rollback failures?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Partial Initialization] If the transaction between lines 33-79 fails after some but not all INSERT statements complete (e.g., due to constraint violation on line 62 or 72), and the COMMIT on line 79 fails, can the database be left in a partially initialized state where some preloaded voters have votes recorded but others don't, breaking vote counting consensus?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Non-Deterministic Bug Fix] Lines 9-29 contain testnet-specific bug fix logic that executes BEFORE the main initialization check - if this bug fix modifies the system_vars table but then the main initialization also proceeds (due to race conditions), can nodes end up with inconsistent system variable histories?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Validation] The bug fix on lines 10-19 checks for exactly 13 OPs and deletes the 13th one - but what if due to corruption or attack, there are 14+ OP votes for address 'EJC4A7WQGHEZEKW6RLO7F26SAR4LAQBU'? Will the fix still execute correctly or throw an error that prevents initialization?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Chain Split Risk] Lines 21-28 modify the op_list in system_vars if vote_count_mci equals exactly 3547796 and value matches a specific JSON array - if some testnet nodes applied this fix and others didn't (due to timing or version differences), can this cause a permanent chain split where nodes have different governance OP lists?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Reversion] The testnet bug fix on line 27 uses a direct UPDATE without checking if the current value is still the expected one - if the op_list changed between line 25 (read) and line 27 (write), can this overwrite a newer legitimate op_list with the buggy one, causing governance corruption?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Network Type Confusion] Lines 39-44 select different arrOPs based on constants.bDevnet and constants.bTestnet - if an attacker can manipulate environment variables to make constants.bTestnet evaluate to true on mainnet (or vice versa), can they force wrong OP lists to be initialized, causing a governance takeover?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Hard-coded OP List] The mainnet OP list on lines 43-44 contains 12 hard-coded addresses - if any of these addresses are compromised or lost control, there is no mechanism in this initialization to update them, potentially leading to permanent freezing of governance if majority of these addresses become inaccessible?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Testnet OP Count Mismatch] The testnet arrOPs on line 42 contains 12 addresses while the devnet on line 40 has only 1 - but the bug fix logic on lines 10-19 expects 13 OPs for a specific testnet address, suggesting historical inconsistency - can this mismatch between expected and actual OP counts cause initialization failures or consensus issues?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Timestamp Manipulation] Line 34 sets a hard-coded timestamp of 1724716800 (27 Aug 2024) for all initial votes - if this timestamp is in the future relative to actual node startup time, can it cause vote counting logic in main_chain.js to miscalculate which votes should be active, potentially rejecting legitimate system_vote messages?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Preloaded Voter Privilege] Lines 46-51 define arrPreloadedVoters who get to vote on initial system parameters without any authorization check - if an attacker can add their address to this array through constants.js or chash.js manipulation, can they gain permanent voting privileges and control system parameter changes?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Mainnet Voter Cardinality] The mainnet preloaded voters array on line 50 contains 5 addresses - but why 5 and not 12 (matching witness count)? If these 5 addresses don't maintain sufficient balance or coordination, can the governance system become deadlocked unable to update critical parameters like tps_fee?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Devnet Voter Generation] Line 47 generates a devnet voter address using `require('./chash.js').getChash160('')` with an empty string - this produces a deterministic address that anyone can derive, meaning the devnet governance is completely insecure and any attacker can vote?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Voter Address Validation] The preloaded voter addresses are inserted directly into system_votes and op_votes tables without any validation that they are valid 32-character base32 addresses - can malformed addresses cause foreign key violations or query failures when main_chain.js tries to process these votes?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Fee Parameter Risks] Line 36 sets base_tps_fee to 10 and line 38 sets tps_fee_multiplier to 10 - are these values properly validated against economic attack scenarios where attackers spam transactions to manipulate TPS-based fees? Can extremely low or high initial values make the network unusable or enable DoS attacks?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Threshold Size Economics] Line 35 sets threshold_size to 10000 bytes - this parameter affects when oversize fees apply - if this value is too high, can attackers post massive units without paying adequate fees, bloating the database and causing network delay (Medium severity impact)?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [TPS Interval Inconsistency] Line 37 sets tps_interval differently for devnet (2) vs mainnet/testnet (1) - this affects TPS fee calculation periods - can nodes running with wrong constants.bDevnet value end up calculating different actual_tps_fee values, causing them to reject each other's units and creating a chain split?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [OP List Size Validation] The op_list is serialized to JSON on line 45 and inserted directly - is there any validation that it contains exactly 12 addresses? Can an attacker modify constants.js to create an op_list with 0, 1, or 20+ OPs, breaking the witness voting assumptions throughout the codebase?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Empty Unit Reference] All INSERT statements on lines 54-69 use an empty string `''` as the unit field - this violates the foreign key constraint comments in byteball-sqlite.sql lines 957 and 971 that reference units(unit), but the constraints are commented out - does this mean initial votes have no unit provenance, and can this be exploited to forge vote history?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Primary Key Collision] The system_votes table has PRIMARY KEY (unit, address, subject) per byteball-sqlite.sql:956 - since all initial votes use unit='', if the same address votes on the same subject twice in the loop (lines 52-70), the second INSERT will fail - but the code uses INSERT OR IGNORE, silently dropping duplicate votes - can this hide initialization errors?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Vote Count MCI Semantics] Line 73 inserts into system_vars with vote_count_mci=-1 - according to byteball-sqlite.sql:992, this means the value applies since the next MCI (i.e., MCI 0) - but what if nodes have different genesis MCIs or the -1 value has special handling that could be exploited?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Idempotency Failure] If initSystemVarVotes() is called multiple times (e.g., due to node restart or code error), lines 7-32 should prevent re-initialization, but what if the system_vars table exists but is corrupted with invalid data? The function will skip initialization, leaving the node with bad governance state permanently?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Partial Table State] The check on line 7 only verifies system_vars has rows, but doesn't check system_votes, op_votes, or numerical_votes tables - can a database corruption scenario exist where system_vars is populated but the vote history tables are empty, causing vote counting to fail when countVotes() is called?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Connection Release Timing] Line 30 releases the database connection after early return, but line 81 also releases after normal completion - if an error occurs between lines 33-79 during the transaction, is the connection properly released? Can connection pool exhaustion occur due to unreleased connections on error paths?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Constants.js Dependency] The file imports and relies on constants.bTestnet, constants.bDevnet throughout lines 9, 37, 39-50 - if constants.js is loaded incorrectly or uses environment variables that differ between nodes, can this cause nodes to initialize with incompatible governance parameters, leading to permanent chain split?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Storage.js Interaction] After initialization, storage.js:initSystemVars() on line 2368 reads system_vars into memory cache - if initSystemVarVotes() fails silently or partially, will storage.js throw an error 'no system vars' on line 2371, preventing the node from starting? Or worse, will it use uninitialized/wrong cached values?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Main_chain.js Vote Processing] The initialized votes have empty unit='' and will never trigger saveSystemVote() in main_chain.js:1528-1560 since that requires objStableUnit to exist - does this mean initial votes are treated differently than regular votes, and can an attacker exploit this to craft fake 'initial' votes after network launch?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [CountVotes Compatibility] When main_chain.js:countVotes() is called at line 1645, it queries 'SELECT DISTINCT address FROM system_votes WHERE subject=?' - will it include the initial votes with unit=''? If so, do the preloaded voters' balances get checked, and if they have zero balance, will their votes be ignored, potentially breaking quorum?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Error Handling] Lines 10-28 contain testnet bug fix logic with throw Error() statements on lines 14, 16, 23 - if these errors are thrown during node startup, does it crash the entire node? Can an attacker trigger these error conditions by corrupting the op_votes table to prevent nodes from starting?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Transaction Rollback] If any query between lines 33-79 fails (e.g., constraint violation, out of disk space), the transaction should rollback - but there's no explicit ROLLBACK statement or try-catch block - does the database connection library handle this automatically, or can partial commits occur?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Silent Failure Risk] The function uses `INSERT OR IGNORE` on lines 54, 62, 64, 72 - this silently ignores errors including primary key violations - can this hide critical initialization failures where votes weren't actually recorded, leading to governance deadlock when vote counting expects certain votes to exist?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Initialization Order] Lines 52-70 iterate over arrPreloadedVoters in array order to insert votes - if different JavaScript engine versions or node implementations iterate arrays differently, can the insertion order differ between nodes, and does this affect any ORDER BY queries that rely on creation_date (default CURRENT_TIMESTAMP)?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Timestamp Determinism] All votes use the same hard-coded timestamp 1724716800 on line 34 - but the database schema adds creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP on lines 955, 969, 982, 994 of byteball-sqlite.sql - this creation_date will differ between nodes that initialize at different times - can this cause consensus issues if any queries sort by creation_date?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [OP List Order Dependency] The arrOPs arrays on lines 40, 42-43 have specific address ordering - does the order matter for vote counting or OP selection in other parts of the codebase? If an attacker can somehow reorder the array elements, can it affect which OPs are selected or vote counting results?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Network Type Detection Attack] If an attacker running a mainnet node can set environment variable testnet=1 to make constants.bTestnet true, will their node initialize with testnet preloaded voters and OP list, causing them to fork permanently from mainnet? Can this be used to DoS attack the network by confusing nodes?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Devnet Security Model] Devnet has a single OP on line 40 and a deterministic voter on line 47 - this means devnet has no security and anyone can control governance - but what if devnet code accidentally runs on testnet or mainnet due to configuration error? Can this completely compromise the network's governance?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Hard Fork Risk from Bug Fix] The testnet bug fix on lines 9-29 only executes if constants.bTestnet is true - if this bug affected mainnet too but wasn't fixed there, or if the fix is applied incorrectly, can testnet and mainnet diverge in their system_vars history, preventing cross-network testing and potential mainnet hard fork?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Initial Voter Centralization] On mainnet, only 5 preloaded voters control initial system parameters (line 50) - if these 5 addresses are controlled by a single entity or collude, can they manipulate fee parameters, OP lists, and threshold_size to make the network unusable or extract excessive fees before other addresses gain voting power?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [OP Address Verification] The OP addresses in arrOPs are hard-coded strings - is there any verification that these addresses actually exist on the network, have posted units, or are controlled by legitimate operators? Can attackers who control these addresses (if keys are leaked) manipulate consensus?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Fee Manipulation Attack Vector] The initial base_tps_fee=10 and tps_fee_multiplier=10 on lines 36, 38 - if these values are set too low, can an attacker spam the network with high-TPS attacks before governance can vote to increase fees, causing network delay (Medium severity) or database bloat?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Table Existence Assumption] The function assumes system_votes, op_votes, numerical_votes, and system_vars tables exist - if database migrations in sqlite_migrations.js haven't run yet (version < 46), will these INSERT queries fail with 'table does not exist' errors, preventing node startup?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Schema Version Mismatch] If the database schema changes in the future (e.g., new columns added to system_vars), but this initialization code isn't updated, can the INSERT statements fail due to missing required columns, breaking new node bootstrapping?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [SQLite vs MySQL Differences] The code uses `INSERT OR IGNORE` syntax on lines 54, 62, 64, 72 - this is SQLite-specific syntax - does MySQL support this? If not, can MySQL nodes fail to initialize properly, causing mainnet (which might use MySQL for hubs) to have different governance state than light clients (which use SQLite)?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Module Export Timing] The file exports initSystemVarVotes on line 84, and db.js calls it immediately on line 43 with `initial_votes.initSystemVarVotes(module.exports)` - but db.js itself is still loading - can circular dependency issues or undefined exports cause the function to receive an incomplete db module, leading to errors?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Constants.js Load Order] Line 3 requires constants.js - but constants.js loads environment variables and configuration - if environment variables change after initial_votes.js loads but before initSystemVarVotes() executes, can nodes end up with mismatched network types?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Chash.js Dependency] Line 47 dynamically requires './chash.js' inside the arrPreloadedVoters initialization - if chash.js has any side effects or depends on database being initialized, can this cause a deadlock or initialization failure on devnet?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Specificity] The bug fix on lines 21-28 checks for extremely specific conditions: vote_count_mci === 3547796 AND value equals a 12-element JSON array - this seems to target one historical event - but what if similar bugs occur at different MCIs? The fix won't detect them, and governance could remain corrupted?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [13th OP Attack Vector] The bug fix deletes a 13th OP with address '2FF7PSL7FYXVU5UIQHCVDTTPUOOG75GX' on line 18 - but this same address is then included in the 'buggy' op_list on line 27 - can an attacker exploit confusion around whether this address should be included to cause nodes to have inconsistent OP lists?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Vote Count MCI Correlation] The bug fix updates system_vars WHERE vote_count_mci=3547796 on line 27 - but does it also update corresponding entries in system_votes, op_votes, or numerical_votes tables? If not, can the vote history and final system_vars become inconsistent, breaking vote auditing?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Race Condition] The bug fix reads op_votes on line 10, checks conditions, and deletes on line 18 without holding any locks - if another process inserts a new vote for the same address between the read and delete, can the deletion target the wrong rows or leave the database in unexpected state?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Integer Overflow] The numerical parameters threshold_size=10000, base_tps_fee=10, tps_interval, tps_fee_multiplier=10 are inserted as integers - are there any checks that these values don't exceed database integer limits (INT/BIGINT max values)? Can extremely large values cause overflow in fee calculation formulas?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Negative Value Injection] Can an attacker modify constants.js or exploit numerical parameter logic to insert negative values for threshold_size, base_tps_fee, or tps_fee_multiplier? If storage.js:getSystemVar() returns negative values, can it cause underflow in fee calculations, making fees negative and enabling free transactions?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Zero TPS Interval] Line 37 sets tps_interval to 1 or 2 - what if this is accidentally set to 0? Division by zero in TPS fee calculations could crash nodes or cause incorrect fee assessment, leading to network halt (Critical severity)?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Large OP List] The op_list is JSON stringified and stored in TEXT column on line 45 - what's the maximum size limit? Can an attacker craft an arrOPs array with millions of addresses, causing JSON.stringify() to consume excessive memory or create multi-GB TEXT values that DoS the database?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [INSERT Statement Size] Line 62 builds a large INSERT with `values.join(', ')` where values can be up to 12 * number_of_preloaded_voters elements - for mainnet with 5 voters * 12 OPs = 60 value tuples - can this exceed MySQL's max_allowed_packet or SQLite's SQLITE_MAX_SQL_LENGTH, causing the query to fail?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Connection Pool Starvation] The function takes a connection from pool on line 6 and holds it through entire initialization (potentially including bug fix queries) - if initialization hangs or takes very long, can this starve the connection pool and prevent other critical operations from executing?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [SQL Injection] In lines 54-62, the function constructs SQL INSERT statements using string interpolation with `'${address}'`, `'${strOPs}'`, and other variables directly embedded in the query string without parameterization - can an attacker who controls the preloaded voter addresses or system parameter values inject malicious SQL to corrupt the system_votes, op_votes, or numerical_votes tables?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [SQL Injection] The INSERT query on line 62 concatenates `values.join(', ')` where values are constructed using template literals with unescaped `address` and `op` variables - if an attacker can influence the arrPreloadedVoters or arrOPs arrays through constants.js manipulation, can they execute arbitrary SQL commands during initialization?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [SQL Injection] Lines 71-78 insert into system_vars table using direct string interpolation of `strOPs` and numerical values without prepared statements - can a malformed op_list value in constants.js containing SQL metacharacters cause injection attacks during bootstrap?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Transaction Atomicity] The function checks if system_vars table is populated on line 7-8 without holding a database lock, then begins a transaction on line 33 - can two nodes simultaneously calling initSystemVarVotes() both detect empty tables and both attempt to insert initial votes, causing primary key constraint violations or duplicate vote records?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Race Condition] Between the check on line 7 (`SELECT 1 FROM system_vars LIMIT 1`) and the BEGIN transaction on line 33, another process could initialize the tables - can this race condition cause duplicate initialization attempts that corrupt the voting state or cause transaction rollback failures?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Partial Initialization] If the transaction between lines 33-79 fails after some but not all INSERT statements complete (e.g., due to constraint violation on line 62 or 72), and the COMMIT on line 79 fails, can the database be left in a partially initialized state where some preloaded voters have votes recorded but others don't, breaking vote counting consensus?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Non-Deterministic Bug Fix] Lines 9-29 contain testnet-specific bug fix logic that executes BEFORE the main initialization check - if this bug fix modifies the system_vars table but then the main initialization also proceeds (due to race conditions), can nodes end up with inconsistent system variable histories?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Validation] The bug fix on lines 10-19 checks for exactly 13 OPs and deletes the 13th one - but what if due to corruption or attack, there are 14+ OP votes for address 'EJC4A7WQGHEZEKW6RLO7F26SAR4LAQBU'? Will the fix still execute correctly or throw an error that prevents initialization?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Chain Split Risk] Lines 21-28 modify the op_list in system_vars if vote_count_mci equals exactly 3547796 and value matches a specific JSON array - if some testnet nodes applied this fix and others didn't (due to timing or version differences), can this cause a permanent chain split where nodes have different governance OP lists?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Reversion] The testnet bug fix on line 27 uses a direct UPDATE without checking if the current value is still the expected one - if the op_list changed between line 25 (read) and line 27 (write), can this overwrite a newer legitimate op_list with the buggy one, causing governance corruption?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Network Type Confusion] Lines 39-44 select different arrOPs based on constants.bDevnet and constants.bTestnet - if an attacker can manipulate environment variables to make constants.bTestnet evaluate to true on mainnet (or vice versa), can they force wrong OP lists to be initialized, causing a governance takeover?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Hard-coded OP List] The mainnet OP list on lines 43-44 contains 12 hard-coded addresses - if any of these addresses are compromised or lost control, there is no mechanism in this initialization to update them, potentially leading to permanent freezing of governance if majority of these addresses become inaccessible?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Testnet OP Count Mismatch] The testnet arrOPs on line 42 contains 12 addresses while the devnet on line 40 has only 1 - but the bug fix logic on lines 10-19 expects 13 OPs for a specific testnet address, suggesting historical inconsistency - can this mismatch between expected and actual OP counts cause initialization failures or consensus issues?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Timestamp Manipulation] Line 34 sets a hard-coded timestamp of 1724716800 (27 Aug 2024) for all initial votes - if this timestamp is in the future relative to actual node startup time, can it cause vote counting logic in main_chain.js to miscalculate which votes should be active, potentially rejecting legitimate system_vote messages?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Preloaded Voter Privilege] Lines 46-51 define arrPreloadedVoters who get to vote on initial system parameters without any authorization check - if an attacker can add their address to this array through constants.js or chash.js manipulation, can they gain permanent voting privileges and control system parameter changes?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Mainnet Voter Cardinality] The mainnet preloaded voters array on line 50 contains 5 addresses - but why 5 and not 12 (matching witness count)? If these 5 addresses don't maintain sufficient balance or coordination, can the governance system become deadlocked unable to update critical parameters like tps_fee?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Devnet Voter Generation] Line 47 generates a devnet voter address using `require('./chash.js').getChash160('')` with an empty string - this produces a deterministic address that anyone can derive, meaning the devnet governance is completely insecure and any attacker can vote?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Voter Address Validation] The preloaded voter addresses are inserted directly into system_votes and op_votes tables without any validation that they are valid 32-character base32 addresses - can malformed addresses cause foreign key violations or query failures when main_chain.js tries to process these votes?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Fee Parameter Risks] Line 36 sets base_tps_fee to 10 and line 38 sets tps_fee_multiplier to 10 - are these values properly validated against economic attack scenarios where attackers spam transactions to manipulate TPS-based fees? Can extremely low or high initial values make the network unusable or enable DoS attacks?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Threshold Size Economics] Line 35 sets threshold_size to 10000 bytes - this parameter affects when oversize fees apply - if this value is too high, can attackers post massive units without paying adequate fees, bloating the database and causing network delay (Medium severity impact)?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [TPS Interval Inconsistency] Line 37 sets tps_interval differently for devnet (2) vs mainnet/testnet (1) - this affects TPS fee calculation periods - can nodes running with wrong constants.bDevnet value end up calculating different actual_tps_fee values, causing them to reject each other's units and creating a chain split?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [OP List Size Validation] The op_list is serialized to JSON on line 45 and inserted directly - is there any validation that it contains exactly 12 addresses? Can an attacker modify constants.js to create an op_list with 0, 1, or 20+ OPs, breaking the witness voting assumptions throughout the codebase?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Empty Unit Reference] All INSERT statements on lines 54-69 use an empty string `''` as the unit field - this violates the foreign key constraint comments in byteball-sqlite.sql lines 957 and 971 that reference units(unit), but the constraints are commented out - does this mean initial votes have no unit provenance, and can this be exploited to forge vote history?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Primary Key Collision] The system_votes table has PRIMARY KEY (unit, address, subject) per byteball-sqlite.sql:956 - since all initial votes use unit='', if the same address votes on the same subject twice in the loop (lines 52-70), the second INSERT will fail - but the code uses INSERT OR IGNORE, silently dropping duplicate votes - can this hide initialization errors?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Vote Count MCI Semantics] Line 73 inserts into system_vars with vote_count_mci=-1 - according to byteball-sqlite.sql:992, this means the value applies since the next MCI (i.e., MCI 0) - but what if nodes have different genesis MCIs or the -1 value has special handling that could be exploited?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Idempotency Failure] If initSystemVarVotes() is called multiple times (e.g., due to node restart or code error), lines 7-32 should prevent re-initialization, but what if the system_vars table exists but is corrupted with invalid data? The function will skip initialization, leaving the node with bad governance state permanently?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Partial Table State] The check on line 7 only verifies system_vars has rows, but doesn't check system_votes, op_votes, or numerical_votes tables - can a database corruption scenario exist where system_vars is populated but the vote history tables are empty, causing vote counting to fail when countVotes() is called?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Connection Release Timing] Line 30 releases the database connection after early return, but line 81 also releases after normal completion - if an error occurs between lines 33-79 during the transaction, is the connection properly released? Can connection pool exhaustion occur due to unreleased connections on error paths?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Constants.js Dependency] The file imports and relies on constants.bTestnet, constants.bDevnet throughout lines 9, 37, 39-50 - if constants.js is loaded incorrectly or uses environment variables that differ between nodes, can this cause nodes to initialize with incompatible governance parameters, leading to permanent chain split?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Storage.js Interaction] After initialization, storage.js:initSystemVars() on line 2368 reads system_vars into memory cache - if initSystemVarVotes() fails silently or partially, will storage.js throw an error 'no system vars' on line 2371, preventing the node from starting? Or worse, will it use uninitialized/wrong cached values?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Main_chain.js Vote Processing] The initialized votes have empty unit='' and will never trigger saveSystemVote() in main_chain.js:1528-1560 since that requires objStableUnit to exist - does this mean initial votes are treated differently than regular votes, and can an attacker exploit this to craft fake 'initial' votes after network launch?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [CountVotes Compatibility] When main_chain.js:countVotes() is called at line 1645, it queries 'SELECT DISTINCT address FROM system_votes WHERE subject=?' - will it include the initial votes with unit=''? If so, do the preloaded voters' balances get checked, and if they have zero balance, will their votes be ignored, potentially breaking quorum?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Error Handling] Lines 10-28 contain testnet bug fix logic with throw Error() statements on lines 14, 16, 23 - if these errors are thrown during node startup, does it crash the entire node? Can an attacker trigger these error conditions by corrupting the op_votes table to prevent nodes from starting?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Transaction Rollback] If any query between lines 33-79 fails (e.g., constraint violation, out of disk space), the transaction should rollback - but there's no explicit ROLLBACK statement or try-catch block - does the database connection library handle this automatically, or can partial commits occur?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Silent Failure Risk] The function uses `INSERT OR IGNORE` on lines 54, 62, 64, 72 - this silently ignores errors including primary key violations - can this hide critical initialization failures where votes weren't actually recorded, leading to governance deadlock when vote counting expects certain votes to exist?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Initialization Order] Lines 52-70 iterate over arrPreloadedVoters in array order to insert votes - if different JavaScript engine versions or node implementations iterate arrays differently, can the insertion order differ between nodes, and does this affect any ORDER BY queries that rely on creation_date (default CURRENT_TIMESTAMP)?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Timestamp Determinism] All votes use the same hard-coded timestamp 1724716800 on line 34 - but the database schema adds creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP on lines 955, 969, 982, 994 of byteball-sqlite.sql - this creation_date will differ between nodes that initialize at different times - can this cause consensus issues if any queries sort by creation_date?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [OP List Order Dependency] The arrOPs arrays on lines 40, 42-43 have specific address ordering - does the order matter for vote counting or OP selection in other parts of the codebase? If an attacker can somehow reorder the array elements, can it affect which OPs are selected or vote counting results?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Network Type Detection Attack] If an attacker running a mainnet node can set environment variable testnet=1 to make constants.bTestnet true, will their node initialize with testnet preloaded voters and OP list, causing them to fork permanently from mainnet? Can this be used to DoS attack the network by confusing nodes?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Devnet Security Model] Devnet has a single OP on line 40 and a deterministic voter on line 47 - this means devnet has no security and anyone can control governance - but what if devnet code accidentally runs on testnet or mainnet due to configuration error? Can this completely compromise the network's governance?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Hard Fork Risk from Bug Fix] The testnet bug fix on lines 9-29 only executes if constants.bTestnet is true - if this bug affected mainnet too but wasn't fixed there, or if the fix is applied incorrectly, can testnet and mainnet diverge in their system_vars history, preventing cross-network testing and potential mainnet hard fork?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Initial Voter Centralization] On mainnet, only 5 preloaded voters control initial system parameters (line 50) - if these 5 addresses are controlled by a single entity or collude, can they manipulate fee parameters, OP lists, and threshold_size to make the network unusable or extract excessive fees before other addresses gain voting power?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [OP Address Verification] The OP addresses in arrOPs are hard-coded strings - is there any verification that these addresses actually exist on the network, have posted units, or are controlled by legitimate operators? Can attackers who control these addresses (if keys are leaked) manipulate consensus?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Fee Manipulation Attack Vector] The initial base_tps_fee=10 and tps_fee_multiplier=10 on lines 36, 38 - if these values are set too low, can an attacker spam the network with high-TPS attacks before governance can vote to increase fees, causing network delay (Medium severity) or database bloat?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Table Existence Assumption] The function assumes system_votes, op_votes, numerical_votes, and system_vars tables exist - if database migrations in sqlite_migrations.js haven't run yet (version < 46), will these INSERT queries fail with 'table does not exist' errors, preventing node startup?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Schema Version Mismatch] If the database schema changes in the future (e.g., new columns added to system_vars), but this initialization code isn't updated, can the INSERT statements fail due to missing required columns, breaking new node bootstrapping?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [SQLite vs MySQL Differences] The code uses `INSERT OR IGNORE` syntax on lines 54, 62, 64, 72 - this is SQLite-specific syntax - does MySQL support this? If not, can MySQL nodes fail to initialize properly, causing mainnet (which might use MySQL for hubs) to have different governance state than light clients (which use SQLite)?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Module Export Timing] The file exports initSystemVarVotes on line 84, and db.js calls it immediately on line 43 with `initial_votes.initSystemVarVotes(module.exports)` - but db.js itself is still loading - can circular dependency issues or undefined exports cause the function to receive an incomplete db module, leading to errors?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Constants.js Load Order] Line 3 requires constants.js - but constants.js loads environment variables and configuration - if environment variables change after initial_votes.js loads but before initSystemVarVotes() executes, can nodes end up with mismatched network types?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Chash.js Dependency] Line 47 dynamically requires './chash.js' inside the arrPreloadedVoters initialization - if chash.js has any side effects or depends on database being initialized, can this cause a deadlock or initialization failure on devnet?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Specificity] The bug fix on lines 21-28 checks for extremely specific conditions: vote_count_mci === 3547796 AND value equals a 12-element JSON array - this seems to target one historical event - but what if similar bugs occur at different MCIs? The fix won't detect them, and governance could remain corrupted?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [13th OP Attack Vector] The bug fix deletes a 13th OP with address '2FF7PSL7FYXVU5UIQHCVDTTPUOOG75GX' on line 18 - but this same address is then included in the 'buggy' op_list on line 27 - can an attacker exploit confusion around whether this address should be included to cause nodes to have inconsistent OP lists?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Vote Count MCI Correlation] The bug fix updates system_vars WHERE vote_count_mci=3547796 on line 27 - but does it also update corresponding entries in system_votes, op_votes, or numerical_votes tables? If not, can the vote history and final system_vars become inconsistent, breaking vote auditing?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Bug Fix Race Condition] The bug fix reads op_votes on line 10, checks conditions, and deletes on line 18 without holding any locks - if another process inserts a new vote for the same address between the read and delete, can the deletion target the wrong rows or leave the database in unexpected state?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Integer Overflow] The numerical parameters threshold_size=10000, base_tps_fee=10, tps_interval, tps_fee_multiplier=10 are inserted as integers - are there any checks that these values don't exceed database integer limits (INT/BIGINT max values)? Can extremely large values cause overflow in fee calculation formulas?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Negative Value Injection] Can an attacker modify constants.js or exploit numerical parameter logic to insert negative values for threshold_size, base_tps_fee, or tps_fee_multiplier? If storage.js:getSystemVar() returns negative values, can it cause underflow in fee calculations, making fees negative and enabling free transactions?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Zero TPS Interval] Line 37 sets tps_interval to 1 or 2 - what if this is accidentally set to 0? Division by zero in TPS fee calculations could crash nodes or cause incorrect fee assessment, leading to network halt (Critical severity)?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Large OP List] The op_list is JSON stringified and stored in TEXT column on line 45 - what's the maximum size limit? Can an attacker craft an arrOPs array with millions of addresses, causing JSON.stringify() to consume excessive memory or create multi-GB TEXT values that DoS the database?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [INSERT Statement Size] Line 62 builds a large INSERT with `values.join(', ')` where values can be up to 12 * number_of_preloaded_voters elements - for mainnet with 5 voters * 12 OPs = 60 value tuples - can this exceed MySQL's max_allowed_packet or SQLite's SQLITE_MAX_SQL_LENGTH, causing the query to fail?",
  "[File: byteball/ocore/initial_votes.js] [Function: initSystemVarVotes()] [Connection Pool Starvation] The function takes a connection from pool on line 6 and holds it through entire initialization (potentially including bug fix queries) - if initialization hangs or takes very long, can this starve the connection pool and prevent other critical operations from executing?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewUnit()] [Race Condition] If two threads call checkIfNewUnit() simultaneously for the same unit before either completes the database query at line 29, can both proceed to callbacks.ifNew() causing duplicate processing and potential double-insertion into storage?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewUnit()] [Cache Poisoning] Can an attacker flood the network with invalid units to populate assocKnownBadUnits (line 16) indefinitely, causing memory exhaustion that crashes the node and prevents new transaction processing (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewUnit()] [Stripped Unit Bypass] At lines 32-33, units marked 'final-bad' with MCI below min retrievable are treated as new - can an attacker exploit this by repeatedly sending stripped bad units to trigger reprocessing and validation overhead (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewUnit()] [Storage Inconsistency] If storage.isKnownUnit() returns false (line 22) but the database query (line 29) finds the unit, and storage.setUnitIsKnown() (line 34) fails or is delayed, can the unit be reprocessed multiple times causing non-deterministic behavior?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewUnit()] [Unhandled Unit Cache Bypass] If a unit exists in assocUnhandledUnits (line 24) but gets deleted from the database before line 29's query, will it incorrectly return callbacks.ifKnownUnverified() instead of detecting the inconsistency?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewJoint()] [Joint Hash Collision] At line 47, assocKnownBadJoints is checked by joint hash - if objectHash.getJointHash() has a collision (different joints produce same hash), can a valid joint be incorrectly marked as bad, causing permanent rejection of valid transactions?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewJoint()] [Cache Desynchronization] If a joint's unit passes checkIfNewUnit() but the joint hash is in assocKnownBadJoints (line 47), can this mismatch cause inconsistent handling where the unit is accepted but the joint is rejected, corrupting DAG structure?",
  "[File: byteball/ocore/joint_storage.js] [Function: removeUnhandledJointAndDependencies()] [Transaction Atomicity] The BEGIN/COMMIT transaction (lines 57-60) performs DELETE operations but assocUnhandledUnits deletion (line 62) occurs after conn.release() - if the process crashes between COMMIT and line 62, will the in-memory cache remain inconsistent with database state?",
  "[File: byteball/ocore/joint_storage.js] [Function: removeUnhandledJointAndDependencies()] [Orphaned Dependencies] If removeUnhandledJointAndDependencies() deletes dependencies at line 59 but another thread is simultaneously adding new dependencies via saveUnhandledJointAndDependencies(), can race conditions create orphaned dependency records?",
  "[File: byteball/ocore/joint_storage.js] [Function: removeUnhandledJointAndDependencies()] [Connection Pool Exhaustion] If onDone callback (line 65) throws an exception or never completes, the connection may not be released properly despite conn.release() (line 63) - can attackers trigger this repeatedly to exhaust the connection pool (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [Memory Leak via Cache] At line 72, assocUnhandledUnits[unit] is set to true without any size limits - can an attacker flood the network with units having missing parents to grow this cache unboundedly, causing memory exhaustion (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [SQL Injection via Array] Lines 74-76 construct SQL with arrMissingParentUnits.map() - if arrMissingParentUnits contains specially crafted unit hashes (despite being escaped), can the resulting SQL exceed query length limits or cause performance degradation (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [JSON Serialization Failure] At line 79, JSON.stringify(objJoint) may fail or produce excessively large strings for maliciously crafted joints - is there size validation before insertion, or can this cause database bloat or insertion failures?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [Dependency Explosion] If arrMissingParentUnits contains hundreds or thousands of entries, the INSERT at lines 74-76 creates that many dependency rows - can attackers flood dependencies table to cause query performance degradation when readDependentJointsThatAreReady() executes (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [Duplicate Insertion] The INSERT uses conn.getIgnore() (lines 79-80) to ignore duplicates, but what if the same unit is saved with different peer values - can this create multiple unhandled_joints rows for the same unit causing processing duplication?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [Cache-Database Mismatch] If the database transaction COMMIT (line 81) fails but assocUnhandledUnits[unit]=true (line 72) already succeeded, will subsequent calls to checkIfNewUnit() incorrectly think the unit is unhandled when it's actually not in the database?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Lock Inconsistency] At lines 97-98, lock is conditionally set to either mutex.lock or mutex.lockOrSkip based on unit parameter - if unit is null and lockOrSkip returns immediately without acquiring lock, can concurrent executions corrupt the dependency query results?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Query Performance DoS] The query at lines 99-108 performs multiple JOINs and GROUP BY without LIMIT - if an attacker creates a deep dependency chain, can this query take minutes to execute, blocking the mutex lock and preventing other units from being processed (Medium: network delay 1 hour)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Callback Flood] Lines 112-118 call handleDependentJoint for each ready unit without rate limiting - if 10,000+ joints become ready simultaneously, can the callback flood exhaust memory or CPU (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Unlocked Processing] The unlock() at line 119 releases the mutex before all handleDependentJoint callbacks complete (they're queued via db.query at line 113) - can this allow other threads to modify dependencies while callbacks are still processing, causing race conditions?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [JSON Parse Attack] At line 115, JSON.parse(internal_row.json) deserializes user-controlled joint data without validation - can a malicious joint with deeply nested structures cause stack overflow or exponential parsing time (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Timestamp Integer Overflow] Line 115 uses parseInt(internal_row.creation_ts) - if creation_ts is a very large number or NaN, can this cause incorrect timestamp handling in downstream processing?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Missing Parent Race] Between the GROUP BY query completing (line 107) and callbacks executing (lines 112-118), if a parent unit is deleted or marked as bad, will the dependent joints still be processed despite no longer having valid parents?",
  "[File: byteball/ocore/joint_storage.js] [Function: findLostJoints()] [Lock Skip Vulnerability] Line 127 uses lockOrSkip - if the lock is already held, findLostJoints() returns immediately without searching for lost joints - can this cause some lost joints to never be detected if timing is adversarial (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: findLostJoints()] [Time-Based Bypass] The query at line 133 only finds dependencies older than 8 seconds - can an attacker coordinate to repeatedly create and resolve dependencies just under 8 seconds to evade lost joint detection?",
  "[File: byteball/ocore/joint_storage.js] [Function: findLostJoints()] [Callback with Unlocked State] handleLostJoints callback at line 139 is invoked after unlock() at line 136 - if handleLostJoints modifies dependencies, can concurrent findLostJoints() calls interfere with each other?",
  "[File: byteball/ocore/joint_storage.js] [Function: findLostJoints()] [Lost Joint Flood] If handleLostJoints requests all lost joints from peers simultaneously (potentially hundreds), can this overwhelm network bandwidth or peer processing capacity (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeJointAndDependencies()] [Cache Pollution] Line 148 adds to assocKnownBadUnits without size limits - can repeated purging of different bad units cause unbounded memory growth in assocKnownBadUnits cache (Critical: memory exhaustion network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeJointAndDependencies()] [Error Propagation Attack] The same error string is propagated to all dependent joints via collectQueriesToPurgeDependentJoints (line 155) - can an attacker create a deep dependency tree where one bad root unit causes thousands of descendants to be marked bad in a cascade, overwhelming database writes (Medium: network delay 1 day)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeJointAndDependencies()] [Transaction Size Limit] If collectQueriesToPurgeDependentJoints adds hundreds of INSERT/DELETE queries to arrQueries (line 155), can the total transaction size exceed database limits causing COMMIT failure and leaving partial purge state?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeJointAndDependencies()] [Callback Race] onPurgedDependentJoint is called for each purged unit (line 155), but if these callbacks try to access dependencies that are being deleted in the same transaction, can this cause read-after-delete inconsistencies?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeJointAndDependencies()] [Cache Deletion Order] Line 158 deletes from assocUnhandledUnits after COMMIT completes - if the process crashes between lines 157 and 158, will the cache incorrectly retain references to purged units, causing future lookups to return stale data?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeDependencies()] [Missing Unit Insertion] Unlike purgeJointAndDependencies, this function doesn't insert the parent unit into known_bad_joints - can this cause the parent to be re-requested and re-validated repeatedly, wasting resources?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeDependencies()] [Partial Cascade] If purgeDependencies fails mid-transaction, dependent joints may be partially purged - can this leave the dependency graph in an inconsistent state where some descendants are marked bad but others are not?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [Recursive Stack Overflow] The function recursively calls itself at line 203 for each dependent unit - if an attacker creates a dependency chain 1000+ units deep, can this cause stack overflow (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [Synchronous Recursion Lock] Line 198 uses async.eachSeries which processes dependencies sequentially - if each dependency has 100 children and there are 5 levels, can the O(100^5) operations take hours to complete while holding database connection (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [Cache Update Race] Lines 190-193 update assocKnownBadUnits and assocUnhandledUnits synchronously, but the database queries (lines 194-197) execute later in async.series - can other threads see inconsistent state where caches are updated but database changes haven't committed?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [IN Clause Limit] Line 195 uses WHERE unit IN(?) with arrUnits - if arrUnits contains 10,000+ units, can this exceed SQL IN clause limits or cause query planner performance degradation (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [Unbounded Query Collection] arrQueries array grows with each recursive call but has no size limit - can a deeply branching dependency tree cause arrQueries to contain millions of queries, exhausting memory before COMMIT (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [Peer Notification Leak] onPurgedDependentJoint callback at line 202 receives row.peer but there's no validation - if peer is null or invalid, can downstream notification code crash?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJointsUnderLock()] [Nested Lock Deadlock] Lines 211-217 acquire two mutex locks sequentially (purge_uncovered, then handleJoint) - if another thread tries to acquire these locks in reverse order, can this cause deadlock freezing the network (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJointsUnderLock()] [Lock Skip on Contention] Line 211 uses lockOrSkip - if lock is busy, purging is skipped entirely - can an attacker keep the lock busy to prevent purging indefinitely, causing uncovered bad units to accumulate (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Witness Count Bypass] Line 232 checks for witness units after the bad unit but the commented-out constants.MAJORITY_OF_WITNESSES-1 at line 239 suggests this validation was removed - can bad units be archived prematurely before sufficient witness confirmation?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Archive Timing Race] Lines 231-235 check if witnesses posted after the bad unit OR if it's >10 seconds old - can an attacker exploit the 10-second window to get bad units archived before witness validation occurs?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Query Performance DoS] The complex query at lines 226-237 with multiple NOT EXISTS subqueries and JOINs - if executed on a database with millions of units, can this query take minutes to complete while holding the write mutex lock (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Recursive Purge Loop] Line 280 recursively calls purgeUncoveredNonserialJoints - if bad units keep arriving faster than they're purged, can this create an infinite processing loop (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Write Lock Starvation] Lines 243-287 hold the write mutex for the entire archiving process which includes multiple database queries and kvstore deletions - can this block all other unit writes for extended periods (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [KVStore Deletion Failure] Line 260 deletes from kvstore but if this fails (disk full, permission error), the async.series continues to line 262-265 which forgets the unit from memory - can this cause desynchronization where SQL has unit but kvstore doesn't (Critical: permanent data inconsistency)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Parent Units Access After Forget] Line 262 reads storage.assocUnstableUnits[row.unit].parent_units but line 263 calls storage.forgetUnit(row.unit) - is there a race condition if another thread modifies this structure between lines 262-263?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Non-Atomic Archive] The archiving process spans multiple steps (lines 254-268) - if the process crashes mid-archiving, can a unit be partially archived (removed from active tables but not fully in archived_joints), breaking referential integrity?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Index Selection Hint] Line 224 uses byIndex hint for SQLite - if the index doesn't exist or is corrupted, can this cause the query to fail silently or use a full table scan (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Free Flag Update Race] Lines 274-276 update is_free=1 for orphaned units - if new child units arrive between the query execution and update, can this incorrectly mark units with children as free?",
  "[File: byteball/ocore/joint_storage.js] [Function: readJointsSinceMci()] [Missing Unit Silent Failure] Lines 304-307 use breadcrumbs.add() instead of throwing when unit not found - can this cause silent data loss where expected units are skipped, leading to incomplete DAG reconstruction during sync (High: permanent data inconsistency)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readJointsSinceMci()] [Level Ordering Attack] Line 297 orders by '+level' (unary plus operator) - can specially crafted level values cause incorrect ordering, leading to non-deterministic processing order across nodes (Critical: chain split)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readJointsSinceMci()] [Archived Joint Exclusion] Line 295 excludes archived_joints - if a unit is archived between being selected in the query and being read at line 303, will storage.readJoint fail, causing the entire readJointsSinceMci operation to abort?",
  "[File: byteball/ocore/joint_storage.js] [Function: readJointsSinceMci()] [Unbounded Result Set] The query at lines 294-298 has no LIMIT clause - if mci is genesis (0) and the DAG has millions of units, can this load them all into memory causing OOM (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readJointsSinceMci()] [Serial Processing Bottleneck] Line 300 uses async.eachSeries for sequential processing - if there are 100,000 units to process and each takes 10ms, can this operation take 1000 seconds (Medium: network delay 1 day)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveKnownBadJoint()] [Joint Hash Cache Leak] Line 323 adds to assocKnownBadJoints without size limits - can repeated calls with unique joints exhaust memory (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveKnownBadJoint()] [Database vs Cache Ordering] Line 323 updates cache immediately but database insert (line 325) happens asynchronously - if the database insert fails, will the cache contain joints marked as bad that aren't in the database, causing divergence?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveKnownBadJoint()] [Error String Injection] The error parameter at line 326 is stored directly in database without sanitization - can a crafted error message containing SQL metacharacters or excessive length cause issues?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveKnownBadJoint()] [Callback Before Commit] onDone() is called at line 328 immediately after query submission, not after commit confirmation - can the caller proceed assuming the joint is saved when the database write might still fail?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeOldUnhandledJoints()] [Time-Based Purge Attack] Line 334 purges unhandled joints older than 1 hour - can an attacker time their attack to send malicious units that remain unhandled for 59 minutes, get purged, then resent, evading permanent bad joint tracking?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeOldUnhandledJoints()] [Cache-Database Desync on Deletion] Lines 338-343 delete from database but line 339 updates assocUnhandledUnits synchronously before database deletion completes - if database deletion fails, will the cache be incorrectly cleared?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeOldUnhandledJoints()] [SQL Injection via Unit List] Line 341 builds SQL with strUnitsList using db.escape() on each unit - if the array is very large (10,000+ units), can the resulting SQL string exceed maximum query length (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeOldUnhandledJoints()] [Separate DELETE Race] Lines 342-343 execute two separate DELETE queries without transaction wrapping - if the process crashes between them, can dependencies be left orphaned without their parent unhandled_joints records?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeOldUnhandledJoints()] [Missing Dependent Notification] Units purged here don't trigger any callbacks to notify dependent joints - can this cause dependent joints to remain in dependencies table indefinitely waiting for parents that were purged (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: initUnhandledAndKnownBad()] [Startup Race Condition] Lines 348-361 perform two sequential queries to populate caches - if joints are added to database between these queries complete, can the caches miss newly added entries causing incorrect fresh/stale state after restart?",
  "[File: byteball/ocore/joint_storage.js] [Function: initUnhandledAndKnownBad()] [Unbounded Cache Initialization] Lines 348-350 load ALL unhandled joints into memory - if node was offline and accumulated 1 million unhandled joints, can this cause OOM on startup (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: initUnhandledAndKnownBad()] [Limited Bad Joint History] Line 352 uses LIMIT 1000 for known_bad_joints - if there are 10,000 bad joints and an attacker sends one of the older (not in top 1000), will it be processed again despite being previously marked bad?",
  "[File: byteball/ocore/joint_storage.js] [Function: initUnhandledAndKnownBad()] [Null Handling] Lines 354-357 check if row.unit and row.joint exist before adding to caches - but what if both are null? Will this add null keys to the cache causing later lookups to behave incorrectly?",
  "[File: byteball/ocore/joint_storage.js] [Global: assocKnownBadJoints] [Memory Exhaustion] The assocKnownBadJoints object at line 16 is never cleared or size-limited - can an attacker generate unique invalid joints (by varying content) to grow this cache to gigabytes (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Global: assocKnownBadUnits] [Memory Exhaustion] The assocKnownBadUnits object at line 17 is never garbage collected - over months of operation with thousands of bad units per day, can this cache grow to exhaust memory?",
  "[File: byteball/ocore/joint_storage.js] [Global: assocUnhandledUnits] [Memory Exhaustion] The assocUnhandledUnits object at line 18 tracks all unhandled units - during a sustained network partition where nodes can't reach witnesses, can this cache grow unboundedly (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Dependencies: mutex module] [Lock Fairness] All functions use mutex.lock or mutex.lockOrSkip - if an attacker keeps requesting locks, can they starve legitimate operations via lock contention (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Dependencies: storage module] [Cache Coherency] Multiple functions call storage.setUnitIsKnown() and storage.forgetUnit() - if storage module's internal cache is corrupted or desynchronized, can joint_storage make incorrect decisions about unit status?",
  "[File: byteball/ocore/joint_storage.js] [Cross-function: saveUnhandledJointAndDependencies + readDependentJointsThatAreReady] [TOCTOU Race] If saveUnhandledJointAndDependencies() commits dependencies at the same moment readDependentJointsThatAreReady() is checking for ready joints, can the COUNT query (lines 101-107) return incorrect counts due to uncommitted reads?",
  "[File: byteball/ocore/joint_storage.js] [Cross-function: purgeJointAndDependencies + readDependentJointsThatAreReady] [Deleted Joint Processing] If purgeJointAndDependencies deletes a joint while readDependentJointsThatAreReady is about to process its dependents, can the dependents be processed with invalid parent reference?",
  "[File: byteball/ocore/joint_storage.js] [Cross-function: checkIfNewUnit + purgeJointAndDependencies] [Cache State Race] If checkIfNewUnit is checking a unit (line 29 query) while purgeJointAndDependencies is marking it bad (line 148), can the unit pass checkIfNewUnit as 'new' despite being already marked bad in cache?",
  "[File: byteball/ocore/joint_storage.js] [Cross-function: removeUnhandledJointAndDependencies + saveUnhandledJointAndDependencies] [Delete-Insert Race] If the same unit is being removed by one thread and saved by another simultaneously, can database constraints be violated or can the unit exist in an inconsistent state?",
  "[File: byteball/ocore/joint_storage.js] [Cross-function: purgeOldUnhandledJoints + saveUnhandledJointAndDependencies] [Premature Purge] If purgeOldUnhandledJoints runs while saveUnhandledJointAndDependencies is saving a unit that already has old creation_date (copied from peer), can the unit be immediately purged after being saved?",
  "[File: byteball/ocore/joint_storage.js] [Transaction: Multiple functions] [Isolation Level] No explicit transaction isolation level is set in any BEGIN statement - can READ UNCOMMITTED or READ COMMITTED defaults cause dirty reads between concurrent purge/save operations (Critical: chain split)?",
  "[File: byteball/ocore/joint_storage.js] [Transaction: purgeUncoveredNonserialJoints] [Connection Leak] Lines 244-287 hold a database connection for extended archiving - if an exception is thrown during archiving, is conn.release() (line 277) guaranteed to execute, or can connections leak (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Transaction: saveUnhandledJointAndDependencies] [Rollback on Error] If any query in the transaction (lines 78-81) fails, does async.series properly handle rollback, or can partial state be committed?",
  "[File: byteball/ocore/joint_storage.js] [Query: readDependentJointsThatAreReady] [Subquery Correlated Performance] Line 113 executes a separate query for EACH row returned by the main query (lines 99-108) - if 1000 joints are ready, does this create 1000 sequential database round trips (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Query: findLostJoints] [Stale Timestamp] Line 133 filters by 'creation_date < 8 seconds ago' but doesn't re-validate after the query completes - if query takes 10 seconds to run on large dependencies table, can units that become >8 seconds old during query execution be missed?",
  "[File: byteball/ocore/joint_storage.js] [Error: collectQueriesToPurgeDependentJoints] [Error Object Cloning] The same error string is propagated to all descendants (line 155, 203) - if the original error contains sensitive information or stack traces, can this leak data through the dependency graph?",
  "[File: byteball/ocore/joint_storage.js] [Error: saveKnownBadJoint] [Unchecked Database Errors] Line 324's db.query has no error handling in its callback - if INSERT fails (constraint violation, disk full), the onDone callback still executes, potentially misleading the caller?",
  "[File: byteball/ocore/joint_storage.js] [Error: readJointsSinceMci] [Silent Missing Units] Lines 304-307 log to breadcrumbs instead of propagating errors when units aren't found - can this mask critical data corruption where expected units are missing from storage (High: permanent state divergence)?",
  "[File: byteball/ocore/joint_storage.js] [Network: saveUnhandledJointAndDependencies] [Peer Attribution] The peer parameter (line 70, 79) identifies which peer sent the joint - if this peer string is not validated and contains special characters, can it cause issues in downstream code that uses this value for peer reputation/banning logic?",
  "[File: byteball/ocore/joint_storage.js] [Network: readDependentJointsThatAreReady] [Peer-Based Notification] Line 115 passes internal_row.peer to handleDependentJoint callback - if different peers sent the same joint (duplicates in unhandled_joints), will handleDependentJoint be called multiple times with different peer values, causing duplicate processing?",
  "[File: byteball/ocore/joint_storage.js] [Network: findLostJoints] [Request Amplification] If findLostJoints identifies 100 lost joints and handleLostJoints broadcasts requests to 50 peers, does this create 5000 network requests that could overwhelm peer nodes or network bandwidth (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Dependency: Circular Dependencies] [Deadlock Detection] None of the functions explicitly check for circular dependencies where unit A depends on B, B depends on C, and C depends on A - can such cycles cause infinite loops in collectQueriesToPurgeDependentJoints (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Dependency: Orphaned Dependencies] [Cleanup] If a parent unit is removed from the units table (e.g., via archive) but its dependencies entries are not deleted, can these orphaned dependencies accumulate and degrade query performance over time (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Dependency: Missing Parent Validation] [Invalid References] When saveUnhandledJointAndDependencies creates dependencies (lines 74-76), there's no validation that arrMissingParentUnits contains valid unit hashes - can invalid hashes be inserted causing later queries to fail?",
  "[File: byteball/ocore/joint_storage.js] [Time: purgeUncoveredNonserialJoints] [Clock Skew] Line 231 uses db.addTime('-10 SECOND') to check creation_date - if the database server's clock is skewed forward by 20 seconds relative to application server, can units be prematurely archived?",
  "[File: byteball/ocore/joint_storage.js] [Time: findLostJoints] [NTP Attack] Line 133 uses db.addTime('-8 SECOND') - if an attacker can manipulate NTP to temporarily freeze or slow the clock, can they prevent lost joints from ever being detected?",
  "[File: byteball/ocore/joint_storage.js] [Time: purgeOldUnhandledJoints] [Timezone Issues] Line 334 uses db.addTime('-1 HOUR') - are time zone conversions handled correctly across MySQL vs SQLite, or can this cause inconsistent purging behavior?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewUnit()] [Race Condition] If two threads call checkIfNewUnit() simultaneously for the same unit before either completes the database query at line 29, can both proceed to callbacks.ifNew() causing duplicate processing and potential double-insertion into storage?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewUnit()] [Cache Poisoning] Can an attacker flood the network with invalid units to populate assocKnownBadUnits (line 16) indefinitely, causing memory exhaustion that crashes the node and prevents new transaction processing (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewUnit()] [Stripped Unit Bypass] At lines 32-33, units marked 'final-bad' with MCI below min retrievable are treated as new - can an attacker exploit this by repeatedly sending stripped bad units to trigger reprocessing and validation overhead (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewUnit()] [Storage Inconsistency] If storage.isKnownUnit() returns false (line 22) but the database query (line 29) finds the unit, and storage.setUnitIsKnown() (line 34) fails or is delayed, can the unit be reprocessed multiple times causing non-deterministic behavior?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewUnit()] [Unhandled Unit Cache Bypass] If a unit exists in assocUnhandledUnits (line 24) but gets deleted from the database before line 29's query, will it incorrectly return callbacks.ifKnownUnverified() instead of detecting the inconsistency?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewJoint()] [Joint Hash Collision] At line 47, assocKnownBadJoints is checked by joint hash - if objectHash.getJointHash() has a collision (different joints produce same hash), can a valid joint be incorrectly marked as bad, causing permanent rejection of valid transactions?",
  "[File: byteball/ocore/joint_storage.js] [Function: checkIfNewJoint()] [Cache Desynchronization] If a joint's unit passes checkIfNewUnit() but the joint hash is in assocKnownBadJoints (line 47), can this mismatch cause inconsistent handling where the unit is accepted but the joint is rejected, corrupting DAG structure?",
  "[File: byteball/ocore/joint_storage.js] [Function: removeUnhandledJointAndDependencies()] [Transaction Atomicity] The BEGIN/COMMIT transaction (lines 57-60) performs DELETE operations but assocUnhandledUnits deletion (line 62) occurs after conn.release() - if the process crashes between COMMIT and line 62, will the in-memory cache remain inconsistent with database state?",
  "[File: byteball/ocore/joint_storage.js] [Function: removeUnhandledJointAndDependencies()] [Orphaned Dependencies] If removeUnhandledJointAndDependencies() deletes dependencies at line 59 but another thread is simultaneously adding new dependencies via saveUnhandledJointAndDependencies(), can race conditions create orphaned dependency records?",
  "[File: byteball/ocore/joint_storage.js] [Function: removeUnhandledJointAndDependencies()] [Connection Pool Exhaustion] If onDone callback (line 65) throws an exception or never completes, the connection may not be released properly despite conn.release() (line 63) - can attackers trigger this repeatedly to exhaust the connection pool (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [Memory Leak via Cache] At line 72, assocUnhandledUnits[unit] is set to true without any size limits - can an attacker flood the network with units having missing parents to grow this cache unboundedly, causing memory exhaustion (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [SQL Injection via Array] Lines 74-76 construct SQL with arrMissingParentUnits.map() - if arrMissingParentUnits contains specially crafted unit hashes (despite being escaped), can the resulting SQL exceed query length limits or cause performance degradation (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [JSON Serialization Failure] At line 79, JSON.stringify(objJoint) may fail or produce excessively large strings for maliciously crafted joints - is there size validation before insertion, or can this cause database bloat or insertion failures?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [Dependency Explosion] If arrMissingParentUnits contains hundreds or thousands of entries, the INSERT at lines 74-76 creates that many dependency rows - can attackers flood dependencies table to cause query performance degradation when readDependentJointsThatAreReady() executes (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [Duplicate Insertion] The INSERT uses conn.getIgnore() (lines 79-80) to ignore duplicates, but what if the same unit is saved with different peer values - can this create multiple unhandled_joints rows for the same unit causing processing duplication?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveUnhandledJointAndDependencies()] [Cache-Database Mismatch] If the database transaction COMMIT (line 81) fails but assocUnhandledUnits[unit]=true (line 72) already succeeded, will subsequent calls to checkIfNewUnit() incorrectly think the unit is unhandled when it's actually not in the database?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Lock Inconsistency] At lines 97-98, lock is conditionally set to either mutex.lock or mutex.lockOrSkip based on unit parameter - if unit is null and lockOrSkip returns immediately without acquiring lock, can concurrent executions corrupt the dependency query results?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Query Performance DoS] The query at lines 99-108 performs multiple JOINs and GROUP BY without LIMIT - if an attacker creates a deep dependency chain, can this query take minutes to execute, blocking the mutex lock and preventing other units from being processed (Medium: network delay 1 hour)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Callback Flood] Lines 112-118 call handleDependentJoint for each ready unit without rate limiting - if 10,000+ joints become ready simultaneously, can the callback flood exhaust memory or CPU (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Unlocked Processing] The unlock() at line 119 releases the mutex before all handleDependentJoint callbacks complete (they're queued via db.query at line 113) - can this allow other threads to modify dependencies while callbacks are still processing, causing race conditions?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [JSON Parse Attack] At line 115, JSON.parse(internal_row.json) deserializes user-controlled joint data without validation - can a malicious joint with deeply nested structures cause stack overflow or exponential parsing time (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Timestamp Integer Overflow] Line 115 uses parseInt(internal_row.creation_ts) - if creation_ts is a very large number or NaN, can this cause incorrect timestamp handling in downstream processing?",
  "[File: byteball/ocore/joint_storage.js] [Function: readDependentJointsThatAreReady()] [Missing Parent Race] Between the GROUP BY query completing (line 107) and callbacks executing (lines 112-118), if a parent unit is deleted or marked as bad, will the dependent joints still be processed despite no longer having valid parents?",
  "[File: byteball/ocore/joint_storage.js] [Function: findLostJoints()] [Lock Skip Vulnerability] Line 127 uses lockOrSkip - if the lock is already held, findLostJoints() returns immediately without searching for lost joints - can this cause some lost joints to never be detected if timing is adversarial (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: findLostJoints()] [Time-Based Bypass] The query at line 133 only finds dependencies older than 8 seconds - can an attacker coordinate to repeatedly create and resolve dependencies just under 8 seconds to evade lost joint detection?",
  "[File: byteball/ocore/joint_storage.js] [Function: findLostJoints()] [Callback with Unlocked State] handleLostJoints callback at line 139 is invoked after unlock() at line 136 - if handleLostJoints modifies dependencies, can concurrent findLostJoints() calls interfere with each other?",
  "[File: byteball/ocore/joint_storage.js] [Function: findLostJoints()] [Lost Joint Flood] If handleLostJoints requests all lost joints from peers simultaneously (potentially hundreds), can this overwhelm network bandwidth or peer processing capacity (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeJointAndDependencies()] [Cache Pollution] Line 148 adds to assocKnownBadUnits without size limits - can repeated purging of different bad units cause unbounded memory growth in assocKnownBadUnits cache (Critical: memory exhaustion network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeJointAndDependencies()] [Error Propagation Attack] The same error string is propagated to all dependent joints via collectQueriesToPurgeDependentJoints (line 155) - can an attacker create a deep dependency tree where one bad root unit causes thousands of descendants to be marked bad in a cascade, overwhelming database writes (Medium: network delay 1 day)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeJointAndDependencies()] [Transaction Size Limit] If collectQueriesToPurgeDependentJoints adds hundreds of INSERT/DELETE queries to arrQueries (line 155), can the total transaction size exceed database limits causing COMMIT failure and leaving partial purge state?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeJointAndDependencies()] [Callback Race] onPurgedDependentJoint is called for each purged unit (line 155), but if these callbacks try to access dependencies that are being deleted in the same transaction, can this cause read-after-delete inconsistencies?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeJointAndDependencies()] [Cache Deletion Order] Line 158 deletes from assocUnhandledUnits after COMMIT completes - if the process crashes between lines 157 and 158, will the cache incorrectly retain references to purged units, causing future lookups to return stale data?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeDependencies()] [Missing Unit Insertion] Unlike purgeJointAndDependencies, this function doesn't insert the parent unit into known_bad_joints - can this cause the parent to be re-requested and re-validated repeatedly, wasting resources?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeDependencies()] [Partial Cascade] If purgeDependencies fails mid-transaction, dependent joints may be partially purged - can this leave the dependency graph in an inconsistent state where some descendants are marked bad but others are not?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [Recursive Stack Overflow] The function recursively calls itself at line 203 for each dependent unit - if an attacker creates a dependency chain 1000+ units deep, can this cause stack overflow (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [Synchronous Recursion Lock] Line 198 uses async.eachSeries which processes dependencies sequentially - if each dependency has 100 children and there are 5 levels, can the O(100^5) operations take hours to complete while holding database connection (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [Cache Update Race] Lines 190-193 update assocKnownBadUnits and assocUnhandledUnits synchronously, but the database queries (lines 194-197) execute later in async.series - can other threads see inconsistent state where caches are updated but database changes haven't committed?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [IN Clause Limit] Line 195 uses WHERE unit IN(?) with arrUnits - if arrUnits contains 10,000+ units, can this exceed SQL IN clause limits or cause query planner performance degradation (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [Unbounded Query Collection] arrQueries array grows with each recursive call but has no size limit - can a deeply branching dependency tree cause arrQueries to contain millions of queries, exhausting memory before COMMIT (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: collectQueriesToPurgeDependentJoints()] [Peer Notification Leak] onPurgedDependentJoint callback at line 202 receives row.peer but there's no validation - if peer is null or invalid, can downstream notification code crash?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJointsUnderLock()] [Nested Lock Deadlock] Lines 211-217 acquire two mutex locks sequentially (purge_uncovered, then handleJoint) - if another thread tries to acquire these locks in reverse order, can this cause deadlock freezing the network (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJointsUnderLock()] [Lock Skip on Contention] Line 211 uses lockOrSkip - if lock is busy, purging is skipped entirely - can an attacker keep the lock busy to prevent purging indefinitely, causing uncovered bad units to accumulate (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Witness Count Bypass] Line 232 checks for witness units after the bad unit but the commented-out constants.MAJORITY_OF_WITNESSES-1 at line 239 suggests this validation was removed - can bad units be archived prematurely before sufficient witness confirmation?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Archive Timing Race] Lines 231-235 check if witnesses posted after the bad unit OR if it's >10 seconds old - can an attacker exploit the 10-second window to get bad units archived before witness validation occurs?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Query Performance DoS] The complex query at lines 226-237 with multiple NOT EXISTS subqueries and JOINs - if executed on a database with millions of units, can this query take minutes to complete while holding the write mutex lock (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Recursive Purge Loop] Line 280 recursively calls purgeUncoveredNonserialJoints - if bad units keep arriving faster than they're purged, can this create an infinite processing loop (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Write Lock Starvation] Lines 243-287 hold the write mutex for the entire archiving process which includes multiple database queries and kvstore deletions - can this block all other unit writes for extended periods (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [KVStore Deletion Failure] Line 260 deletes from kvstore but if this fails (disk full, permission error), the async.series continues to line 262-265 which forgets the unit from memory - can this cause desynchronization where SQL has unit but kvstore doesn't (Critical: permanent data inconsistency)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Parent Units Access After Forget] Line 262 reads storage.assocUnstableUnits[row.unit].parent_units but line 263 calls storage.forgetUnit(row.unit) - is there a race condition if another thread modifies this structure between lines 262-263?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Non-Atomic Archive] The archiving process spans multiple steps (lines 254-268) - if the process crashes mid-archiving, can a unit be partially archived (removed from active tables but not fully in archived_joints), breaking referential integrity?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Index Selection Hint] Line 224 uses byIndex hint for SQLite - if the index doesn't exist or is corrupted, can this cause the query to fail silently or use a full table scan (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeUncoveredNonserialJoints()] [Free Flag Update Race] Lines 274-276 update is_free=1 for orphaned units - if new child units arrive between the query execution and update, can this incorrectly mark units with children as free?",
  "[File: byteball/ocore/joint_storage.js] [Function: readJointsSinceMci()] [Missing Unit Silent Failure] Lines 304-307 use breadcrumbs.add() instead of throwing when unit not found - can this cause silent data loss where expected units are skipped, leading to incomplete DAG reconstruction during sync (High: permanent data inconsistency)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readJointsSinceMci()] [Level Ordering Attack] Line 297 orders by '+level' (unary plus operator) - can specially crafted level values cause incorrect ordering, leading to non-deterministic processing order across nodes (Critical: chain split)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readJointsSinceMci()] [Archived Joint Exclusion] Line 295 excludes archived_joints - if a unit is archived between being selected in the query and being read at line 303, will storage.readJoint fail, causing the entire readJointsSinceMci operation to abort?",
  "[File: byteball/ocore/joint_storage.js] [Function: readJointsSinceMci()] [Unbounded Result Set] The query at lines 294-298 has no LIMIT clause - if mci is genesis (0) and the DAG has millions of units, can this load them all into memory causing OOM (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: readJointsSinceMci()] [Serial Processing Bottleneck] Line 300 uses async.eachSeries for sequential processing - if there are 100,000 units to process and each takes 10ms, can this operation take 1000 seconds (Medium: network delay 1 day)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveKnownBadJoint()] [Joint Hash Cache Leak] Line 323 adds to assocKnownBadJoints without size limits - can repeated calls with unique joints exhaust memory (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveKnownBadJoint()] [Database vs Cache Ordering] Line 323 updates cache immediately but database insert (line 325) happens asynchronously - if the database insert fails, will the cache contain joints marked as bad that aren't in the database, causing divergence?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveKnownBadJoint()] [Error String Injection] The error parameter at line 326 is stored directly in database without sanitization - can a crafted error message containing SQL metacharacters or excessive length cause issues?",
  "[File: byteball/ocore/joint_storage.js] [Function: saveKnownBadJoint()] [Callback Before Commit] onDone() is called at line 328 immediately after query submission, not after commit confirmation - can the caller proceed assuming the joint is saved when the database write might still fail?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeOldUnhandledJoints()] [Time-Based Purge Attack] Line 334 purges unhandled joints older than 1 hour - can an attacker time their attack to send malicious units that remain unhandled for 59 minutes, get purged, then resent, evading permanent bad joint tracking?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeOldUnhandledJoints()] [Cache-Database Desync on Deletion] Lines 338-343 delete from database but line 339 updates assocUnhandledUnits synchronously before database deletion completes - if database deletion fails, will the cache be incorrectly cleared?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeOldUnhandledJoints()] [SQL Injection via Unit List] Line 341 builds SQL with strUnitsList using db.escape() on each unit - if the array is very large (10,000+ units), can the resulting SQL string exceed maximum query length (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeOldUnhandledJoints()] [Separate DELETE Race] Lines 342-343 execute two separate DELETE queries without transaction wrapping - if the process crashes between them, can dependencies be left orphaned without their parent unhandled_joints records?",
  "[File: byteball/ocore/joint_storage.js] [Function: purgeOldUnhandledJoints()] [Missing Dependent Notification] Units purged here don't trigger any callbacks to notify dependent joints - can this cause dependent joints to remain in dependencies table indefinitely waiting for parents that were purged (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Function: initUnhandledAndKnownBad()] [Startup Race Condition] Lines 348-361 perform two sequential queries to populate caches - if joints are added to database between these queries complete, can the caches miss newly added entries causing incorrect fresh/stale state after restart?",
  "[File: byteball/ocore/joint_storage.js] [Function: initUnhandledAndKnownBad()] [Unbounded Cache Initialization] Lines 348-350 load ALL unhandled joints into memory - if node was offline and accumulated 1 million unhandled joints, can this cause OOM on startup (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Function: initUnhandledAndKnownBad()] [Limited Bad Joint History] Line 352 uses LIMIT 1000 for known_bad_joints - if there are 10,000 bad joints and an attacker sends one of the older (not in top 1000), will it be processed again despite being previously marked bad?",
  "[File: byteball/ocore/joint_storage.js] [Function: initUnhandledAndKnownBad()] [Null Handling] Lines 354-357 check if row.unit and row.joint exist before adding to caches - but what if both are null? Will this add null keys to the cache causing later lookups to behave incorrectly?",
  "[File: byteball/ocore/joint_storage.js] [Global: assocKnownBadJoints] [Memory Exhaustion] The assocKnownBadJoints object at line 16 is never cleared or size-limited - can an attacker generate unique invalid joints (by varying content) to grow this cache to gigabytes (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Global: assocKnownBadUnits] [Memory Exhaustion] The assocKnownBadUnits object at line 17 is never garbage collected - over months of operation with thousands of bad units per day, can this cache grow to exhaust memory?",
  "[File: byteball/ocore/joint_storage.js] [Global: assocUnhandledUnits] [Memory Exhaustion] The assocUnhandledUnits object at line 18 tracks all unhandled units - during a sustained network partition where nodes can't reach witnesses, can this cache grow unboundedly (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Dependencies: mutex module] [Lock Fairness] All functions use mutex.lock or mutex.lockOrSkip - if an attacker keeps requesting locks, can they starve legitimate operations via lock contention (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Dependencies: storage module] [Cache Coherency] Multiple functions call storage.setUnitIsKnown() and storage.forgetUnit() - if storage module's internal cache is corrupted or desynchronized, can joint_storage make incorrect decisions about unit status?",
  "[File: byteball/ocore/joint_storage.js] [Cross-function: saveUnhandledJointAndDependencies + readDependentJointsThatAreReady] [TOCTOU Race] If saveUnhandledJointAndDependencies() commits dependencies at the same moment readDependentJointsThatAreReady() is checking for ready joints, can the COUNT query (lines 101-107) return incorrect counts due to uncommitted reads?",
  "[File: byteball/ocore/joint_storage.js] [Cross-function: purgeJointAndDependencies + readDependentJointsThatAreReady] [Deleted Joint Processing] If purgeJointAndDependencies deletes a joint while readDependentJointsThatAreReady is about to process its dependents, can the dependents be processed with invalid parent reference?",
  "[File: byteball/ocore/joint_storage.js] [Cross-function: checkIfNewUnit + purgeJointAndDependencies] [Cache State Race] If checkIfNewUnit is checking a unit (line 29 query) while purgeJointAndDependencies is marking it bad (line 148), can the unit pass checkIfNewUnit as 'new' despite being already marked bad in cache?",
  "[File: byteball/ocore/joint_storage.js] [Cross-function: removeUnhandledJointAndDependencies + saveUnhandledJointAndDependencies] [Delete-Insert Race] If the same unit is being removed by one thread and saved by another simultaneously, can database constraints be violated or can the unit exist in an inconsistent state?",
  "[File: byteball/ocore/joint_storage.js] [Cross-function: purgeOldUnhandledJoints + saveUnhandledJointAndDependencies] [Premature Purge] If purgeOldUnhandledJoints runs while saveUnhandledJointAndDependencies is saving a unit that already has old creation_date (copied from peer), can the unit be immediately purged after being saved?",
  "[File: byteball/ocore/joint_storage.js] [Transaction: Multiple functions] [Isolation Level] No explicit transaction isolation level is set in any BEGIN statement - can READ UNCOMMITTED or READ COMMITTED defaults cause dirty reads between concurrent purge/save operations (Critical: chain split)?",
  "[File: byteball/ocore/joint_storage.js] [Transaction: purgeUncoveredNonserialJoints] [Connection Leak] Lines 244-287 hold a database connection for extended archiving - if an exception is thrown during archiving, is conn.release() (line 277) guaranteed to execute, or can connections leak (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Transaction: saveUnhandledJointAndDependencies] [Rollback on Error] If any query in the transaction (lines 78-81) fails, does async.series properly handle rollback, or can partial state be committed?",
  "[File: byteball/ocore/joint_storage.js] [Query: readDependentJointsThatAreReady] [Subquery Correlated Performance] Line 113 executes a separate query for EACH row returned by the main query (lines 99-108) - if 1000 joints are ready, does this create 1000 sequential database round trips (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Query: findLostJoints] [Stale Timestamp] Line 133 filters by 'creation_date < 8 seconds ago' but doesn't re-validate after the query completes - if query takes 10 seconds to run on large dependencies table, can units that become >8 seconds old during query execution be missed?",
  "[File: byteball/ocore/joint_storage.js] [Error: collectQueriesToPurgeDependentJoints] [Error Object Cloning] The same error string is propagated to all descendants (line 155, 203) - if the original error contains sensitive information or stack traces, can this leak data through the dependency graph?",
  "[File: byteball/ocore/joint_storage.js] [Error: saveKnownBadJoint] [Unchecked Database Errors] Line 324's db.query has no error handling in its callback - if INSERT fails (constraint violation, disk full), the onDone callback still executes, potentially misleading the caller?",
  "[File: byteball/ocore/joint_storage.js] [Error: readJointsSinceMci] [Silent Missing Units] Lines 304-307 log to breadcrumbs instead of propagating errors when units aren't found - can this mask critical data corruption where expected units are missing from storage (High: permanent state divergence)?",
  "[File: byteball/ocore/joint_storage.js] [Network: saveUnhandledJointAndDependencies] [Peer Attribution] The peer parameter (line 70, 79) identifies which peer sent the joint - if this peer string is not validated and contains special characters, can it cause issues in downstream code that uses this value for peer reputation/banning logic?",
  "[File: byteball/ocore/joint_storage.js] [Network: readDependentJointsThatAreReady] [Peer-Based Notification] Line 115 passes internal_row.peer to handleDependentJoint callback - if different peers sent the same joint (duplicates in unhandled_joints), will handleDependentJoint be called multiple times with different peer values, causing duplicate processing?",
  "[File: byteball/ocore/joint_storage.js] [Network: findLostJoints] [Request Amplification] If findLostJoints identifies 100 lost joints and handleLostJoints broadcasts requests to 50 peers, does this create 5000 network requests that could overwhelm peer nodes or network bandwidth (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Dependency: Circular Dependencies] [Deadlock Detection] None of the functions explicitly check for circular dependencies where unit A depends on B, B depends on C, and C depends on A - can such cycles cause infinite loops in collectQueriesToPurgeDependentJoints (Critical: network halt)?",
  "[File: byteball/ocore/joint_storage.js] [Dependency: Orphaned Dependencies] [Cleanup] If a parent unit is removed from the units table (e.g., via archive) but its dependencies entries are not deleted, can these orphaned dependencies accumulate and degrade query performance over time (Medium: network delay)?",
  "[File: byteball/ocore/joint_storage.js] [Dependency: Missing Parent Validation] [Invalid References] When saveUnhandledJointAndDependencies creates dependencies (lines 74-76), there's no validation that arrMissingParentUnits contains valid unit hashes - can invalid hashes be inserted causing later queries to fail?",
  "[File: byteball/ocore/joint_storage.js] [Time: purgeUncoveredNonserialJoints] [Clock Skew] Line 231 uses db.addTime('-10 SECOND') to check creation_date - if the database server's clock is skewed forward by 20 seconds relative to application server, can units be prematurely archived?",
  "[File: byteball/ocore/joint_storage.js] [Time: findLostJoints] [NTP Attack] Line 133 uses db.addTime('-8 SECOND') - if an attacker can manipulate NTP to temporarily freeze or slow the clock, can they prevent lost joints from ever being detected?",
  "[File: byteball/ocore/joint_storage.js] [Time: purgeOldUnhandledJoints] [Timezone Issues] Line 334 uses db.addTime('-1 HOUR') - are time zone conversions handled correctly across MySQL vs SQLite, or can this cause inconsistent purging behavior?",
  "[File: byteball/ocore/light.js] [Function: prepareHistory()] [SQL Injection] In the SQL query construction at lines 73-93, can an attacker inject malicious SQL through specially crafted addresses in arrAddresses that bypass db.escape() sanitization, potentially exposing sensitive database contents or causing database corruption leading to network halt?",
  "[File: byteball/ocore/light.js] [Function: prepareHistory()] [Input Validation Bypass] At lines 39-44, if arrAddresses contains addresses that pass ValidationUtils.isValidAddress() but are crafted to exploit downstream SQL query logic, can an attacker retrieve transaction history for addresses they don't own, leaking private financial information?",
  "[File: byteball/ocore/light.js] [Function: prepareHistory()] [DoS via MAX_HISTORY_ITEMS] At lines 99-100, if a light client requests history for addresses with exactly MAX_HISTORY_ITEMS (2000) units repeatedly, can an attacker force the hub to lock the 'prepareHistory' mutex for extended periods (line 103), causing denial of service for other light clients by delaying history requests for >1 hour?",
  "[File: byteball/ocore/light.js] [Function: prepareHistory()] [Race Condition with last_aa_response_id] At line 101, the code captures storage.last_aa_response_id before acquiring mutex lock at line 103. Can a race condition occur where new AA responses are created between reading last_aa_response_id and building the response, causing light clients to miss critical AA response data and potentially make incorrect transaction decisions?",
  "[File: byteball/ocore/light.js] [Function: prepareHistory()] [Known Units Filter Bypass] At line 96, the code filters out units in assocKnownStableUnits. If an attacker provides a large array of fake known_stable_units (passing validation at lines 57-65), can they force the server to process and validate these fake units, causing excessive CPU usage and delaying history preparation for >1 day?",
  "[File: byteball/ocore/light.js] [Function: prepareHistory()] [Witness Proof Manipulation] At lines 105-111, if witnessProof.prepareWitnessProof() returns manipulated arrUnstableMcJoints that appear valid but contain incorrect MCI values, can a light client be tricked into accepting an alternate chain fork, causing permanent chain split requiring hard fork?",
  "[File: byteball/ocore/light.js] [Function: prepareHistory()] [Incomplete Proofchain] At lines 144-145, if objResponse.proofchain_balls is empty and gets deleted, but the joints require proofs for validation, can light clients incorrectly mark units as stable without proper verification, leading to acceptance of double-spend transactions?",
  "[File: byteball/ocore/light.js] [Function: prepareHistory()] [AA Response Timestamp Manipulation] At line 149, the query includes timestamp and creation_date from aa_responses. If these timestamps are manipulated or inconsistent with unit timestamps, can light clients make incorrect time-based decisions in AA formulas, causing unintended AA behavior without direct fund loss?",
  "[File: byteball/ocore/light.js] [Function: prepareHistory()] [Unit Not Found Error Handling] At lines 125-127, if storage.readJoint() throws an error for a unit that should exist, does the error propagate correctly through the async.eachSeries() callback, or could it cause the mutex to remain locked indefinitely, freezing all subsequent history requests and causing network delay 1 day?",
  "[File: byteball/ocore/light.js] [Function: prepareHistory()] [Proofchain Build Failure] At lines 134-137, if proofChain.buildProofChain() fails silently or returns incomplete proofs, can stable units be returned without valid proofs, allowing light clients to accept forged stable units and causing direct loss of funds through acceptance of invalid transactions?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Witness Proof Validation Bypass] At lines 183-188, if witnessProof.processWitnessProof() returns success with manipulated assocLastBallByLastBallUnit mapping that doesn't match actual last balls, can an attacker trick light clients into accepting an invalid stability point, causing permanent chain split requiring hard fork?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Ball Hash Validation Bypass] At lines 200-201, the code validates ball hashes using objectHash.getBallHash(). If an attacker crafts a collision in ball hash computation (exploiting SHA256 weaknesses or implementation bugs), can they substitute malicious unit content while maintaining valid ball hashes, causing direct loss of funds?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Parent Ball Reference Manipulation] At lines 205-207, parent_balls are added to assocKnownBalls without verifying they correspond to actual parent units. Can an attacker inject fake parent_ball references that point to non-existent or manipulated units, corrupting the light client's DAG view and accepting invalid transaction chains?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Skiplist Ball Validation Failure] At lines 208-211, skiplist_balls are trusted without validation. Can an attacker provide fake skiplist_balls that skip over critical stability checkpoints, allowing light clients to accept units as stable when they're not, enabling double-spend attacks?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Joint Hash Validation Insufficient] At line 222, validation.hasValidHashes() is called but the function may not verify all critical fields. Can an attacker modify unit fields (like timestamp, witness list, or messages) after hash validation, causing light clients to store corrupted units and accept invalid transactions?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Timestamp Validation Missing Range Check] At line 224, only ValidationUtils.isPositiveInteger() is checked for timestamp. Can an attacker provide timestamps far in the future or past that pass this check but violate protocol timestamp constraints, causing main chain ordering issues and potential chain split?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [AA Response Validation Without Proof] At lines 231-258, AA responses are explicitly stated as 'trusted without proof'. Can a malicious hub inject fake AA responses that appear legitimate (passing validation checks) but never actually occurred, causing light clients to emit false events and trigger incorrect wallet behavior?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [AA Response MCI Manipulation] At line 237, aa_response.mci is validated as positive integer but not checked against actual unit MCIs. Can an attacker provide AA responses with incorrect MCI values, causing light clients to process responses in wrong order and violating AA execution determinism?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Foreign Trigger Unit Validation Insufficient] At lines 255-256, the code checks if trigger_unit exists in objResponse.joints but not if the AA response actually corresponds to that trigger. Can an attacker associate a legitimate trigger_unit with a fake AA response, causing light clients to believe their transactions triggered responses they didn't?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Response JSON Parsing Vulnerability] At lines 249-254, JSON.parse() is called on aa_response.response without sanitization. Can an attacker inject malicious JSON that exploits parsing vulnerabilities or contains unexpected data types, causing light client crashes or incorrect AA response handling?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Mutex Lock Race Condition] At line 261, mutex.lock(['light_joints']) is acquired but the lock scope spans database queries and unit processing. Can two concurrent processHistory() calls race on database updates between lines 264-350, causing inconsistent is_stable flags or duplicate unit storage?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Existing Unit Detection Race] At lines 264-271, the code checks for existing units but doesn't lock them. Can an attacker send duplicate units in rapid succession that both pass the existence check at line 264, causing both to be processed and creating duplicate database entries that corrupt the DAG?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Stable Unit Re-processing] At lines 296-299, units marked as stable are skipped with console.log. Can an attacker repeatedly send stable units to flood logs and waste processing time, causing CPU exhaustion and network delay 1 hour through log I/O bottleneck?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Sequence Assignment Logic Error] At lines 301-302, sequence is determined by assocProvenUnitsNonserialness[unit]. If this mapping is incorrect or manipulated, can units be marked as 'good' when they should be 'final-bad', allowing double-spend transactions to appear valid in light client wallets?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Final-Bad Voiding Failure] At lines 316-324, final-bad units are voided through archiving.generateQueriesToArchiveJoint(). If this process fails partially or the transaction doesn't commit atomically, can outputs from final-bad units remain spendable, enabling direct loss of funds through double-spend?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [New Unit Insertion Without Full Validation] At line 329, writer.saveJoint() is called for new units but may not perform full validation expected for units received over the network. Can an attacker exploit this to inject invalid units through the light client history API that wouldn't pass normal validation?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Is_spent Flag Fixing Race Condition] At line 338, fixIsSpentFlagAndInputAddress() is called after saving units. Can outputs be spent in transactions received between unit save and is_spent flag fix, causing the flag to incorrectly mark spent outputs as unspent?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Event Emission Timing Attack] At line 340, emitNewMyTransactions() is called before processProvenUnits(). Can an attacker trigger events for unstable transactions that later become proven as final-bad, causing wallet UI to show balance increases that are later voided?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Proven Units Update Atomicity] At lines 279-280, inputs and units tables are updated separately with is_unique=1 and is_stable=1. Can a crash or error between these updates leave database in inconsistent state where inputs are marked unique but units are not stable?",
  "[File: byteball/ocore/light.js] [Function: processHistory()] [Stability Event Emission Logic Error] At lines 284-286, emitStability() returns bEmitted and cb(!bEmitted). If no stability events are emitted (bEmitted=false), does this incorrectly signal success (cb(true)) when it should indicate no updates occurred?",
  "[File: byteball/ocore/light.js] [Function: processAAResponses()] [INSERT IGNORE Race Condition] At line 364, INSERT with db.getIgnore() is used. Can two concurrent calls insert the same aa_response, with one being ignored but both emitting events at lines 378-383, causing duplicate event handling and incorrect wallet state updates?",
  "[File: byteball/ocore/light.js] [Function: processAAResponses()] [Response JSON Re-parsing] At line 371, objAAResponse.response is JSON.parse()'d again after being a string. Can this cause issues if the response field contains malformed JSON that was stored but now fails parsing, causing crashes during event emission?",
  "[File: byteball/ocore/light.js] [Function: processAAResponses()] [Event Emission Without Validation] At lines 378-383, multiple events are emitted without re-validating the AA response data. Can stale or corrupted data from the database trigger events that cause incorrect wallet behavior, such as showing fake incoming payments?",
  "[File: byteball/ocore/light.js] [Function: processAAResponses()] [Creation_date Timestamp Manipulation] At line 365, creation_date is stored without validation. Can an attacker provide AA responses with manipulated creation_date values that cause events to be processed in incorrect chronological order?",
  "[File: byteball/ocore/light.js] [Function: processAAResponses()] [AffectedRows Check Bypass] At line 367, affectedRows===0 is used to avoid re-emitting events. Can database errors or constraints cause affectedRows to be 0 even for new responses, preventing legitimate events from being emitted and causing missing transaction notifications?",
  "[File: byteball/ocore/light.js] [Function: enrichAAResponses()] [Response Unit Not Found Handling] At lines 402-407, if response_unit is not found in light client mode, only a console.log is issued and processing continues. Can this cause incomplete AA response data to be emitted in events, leading to incorrect display of AA execution results?",
  "[File: byteball/ocore/light.js] [Function: enrichAAResponses()] [Response String vs Object Inconsistency] At lines 394-395, response is conditionally parsed if it's a string. Can inconsistent data types in the database cause some responses to be parsed multiple times or not at all, corrupting the response data structure?",
  "[File: byteball/ocore/light.js] [Function: enrichAAResponses()] [SetImmediate Stack Interruption] At lines 397-399, setImmediate/setTimeout is used to interrupt the call stack. Can this delay processing in a way that allows race conditions with concurrent database operations on the same AA responses?",
  "[File: byteball/ocore/light.js] [Function: enrichAAResponses()] [Response Unit Read Race] At line 401, storage.readJoint() is called without locking. Can the response_unit be deleted or modified between the read attempt and callback, causing objResponseUnit to reference stale or invalid data?",
  "[File: byteball/ocore/light.js] [Function: fixIsSpentFlag()] [Double-spend Window] At lines 424-428, the query identifies outputs that should be marked spent. Between query execution and update execution (line 436), can another transaction spend these outputs again, causing a race condition that allows double-spending?",
  "[File: byteball/ocore/light.js] [Function: fixIsSpentFlag()] [Partial Update Failure] At lines 433-438, updates are performed in series via async.series(). If some updates succeed and others fail, can the database be left in an inconsistent state with some spent outputs still marked as unspent?",
  "[File: byteball/ocore/light.js] [Function: fixIsSpentFlag()] [Type Filter Limitation] At line 427, only type='transfer' outputs are considered. Can other output types (e.g., headers_commission, witnessing) remain incorrectly marked as unspent, causing balance calculation errors or allowing invalid spending?",
  "[File: byteball/ocore/light.js] [Function: fixIsSpentFlag()] [New Units Array Manipulation] The arrNewUnits parameter comes from processHistory(). Can an attacker manipulate this array to exclude certain units, preventing their spent outputs from being fixed and maintaining spendable outputs that should be marked spent?",
  "[File: byteball/ocore/light.js] [Function: fixInputAddress()] [Address Validation Missing] At lines 444-448, the query retrieves output addresses and uses them to update inputs. Can corrupted or invalid addresses in the outputs table propagate to inputs table, causing address-based queries to return incorrect results?",
  "[File: byteball/ocore/light.js] [Function: fixInputAddress()] [Atomic Update Failure] Similar to fixIsSpentFlag(), async.series() is used for updates. Can partial failures leave some inputs without addresses while others are updated, breaking address-based balance queries?",
  "[File: byteball/ocore/light.js] [Function: fixInputAddress()] [Type Filter Limitation] Only type='transfer' is filtered. Can non-transfer inputs remain without addresses, causing incomplete transaction history for addresses?",
  "[File: byteball/ocore/light.js] [Function: fixInputAddress()] [Missing NULL Address Validation] The query filters inputs.address IS NULL but doesn't validate that outputs.address is NOT NULL. Can NULL addresses from outputs be copied to inputs, creating invalid database state?",
  "[File: byteball/ocore/light.js] [Function: determineIfHaveUnstableJoints()] [Empty Address Array Handling] At lines 472-473, empty array returns false immediately. Can this cause incorrect assumptions about wallet state when addresses are legitimately empty, potentially skipping important sync operations?",
  "[File: byteball/ocore/light.js] [Function: determineIfHaveUnstableJoints()] [LIMIT 1 Optimization Risk] At line 480, LIMIT 1 is used for performance. Can this miss edge cases where multiple unstable joints exist with different stability states, causing incomplete sync detection?",
  "[File: byteball/ocore/light.js] [Function: determineIfHaveUnstableJoints()] [Sequence Filter Logic] At lines 476-479, only sequence='good' is checked. Can temp-bad or final-bad units that need reprocessing be missed by this check, causing wallets to appear synced when they're not?",
  "[File: byteball/ocore/light.js] [Function: getSqlToFilterMyUnits()] [SQL Injection via Unit Array] At line 489, arrUnits are escaped and joined but no validation is performed on the array contents. Can malformed unit hashes bypass db.escape() and inject SQL in the multiple UNION queries?",
  "[File: byteball/ocore/light.js] [Function: getSqlToFilterMyUnits()] [Duplicate Unit Detection] The function uses multiple UNION queries without DISTINCT. Can duplicate units in the input array cause duplicate results, leading to multiple event emissions for the same unit?",
  "[File: byteball/ocore/light.js] [Function: getSqlToFilterMyUnits()] [Shared Address vs My Address Priority] At lines 490-496, both my_addresses and shared_addresses are checked. Can ambiguity in ownership cause incorrect event emission, such as emitting 'my_stable' events for shared addresses that should have different handling?",
  "[File: byteball/ocore/light.js] [Function: getSqlToFilterMyUnits()] [Watched Address Security] At lines 498-500, my_watched_addresses are included. Can an attacker who gains ability to add watched addresses trigger events for addresses they don't own, causing false transaction notifications?",
  "[File: byteball/ocore/light.js] [Function: emitStability()] [Event Emission Race Condition] At lines 510-513, events are emitted without locks. Can concurrent emitStability() calls emit duplicate 'my_stable-<unit>' events, causing wallet logic to process the same stabilization multiple times?",
  "[File: byteball/ocore/light.js] [Function: emitStability()] [OnDone Callback Timing] At line 508, onDone(ownUnits.length > 0) is called before event emission. Can the callback return control to caller while events are still being emitted asynchronously, causing race conditions in caller logic?",
  "[File: byteball/ocore/light.js] [Function: emitStability()] [Not_my_stable Event Logic] At lines 515-517, 'not_my_stable' events are emitted for units not owned by the user. Can these events leak information about other users' transactions being stabilized, creating privacy concerns?",
  "[File: byteball/ocore/light.js] [Function: emitStability()] [Array Difference Operation] At line 515, _.difference() is used. Can large arrays cause performance issues, delaying event emission and causing units to be processed in incorrect order?",
  "[File: byteball/ocore/light.js] [Function: emitNewMyTransactions()] [Duplicate Event Emission] Similar to emitStability(), can concurrent calls emit duplicate 'new_my_unit-<unit>' events, causing wallet UI to show duplicate transaction notifications?",
  "[File: byteball/ocore/light.js] [Function: emitNewMyTransactions()] [Event Emission Without Validation] At lines 527-530, events are emitted without re-checking if units are still valid or sequence is still good. Can invalidated units trigger events that cause incorrect balance updates?",
  "[File: byteball/ocore/light.js] [Function: updateAndEmitBadSequenceUnits()] [Retry Delay Exponential Backoff Cap] At lines 541-542, retryDelay is capped at 6400ms and function returns. Can units that take longer to validate be permanently missed, causing their sequence to remain 'good' when it should be 'temp-bad', allowing invalid spending?",
  "[File: byteball/ocore/light.js] [Function: updateAndEmitBadSequenceUnits()] [Concurrent Update Race] At line 551, UPDATE units SET sequence='temp-bad' is performed without locking. Can concurrent calls update the same units multiple times, causing database contention or incorrect sequence state?",
  "[File: byteball/ocore/light.js] [Function: updateAndEmitBadSequenceUnits()] [Is_stable=0 Filter] At line 551, only units with is_stable=0 are updated. Can stable units with bad sequence bypass this update, remaining marked as good and causing incorrect transaction history?",
  "[File: byteball/ocore/light.js] [Function: updateAndEmitBadSequenceUnits()] [Event Emission for Already-Bad Units] At lines 552-556, events are emitted even if sequence was already temp-bad. Can duplicate 'sequence_became_bad' events cause wallet logic to double-process the sequence change?",
  "[File: byteball/ocore/light.js] [Function: updateAndEmitBadSequenceUnits()] [Recursive Call Stack Overflow] At lines 547-549, the function recursively calls itself with increasing delays. Can a large batch of arrNotSavedUnits cause stack overflow or exhaust system timers, causing DoS?",
  "[File: byteball/ocore/light.js] [Function: prepareParentsAndLastBallAndWitnessListUnit()] [Witness Address References Check] At lines 571-573, if witnesses have references in their addresses, an error is returned. Can an attacker register as a witness with a time-locked or complex definition that initially has no references but later develops references, causing units referencing these witnesses to be rejected and freezing transactions?",
  "[File: byteball/ocore/light.js] [Function: prepareParentsAndLastBallAndWitnessListUnit()] [Database Connection Release Timing] At line 582, conn.release() is called after parentComposer.pickParentUnitsAndLastBall() completes. Can errors in witness validation or subsequent processing leave the connection unreleased, causing connection pool exhaustion and network delay 1 hour?",
  "[File: byteball/ocore/light.js] [Function: prepareParentsAndLastBallAndWitnessListUnit()] [TPS Fee Calculation Race] At lines 603-609, TPS fees are calculated based on current database state. Can concurrent transactions alter the TPS balance between calculation and actual unit composition, causing under-paid units to be rejected or over-paid fees?",
  "[File: byteball/ocore/light.js] [Function: prepareParentsAndLastBallAndWitnessListUnit()] [V5 Light Bug Workaround] At lines 593-596, a workaround for buggy v5.0.0 light clients sets tps_fee=0 if no addresses are provided. Can attackers using old light client versions exploit this to avoid paying TPS fees, gaining unfair advantage in high-traffic periods?",
  "[File: byteball/ocore/light.js] [Function: prepareParentsAndLastBallAndWitnessListUnit()] [max_aa_responses Validation] At line 567, max_aa_responses is only validated as non-negative integer. Can an attacker provide extremely large values that cause integer overflow in TPS fee calculation at line 605, resulting in negative or zero fees?",
  "[File: byteball/ocore/light.js] [Function: prepareParentsAndLastBallAndWitnessListUnit()] [Output Addresses AA Detection] At line 603, AA addresses are detected in arrOutputAddresses. Can an attacker craft addresses that look like AAs but aren't, or vice versa, manipulating the TPS fee calculation to pay less than required?",
  "[File: byteball/ocore/light.js] [Function: prepareParentsAndLastBallAndWitnessListUnit()] [First Address TPS Fee Payment] At line 607, TPS fees are paid by arrFromAddresses[0] only. Can an attacker structure transactions with a low-balance address first to avoid TPS fees, or cause legitimate transactions to fail due to insufficient fees in the first address?",
  "[File: byteball/ocore/light.js] [Function: prepareParentsAndLastBallAndWitnessListUnit()] [TPS Balance Historical Lookup] At line 607, tps_fees_balance is queried with mci<=last_stable_mc_ball_mci. Can this query return stale balance data if recent TPS fee payments haven't been stabilized yet, causing incorrect fee calculations?",
  "[File: byteball/ocore/light.js] [Function: prepareParentsAndLastBallAndWitnessListUnit()] [Witness List Unit Missing] At lines 612-615, witness_list_unit may be null for older MCIs. Can this cause issues for clients expecting this field, potentially causing unit composition failures or validation rejections?",
  "[File: byteball/ocore/light.js] [Function: prepareParentsAndLastBallAndWitnessListUnit()] [Timestamp Manipulation] At line 575, timestamp is generated as Math.round(Date.now()/1000). Can system clock manipulation on the server affect timestamp values, causing units to have incorrect timestamps that violate protocol constraints?",
  "[File: byteball/ocore/light.js] [Function: prepareLinkProofs()] [Single Element Chain Rejection] At lines 627-628, chains of one element are rejected with error. Can this prevent legitimate proof requests for adjacent units, causing light clients to fail to verify spend chains?",
  "[File: byteball/ocore/light.js] [Function: prepareLinkProofs()] [Mutex Lock Timeout] At line 629, mutex.lock(['prepareLinkProofs']) is acquired but no timeout is specified. Can a long-running proof creation cause the mutex to be held indefinitely, blocking all concurrent prepareLinkProofs() calls and causing network delay 1 day?",
  "[File: byteball/ocore/light.js] [Function: prepareLinkProofs()] [Array Index Assumptions] At lines 632-638, the code assumes arrUnits[i-1] and arrUnits[i] are valid. Can malformed input arrays cause array index errors that crash the node, causing network halt?",
  "[File: byteball/ocore/light.js] [Function: prepareLinkProofs()] [Error Propagation Failure] At lines 639-643, if createLinkProof() returns an error, it's passed to callbacks.ifError(). Can error messages leak sensitive database information or unit details that help attackers understand the DAG structure?",
  "[File: byteball/ocore/light.js] [Function: createLinkProof()] [Later Unit Not Found] At lines 652-654, if later_unit is not found, an error is returned. Can an attacker request proofs for non-existent units to probe which units exist in the database, leaking transaction graph information?",
  "[File: byteball/ocore/light.js] [Function: createLinkProof()] [Earlier Unit Not Found] At lines 661-663, similar error for earlier_unit. Can this be exploited in a DoS attack by requesting proofs for many non-existent units, wasting server resources?",
  "[File: byteball/ocore/light.js] [Function: createLinkProof()] [MCI Comparison Logic Error] At lines 667-668, the code checks if later_mci < earlier_mci and returns 'not included'. Can units with NULL MCIs bypass this check, allowing proofs to be created for units that aren't actually linked in the DAG?",
  "[File: byteball/ocore/light.js] [Function: createLinkProof()] [Last Ball MCI Calculation] At line 659, later_lb_mci is retrieved from last_ball_unit properties. Can manipulated last_ball_unit references cause incorrect MCI calculations, leading to invalid proof chains being accepted?",
  "[File: byteball/ocore/light.js] [Function: createLinkProof()] [Inclusion Check Bypass] At lines 676-678, graph.determineIfIncluded() determines if earlier_unit is included in later_unit. Can this check be bypassed through race conditions or database inconsistencies, allowing proofs for non-included units?",
  "[File: byteball/ocore/light.js] [Function: createLinkProof()] [ProofChain Build Failure] At lines 670-673, proofChain.buildProofChain() is called but error handling is absent. Can failures in proof chain building silently succeed, creating incomplete proofs that light clients can't verify?",
  "[File: byteball/ocore/light.js] [Function: createLinkProof()] [Unconfirmed Output Spending Path] At lines 675-682, if output was unconfirmed when spent, buildPath() is called. Can this create unbounded proof chains for deeply nested unconfirmed transactions, causing memory exhaustion?",
  "[File: byteball/ocore/light.js] [Function: buildPath()] [Recursive Stack Overflow] The function uses nested callbacks with goUp() and buildPathToEarlierUnit(). Can deeply nested DAG structures cause stack overflow, crashing the node and causing network halt?",
  "[File: byteball/ocore/light.js] [Function: buildPath()] [Best Parent Chain Following] At lines 710-712, the query follows best_parent_unit. Can manipulated best_parent relationships (due to database corruption or race conditions) create infinite loops or incorrect paths?",
  "[File: byteball/ocore/light.js] [Function: buildPath()] [MCI Comparison with NULL] At lines 718-719, MCI is compared with NULL checks. Can edge cases where both units have NULL MCI cause the comparison logic to fail, creating invalid paths?",
  "[File: byteball/ocore/light.js] [Function: buildPath()] [Inclusion Check Async Race] At line 720, graph.determineIfIncluded() is awaited. Can concurrent database modifications during this check cause race conditions where the inclusion result is stale by the time buildPathToEarlierUnit() is called?",
  "[File: byteball/ocore/light.js] [Function: buildPath()] [Parent Selection from Multiple Parents] At lines 746-760, when multiple parents exist, async.eachSeries() searches for one that includes earlier_unit. Can this fail to find any valid parent if inclusion checks are inconsistent, throwing an error and failing proof generation?",
  "[File: byteball/ocore/light.js] [Function: buildPath()] [MCI Undefined Check] At lines 731-732, if MCI is undefined, an error is thrown. Can race conditions during unit storage leave MCI undefined temporarily, causing legitimate proof requests to fail during sync periods?",
  "[File: byteball/ocore/light.js] [Function: buildPath()] [No Parents Found Error] At lines 738-739, if no parents are found with same MCI, an error is thrown. Can database inconsistencies cause this error for valid DAG structures, preventing proof generation?",
  "[File: byteball/ocore/light.js] [Function: buildPath()] [Same Unit Early Exit] At lines 765-766, if later and earlier units are the same, onDone() is called immediately. Can this bypass necessary validation steps that should occur even for self-proofs?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [First Element Validation] At lines 772-774, only the first element is checked against arrUnits[0]. Can an attacker provide a valid first element but manipulate subsequent elements to inject fake proof chains?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [Known Units Bootstrap] At line 777, assocKnownUnits[arrUnits[0]] is set to true without validating arrUnits[0] exists or is valid. Can attackers initialize the known units set with fake units, allowing entire fake proof chains to validate?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [Hash Validation Bypass] At line 786, validation.hasValidHashes() is called but may not check all fields. Can attackers modify non-validated fields after hash validation to inject malicious data into validated proof chains?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [Last Ball Reference Validation] At lines 788-789, last_ball and last_ball_unit are added to known sets without validation. Can fake last ball references be injected to create false stability checkpoints?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [Parent Unit Trust Propagation] At lines 790-792, parent_units are added to assocKnownUnits without validation. Can a single valid joint with fake parent_unit references poison the entire known units set, allowing fake proofs?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [Ball Hash Validation Formula] At line 798, ball hash is validated using objectHash.getBallHash(). Can differences in hash calculation between client and server (due to version differences or bugs) cause legitimate proofs to be rejected?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [Genesis Unit Exception] At lines 800-803, GENESIS_UNIT is exempted from parent_balls checks. Can attackers exploit this by claiming units are descendants of GENESIS_UNIT without proper validation?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [Skiplist Ball Trust Propagation] At lines 804-807, skiplist_balls are trusted and added to known balls. Can fake skiplist references create shortcuts in proof validation, allowing attackers to skip critical validation checkpoints?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [Unknown Ball Error] At lines 796-797, if ball is not in assocKnownBalls, an error is returned. Can this be bypassed by providing balls in a specific order that causes all balls to appear known?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [Unit Not Found in Chain] At lines 814-816, if any requested unit is not found in assocKnownUnits, an error is returned. Can partial proof chains pass validation if they don't include all requested units due to indexing errors?",
  "[File: byteball/ocore/light.js] [Function: processLinkProofs()] [Chain Element Type Validation] At lines 780-811, elements are validated as either joints or balls based on field presence. Can ambiguous elements with both joint and ball fields confuse validation logic?",
  "[File: byteball/ocore/light.js] [Integration: prepareHistory + processHistory] Can a malicious hub prepare history with valid witness proofs but manipulated joint data, exploiting the fact that processHistory trusts witness proofs to skip full validation, allowing invalid units to be stored?",
  "[File: byteball/ocore/light.js] [Integration: processHistory + writer.saveJoint] At line 329, units are saved with sequence from proofchain analysis. Can inconsistencies between proofchain sequence determination and writer.saveJoint's validation cause units to be saved with incorrect sequence, enabling double-spends?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [SQL Injection] In the query at lines 73-76 where address list is constructed using db.escape() and string concatenation, can an attacker register addresses containing escape sequence bypass characters that break out of the IN() clause to inject arbitrary SQL, potentially deleting units table or exfiltrating private keys from the database?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [SQL Injection] The query at line 134 concatenates escaped addresses using join(', '), but if db.escape() is implemented incorrectly or has edge cases with Unicode characters, can an attacker craft addresses that survive escaping and inject malicious SQL to mark unstable units as stable, bypassing double-spend detection?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [SQL Injection - UNION attack] At lines 74-76, the query uses UNION to combine results from unit_authors and outputs tables - can an attacker register an address that closes the IN clause early and appends a UNION SELECT to retrieve witness private keys or other sensitive data from unrelated tables?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Database Transaction Atomicity] The query at lines 86-92 reads MAX(main_chain_index) without explicit transaction isolation - if a new stable unit is committed between the query execution and history refresh, can this create a gap in the light client's history where units are missed, potentially hiding double-spends or invalid transactions?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: new_address] [SQL Injection] At line 109, the DELETE query uses a parameterized query with address, but at line 115, the same address is passed to refreshLightClientHistory() which constructs SQL at line 71 - can an attacker register multiple addresses where one bypasses db.escape() due to encoding differences, causing SQL injection in the prepareRequestForHistory() path while the DELETE succeeds?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: connected] [SQL Injection] At line 126, addresses are selected from unprocessed_addresses table, then at line 134, these are used in a DELETE statement with db.escape() - if the unprocessed_addresses table was previously corrupted by SQL injection, can malicious address values be retrieved and used to inject SQL in the DELETE statement, dropping the units table entirely?",
  "[File: byteball/ocore/light_wallet.js] [Function: archiveDoublespendUnits()] [SQL Injection via column name] At line 223, the query conditionally uses 'rowid' or 'creation_date' based on conf.storage - can an attacker modify conf.storage to inject arbitrary column names or SQL fragments into the ORDER BY clause, causing the query to leak sensitive data through error messages or timing side channels?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: new_my_transactions] [SQL Injection] At line 244, arrUnits is mapped through db.escape() and joined - but if arrUnits contains non-string values (objects, arrays, null) that db.escape() doesn't handle correctly, can this result in SQL injection that modifies the outputs table to mark attacker's addresses as owners of victim's assets?",
  "[File: byteball/ocore/light_wallet.js] [Function: reconnectToLightVendor()] [Race Condition - bLightVendor flag] At lines 32-33, the function checks ws.bLightVendor to detect if already connected, but this check happens AFTER the connection is established - can two concurrent calls to reconnectToLightVendor() both pass the check and set ws.bLightVendor=true at line 189, causing duplicate history refresh requests that process the same units twice and corrupt balance calculations?",
  "[File: byteball/ocore/light_wallet.js] [Function: reconnectToLightVendor()] [Race Condition - bRefreshingHistory flag] At lines 34-35, the function checks ws.bRefreshingHistory but doesn't use any mutex - if reconnectToLightVendor() is called simultaneously from the 60-second interval timer (line 23) and the 'connected' event handler (line 24), can both threads proceed to refreshLightClientHistory() causing concurrent history processing and DAG corruption?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Race Condition - bFirstRefreshStarted] At lines 156-159, bFirstRefreshStarted is checked and set without atomicity - if two calls to refreshLightClientHistory() execute simultaneously on startup, can both skip archiveDoublespendUnits(), causing unstable units older than 1 day to remain in the database and enabling double-spend attacks through reuse of archived unit references?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Race Condition - bRefreshingHistory flag check/set] At lines 175-178, the code checks ws.bRefreshingHistory and sets it to true in separate statements without atomic compare-and-swap - can two concurrent full refresh requests both pass the check at line 176, then both set the flag at line 178, causing two simultaneous history processing operations that write conflicting unit data and corrupt the DAG structure?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Race Condition - bFirstHistoryReceived] At lines 208-212, bFirstHistoryReceived is set to true and 'first_history_received' event is emitted - if multiple history refreshes complete simultaneously (e.g., selective + full), can the event be emitted multiple times causing event handlers to execute duplicate operations like re-composing already sent transactions, resulting in double-spends?",
  "[File: byteball/ocore/light_wallet.js] [Function: waitUntilHistoryRefreshDone()] [Race Condition - callback execution] At lines 269-276, the function checks ws.bRefreshingHistory at line 272 and registers a callback at line 275 - if refresh completes between these lines, can the callback never fire, causing the waiting operation to hang indefinitely and blocking transaction composition, effectively freezing user funds until restart?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [TOCTOU - selective vs full refresh] At lines 180-184, selective refresh is delayed if full refresh is ongoing, but the checks for ws.bRefreshingHistory and isFirstHistoryReceived() are separate - can an attacker trigger selective refresh exactly when first history completes but before bRefreshingHistory is cleared, bypassing the delay and causing concurrent processing that corrupts address history?",
  "[File: byteball/ocore/light_wallet.js] [Global State] [Race Condition - bFirstHistoryReceived across restarts] At line 209, bFirstHistoryReceived is set but never persisted to database - if the light client crashes after setting this flag but before processing all history, can the restart cause the client to skip requesting critical units, leaving permanent gaps in transaction history that hide double-spends affecting the user?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Race Condition - finish() callback] At lines 161-170, the finish() callback is defined but can be called from multiple paths (lines 172, 188, 194, 203, 207) - if an error occurs after ws.bRefreshingHistory is set but the callback is invoked multiple times due to exception handling, can this cause the flag to be cleared prematurely while another refresh is still processing, leading to concurrent history updates?",
  "[File: byteball/ocore/light_wallet.js] [Function: setLightVendorHost()] [Man-in-the-Middle - URL substitution] At lines 17-18, if network.light_vendor_url is already set, the function logs a warning but doesn't prevent the new host from being used in subsequent calls - can an attacker who compromises the application after initial setup call setLightVendorHost() again with a malicious server, causing all future history requests to go to the attacker's server which returns fake units that steal user funds?",
  "[File: byteball/ocore/light_wallet.js] [Function: setLightVendorHost()] [Domain Replacement Attack] At line 19, the function replaces 'byteball.org/' with 'obyte.org/' in the host string - can an attacker register addresses or send units with data fields containing 'byteball.org/' followed by malicious JavaScript that gets executed when this replacement is applied to data fields instead of just the vendor host?",
  "[File: byteball/ocore/light_wallet.js] [Function: setLightVendorHost()] [Downgrade Attack - WS_PROTOCOL] At line 20, the light_vendor_url is constructed using conf.WS_PROTOCOL without validation - if conf.WS_PROTOCOL is set to 'ws://' instead of 'wss://', can an attacker perform MITM on the unencrypted connection to inject malicious history responses that replace stable units with fake ones, allowing theft of user funds?",
  "[File: byteball/ocore/light_wallet.js] [Function: reconnectToLightVendor()] [Vendor Impersonation] At line 29, the function calls network.findOutboundPeerOrConnect() but doesn't verify the peer's identity or certificate - can an attacker perform DNS poisoning or BGP hijacking to redirect connections to a malicious light vendor that returns fake history showing the attacker owns all user addresses?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Light Vendor Response Validation] At lines 190-195, the function receives response from light vendor and checks response.error, but what if the vendor returns response.error = null but with a massive history object exceeding memory limits - can this cause memory exhaustion DoS that crashes the light client, preventing users from accessing funds until they connect to a different vendor?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Malicious History - Unit Flooding] At line 199, light.processHistory() is called with the response from light vendor - if the vendor returns millions of fake unstable units all referencing user addresses, can the processing cause database bloat, CPU exhaustion, and permanent slowdown that prevents the light client from confirming new transactions for >24 hours (Critical: network shutdown)?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Witness List Tampering] At line 199, objRequest.witnesses is passed to light.processHistory() - if the light vendor has an old cached version of user's witness list and returns history based on incompatible witnesses, can this cause the light client to accept units that are invalid according to its current witness list, leading to a permanent chain split when the client tries to compose new transactions?",
  "[File: byteball/ocore/light_wallet.js] [Function: archiveDoublespendUnits()] [Light Vendor History Omission] At lines 228-235, the function requests joints from light vendor and archives units if joint_not_found - can a malicious light vendor claim joint_not_found=true for units that DO exist but contain evidence of the vendor's own double-spend attempts, causing the client to archive valid units and miss fraud detection?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Selective History Withholding] At lines 186-188, if objRequest is null (no addresses or unstable units), refresh is skipped - can an attacker who compromises witness list management cause prepareRequestForHistory() to return null by ensuring myWitnesses returns empty array, preventing the client from ever receiving history and permanently freezing all funds?",
  "[File: byteball/ocore/light_wallet.js] [Network Layer] [Vendor Connection Monopoly] At lines 23-24, reconnection happens on both timer and 'connected' event - if light_vendor_url is set to a malicious vendor, can that vendor monopolize all connections by disconnecting and reconnecting in a loop, preventing the client from ever connecting to honest peers who could provide correct history?",
  "[File: byteball/ocore/light_wallet.js] [Function: readListOfUnstableUnits()] [Double-Spend Window] At line 41, the query selects units WHERE is_stable=0 without any time-based filtering - if an attacker creates a double-spend with one branch having unstable units from 6 months ago and another branch confirmed today, can the history refresh at line 65 request all old unstable units, causing the vendor to return the attacker's preferred branch and hide the valid branch that already spent the user's funds?",
  "[File: byteball/ocore/light_wallet.js] [Function: archiveDoublespendUnits()] [Premature Archiving] At line 224, units unstable for >1 day are selected for archiving - but if network congestion or witness downtime legitimately delays confirmation beyond 1 day, can honest user transactions be incorrectly archived at line 233, causing the user to lose track of their own pending transactions and enabling an attacker to double-spend those outputs?",
  "[File: byteball/ocore/light_wallet.js] [Function: archiveDoublespendUnits()] [Archival Bypass] At lines 228-235, archival only happens if light vendor returns joint_not_found, but the function doesn't verify the vendor's claim - can a compromised light vendor always return the joint (even for double-spends) to prevent archiving, keeping both branches of a double-spend active in the database and allowing the attacker to alternate between them when composing transactions?",
  "[File: byteball/ocore/light_wallet.js] [Function: archiveDoublespendUnits()] [Descendant Archival] At line 233, storage.archiveJointAndDescendantsIfExists() is called - if this archives not just the double-spend but also all descendant units, can an attacker create a double-spend that descendants from valid user transactions depend on, causing those valid transactions to be archived and the user to lose funds permanently?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: new_my_transactions] [Asset Proof Race] At lines 244-249, when new transactions arrive, the code requests proofs for assets, but this happens AFTER the transactions are already considered confirmed - if the light vendor provides fake asset proofs showing the assets don't exist, can this retroactively invalidate the transaction and cause the user's balance calculations to become permanently corrupted?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Known Stable Units Manipulation] At line 79, known_stable_units are set based on current database state - if an attacker poisons the database with fake stable units (e.g., via SQL injection or vendor compromise), can the history request tell the vendor 'I already have these stable units', causing the vendor to omit them and the client to miss detection of double-spends that invalidate those units?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Unstable Unit Request Injection] At lines 63-65, unstable units are added to requested_joints - if an attacker can inject unit hashes into the units table with is_stable=0 (via SQL injection or compromised light.processHistory()), can they cause the client to request attacker-controlled fake units that the vendor provides, corrupting the client's DAG?",
  "[File: byteball/ocore/light_wallet.js] [Global State] [bRefreshHistoryOnNewAddress bypass] At lines 102-105 and 107-117, exports.bRefreshHistoryOnNewAddress controls whether history is refreshed on new addresses - can an attacker who gains code execution disable this by setting exports.bRefreshHistoryOnNewAddress=false, then register addresses that receive payments but never sync history, causing the user to be unaware of received funds that the attacker later steals using a different client?",
  "[File: byteball/ocore/light_wallet.js] [Global State] [bRefreshFullHistory disable attack] At line 103, exports.bRefreshFullHistory can be set to false - if an attacker disables this before the first history refresh completes at line 152, can this cause the light client to never sync its full history, leaving it in a state where all previous transactions are unknown and the user appears to have zero balance despite owning funds?",
  "[File: byteball/ocore/light_wallet.js] [Global State] [bRefreshHistory disable attack] At line 104, exports.bRefreshHistory can be set to false - if this is disabled after bFirstHistoryReceived is set but before subsequent refreshes, can the client miss new transactions and witness proofs, causing its view of the main chain to diverge from the network and all future transactions to be rejected as invalid?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Event emission ordering] At lines 155, 169, 211, the function emits events 'refresh_light_started', 'refresh_light_done', 'first_history_received' - if event handlers for these events modify state that affects concurrent refreshes, can this create race conditions where address registration during refresh causes the refresh to be restarted mid-processing, corrupting the DAG?",
  "[File: byteball/ocore/light_wallet.js] [Function: isFirstHistoryReceived()] [State Query Race] At line 253-255, this function returns bFirstHistoryReceived without any locking - if transaction composition in wallet.js checks this value, decides to proceed, but then bFirstHistoryReceived changes before the transaction is submitted, can the transaction be composed with incomplete history data that causes it to reference already-spent outputs, leading to transaction rejection and fee loss?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [min_mci Manipulation] At lines 80-81 and 89, min_mci is set from conf.refreshHistoryOnlyAboveMci - if an attacker modifies this config value to a very high MCI, can the history request skip all existing units, causing the client to think it has zero transaction history and compose invalid transactions that double-spend already-used outputs?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Witness List Empty State] At lines 49-51, if arrWitnesses.length === 0, the function returns null and skips history refresh - can an attacker delete all entries from the my_witnesses table (via SQL injection or direct database access), causing all future history refreshes to be skipped and the client to never learn about incoming payments or outgoing double-spends?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Error Handler - throw vs callback] At line 148, if handle callback exists, errors throw instead of being passed to callback - can this cause unhandled promise rejections that crash the Node.js process when refreshLightClientHistory() is called with a callback during startup, leading to DoS where the light client cannot start at all?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Error Handler - bRefreshingHistory cleanup] At lines 161-170, the finish() callback clears ws.bRefreshingHistory at line 165, but if an exception occurs before finish() is called (e.g., in prepareRequestForHistory()), can bRefreshingHistory remain true permanently, blocking all future history refreshes and freezing user funds?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Large History Exception] At line 192-193, if response.error contains 'your history is too large', an Error is thrown without cleanup - does this throw bypass the finish() callback, leaving ws.bRefreshingHistory=true and preventing any future refreshes, effectively bricking the light client until restart?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Network Error During Processing] At lines 196-216, light.processHistory() is called with ifError and ifOk callbacks, but if the network connection drops during processing (after line 190), can the callbacks never fire, leaving ws.bRefreshingHistory stuck and preventing all future refreshes?",
  "[File: byteball/ocore/light_wallet.js] [Function: archiveDoublespendUnits()] [Silent Failure] At lines 229-230, if network.requestFromLightVendor() errors, the error is only logged to breadcrumbs without any retry or fallback - can a temporarily unavailable light vendor cause double-spend units to remain unarchived indefinitely, allowing an attacker to resurrect old double-spend attempts months later?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Response Validation Bypass] At line 191, only response.error is checked before processing - if the response object is malformed (null, undefined, or missing required fields), can light.processHistory() crash with an exception that doesn't go through the ifError callback, leaving the refresh in an inconsistent state?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: connected] [Error Handling in Query Callback] At lines 126-137, database errors in the SELECT or DELETE queries are not explicitly caught - if the query fails due to database corruption, can the callback never fire, preventing unprocessed addresses from being cleared and causing the same addresses to be reprocessed on every connection, amplifying DoS attacks?",
  "[File: byteball/ocore/light_wallet.js] [Function: waitUntilHistoryRefreshDone()] [Promise Rejection] At lines 266-277, if the promise version is used and network.findOutboundPeerOrConnect() returns an error, the promise rejects - but if the callback version is used and an exception occurs in the eventBus.once() handler, can this create an unhandled exception that crashes the process?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: new_address] [Address Format Validation] At line 107, a 'new_address' event is received with address parameter, but there's no validation that the address is a valid Obyte address (base32, correct checksum) - can an attacker emit fake new_address events with malicious strings that contain SQL injection, causing database corruption when the address is used in queries at lines 109 and 115?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: new_address] [Address Length DoS] At lines 112-116, refreshLightClientHistory() is called with a single-element array [address] - if the address parameter is an extremely long string (e.g., 1MB), can this cause memory exhaustion when the address is used in SQL queries at line 71, or when sent to the light vendor in the history request, leading to DoS?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Address Array Injection] At lines 54 and 56-57, newAddresses or arrAddresses are used without validation - if these contain non-string elements (null, undefined, objects), can this cause db.escape() to fail or produce unexpected output that corrupts SQL queries or sends malformed requests to the light vendor?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: connected] [Unprocessed Address Validation] At lines 126-135, addresses are read from unprocessed_addresses table and used directly - if an attacker previously inserted invalid address formats into this table, can the subsequent history refresh or DELETE statement fail silently, leaving addresses permanently unprocessed and funds undetectable?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Empty Address Array] At lines 61-69, if arrAddresses.length === 0, objHistoryRequest.addresses is not set, but the function continues - can this cause the light vendor to return history for ALL addresses in the network, overwhelming the client with gigabytes of irrelevant data and causing memory exhaustion DoS?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Address Count Limit] At lines 61-62, objHistoryRequest.addresses is set to arrAddresses without any limit on array size - if a user has registered 10,000 addresses, can the resulting history request be so large that the light vendor rejects it, the network layer times out, or the response is so massive that it causes permanent memory exhaustion?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: new_my_transactions] [Unit Hash Validation] At line 243, arrUnits is received from event but not validated - can an attacker emit fake new_my_transactions events with malicious unit hashes that cause SQL injection at line 244 or invalid asset proof requests at line 248 that crash the network module?",
  "[File: byteball/ocore/light_wallet.js] [Global] [Reconnection Timer Race] At line 23, setInterval() schedules reconnection every 60 seconds, and line 24 adds 'connected' event handler - if the client connects exactly at the 60-second mark, can both triggers fire simultaneously, causing duplicate reconnection attempts that bypass the bRefreshingHistory check and corrupt history processing?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Selective Refresh Delay] At lines 182-184, selective refresh is delayed by 2 seconds if full refresh is ongoing - but what if full refresh takes >2 seconds and completes while the delayed selective refresh is waiting? Can the selective refresh start just as the next full refresh begins, causing concurrent processing and DAG corruption?",
  "[File: byteball/ocore/light_wallet.js] [Function: waitUntilFirstHistoryReceived()] [Deadlock] At lines 257-264, if bFirstHistoryReceived is false, the function waits for 'first_history_received' event - but if the event was already emitted before this function is called (race condition), can the callback never fire, causing wallet operations to hang indefinitely and freeze all funds?",
  "[File: byteball/ocore/light_wallet.js] [Function: waitUntilHistoryRefreshDone()] [Deadlock] At lines 266-277, if bRefreshingHistory is false when checked at line 272, the function returns immediately - but if refresh starts between the check and return, can subsequent code proceed assuming refresh is done when it's actually ongoing, causing transaction composition with incomplete data?",
  "[File: byteball/ocore/light_wallet.js] [Global] [Archive Timer] At line 242, archiveDoublespendUnits() runs every 24 hours - if the light client is offline for 48 hours, then comes online, can the timer fire immediately and archive legitimate transactions that took 25 hours to confirm due to network congestion, hiding those transactions from the user's history?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Processing Time Estimation] At line 196, an interval is set to emit events every 10 seconds during history processing - if processing actually takes 10 hours due to massive history, can the 3600 event emissions cause memory leaks or CPU exhaustion that crash the client mid-processing, leaving the database in a corrupted state?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: new_my_transactions] [Asset Proof Timing] At lines 243-250, asset proofs are requested immediately when new transactions arrive - but if those transactions are still unstable and get double-spent before proofs arrive, can the proofs validate a transaction that no longer exists, causing the user's balance to show received funds that aren't actually available?",
  "[File: byteball/ocore/light_wallet.js] [Function: waitUntilFirstHistoryReceived()] [Promise/Callback Dual Mode] At lines 258-259, the function supports both callback and promise modes - if caller accidentally provides both a callback and expects a promise, can the callback be called but the promise never resolve, causing memory leaks from waiting promises?",
  "[File: byteball/ocore/light_wallet.js] [Function: waitUntilFirstHistoryReceived()] [Event Handler Memory Leak] At line 263, eventBus.once() is used, but if the 'first_history_received' event is never emitted (e.g., refresh fails permanently), can the registered callback remain in memory indefinitely, causing a memory leak that accumulates with each failed wait attempt?",
  "[File: byteball/ocore/light_wallet.js] [Function: waitUntilHistoryRefreshDone()] [Callback Error Propagation] At lines 268-271, if network.findOutboundPeerOrConnect() returns an error, cb(err) is called - but if the caller expects the error to be an Error object and it's a string, can this cause unhandled exceptions in the caller's error handling code?",
  "[File: byteball/ocore/light_wallet.js] [Function: waitUntilHistoryRefreshDone()] [Event Handler Race] At line 275, eventBus.once() is registered, but if 'refresh_light_done' event fires between line 272 (check) and line 275 (registration), can the callback never be invoked, causing permanent deadlock in any code waiting for history refresh completion?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Callback Invocation Order] At lines 161-170, finish() callback is defined to call the user-provided handle() callback - if handle() throws an exception, can this prevent 'refresh_light_done' event emission at line 169, breaking any code waiting via waitUntilHistoryRefreshDone()?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Handle Callback Optional] At lines 166-167, handle() callback is only invoked if it's truthy - but if handle=null was passed, can critical cleanup code that the caller expected to run in the callback never execute, leaving the application in an inconsistent state?",
  "[File: byteball/ocore/light_wallet.js] [Function: readListOfUnstableUnits()] [Stale Read] At line 41, unstable units are read without transaction isolation - if another process is simultaneously marking units as stable (in storage.js or validation.js), can the query return a mix of old and new is_stable values, causing some unstable units to be missed in history refresh and double-spend detection to fail?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Transaction Boundary] At lines 73-84, multiple queries are executed (unit_authors UNION outputs, then conditional query for known_stable_units or last_stable_mci) without explicit transaction - can units become stable between these queries, causing the history request to have inconsistent min_mci and known_stable_units that confuse the light vendor?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: new_address] [Delete Before Refresh] At lines 109 and 115, unprocessed_addresses is deleted after refreshLightClientHistory() completes - but if refresh fails partway through (line 113-114), can the DELETE still execute at line 115, causing the address to be marked as processed despite incomplete history, hiding future transactions to that address?",
  "[File: byteball/ocore/light_wallet.js] [Event Handler: connected] [Atomic Delete] At line 134, unprocessed_addresses is deleted in a single query without verifying refresh success - if refreshLightClientHistory() at line 131 fails due to network error, can the DELETE still execute, marking addresses as processed when they weren't, causing permanent loss of transaction history for those addresses?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [MAX() Query Edge Case] At line 87, MAX(main_chain_index) is queried which returns NULL if no stable units exist - the code uses rows[0].last_stable_mci || 0 at line 89, but what if rows is empty array? Can this cause undefined access that crashes the client or sets min_mci to undefined, breaking history requests?",
  "[File: byteball/ocore/light_wallet.js] [Function: archiveDoublespendUnits()] [Archive Without Transaction] At line 233, storage.archiveJointAndDescendantsIfExists() is called, which likely modifies multiple database tables - if this operation is not atomic and crashes midway, can the database be left in a state where some parts of the unit are archived but others aren't, causing future queries to get inconsistent results?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Witness List Wait Mode] At line 97, myWitnesses.readMyWitnesses() is called with 'wait' parameter - what does 'wait' do, and can an attacker prevent witness list initialization, causing this function to wait indefinitely and block all history refreshes, effectively freezing all user funds?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Witness List Race] At lines 49-51, if arrWitnesses.length === 0, refresh is skipped - but what if witness list is being updated concurrently by my_witnesses.js? Can a race condition cause the light client to skip refresh during witness list change, missing critical units that affect witness compatibility?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Witness List Validation] At line 199, objRequest.witnesses is passed to light.processHistory() - are these witnesses validated to be the current witness list? If the light vendor returns history for a different witness set that's incompatible, can this cause the client to accept units that violate witness compatibility rules, leading to a permanent chain split?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [Witness Count] At line 52, objHistoryRequest.witnesses is set to arrWitnesses - but the protocol requires exactly 12 witnesses; if arrWitnesses has <12 or >12 elements due to database corruption, can the light vendor return invalid history or reject the request, causing the client to never sync?",
  "[File: byteball/ocore/light_wallet.js] [Function: setLightVendorHost()] [Vendor-Witness Alignment] At lines 16-26, light vendor is set but there's no verification that the vendor actually supports the user's witness list - can a mismatch cause the vendor to return history for incompatible witness set, leading to the client accepting invalid units and creating a permanent chain split when it tries to post transactions?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [requested_joints Size Limit] At lines 63-65, all unstable units are added to requested_joints without size limit - if a light client has accumulated 100,000 unstable units due to network issues, can the resulting history request be so large that it exceeds network message size limits, causing the request to be rejected and the client to never sync?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [known_stable_units Uniqueness] At line 79, known_stable_units are collected from UNION of unit_authors and outputs - can the same unit appear multiple times if it has multiple authors or outputs? If the array contains duplicates, can this confuse the light vendor or waste bandwidth/processing on redundant data?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Response Size Validation] At lines 190-199, the light vendor response is received but there's no check on response size before passing to light.processHistory() - can a malicious vendor return a 10GB history response that causes memory exhaustion and crashes the Node.js process, DoS-ing the light client?",
  "[File: byteball/ocore/light_wallet.js] [Function: refreshLightClientHistory()] [Response Field Validation] At line 191, only response.error is checked - what if response.joints, response.proofs, or other expected fields are missing, malformed, or contain unexpected types? Can this cause light.processHistory() to crash with a type error that leaves the client in an inconsistent state?",
  "[File: byteball/ocore/light_wallet.js] [Function: prepareRequestForHistory()] [min_mci vs known_stable_units Conflict] At lines 78-82, for new addresses, known_stable_units are provided with optional min_mci, but at lines 86-92, for existing addresses, only min_mci is provided - can the light vendor be confused by requests that have both, causing it to return duplicate or missing units that corrupt the client's DAG?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Command Injection] Can an attacker inject shell commands through the params.to parameter when it's passed directly to child_process.spawn('/usr/sbin/sendmail', ['-t', params.to]), potentially executing arbitrary commands on the host system if params.to contains shell metacharacters like ';', '&&', or '|'?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Email Header Injection - CRLF] Can an attacker inject arbitrary email headers by including CRLF sequences (\\\\r\\\\n) in params.from, params.to, params.subject, or params.body when these are written to child.stdin without sanitization, allowing spoofing of sender, adding BCC recipients, or injecting malicious headers?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Information Disclosure] When network.js calls sendBugEmail() with body.message and body.exception from a peer's bugreport message, does the function send potentially sensitive information (stack traces, internal state, database queries, private keys in memory) to the configured bug_sink_email address without rate limiting or validation?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Denial of Service] Can a malicious peer flood the node with bugreport messages to trigger unlimited calls to sendBugEmail(), causing the node to spawn thousands of sendmail processes or SMTP connections, exhausting file descriptors, memory, or network bandwidth and potentially crashing the node?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Path Traversal] Is the hardcoded path '/usr/sbin/sendmail' validated to exist and be executable before spawning, and could an attacker who gains filesystem access create a malicious binary at this path (e.g., via symlink attack or package installation) to execute arbitrary code whenever emails are sent?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [DNS Poisoning] When DNS.resolveMx() is called to find the recipient's mail server, does the code validate the returned MX records, or could a DNS poisoning attack (or compromised DNS server) redirect emails to an attacker-controlled SMTP server, allowing interception of textcoin mnemonics, bug reports, or admin notifications?",
  "[File: byteball/ocore/mail.js] [Module Initialization] [DNS Configuration] Are the hardcoded DNS servers '8.8.8.8' and '114.114.114.114' set via DNS.setServers() potentially unreliable or subject to hijacking, and could using these servers (especially the China-based 114dns) expose email routing to state-level interception or censorship?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [TLS Misconfiguration] The tls.rejectUnauthorized is set to true, but does this prevent connections when the target SMTP server has a self-signed or expired certificate, potentially causing emails (including critical textcoin payments) to fail silently without proper error handling?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [Credential Exposure] When conf.smtpUser and conf.smtpPassword are used for SMTP authentication, are these credentials stored securely in the conf module, or could they be exposed in logs, error messages, or through memory dumps if the node is compromised?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Missing Callback Error Handling] When cb is not provided and defaults to an empty function, do errors from email sending get silently dropped without any logging or monitoring, potentially causing critical notifications (daemon failures, textcoin payments) to fail unnoticed?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Race Condition] If multiple threads or asynchronous operations call sendMailThroughUnixSendmail() simultaneously, could race conditions occur when writing to child.stdin, causing email bodies to be interleaved or corrupted, potentially mixing textcoin mnemonics between different recipients?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Subject Line Injection] When error_message.substr(0, 200) is used directly in the email subject without escaping, can an attacker craft a bug report containing CRLF sequences in the first 200 characters to inject additional email headers or body content through the subject line?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Input Validation] Are the params.from, params.to, params.subject, and params.body parameters validated for length, format, or malicious content before being passed to sendmail, or could excessively long inputs cause buffer overflows in the sendmail binary or exhaust stdin buffer?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [MX Record Fallback] When exchanges array is empty or DNS.resolveMx() fails, the code falls back to using the hostname directly as the exchange, but does this bypass MX record validation and potentially allow emails to be sent to incorrect or non-existent servers?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [SMTP Relay Validation] When conf.smtpRelay is checked on line 11-12, is the relay address validated for format and reachability, or could a misconfigured or malicious relay address cause all emails to fail or be intercepted by an attacker-controlled server?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [JSON Stringification] When exception is stringified using JSON.stringify(exception, null, '\\\\t'), could circular references in the exception object cause JSON.stringify to throw an error, crashing the email sending process and potentially the node if error handlers are missing?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Error Handling] The catch block on line 33-36 logs errors but then re-throws them, potentially crashing the calling code; should critical email sending failures (like daemon down notifications) be handled more gracefully to prevent node crashes?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [Port Configuration] When conf.smtpPort is null, does nodemailer use the correct default port based on conf.smtpSsl (465 for SSL, 587 for TLS, 25 for plaintext), or could the wrong port be selected, causing connection failures or downgraded security?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Transport Method Validation] Is conf.smtpTransport validated to be one of the expected values ('relay', 'direct', 'local'), or could an invalid configuration value cause the switch statement to fall through to the default case unexpectedly?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Sensitive Data in Bug Reports] When wallet.js or other modules call sendBugEmail() with exception objects, could these exceptions contain sensitive information like private keys, mnemonics, addresses, or user data that should be redacted before sending to external email addresses?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Process Management] When child_process.spawn() creates sendmail processes, are these processes properly cleaned up if they hang or fail, or could accumulated zombie processes exhaust system resources over time?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [SMTP Enumeration] Does sending emails directly to recipient MX servers expose the node's IP address and identity to potentially malicious mail servers, allowing enumeration of Obyte nodes or targeted attacks against node operators?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Rate Limiting] Is there any rate limiting on how frequently sendBugEmail() can be called, or could a rapidly failing component (like a validation loop error) trigger thousands of bug emails per second, causing email provider rate limits to blacklist the sender address?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [TLS Downgrade] With requireTLS set to false and secure depending on conf.smtpSsl, could an attacker perform a TLS downgrade attack to intercept SMTP credentials or email content when connecting to the relay server?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Missing Input Sanitization] Are params.to email addresses validated against RFC 5321 standards to prevent invalid addresses from being processed, or could malformed addresses cause sendmail or nodemailer to behave unexpectedly?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Return-Path Injection] Is the Return-Path header constructed from params.from without validation, potentially allowing an attacker to inject a malicious Return-Path that could be used for email spoofing or bounce message manipulation?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Configuration Exposure] When conf.bug_sink_email and conf.bugs_from_email are checked, could these configuration values be logged or exposed in error messages, revealing the email addresses used for internal bug reporting?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [Nodemailer Version] Is the nodemailer dependency version pinned and regularly updated, or could vulnerabilities in older nodemailer versions (e.g., SMTP injection, TLS issues) be exploited if the dependency is outdated?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Callback Inconsistency] When different transport methods call the callback with different argument patterns (error first for some, info second for others), could calling code that expects consistent callback signatures experience errors or undefined behavior?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [stdin.end() Timing] Is child.stdin.end() called before the callback, potentially causing the callback to execute before the email is fully written to sendmail, leading to race conditions or truncated emails?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Whitespace Replacement] When error_message.substr(0, 200).replace(/\\\\s/g, ' ') replaces all whitespace with spaces, could this transformation corrupt structured error messages or stack traces that rely on newlines for readability?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [Exchange Selection] When multiple MX records are returned but only exchanges[0].exchange is used, does this ignore MX priority and backup servers, potentially causing email delivery failures if the primary server is down?",
  "[File: byteball/ocore/mail.js] [Module Dependencies] [Conditional Require] Are the conditional requires for 'dns' and 'nodemailer' safe when conf.smtpTransport changes at runtime, or could changing the transport method after module initialization cause missing dependencies to be accessed?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [Authentication Optional] When conf.smtpUser and conf.smtpPassword are not provided, does the relay connection attempt unauthenticated SMTP, and could this fail with modern SMTP servers that require authentication, causing all emails to fail silently?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Message Truncation] When error_message is potentially very long but only the first 200 characters are used in the subject, could critical context be lost, making bug reports impossible to diagnose without the full message?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [stdout/stderr Piping] When child.stdout and child.stderr are piped to process.stdout/stderr, could this expose sensitive information from sendmail output (like recipient addresses, delivery status) in node logs?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [conf.smtpTransport Mutation] If conf.smtpTransport is modified at runtime by other modules, could this cause unexpected behavior in pending email sends or create race conditions between transport method selection and execution?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [Hostname Extraction] When hostname is extracted using params.to.slice(params.to.indexOf('@')+1), is the '@' character validated to exist in the email address, or could a malformed address cause indexOf to return -1, resulting in the entire string being used as the hostname?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Exception Type Coercion] When checking typeof exception === 'string', what happens if exception is undefined, null, or a complex object that cannot be JSON stringified, and could this cause sendBugEmail to fail or send malformed emails?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Email Body Encoding] Are non-ASCII characters in params.body properly encoded before being written to stdin, or could UTF-8 or other encoding issues cause email corruption when sending internationalized text?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [Connection Timeout] Is there a timeout configured for the nodemailer transport connection, or could connecting to a slow or unresponsive MX server hang indefinitely, blocking the event loop and causing node unresponsiveness?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Error Propagation] When email sending fails in any transport method, are errors properly propagated to calling code (like wallet.js for textcoin emails), or could critical payment notifications fail without the user being notified?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [SSL/TLS Version] Does the tls configuration specify minimum TLS versions (e.g., TLSv1.2+), or could the connection negotiate weak or deprecated protocols (SSLv3, TLSv1.0) that are vulnerable to attacks like POODLE or BEAST?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Configuration Check Timing] When conf.bug_sink_email and conf.bugs_from_email are checked at the time of sending, could race conditions occur if configuration is reloaded while sendBugEmail is executing, causing inconsistent behavior?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Header Injection via Subject] When params.subject is written directly to the email headers without escaping, could an attacker inject additional headers by including newlines in the subject, allowing arbitrary header manipulation?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [HTML Body Injection] When params.htmlBody is included in mailOptions without sanitization, could an attacker inject malicious HTML or JavaScript that executes when the recipient opens the email in an HTML-capable client?",
  "[File: byteball/ocore/mail.js] [Module Initialization] [DNS Resolution Failure] If DNS.setServers() fails or the specified DNS servers are unreachable, does the module handle this gracefully, or could DNS resolution failures cause all direct email sending to fail without fallback?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Synchronous Configuration Access] When conf.smtpTransport is accessed synchronously, could this cause issues if the conf module performs asynchronous initialization or configuration updates, leading to undefined or stale values being used?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [Relay Server Validation] Is conf.smtpRelay validated to be a valid hostname or IP address, or could invalid values (like URLs with schemes, or values with shell metacharacters) cause nodemailer to throw unexpected errors?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Log Exposure] When logging 'not sending bug email' messages to console, could these logs expose sensitive error information to unauthorized users who have access to node logs (e.g., in shared hosting environments)?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Command Injection] Can an attacker inject shell commands through the params.to parameter when it's passed directly to child_process.spawn('/usr/sbin/sendmail', ['-t', params.to]), potentially executing arbitrary commands on the host system if params.to contains shell metacharacters like ';', '&&', or '|'?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Email Header Injection - CRLF] Can an attacker inject arbitrary email headers by including CRLF sequences (\\\\r\\\\n) in params.from, params.to, params.subject, or params.body when these are written to child.stdin without sanitization, allowing spoofing of sender, adding BCC recipients, or injecting malicious headers?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Information Disclosure] When network.js calls sendBugEmail() with body.message and body.exception from a peer's bugreport message, does the function send potentially sensitive information (stack traces, internal state, database queries, private keys in memory) to the configured bug_sink_email address without rate limiting or validation?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Denial of Service] Can a malicious peer flood the node with bugreport messages to trigger unlimited calls to sendBugEmail(), causing the node to spawn thousands of sendmail processes or SMTP connections, exhausting file descriptors, memory, or network bandwidth and potentially crashing the node?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Path Traversal] Is the hardcoded path '/usr/sbin/sendmail' validated to exist and be executable before spawning, and could an attacker who gains filesystem access create a malicious binary at this path (e.g., via symlink attack or package installation) to execute arbitrary code whenever emails are sent?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [DNS Poisoning] When DNS.resolveMx() is called to find the recipient's mail server, does the code validate the returned MX records, or could a DNS poisoning attack (or compromised DNS server) redirect emails to an attacker-controlled SMTP server, allowing interception of textcoin mnemonics, bug reports, or admin notifications?",
  "[File: byteball/ocore/mail.js] [Module Initialization] [DNS Configuration] Are the hardcoded DNS servers '8.8.8.8' and '114.114.114.114' set via DNS.setServers() potentially unreliable or subject to hijacking, and could using these servers (especially the China-based 114dns) expose email routing to state-level interception or censorship?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [TLS Misconfiguration] The tls.rejectUnauthorized is set to true, but does this prevent connections when the target SMTP server has a self-signed or expired certificate, potentially causing emails (including critical textcoin payments) to fail silently without proper error handling?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [Credential Exposure] When conf.smtpUser and conf.smtpPassword are used for SMTP authentication, are these credentials stored securely in the conf module, or could they be exposed in logs, error messages, or through memory dumps if the node is compromised?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Missing Callback Error Handling] When cb is not provided and defaults to an empty function, do errors from email sending get silently dropped without any logging or monitoring, potentially causing critical notifications (daemon failures, textcoin payments) to fail unnoticed?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Race Condition] If multiple threads or asynchronous operations call sendMailThroughUnixSendmail() simultaneously, could race conditions occur when writing to child.stdin, causing email bodies to be interleaved or corrupted, potentially mixing textcoin mnemonics between different recipients?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Subject Line Injection] When error_message.substr(0, 200) is used directly in the email subject without escaping, can an attacker craft a bug report containing CRLF sequences in the first 200 characters to inject additional email headers or body content through the subject line?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Input Validation] Are the params.from, params.to, params.subject, and params.body parameters validated for length, format, or malicious content before being passed to sendmail, or could excessively long inputs cause buffer overflows in the sendmail binary or exhaust stdin buffer?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [MX Record Fallback] When exchanges array is empty or DNS.resolveMx() fails, the code falls back to using the hostname directly as the exchange, but does this bypass MX record validation and potentially allow emails to be sent to incorrect or non-existent servers?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [SMTP Relay Validation] When conf.smtpRelay is checked on line 11-12, is the relay address validated for format and reachability, or could a misconfigured or malicious relay address cause all emails to fail or be intercepted by an attacker-controlled server?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [JSON Stringification] When exception is stringified using JSON.stringify(exception, null, '\\\\t'), could circular references in the exception object cause JSON.stringify to throw an error, crashing the email sending process and potentially the node if error handlers are missing?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Error Handling] The catch block on line 33-36 logs errors but then re-throws them, potentially crashing the calling code; should critical email sending failures (like daemon down notifications) be handled more gracefully to prevent node crashes?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [Port Configuration] When conf.smtpPort is null, does nodemailer use the correct default port based on conf.smtpSsl (465 for SSL, 587 for TLS, 25 for plaintext), or could the wrong port be selected, causing connection failures or downgraded security?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Transport Method Validation] Is conf.smtpTransport validated to be one of the expected values ('relay', 'direct', 'local'), or could an invalid configuration value cause the switch statement to fall through to the default case unexpectedly?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Sensitive Data in Bug Reports] When wallet.js or other modules call sendBugEmail() with exception objects, could these exceptions contain sensitive information like private keys, mnemonics, addresses, or user data that should be redacted before sending to external email addresses?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Process Management] When child_process.spawn() creates sendmail processes, are these processes properly cleaned up if they hang or fail, or could accumulated zombie processes exhaust system resources over time?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [SMTP Enumeration] Does sending emails directly to recipient MX servers expose the node's IP address and identity to potentially malicious mail servers, allowing enumeration of Obyte nodes or targeted attacks against node operators?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Rate Limiting] Is there any rate limiting on how frequently sendBugEmail() can be called, or could a rapidly failing component (like a validation loop error) trigger thousands of bug emails per second, causing email provider rate limits to blacklist the sender address?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [TLS Downgrade] With requireTLS set to false and secure depending on conf.smtpSsl, could an attacker perform a TLS downgrade attack to intercept SMTP credentials or email content when connecting to the relay server?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Missing Input Sanitization] Are params.to email addresses validated against RFC 5321 standards to prevent invalid addresses from being processed, or could malformed addresses cause sendmail or nodemailer to behave unexpectedly?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Return-Path Injection] Is the Return-Path header constructed from params.from without validation, potentially allowing an attacker to inject a malicious Return-Path that could be used for email spoofing or bounce message manipulation?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Configuration Exposure] When conf.bug_sink_email and conf.bugs_from_email are checked, could these configuration values be logged or exposed in error messages, revealing the email addresses used for internal bug reporting?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [Nodemailer Version] Is the nodemailer dependency version pinned and regularly updated, or could vulnerabilities in older nodemailer versions (e.g., SMTP injection, TLS issues) be exploited if the dependency is outdated?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Callback Inconsistency] When different transport methods call the callback with different argument patterns (error first for some, info second for others), could calling code that expects consistent callback signatures experience errors or undefined behavior?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [stdin.end() Timing] Is child.stdin.end() called before the callback, potentially causing the callback to execute before the email is fully written to sendmail, leading to race conditions or truncated emails?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Whitespace Replacement] When error_message.substr(0, 200).replace(/\\\\s/g, ' ') replaces all whitespace with spaces, could this transformation corrupt structured error messages or stack traces that rely on newlines for readability?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [Exchange Selection] When multiple MX records are returned but only exchanges[0].exchange is used, does this ignore MX priority and backup servers, potentially causing email delivery failures if the primary server is down?",
  "[File: byteball/ocore/mail.js] [Module Dependencies] [Conditional Require] Are the conditional requires for 'dns' and 'nodemailer' safe when conf.smtpTransport changes at runtime, or could changing the transport method after module initialization cause missing dependencies to be accessed?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [Authentication Optional] When conf.smtpUser and conf.smtpPassword are not provided, does the relay connection attempt unauthenticated SMTP, and could this fail with modern SMTP servers that require authentication, causing all emails to fail silently?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Message Truncation] When error_message is potentially very long but only the first 200 characters are used in the subject, could critical context be lost, making bug reports impossible to diagnose without the full message?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [stdout/stderr Piping] When child.stdout and child.stderr are piped to process.stdout/stderr, could this expose sensitive information from sendmail output (like recipient addresses, delivery status) in node logs?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [conf.smtpTransport Mutation] If conf.smtpTransport is modified at runtime by other modules, could this cause unexpected behavior in pending email sends or create race conditions between transport method selection and execution?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [Hostname Extraction] When hostname is extracted using params.to.slice(params.to.indexOf('@')+1), is the '@' character validated to exist in the email address, or could a malformed address cause indexOf to return -1, resulting in the entire string being used as the hostname?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Exception Type Coercion] When checking typeof exception === 'string', what happens if exception is undefined, null, or a complex object that cannot be JSON stringified, and could this cause sendBugEmail to fail or send malformed emails?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Email Body Encoding] Are non-ASCII characters in params.body properly encoded before being written to stdin, or could UTF-8 or other encoding issues cause email corruption when sending internationalized text?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [Connection Timeout] Is there a timeout configured for the nodemailer transport connection, or could connecting to a slow or unresponsive MX server hang indefinitely, blocking the event loop and causing node unresponsiveness?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Error Propagation] When email sending fails in any transport method, are errors properly propagated to calling code (like wallet.js for textcoin emails), or could critical payment notifications fail without the user being notified?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [SSL/TLS Version] Does the tls configuration specify minimum TLS versions (e.g., TLSv1.2+), or could the connection negotiate weak or deprecated protocols (SSLv3, TLSv1.0) that are vulnerable to attacks like POODLE or BEAST?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Configuration Check Timing] When conf.bug_sink_email and conf.bugs_from_email are checked at the time of sending, could race conditions occur if configuration is reloaded while sendBugEmail is executing, causing inconsistent behavior?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughUnixSendmail()] [Header Injection via Subject] When params.subject is written directly to the email headers without escaping, could an attacker inject additional headers by including newlines in the subject, allowing arbitrary header manipulation?",
  "[File: byteball/ocore/mail.js] [Function: sendMailDirectly()] [HTML Body Injection] When params.htmlBody is included in mailOptions without sanitization, could an attacker inject malicious HTML or JavaScript that executes when the recipient opens the email in an HTML-capable client?",
  "[File: byteball/ocore/mail.js] [Module Initialization] [DNS Resolution Failure] If DNS.setServers() fails or the specified DNS servers are unreachable, does the module handle this gracefully, or could DNS resolution failures cause all direct email sending to fail without fallback?",
  "[File: byteball/ocore/mail.js] [Function: sendmail()] [Synchronous Configuration Access] When conf.smtpTransport is accessed synchronously, could this cause issues if the conf module performs asynchronous initialization or configuration updates, leading to undefined or stale values being used?",
  "[File: byteball/ocore/mail.js] [Function: sendMailThroughRelay()] [Relay Server Validation] Is conf.smtpRelay validated to be a valid hostname or IP address, or could invalid values (like URLs with schemes, or values with shell metacharacters) cause nodemailer to throw unexpected errors?",
  "[File: byteball/ocore/mail.js] [Function: sendBugEmail()] [Log Exposure] When logging 'not sending bug email' messages to console, could these logs expose sensitive error information to unauthorized users who have access to node logs (e.g., in shared hosting environments)?",
  "[File: byteball/ocore/main_chain.js] [Function: updateMainChain()] [Race Condition] If two parallel calls to updateMainChain() occur simultaneously (e.g., from different network peers adding units concurrently), can the lack of mutex protection during the initial goUpFromUnit() traversal cause both operations to read stale arrAllParents and arrNewMcUnits state, leading to non-deterministic main chain selection and permanent chain split across nodes?",
  "[File: byteball/ocore/main_chain.js] [Function: updateMainChain()] [Memory Leak] The arrNewMcUnits array accumulates units during MC traversal but is never explicitly cleared between calls - can a long-running node processing thousands of units experience memory exhaustion from unbounded array growth, causing network halt when the process crashes?",
  "[File: byteball/ocore/main_chain.js] [Function: updateMainChain()] [Non-determinism] The bStabilizedAATriggers flag and arrStabilizedMcis array are shared across the entire function scope - if multiple sequential MCI stabilizations occur in a single updateMainChain() call, can race conditions in their updates cause different nodes to disagree on which MCIs contained AA triggers, breaking consensus on AA execution order?",
  "[File: byteball/ocore/main_chain.js] [Function: updateMainChain()] [Parameter Validation] The function accepts from_unit which can be null to indicate reading free balls - can an attacker deliberately pass an invalid but non-null from_unit that doesn't exist in the database, causing the initial goUpFromUnit() call to fail silently or throw an unhandled exception that crashes the node?",
  "[File: byteball/ocore/main_chain.js] [Function: updateMainChain()] [Callback Hell] The deeply nested async callback structure with goUpFromUnit  checkNotRebuildingStableMainChainAndGoDown  goDownAndUpdateMainChainIndex  updateLatestIncludedMcIndex  updateStableMcFlag creates opportunities for callback errors to be swallowed - can an exception in any intermediate callback prevent onDone from being called, leaving the system in a partially updated state with locks never released?",
  "[File: byteball/ocore/main_chain.js] [Function: findNextUpMainChainUnit()] [Hardcoded Exception List] The arrRetreatingUnits array contains 6 hardcoded unit hashes that override normal best parent selection logic - can an attacker who discovers the criteria for being added to this list deliberately create units that match those patterns, allowing them to manipulate main chain selection by forcing their unit to be chosen as best parent even when it shouldn't be?",
  "[File: byteball/ocore/main_chain.js] [Function: findNextUpMainChainUnit()] [SQL Injection via LIMIT] The query uses LIMIT 5 to select potential best parents when unit is null - can an attacker flood the network with carefully crafted free units that all have identical witnessed_level and level-witnessed_level values, causing the ORDER BY tie-breaking to become non-deterministic due to database-dependent sorting of equal values, leading to different nodes selecting different best parents and causing a permanent chain split?",
  "[File: byteball/ocore/main_chain.js] [Function: findNextUpMainChainUnit()] [Array Index Attack] When multiple free units are found (rows.length > 1), the code iterates through arrRetreatingUnits and uses indexOf to find matches - if an attacker can add thousands of units to arrAllParents, can the O(n*m) complexity of these nested indexOf operations cause a DoS where findNextUpMainChainUnit() takes minutes to complete, freezing new transaction confirmations for hours?",
  "[File: byteball/ocore/main_chain.js] [Function: findNextUpMainChainUnit()] [Best Parent Null] The function throws 'best parent is null' if props.best_parent_unit === null - can an attacker create a unit where best_parent_unit is legitimately null due to database corruption or a race condition during storage, causing all subsequent MC updates to crash with an unhandled exception and halting the entire network permanently?",
  "[File: byteball/ocore/main_chain.js] [Function: readLastUnitProps()] [Free Unit Exhaustion] The query selects units WHERE is_free=1 and throws 'no free units?' if none are found - can an attacker exploit a scenario where all free units simultaneously become non-free due to parallel additions, causing this query to fail and preventing any new MC updates until at least one unit becomes free again, effectively halting consensus for an unbounded period?",
  "[File: byteball/ocore/main_chain.js] [Function: goUpFromUnit()] [Cache Inconsistency] The function reads unit props from both database (storage.readUnitProps) and in-memory cache (storage.assocUnstableUnits / storage.assocStableUnits) and compares them with _.isEqual - if a race condition causes the database and cache to diverge (e.g., another process updates DB but not cache), can the throwError('different props') be triggered during normal operation, crashing nodes randomly and causing network instability?",
  "[File: byteball/ocore/main_chain.js] [Function: goUpFromUnit()] [Infinite Loop] The function recursively calls itself via goUpFromUnit(best_parent_unit) until reaching genesis - can an attacker create a cycle in best_parent_unit references through database corruption or a validation bypass, causing infinite recursion that exhausts the call stack and crashes the node with a stack overflow?",
  "[File: byteball/ocore/main_chain.js] [Function: goUpFromUnit()] [Genesis Check Bypass] The function checks storage.isGenesisUnit(unit) to stop recursion - if an attacker can manipulate the genesis unit hash constant or inject a fake genesis unit, can they create a situation where goUpFromUnit never terminates because it never encounters the real genesis, causing all MC updates to hang indefinitely?",
  "[File: byteball/ocore/main_chain.js] [Function: goUpFromUnit()] [UPDATE Race Condition] When a unit is not on MC, it executes 'UPDATE units SET is_on_main_chain=1, main_chain_index=NULL WHERE unit=?' - if two parallel goUpFromUnit calls process the same unit simultaneously, can both UPDATE queries succeed but the in-memory cache updates conflict, causing objBestParentUnitProps2.is_on_main_chain and .main_chain_index to have inconsistent values across the two operations?",
  "[File: byteball/ocore/main_chain.js] [Function: goUpFromUnit()] [arrNewMcUnits Ordering] The arrNewMcUnits.push(best_parent_unit) occurs inside the UPDATE callback - if database query execution order is non-deterministic due to connection pooling, can different nodes build arrNewMcUnits in different orders even when processing the same units, causing disagreement on MCI assignments in goDownAndUpdateMainChainIndex?",
  "[File: byteball/ocore/main_chain.js] [Function: checkNotRebuildingStableMainChainAndGoDown()] [Stable Unit Removal] The function queries for stable units with main_chain_index > last_main_chain_index and throws an error if any exist - can an attacker exploit a timing window where units are marked stable between the check and the subsequent UPDATE in goDownAndUpdateMainChainIndex, allowing stable units to be removed from MC without triggering this safety check, permanently corrupting the last ball chain?",
  "[File: byteball/ocore/main_chain.js] [Function: checkNotRebuildingStableMainChainAndGoDown()] [Error Message Info Leak] The error message includes 'removing stable units X from MC after adding Y with all parents Z' revealing internal DAG structure - while not directly exploitable, can this information disclosure help an attacker understand the current MC topology and time their attacks to maximize impact on stability advancement?",
  "[File: byteball/ocore/main_chain.js] [Function: checkNotRebuildingStableMainChainAndGoDown()] [Query Performance] The query SELECT unit FROM units WHERE is_on_main_chain=1 AND main_chain_index>? AND is_stable=1 scans all stable MC units above a threshold - if an attacker floods the network causing millions of units to stabilize, can this query become so slow (O(n) where n is stable units) that every MC update takes seconds, effectively DoSing the network by making transaction confirmation take hours?",
  "[File: byteball/ocore/main_chain.js] [Function: goDownAndUpdateMainChainIndex()] [UPDATE Without WHERE] The query 'UPDATE units SET is_on_main_chain=0, main_chain_index=NULL WHERE main_chain_index>?' clears MC flags for all units above a threshold - if last_main_chain_index is accidentally 0 due to a bug, can this UPDATE clear the genesis unit's MC flags, corrupting the entire DAG history irreversibly and requiring a hard fork?",
  "[File: byteball/ocore/main_chain.js] [Function: goDownAndUpdateMainChainIndex()] [In-Memory Desync] The function updates storage.assocUnstableUnits in a loop AFTER executing the database UPDATE - if the node crashes between the DB update and the cache update, can the node restart with a database where MC flags are cleared but a cache where they still exist, causing all future MC comparisons to fail the _.isEqual check and crash the node repeatedly?",
  "[File: byteball/ocore/main_chain.js] [Function: goDownAndUpdateMainChainIndex()] [MCI Assignment Race] The main_chain_index++ occurs in a loop processing arrNewMcUnits sequentially via async.eachSeries - if the callback for one unit hangs or times out, can subsequent units be assigned MCIs in the wrong order or skip MCIs entirely, breaking the monotonicity invariant where MCI must increase strictly along any path in the DAG?",
  "[File: byteball/ocore/main_chain.js] [Function: goDownAndUpdateMainChainIndex()] [goUp() Infinite Loop] The nested goUp() function recursively traverses parents with main_chain_index === null - can an attacker create a unit whose parents form a cycle in the 'main_chain_index IS NULL' subgraph, causing goUp to recurse infinitely and hang this critical function, preventing any MCI assignments and halting all transaction confirmations?",
  "[File: byteball/ocore/main_chain.js] [Function: goDownAndUpdateMainChainIndex()] [String Concatenation SQL Injection] The query uses 'WHERE unit IN('+strUnitList+')' with strUnitList built from arrUnits.map(db.escape).join(', ') - if db.escape() has a bug or an attacker finds a unit hash that breaks the escape logic, can they inject arbitrary SQL to manipulate the UPDATE query, potentially marking attacker-controlled units as being on MC or corrupting other database state?",
  "[File: byteball/ocore/main_chain.js] [Function: goDownAndUpdateMainChainIndex()] [arrNewMcUnits Reversal] The function calls arrNewMcUnits.reverse() to process units in ascending MCI order - if the initial accumulation in goUpFromUnit pushes units in inconsistent order due to race conditions, can the reversed array still be out of order, causing MCIs to be assigned non-monotonically and creating a permanent inconsistency between declared MCI values and actual topological ordering?",
  "[File: byteball/ocore/main_chain.js] [Function: goDownAndUpdateMainChainIndex()] [unit_authors Update] After updating units table, it updates 'unit_authors SET _mci=?' - if this second UPDATE fails due to database error but the first succeeds, can queries that rely on unit_authors._mci return stale data, causing address balance calculations or AA trigger detection to use wrong MCI values and produce incorrect results?",
  "[File: byteball/ocore/main_chain.js] [Function: goDownAndUpdateMainChainIndex()] [NULL Propagation] The final query sets '_mci=NULL WHERE main_chain_index IS NULL' - if there are millions of unstable units, can this UPDATE take minutes to execute, holding a database write lock that blocks all other operations and effectively DoSing the node until the update completes?",
  "[File: byteball/ocore/main_chain.js] [Function: updateLatestIncludedMcIndex()] [Infinite Recursion] The propagateLIMCI() function calls itself recursively when rows.length > 0 - can an attacker create a DAG structure where LIMCI propagation never converges (e.g., cycles or constantly increasing LIMCI values), causing infinite recursion that exhausts stack space and crashes the node?",
  "[File: byteball/ocore/main_chain.js] [Function: updateLatestIncludedMcIndex()] [calcLIMCIs Deadlock] The calcLIMCIs() function removes units from assocChangedUnits as it processes them, then recursively calls itself if any remain - can an attacker create a dependency cycle where unit A's LIMCI depends on unit B's LIMCI which depends on C's which depends on A's, causing calcLIMCIs to never remove all units and recurse infinitely?",
  "[File: byteball/ocore/main_chain.js] [Function: updateLatestIncludedMcIndex()] [LIMCI = -1 Bypass] When a parent is on MC, the code sets 'props.latest_included_mc_index = parent_props.main_chain_index' - if an attacker creates a unit whose parent has main_chain_index = -1 due to overflow or corruption, can this propagate -1 as LIMCI to descendants, breaking all queries that rely on LIMCI being non-negative and causing validation failures for all child units?",
  "[File: byteball/ocore/main_chain.js] [Function: updateLatestIncludedMcIndex()] [max_limci < 0 Exception] The code throws 'max limci < 0 for unit X' if all parents have negative max_limci - can an attacker deliberately create this condition by exploiting integer underflow in parent MCI calculations, causing the exception to halt MC updates and prevent any new units from being added until manual database repair?",
  "[File: byteball/ocore/main_chain.js] [Function: updateLatestIncludedMcIndex()] [assocLimcisByUnit Memory Leak] The assocLimcisByUnit object accumulates entries for all units being processed but is never explicitly cleared - if a single updateMainChain() call processes millions of units (e.g., during initial sync), can this object grow to gigabytes of memory, causing OOM and node crash?",
  "[File: byteball/ocore/main_chain.js] [Function: propagateLIMCI()] [UPDATE Without Limit] The query 'UPDATE units SET latest_included_mc_index=? WHERE unit=?' is called in a loop for potentially thousands of units via async.eachSeries - if this loop encounters a unit that doesn't exist (e.g., deleted by parallel archiving), can the UPDATE fail silently, leaving that unit with NULL LIMCI forever and breaking all child units that try to propagate LIMCI from it?",
  "[File: byteball/ocore/main_chain.js] [Function: updateLatestIncludedMcIndex()] [assocDbLimcisByUnit Comparison] The code compares assocDbLimcisByUnit with assocLimcisByUnit using _.isEqual and throws error if different - if the two objects are built using different iteration orders (JavaScript object property iteration is not guaranteed), can this throw false positive errors even when the data is actually consistent, causing nodes to crash unnecessarily?",
  "[File: byteball/ocore/main_chain.js] [Function: updateLatestIncludedMcIndex()] [NULL LIMCI Propagation] Units with main_chain_index > last_main_chain_index OR main_chain_index IS NULL get their LIMCI set to NULL - can an attacker exploit this by creating a unit that triggers MC reorg, causing its descendants to have NULL LIMCI temporarily, and if those descendants have children committed during that window, can those grandchildren inherit incorrect LIMCI values permanently?",
  "[File: byteball/ocore/main_chain.js] [Function: updateStableMcFlag()] [bKeepStabilityPoint Override] The function immediately calls finish() and returns if bKeepStabilityPoint is true - can an attacker exploit a code path that sets bKeepStabilityPoint=true incorrectly, preventing any stability advancement permanently and causing all units to remain unstable forever, breaking light client sync and last ball updates?",
  "[File: byteball/ocore/main_chain.js] [Function: updateStableMcFlag()] [No Best Children] The code throws 'no best children of last stable MC unit X?' if rows.length === 0 - can an attacker create a unit that becomes the last stable MC unit but has zero best children due to all its children being on alt branches, causing this exception to halt all future stability advancement until a hard fork manually fixes the state?",
  "[File: byteball/ocore/main_chain.js] [Function: updateStableMcFlag()] [arrMcRows.length !== 1] The code throws 'not a single MC child?' if the number of MC children is not exactly 1 - can a race condition during MC updates cause two units to both be marked is_on_main_chain=1 with the same best_parent, causing this exception to be thrown randomly and halting stability advancement unpredictably?",
  "[File: byteball/ocore/main_chain.js] [Function: updateStableMcFlag()] [Recursive Call without Bound] The function calls itself recursively via advanceLastStableMcUnitAndTryNext()  updateStableMcFlag() - if many consecutive MCIs become stable in one pass, can the recursive call depth exceed JavaScript's stack limit, causing a stack overflow that crashes the node mid-stability-advancement and leaves the database in an inconsistent state?",
  "[File: byteball/ocore/main_chain.js] [Function: updateStableMcFlag()] [min_mc_wl = -1 Return] When findMinMcWitnessedLevel returns -1 (couldn't collect witnesses), the function calls finish() without advancing stability - can an attacker manipulate witness postings to repeatedly force min_mc_wl = -1, preventing any stability advancement and keeping all units unstable indefinitely, breaking the protocol's finality guarantee?",
  "[File: byteball/ocore/main_chain.js] [Function: updateStableMcFlag()] [arrFreeUnits Collection] The code collects free units by iterating storage.assocUnstableUnits - if an attacker floods the network with thousands of free units, can the determineIfStableInLaterUnits call with a large arrFreeUnits array become so slow that updateStableMcFlag takes minutes, causing 1+ hour transaction delay and medium severity impact?",
  "[File: byteball/ocore/main_chain.js] [Function: updateStableMcFlag()] [MC Tip Not Single] The query for tip units with 'is_free=1 AND is_on_main_chain=1' throws 'not a single mc tip' if rows.length !== 1 - can two units both be marked as MC tips simultaneously due to race conditions, causing this exception to halt all stability checks until database state is manually repaired?",
  "[File: byteball/ocore/main_chain.js] [Function: updateStableMcFlag()] [arrAllParents.length Check] The code checks 'if (arrAllParents.length <= 1)' to determine if there's a single free unit - if arrAllParents was incorrectly populated earlier due to a bug in findNextUpMainChainUnit, can this condition be false when it should be true, causing the code to skip determineIfStableInLaterUnits when it shouldn't and advancing stability incorrectly?",
  "[File: byteball/ocore/main_chain.js] [Function: findMinMcWitnessedLevel()] [level < first_unstable_mc_level] The function returns -1 if level drops below first_unstable_mc_level - can an attacker create a long chain of units with gradually decreasing witnessed_level values that forces this function to walk back to genesis, taking exponential time and causing DoS where findMinMcWitnessedLevel never completes?",
  "[File: byteball/ocore/main_chain.js] [Function: findMinMcWitnessedLevel()] [Witness List Substitution] The function initially uses arrWitnesses parameter but can switch to arrTipUnitWitnesses if first_unstable_mc_index <= constants.lastBallStableInParentsUpgradeMci - can an attacker exploit the boundary condition where MCI equals the upgrade MCI, causing different nodes to use different witness lists and collect different witnesses, leading to different min_mc_wl values and consensus failure on which units should stabilize?",
  "[File: byteball/ocore/main_chain.js] [Function: findMinMcWitnessedLevel()] [arrCollectedWitnesses.length < MAJORITY_OF_WITNESSES] The code recurses via addWitnessesAndGoUp(best_parent_unit) while collected witnesses < 7 - can an attacker create a DAG where no path from tip to genesis contains 7 witness addresses, causing infinite recursion that never reaches the base case and hangs the stability check indefinitely?",
  "[File: byteball/ocore/main_chain.js] [Function: findMinMcWitnessedLevel()] [Duplicate Witness Collection] The code checks 'arrCollectedWitnesses.indexOf(address) === -1' before adding a witness - if the same address authors multiple units on the MC, can the function count it multiple times due to race conditions in array updates, incorrectly reaching MAJORITY_OF_WITNESSES threshold with fewer than 7 distinct witnesses and advancing stability prematurely?",
  "[File: byteball/ocore/main_chain.js] [Function: findMinMcWitnessedLevel()] [min_mc_wl Integer Overflow] The function tracks min_mc_wl starting at Number.POSITIVE_INFINITY and updates it with Math.min - if witnessed_level values contain corrupted negative numbers or NaN, can min_mc_wl become NaN or negative infinity, causing all subsequent comparisons (min_mc_wl >= first_unstable_mc_level) to fail and preventing any stability advancement?",
  "[File: byteball/ocore/main_chain.js] [Function: createListOfBestChildren()] [Empty Array Handling] The function returns empty array if arrParentUnits.length === 0 - can this lead to incorrect max_alt_level calculations in determineMaxAltLevel where an empty alt branch is treated as having no impact on stability, causing units to stabilize prematurely when active alt branches exist?",
  "[File: byteball/ocore/main_chain.js] [Function: createListOfBestChildren()] [Infinite Loop via is_free] The recursive goDownAndCollectBestChildren continues until finding a unit with is_free === 1 - can an attacker create a chain of non-free units with circular best_parent relationships that never encounters a free unit, causing infinite recursion in this function and hanging all stability checks?",
  "[File: byteball/ocore/main_chain.js] [Function: createListOfBestChildren()] [arrBestChildren Memory] The arrBestChildren array accumulates all units in the best-child chain - if an attacker creates a DAG with millions of units in a single best-child chain, can this array grow to gigabytes of memory, causing OOM crashes when updateStableMcFlag tries to process it?",
  "[File: byteball/ocore/main_chain.js] [Function: determineMaxAltLevel()] [SQL Query Complexity] The query for MCI >= constants.altBranchByBestParentUpgradeMci uses 'CROSS JOIN units AS bpunits ON units.best_parent_unit=bpunits.unit' - if arrAltBestChildren contains thousands of units, can this query become O(n) complexity, taking minutes to execute and blocking all database operations, causing 1+ hour transaction delay?",
  "[File: byteball/ocore/main_chain.js] [Function: determineMaxAltLevel()] [max_alt_level NULL Handling] The query result can be NULL if no units match the condition, and the code returns 'max_alt_level || first_unstable_mc_level' - can an attacker exploit this by creating an alt branch where all units have witnessed_level >= best_parent witnessed_level (no WL increase), causing NULL result that defaults to first_unstable_mc_level, making the stability check use wrong max_alt_level and advance stability incorrectly?",
  "[File: byteball/ocore/main_chain.js] [Function: determineMaxAltLevel()] [Old Algorithm Bug] The comment says 'this sql query is totally wrong but we still leave it for compatibility' - can the intentionally buggy old algorithm (used for MCI < upgrade MCI) produce different max_alt_level values than expected, causing historical units near the upgrade boundary to have inconsistent stability determinations across nodes and creating a potential chain split?",
  "[File: byteball/ocore/main_chain.js] [Function: determineMaxAltLevel()] [Witness Count Check] The old algorithm includes a subquery counting matching witnesses with threshold COUNT_WITNESSES - MAX_WITNESS_LIST_MUTATIONS - can an attacker exploit the migration period where some nodes use old algorithm and some use new, causing different max_alt_level calculations and consensus failure on which units should stabilize?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnits()] [Hardcoded Exception Units] The function contains 10+ hardcoded unit hash exceptions that return true unconditionally - can an attacker who discovers the pattern for being added to this list (e.g., causing validation errors during testnet) exploit this to have their mainnet units hardcoded as stable, allowing them to double-spend by making two incompatible units both appear stable?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnits()] [is_free = 1 False Negative] The function returns false if objEarlierUnitProps.is_free === 1 - can an attacker exploit timing where a unit transitions from free to non-free during this check, causing the function to return false when it should check stability properly, preventing legitimate units from stabilizing and causing 1+ day transaction delays?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnits()] [max_later_limci Calculation] The function calculates max_later_limci using Math.max.apply on arrLaterUnitProps - if arrLaterUnitProps is empty due to a bug, can Math.max.apply return -Infinity, causing the comparison 'max_later_limci < objEarlierUnitProps.main_chain_index' to always be true and making no units ever appear stable in later units?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnits()] [best_parent_unit Reading] The function calls readBestParentAndItsWitnesses to get witnesses from earlier unit's best parent - if the best parent has different witnesses than the unit being checked, can this cause the stability calculation to use wrong witness list, making units appear stable/unstable incorrectly and advancing stability at wrong times?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnits()] [findMinMcWitnessedLevel Callback Hell] The deeply nested callbacks (findMinMcWitnessedLevel  determineIfHasAltBranches  createListOfBestChildrenIncludedByLaterUnits  determineMaxAltLevel) span hundreds of lines - can an exception in any intermediate callback escape error handling, preventing handleResult from being called and leaving the stability check hanging forever, blocking all future MC updates?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnits()] [goDownAndCollectBestChildrenFast Performance] The fast path uses setImmediate every 100 iterations 'if (count % 100 === 0)' - can an attacker create a best-child chain with exactly 99, 199, 299 units to avoid setImmediate checks, causing the function to block the event loop for seconds and making the node unresponsive to network messages?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnits()] [arrNotIncludedTips Heuristic] The code adds units to arrNotIncludedTips if they meet various heuristics like 'level >= max_later_level' - can an attacker craft units that falsely match these heuristics (e.g., artificially high level values) to be excluded from best children list, causing createListOfBestChildrenIncludedByLaterUnits to return incomplete results and make stability checks pass when they shouldn't?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnits()] [findBestChildrenNotIncludedInLaterUnits Recursion] The function recursively calls findBestChildrenNotIncludedInLaterUnits  goUp  findBestChildrenNotIncludedInLaterUnits - can an attacker create a DAG structure where this recursion never converges (e.g., circular parent relationships in the non-included subgraph), causing infinite recursion and stack overflow?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnits()] [arrRemovedBestChildren Accumulation] The arrRemovedBestChildren array accumulates removed units across multiple goUp iterations but is never cleared - if the DAG has complex structure with many back-and-forth parent relationships, can this array grow to millions of entries, causing _.difference(arrBestChildren, arrRemovedBestChildren) to take minutes and DoS the stability check?",
  "[File: byteball/ocore/main_chain.js] [Function: findMinMcWitnessedLevelOld()] [Witness Count Bug] The comment explicitly says 'this is a bug, should count only unique witnesses' where count += row.count adds witness counts without checking uniqueness - can an attacker who controls multiple witness addresses deliberately author the same unit with multiple witness identities, causing count to reach MAJORITY_OF_WITNESSES threshold faster than intended and advancing stability prematurely with fewer than 7 distinct witnesses actually voting?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnitsWithMaxLastBallMciFastPath()] [Fast Path Bypass] The function falls back to determineIfStableInLaterUnits if 'objEarlierUnitProps.main_chain_index > max_last_ball_mci' - can an attacker deliberately manipulate max_last_ball_mci values to force all stability checks to use the slower path, causing each check to take seconds instead of milliseconds and creating 1+ hour transaction delays under normal network load?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnitsWithMaxLastBallMciFastPath()] [readMaxLastBallMci Error] If storage.readMaxLastBallMci fails or returns incorrect data due to database corruption, can this function incorrectly return true for unstable units, causing them to be marked stable prematurely and breaking the protocol's safety guarantees about finality?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnitsAndUpdateStableMcFlag()] [Double Callback Invocation] The function calls handleResult(bStable) early, then continues to acquire write lock and update stability - if the callback assumes synchronous completion and immediately starts another MC update, can two parallel stability updates occur (one from callback, one from continued execution), causing race conditions in markMcIndexStable and database corruption?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnitsAndUpdateStableMcFlag()] [Write Lock Deadlock] The function calls mutex.lock(['write'], ...) after returning from handleResult - if another operation already holds a write lock and is waiting for this function to complete, can a deadlock occur where neither operation can proceed, permanently freezing the node and requiring manual restart?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnitsAndUpdateStableMcFlag()] [last_stable_mci >= v4UpgradeMci Check] The function throws error if 'last_stable_mci >= constants.v4UpgradeMci' and unit is not stable in DB - can this check be bypassed by timing the attack exactly at MCI = v4UpgradeMci - 1, allowing the attacker to exploit both pre-v4 and post-v4 stability logic simultaneously and cause chain split?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnitsAndUpdateStableMcFlag()] [new_last_stable_mci <= last_stable_mci] The code throws error if new MCI is not higher than existing - can integer overflow cause new_last_stable_mci to wrap around to negative value or zero, making it appear less than last_stable_mci and throwing this error even though stability should advance legitimately?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnitsAndUpdateStableMcFlag()] [advanceLastStableMcUnitAndStepForward Loop] The function calls markMcIndexStable in a loop incrementing mci++ until reaching new_last_stable_mci - can an attacker manipulate the DAG so that new_last_stable_mci is billions larger than current, causing this loop to run for hours and blocking all other database operations with the write lock, creating total network halt?",
  "[File: byteball/ocore/main_chain.js] [Function: determineIfStableInLaterUnitsAndUpdateStableMcFlag()] [Batch Write Failure] After all markMcIndexStable calls, it does 'batch.write({ sync: true })' - if this fails (e.g., disk full), can the database COMMIT succeed but KV store write fail, causing permanent inconsistency between relational DB and KV store where units are marked stable in DB but not in KV, breaking AA state reads?",
  "[File: byteball/ocore/main_chain.js] [Function: markMcIndexStable()] [storage.assocStableUnitsByMci Memory Leak] The function creates storage.assocStableUnitsByMci[mci] array for each stabilized MCI - are these arrays ever cleaned up, or do they accumulate indefinitely, causing memory to grow unbounded as the blockchain grows and eventually crashing the node with OOM after millions of MCIs?",
  "[File: byteball/ocore/main_chain.js] [Function: markMcIndexStable()] [Partial Stabilization] The function updates storage.assocUnstableUnits by setting is_stable=1 and moving to assocStableUnits, but if the subsequent database UPDATE fails, can the in-memory cache show units as stable while the database shows them as unstable, causing all future validation checks to disagree between nodes and creating consensus failure?",
  "[File: byteball/ocore/main_chain.js] [Function: markMcIndexStable()] [arrStabilizedUnits Delete] The code deletes from storage.assocUnstableUnits after stabilization - if a parallel operation is iterating over assocUnstableUnits at the same time, can the iterator skip entries or crash due to concurrent modification, causing that operation to miss processing some units?",
  "[File: byteball/ocore/main_chain.js] [Function: markMcIndexStable()] [UPDATE units SET is_stable=1] The UPDATE is done before handleNonserialUnits checks for sequence issues - can a unit be marked is_stable=1 in the database but then have its sequence changed from temp-bad to final-bad, causing a stable unit to have final-bad sequence which violates the invariant that stable units with good sequence can be referenced?",
  "[File: byteball/ocore/main_chain.js] [Function: handleNonserialUnits()] [sequence = 'final-bad' Logic] The function identifies temp-bad units that should become final-bad by finding stable conflicting units - can an attacker exploit timing where a conflicting unit becomes stable between the 'SELECT * FROM units WHERE sequence!='good'' query and the findStableConflictingUnits call, causing a unit to be marked good when it should be final-bad, allowing a double-spend to be confirmed as valid?",
  "[File: byteball/ocore/merkle.js] [Function: hash()] [Hash collision] Since hash() concatenates strings before hashing (line 6), can an attacker craft two different elements that produce the same hash by exploiting string boundary ambiguity (e.g., 'ab' + 'c' vs 'a' + 'bc' both becoming 'abc'), allowing forged Merkle proofs to pass verification in AA formulas or address definitions, potentially enabling unauthorized fund access?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Second preimage attack] In getMerkleRoot() line 15, when hashing pairs, can an attacker find a collision where hash(hash(A) + hash(B)) equals hash(hash(C) + hash(D)) for different element pairs, allowing substitution of data feed values in 'in merkle' address definitions without detection, potentially bypassing authorization checks?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Hash prefix collision] In verifyMerkleProof() lines 90-92, the concatenation order depends on index parity - can an attacker exploit this by finding elements where hash(A + B) = hash(B + A), causing the same proof to validate different elements and allowing impersonation in multi-signature address definitions?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Tree structure manipulation] Since getMerkleRoot() builds the tree bottom-up (lines 11-18), can an attacker craft a malicious element set where intermediate hash collisions occur at higher levels, causing two different oracle data feed arrays to produce the same Merkle root, allowing the attacker to substitute oracle data and manipulate AA execution outcomes?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Odd element duplication] In getMerkleRoot() line 14, when arrHashes.length is odd, the last element is duplicated (hash2_index = i when i+1 >= length) - can an attacker exploit this by constructing trees where the duplicated element creates predictable hash patterns, allowing them to forge proofs for non-existent elements in oracle data feeds used by AAs, potentially causing incorrect AA state transitions and fund loss?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleProof()] [Duplicate sibling in proof] In getMerkleProof() line 32, the same duplication logic applies - if an element is at an odd position at the end of the array, its sibling in the proof will be itself - can this be exploited to create ambiguous proofs where an attacker can claim any element was the duplicated one, bypassing 'in merkle' validation in address definitions and gaining unauthorized spending rights?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Duplication replay attack] Since verifyMerkleProof() (lines 84-95) does not explicitly check whether siblings are duplicates, can an attacker submit a proof claiming an element is both the original and the duplicate in an odd-sized tree, allowing them to forge membership proofs for elements not actually in the original oracle data feed, potentially manipulating AA formula evaluation results?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleProof()] [Index bounds bypass] getMerkleProof() checks index bounds only at line 23-24 - but if element_index is exactly arrElements.length, does the check fail to catch this edge case, potentially causing an out-of-bounds read that could return garbage data and create invalid proofs that might still verify against a corrupted root, breaking oracle data integrity?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Negative index exploitation] In verifyMerkleProof() line 85, proof.index is used directly without validation - if an attacker passes a negative index through deserializeMerkleProof(), will the modulo operation (line 89) on negative numbers produce unexpected results, potentially allowing verification of elements not in the tree and bypassing AA authorization checks?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Index overflow] In verifyMerkleProof() line 93, index is repeatedly divided by 2 using Math.floor() - for extremely large initial index values (e.g., 2^53 from deserialized proof), could integer precision loss in JavaScript cause incorrect path reconstruction, allowing forged proofs to verify and enabling unauthorized access to funds in AA-controlled addresses?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleProof()] [OverIndex null check bypass] getMerkleProof() throws an error if overIndex is null (lines 44-45), but this check occurs after the loop - if the loop somehow completes with overIndex remaining null due to array manipulation, could this cause undefined behavior in subsequent iterations, potentially generating corrupt proofs that verify against wrong roots?",
  "[File: byteball/ocore/merkle.js] [Function: deserializeMerkleProof()] [No validation] deserializeMerkleProof() (lines 75-82) performs NO validation on the input - it blindly splits on '-' and trusts the result - can an attacker craft malicious serialized proofs with empty components, special characters, or incorrect structure that cause verifyMerkleProof() to behave unexpectedly, potentially bypassing authorization in address definitions or AA formulas?",
  "[File: byteball/ocore/merkle.js] [Function: deserializeMerkleProof()] [Type confusion] deserializeMerkleProof() line 79 returns proof.index as a STRING (from arr.shift()) but verifyMerkleProof() line 89 uses it in modulo arithmetic (index % 2) - does JavaScript's type coercion handle this correctly for all possible string values, or can an attacker inject non-numeric strings (e.g., '0x1', '1e10', 'Infinity') that cause verification logic to malfunction and accept forged proofs?",
  "[File: byteball/ocore/merkle.js] [Function: deserializeMerkleProof()] [Empty siblings array] If a serialized proof contains consecutive dashes (e.g., '0--root'), deserializeMerkleProof() will create empty string siblings in proof.siblings array - will verifyMerkleProof() treat empty strings as valid hashes in concatenation (lines 90-92), potentially allowing trivial hash collisions and forged proofs that bypass AA security?",
  "[File: byteball/ocore/merkle.js] [Function: deserializeMerkleProof()] [Missing components] If serialized_proof has fewer than 2 components (e.g., just 'root' or ''), deserializeMerkleProof() will return a proof with undefined index or root - does verifyMerkleProof() handle undefined values safely, or will it cause crashes or undefined behavior that could be exploited to DoS nodes or bypass validation?",
  "[File: byteball/ocore/merkle.js] [Function: serializeMerkleProof()] [Dash injection] serializeMerkleProof() line 70 joins siblings with '-' delimiter - if an attacker can control sibling hash values (via hash collisions or input manipulation) to include '-' characters in base64 hashes, can they inject fake siblings into the serialized proof that deserializeMerkleProof() will incorrectly parse, allowing creation of valid-looking proofs for arbitrary elements?",
  "[File: byteball/ocore/merkle.js] [Function: serializeMerkleProof()] [Index spoofing] serializeMerkleProof() line 68 puts proof.index first without validation - if proof.index is a malicious string like '-1-fakehash', will this corrupt the serialization format such that deserialization produces a completely different proof structure that still verifies, enabling proof forgery attacks on AA formulas?",
  "[File: byteball/ocore/merkle.js] [Function: serializeMerkleProof()] [Root collision] serializeMerkleProof() line 71 appends proof.root last - if the last sibling hash contains the delimiter pattern '-'+proof.root, could deserialization incorrectly identify the root, causing verification against wrong Merkle roots and allowing attackers to use proofs from one data feed tree to impersonate elements in another data feed?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Empty proof.siblings] If proof.siblings is an empty array, verifyMerkleProof() loop (lines 87-94) never executes and returns (hash(element) === proof.root) - can an attacker exploit this by crafting single-element trees where they control the element to match any root they want, bypassing multi-element oracle data feed validation in AAs and causing incorrect state transitions?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Siblings length mismatch] verifyMerkleProof() does not validate that proof.siblings.length matches the expected tree depth for proof.index - can an attacker provide too few or too many siblings, causing the verification to either fail silently or use partial paths that incorrectly validate forged elements?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Non-string siblings] If proof.siblings contains non-string values (numbers, objects, arrays) from malicious deserialization, will the hash() function on lines 90-92 handle them correctly, or will JavaScript's toString() coercion create unexpected hash inputs that validate forged proofs?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Root format validation] verifyMerkleProof() line 95 compares the_other_sibling === proof.root using string equality - if hash() returns base64 but proof.root is hex or vice versa due to encoding mismatches, could this always return false even for valid proofs, causing DoS of legitimate 'in merkle' address definitions and freezing funds?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Empty array] getMerkleRoot() does not check for empty arrElements - if called with [], the while loop (lines 11-18) never executes and returns undefined from arrHashes[0], potentially causing AA formulas to accept undefined as a valid Merkle root and bypass data feed validation entirely, allowing unauthorized state changes?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Single element] For single-element arrays, getMerkleRoot() returns hash(arrElements[0]) directly - is this consistent with proof verification expectations? Can an attacker exploit the difference between single-element and multi-element tree structures to forge proofs that work for one structure but claim membership in another, bypassing oracle validation?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Array mutation] getMerkleRoot() line 10 uses arrElements.map(hash) which creates a new array, but does not validate arrElements is actually an array - if an attacker passes an array-like object with a malicious map function, could they inject arbitrary hashes into the tree construction and generate a controlled root that validates forged proofs?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleProof()] [Array length change] getMerkleProof() does not freeze or copy arrElements before processing - if another thread or callback modifies arrElements during proof generation (especially in async contexts), could the proof become inconsistent with the final root, creating race conditions that allow temporary proof forgeries during AA execution?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [AA non-determinism] Since AA formula evaluation calls verifyMerkleProof() (formula/evaluation.js line 1668), and JavaScript's type coercion behavior may vary across Node.js versions or V8 implementations, could proof.index type confusion (string vs number) cause non-deterministic validation results on different nodes, leading to chain splits where some nodes accept an AA response and others reject it?",
  "[File: byteball/ocore/merkle.js] [Function: deserializeMerkleProof()] [Proof size DoS] formula/evaluation.js limits proof length to 1024 chars (line 1662), but deserializeMerkleProof() still processes it - can an attacker craft a 1024-char proof with thousands of tiny siblings (single-char + delimiters) that causes verifyMerkleProof() to iterate excessively, creating a DoS vulnerability where AA execution times out and blocks network transaction processing for hours or days?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Element coercion in AA] formula/evaluation.js lines 1651-1654 coerce boolean/number elements to strings before passing to verifyMerkleProof() - could the difference between JavaScript's string coercion ('true' vs 'false', '0' vs '0.0') and the actual string stored in oracle data feeds cause valid proofs to fail or invalid proofs to pass, breaking AA authorization logic?",
  "[File: byteball/ocore/merkle.js] [Function: hash()] [Encoding mismatch in AA] hash() uses UTF-8 encoding (line 6) - if AA formula data or oracle feeds contain binary data or different encodings, could encoding mismatches cause hash() to produce different results than expected, allowing attackers to create proofs that verify in AA context but don't match the actual oracle data, manipulating AA state and causing fund loss?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Definition validation bypass] In definition.js 'in merkle' operator (line 939), if verifyMerkleProof() returns false, it sets fatal_error and returns false - but if verifyMerkleProof() throws an exception due to malformed proof, is the exception caught properly, or could it bypass the fatal_error check and allow the definition evaluation to continue with undefined results, potentially authorizing unauthorized spends?",
  "[File: byteball/ocore/merkle.js] [Function: deserializeMerkleProof()] [Authentifier injection] definition.js line 936 gets serialized_proof from assocAuthentifiers[path] - can an attacker craft a malicious path string that causes deserializeMerkleProof() to return a proof object with prototype pollution (e.g., proof.__proto__ or proof.constructor), allowing them to override verifyMerkleProof() behavior and bypass all Merkle validation in address definitions?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Root comparison with data feeds] definition.js line 943 checks if proof.root exists in data_feeds - if verifyMerkleProof() returns true but proof.root is undefined, empty string, or null, could the database query match everything or nothing, either allowing unauthorized access or causing DoS by rejecting all legitimate 'in merkle' definitions and permanently freezing funds?",
  "[File: byteball/ocore/merkle.js] [Function: hash()] [Base64 encoding collision] hash() outputs base64 (line 6) which can contain '+', '/', '=' characters - if these appear in hashes and interact badly with the '-' delimiter in serialization, could this cause deserialization ambiguity where one serialized proof deserializes to multiple different proof structures, enabling proof forgery?",
  "[File: byteball/ocore/merkle.js] [Function: hash()] [UTF-8 edge cases] hash() uses UTF-8 encoding - if an attacker includes invalid UTF-8 sequences or Unicode normalization-sensitive characters in elements, could different nodes normalize strings differently, causing hash() to return different results and breaking consensus on Merkle root validation across the network?",
  "[File: byteball/ocore/merkle.js] [Function: hash()] [Length extension attack] While SHA-256 itself is resistant to length extension, the concatenation in getMerkleRoot() line 15 (hash(hashA + hashB)) creates a new input - could an attacker exploit the structure of base64-encoded hashes to craft extension attacks where hash(A + B + X) for some X equals hash(C + D), allowing tree structure manipulation?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleProof()] [Exponential tree depth] getMerkleProof() recursively halves array size (line 43) - for an array of size 2^30, this requires 30 iterations - can an attacker submit an extremely large oracle data feed that causes getMerkleProof() to consume excessive memory or CPU when building proof.siblings, creating a DoS vulnerability that freezes nodes attempting to validate 'in merkle' definitions?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Siblings array bomb] If proof.siblings contains thousands of entries (from a deep tree), verifyMerkleProof() lines 87-94 must iterate through all of them - even with the 1024-char serialization limit in AA context, could a cleverly compressed proof with minimal siblings size but maximal iteration count cause verification to become a DoS vector?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Memory exhaustion] getMerkleRoot() builds arrOverHashes arrays repeatedly (lines 12-17) - for very large element arrays, does this cause multiple large array allocations that exhaust Node.js memory, potentially crashing nodes that attempt to process oracle data feeds with millions of elements and causing network-wide outages?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleProof()] [Index at boundary] When element_index is exactly arrElements.length - 1 (last element) in an odd-sized array, getMerkleProof() duplicates this element as its own sibling (line 32) - does this create a degenerate proof that could be exploited to claim any element is the last element, bypassing positional verification in oracle data structures?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Proof with zero siblings] If proof.siblings is [] (single-element tree), verification becomes (hash(element) === proof.root) - can an attacker who controls one element in an oracle feed use this to construct a single-element subtree proof that validates, then claim this proof represents membership in the full multi-element feed, bypassing data integrity checks?",
  "[File: byteball/ocore/merkle.js] [Function: hash()] [Null/undefined input] hash() line 6 calls .update(str, 'utf8') - if str is null or undefined, does the crypto library throw an exception or coerce to string? Could an attacker exploit this in AA formulas by passing null elements that either crash the node (DoS) or produce predictable hashes that forge proofs?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Non-power-of-2 sizes] For array sizes that aren't powers of 2, getMerkleRoot() duplicates the last element multiple times at different levels - could this create structural patterns in the tree that make it easier to find hash collisions at specific positions, weakening the security of oracle data feed validation?",
  "[File: byteball/ocore/merkle.js] [Function: serializeMerkleProof() + deserializeMerkleProof()] [Round-trip loss] If serializeMerkleProof() is called on a proof object with additional properties (e.g., proof.metadata), deserializeMerkleProof() only restores index/siblings/root - could this cause information loss that makes subsequent operations behave differently, potentially allowing attackers to bypass validation steps that depend on proof metadata?",
  "[File: byteball/ocore/merkle.js] [Function: serializeMerkleProof()] [Index type preservation] serializeMerkleProof() line 68 converts proof.index to string via concatenation - if proof.index was originally a number, does the type change after round-trip through deserializeMerkleProof() affect verifyMerkleProof() behavior due to JavaScript's === vs == comparison semantics?",
  "[File: byteball/ocore/merkle.js] [Function: deserializeMerkleProof()] [Siblings ordering] deserializeMerkleProof() line 80 assigns arr directly to proof.siblings - if arr was modified during split() operation (unlikely but possible with prototype pollution), could the siblings order be corrupted, causing valid proofs to fail verification and freezing funds in 'in merkle' addresses?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Non-atomic tree construction] getMerkleRoot() modifies arrHashes in-place across multiple loop iterations (line 17) - in a concurrent environment where multiple threads generate Merkle roots simultaneously, could race conditions cause one thread's arrHashes to be corrupted by another thread, producing non-deterministic roots that break consensus?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleProof()] [Index tracking corruption] getMerkleProof() tracks index and overIndex across loop iterations (lines 26, 35, 39, 46) - if Node.js event loop allows context switching during this function, could the index variables be corrupted by reentrancy, generating incorrect proofs that either fail verification (DoS) or incorrectly verify (authorization bypass)?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Inconsistent validation] formula/evaluation.js checks proof length < 1024 before calling deserializeMerkleProof() (line 1662-1663), but definition.js has no such check (line 936-937) - can an attacker submit arbitrarily large proofs in address definitions that cause memory exhaustion or DoS when deserializeMerkleProof() processes them, freezing all transactions from addresses using 'in merkle' operator?",
  "[File: byteball/ocore/merkle.js] [Function: hash()] [Hash algorithm mismatch] merkle.js uses crypto.createHash('sha256') while object_hash.js may use different hashing - if oracle data feeds are hashed using object_hash for storage but merkle.js hashes for verification, could the hash algorithm mismatch cause all Merkle proofs to fail verification, permanently breaking 'in merkle' address definitions and freezing funds?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Element encoding mismatch] formula/evaluation.js coerces elements to strings (line 1652) but definition.js passes element directly from args[2] (line 934) - if definition evaluation expects binary data but formula evaluation uses string encoding, could this create inconsistencies where the same proof validates in one context but not another, causing non-deterministic AA execution?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Quadratic complexity] For an array of size N, getMerkleRoot() performs ~N hashing operations at first level, N/2 at second, N/4 at third, etc., totaling ~2N operations - however, if an attacker can control element content to maximize hash computation time (e.g., very long strings), could this create quadratic or worse complexity that DoS nodes processing large oracle feeds?",
  "[File: byteball/ocore/merkle.js] [Function: hash()] [Crypto exhaustion] hash() creates a new crypto.createHash() object for every call (line 6) - if an attacker triggers Merkle operations on massive trees with millions of elements, could the repeated crypto object creation exhaust system resources (file descriptors, memory), causing node crashes and network-wide transaction processing delays exceeding 24 hours?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Verification DoS] For deeply nested proofs (many siblings), verifyMerkleProof() performs repeated hash concatenations and hash computations (lines 90-92) - can an attacker submit maximum-depth proofs (e.g., from a tree with 2^30 elements) that cause verification to take seconds or minutes per proof, allowing them to flood the network with expensive verification operations that delay transaction processing?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleProof()] [Sibling selection logic] getMerkleProof() chooses siblings based on whether index matches i or hash2_index (lines 33-40) - if index equals hash2_index (occurs when i+1 >= arrHashes.length), both conditions could theoretically match - does this create ambiguity in sibling selection that could be exploited to generate multiple valid proofs for the same element, allowing proof replay attacks?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Path reconstruction] verifyMerkleProof() reconstructs the Merkle path using index % 2 to determine concatenation order (lines 89-92) - for malformed proofs where siblings are incorrectly ordered, could the verification still succeed due to hash collisions in the wrong order, allowing attackers to use proofs from unrelated trees to validate elements in oracle data feeds?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot() vs getMerkleProof()] [Tree construction inconsistency] getMerkleRoot() and getMerkleProof() both implement tree construction logic (lines 11-18 vs 28-47) - are these implementations guaranteed to produce identical tree structures? Could subtle differences allow an attacker to generate a proof against a slightly different tree structure that still verifies against the legitimate root?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Integer division precision] verifyMerkleProof() line 93 uses Math.floor(index/2) - for extremely large index values approaching JavaScript's MAX_SAFE_INTEGER (2^53-1), could precision loss in the division operation cause incorrect path reconstruction, allowing proofs with wrong indices to verify and bypass oracle validation?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleProof()] [Array index precision] getMerkleProof() uses integer arithmetic for array indexing (lines 31-32) - if arrElements.length approaches MAX_SAFE_INTEGER, could overflow in i+1 or i/2 calculations cause incorrect array access, generating corrupt proofs that claim to prove membership of wrong elements?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Oracle feed substitution] Since verifyMerkleProof() only validates proof against proof.root without verifying which oracle posted the root, can an attacker use a valid proof from Oracle A's data feed to impersonate membership in Oracle B's feed (by substituting proof.root), bypassing oracle-specific authorization in AA formulas and gaining unauthorized fund access?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleRoot()] [Feed timing attack] If an oracle posts multiple data feeds with different Merkle roots over time, and getMerkleRoot() produces deterministic roots, can an attacker predict future roots based on past patterns and precompute valid proofs for non-existent future data, allowing them to front-run AA executions that depend on oracle updates?",
  "[File: byteball/ocore/merkle.js] [Function: deserializeMerkleProof()] [Prototype pollution] deserializeMerkleProof() creates a new object with proof.root, proof.index, proof.siblings (lines 77-81) - if an attacker controls serialized_proof content to include strings like '__proto__' or 'constructor' in the split result, could this cause prototype pollution that affects subsequent verifyMerkleProof() calls and allows global bypass of Merkle validation?",
  "[File: byteball/ocore/merkle.js] [Function: serializeMerkleProof()] [Delimiter injection] If proof.siblings array contains base64 strings with '+' that look like multiple elements when split on '-', and serializeMerkleProof() doesn't escape delimiters (line 70), could this cause deserialization to produce more siblings than originally existed, creating invalid proofs that might still verify due to tree structure manipulation?",
  "[File: byteball/ocore/merkle.js] [Function: getMerkleProof() + verifyMerkleProof()] [Proof incompleteness] getMerkleProof() does not include the element itself in the proof object, only index/siblings/root (lines 50-54) - if verifyMerkleProof() is called with wrong element than originally proved, will it incorrectly validate, allowing attackers to substitute elements in oracle feeds while reusing the same proof structure?",
  "[File: byteball/ocore/merkle.js] [Function: hash()] [Output encoding] hash() returns base64-encoded output (line 6) - if other parts of Obyte expect hex encoding for hash comparison, could encoding mismatches cause valid Merkle proofs to always fail verification, creating a permanent DoS for all 'in merkle' address definitions and freezing funds indefinitely?",
  "[File: byteball/ocore/merkle.js] [Function: verifyMerkleProof()] [Root validation absence] verifyMerkleProof() does not validate that proof.root actually came from a trusted oracle or matches expected format - can an attacker submit proofs with arbitrary roots that verify correctly but don't correspond to any legitimate oracle data feed, bypassing the security assumption that roots come from trusted sources and manipulating AA execution?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Migration atomicity] If the migrate() function is interrupted after migrateUnits() completes but before migrateDataFeeds() finishes, does the system enter an inconsistent state where units exist in KV store but data feeds remain in SQL only, causing oracle queries to fail and potentially breaking AA execution that depends on data feeds?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Race condition] Can two nodes simultaneously execute migrate() on the same database, causing both to write conflicting data to the KV store and resulting in corrupted joint data or duplicate key writes that diverge node states and create a permanent chain split?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Rollback mechanism] If migration fails midway through processing 500,000 units, is there any rollback mechanism to restore the database to pre-migration state, or does partial migration leave the node in an unusable state requiring manual intervention and potentially causing network partition if other nodes completed migration successfully?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Transaction boundaries] Since migrateUnits() commits data in CHUNK_SIZE batches of 10,000 units, if a crash occurs after batch N is committed but before batch N+1, does the migration resume from the correct offset or does it restart from offset 0, potentially creating duplicate entries in the KV store with conflicting data?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Offset overflow] Can an attacker with a database containing more than 2^31 units cause integer overflow when offset += CHUNK_SIZE is executed repeatedly, making offset wrap to negative values and causing the migration to re-process earlier units, potentially overwriting correct data with stale data?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Unit hash validation bypass] When migrating units, readJoint() is called with bSql=true parameter, which bypasses the normal hash verification in storage.js. Can this allow corrupted units with invalid hashes in the SQL database to be migrated into the KV store, permanently cementing invalid data that would normally be rejected?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Data modification during migration] The code deletes objJoint.unit.timestamp and objJoint.unit.main_chain_index for certain unit versions. If the migration modifies unit data differently than the original storage logic, can this cause hash mismatches when the unit is later read from KV store and compared against the unit hash, breaking unit validation?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Version-specific deletion] When objJoint.unit.version === constants.versionWithoutTimestamp, the timestamp is deleted from the migrated data. If a unit somehow has an incorrect version field in SQL, could deleting the timestamp from a unit that actually requires it cause consensus divergence when other nodes read this unit from KV store?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [MCI deletion] The code unconditionally deletes main_chain_index from units during migration. If other code paths expect MCI to be present in the joint object read from KV store, could this deletion cause null reference errors or incorrect MC calculations that prevent unit validation and halt network consensus?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [JSON serialization inconsistency] When storing joints as JSON.stringify(objJoint), if the JavaScript JSON serializer produces different field ordering or whitespace compared to the original storage format, could this cause hash mismatches or create non-deterministic data that diverges across nodes?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Concurrent reads during migration] While migrate() is running and reading units from SQL with bSql=true, if another process is simultaneously writing new units to the SQL database, can newly written units be skipped by the migration query's rowid-based pagination, leaving them unmigrated and inaccessible after migration completes?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Database connection reuse] The migration uses the same conn object passed from sqlite_migrations.js. If the migration takes hours and the SQL connection times out or is closed by another process, does the migration crash with a connection error that leaves the database in partial migration state?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Data feed consistency] If oracle addresses post new data feeds while migrateDataFeeds() is executing, and these new feeds have rowid values within the range being processed but are inserted after the query executes, can these feeds be skipped during migration, causing AAs that depend on them to malfunction?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: commitBatch()] [Batch write failure handling] If batch.write() fails with an error (e.g., disk full, permission denied), the code throws an Error that aborts migration. Does this leave the KV store in an inconsistent state with some batches committed and others not, potentially causing the node to have incomplete unit history?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Memory exhaustion attack] With CHUNK_SIZE=10000 and PRAGMA cache_size=-400000 (400MB), if an attacker fills the database with extremely large units (maximum message payload), can the migration consume excessive memory when loading 10,000 large units simultaneously, causing OOM crashes that prevent migration completion?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Key format collision] Units are stored with key 'j\\\\n'+unit in the KV store. If a unit hash somehow contains a newline character or null byte due to a bug in object_hash.js, could this create key collisions where multiple units map to the same KV key, causing units to overwrite each other?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Data feed key collision] Data feeds use composite keys like 'df\\\\n'+address+'\\\\n'+feed_name+'\\\\ns\\\\n'+strValue+'\\\\n'+strMci. If any component (address, feed_name, value) contains newline characters, could this cause key parsing ambiguity where different feeds map to the same key and overwrite each other?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Duplicate feed overwrite] The code comment states 'duplicates will be overwritten, that's ok for data feed search'. However, if two data feeds have the same address+feed_name+value+MCI but different units, does overwriting one with the other cause loss of historical data that AAs might need for auditing or time-weighted calculations?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed value encoding collision] When encoding float values with string_utils.encodeDoubleInLexicograpicOrder(), if two different float values produce the same encoded string due to precision loss, do they collide in the KV store, causing queries for one value to incorrectly return data for a different value?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [MCI encoding issues] Using string_utils.encodeMci(row.main_chain_index) to encode MCI as part of the key. If encodeMci() produces non-unique encodings for different MCI values, or if it's not lexicographically sortable as intended, could this break range queries on data feeds by MCI?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [MySQL rejection] The code throws Error('only sqlite migration supported') if conf.storage !== 'sqlite'. However, if a node was previously running on MySQL and attempts to migrate, does this error leave the node unable to start, causing permanent exclusion from the network and reducing decentralization?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Cordova special path] Cordova builds use INSERT INTO joints table instead of KV batch writes. If the joints table schema differs between Cordova and non-Cordova builds, or if the INSERT uses getIgnore() incorrectly, can this cause Cordova nodes to store malformed joint data?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Cordova data divergence] Since Cordova nodes write to SQL joints table while non-Cordova nodes write to RocksDB, do Cordova and non-Cordova nodes effectively use different storage formats, and can this cause them to diverge when reading joints, leading to consensus failures?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Cordova feed migration skip] The code returns early with onDone() if bCordova is true, skipping data feed migration entirely for Cordova builds. Does this mean Cordova nodes cannot query data feeds from KV store, breaking any AAs that rely on oracle data and making Cordova builds incompatible with full nodes?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Light node special handling] The code checks conf.bLight and skips certain data deletions. If a light node migrates its partial database and then switches to full node mode, does the migrated data have incorrect schema (missing or extra fields) that causes validation errors?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [IfNotFound error handling] When storage.readJoint() calls ifNotFound callback, the code throws Error('not found: '+unit). If this occurs for a unit that exists in the units table but whose messages were corrupted or deleted, does this crash abort the entire migration, leaving the database permanently unmigrated?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: commitBatch()] [Batch write error] If batch.write() encounters a non-fatal error (e.g., temporary disk full that resolves), the code still throws Error and aborts migration. Should the migration retry the batch write instead of permanently failing?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Async error propagation] The async.forever loop catches errors in the final callback, but if an exception is thrown inside the readJoint() ifFound callback, does it get properly caught, or does it crash the process without triggering the error callback?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed query failure] If the complex JOIN query selecting from data_feeds+units+unit_authors fails due to missing indexes or corrupted foreign keys, does the migration fail silently by returning 0 rows, or does it throw an error that halts migration?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Initialization failure] If storage.initializeMinRetrievableMci() fails or takes too long, does the migration timeout, and if so, what happens to partially initialized state in the KV store?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Query performance DoS] The query 'SELECT unit FROM units WHERE rowid>=? AND rowid<?' relies on rowid index. If the SQLite database has millions of units and rowid index is missing or corrupted, can this query cause full table scans that take hours per chunk, effectively DoSing the migration indefinitely?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [PRAGMA cache_size memory bomb] Setting PRAGMA cache_size=-400000 allocates 400MB of cache for SQLite. If a node has limited RAM (e.g., 1GB), can this cache allocation combined with loading large units cause OOM killer to terminate the migration process repeatedly?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Batch size optimization] CHUNK_SIZE is hardcoded to 10000. For databases with hundreds of millions of units, does this small chunk size make migration take days or weeks, during which the node cannot participate in consensus, effectively removing it from the network?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Complex JOIN performance] The data feed query joins three tables (data_feeds, units, unit_authors). If indexes on these joins are missing, can this query take exponential time for large databases, causing migration to never complete?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [SetImmediate throttling] The code uses setImmediate(cb) every 1000 feeds to yield to event loop. If the event loop is blocked by other long-running tasks during migration, can this cause the migration to stall indefinitely waiting for the next event loop tick?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [No unit hash verification] Since readJoint() is called with bSql=true, it bypasses hash verification. If the SQL database was corrupted by a bug or attack and contains units whose serialized JSON doesn't match their unit hash, does migration cement these invalid units into KV store?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [JSON parse vulnerability] After reading from KV store, storage.js calls JSON.parse(strJoint). If an attacker previously injected malformed JSON into the SQL database, can this cause JSON.parse() to throw exceptions when other code tries to read the migrated unit, bricking access to that unit?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Null value handling] The code checks if row.value !== null to determine whether to use string or numeric encoding. If both row.value and row.int_value are null due to database corruption, does this cause the feed to be stored with value=null, breaking AA queries that expect valid values?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed name injection] Feed names are concatenated directly into KV keys without sanitization. If a malicious oracle posts a feed_name containing newlines or null bytes, can this break key parsing when reading the feed back, causing queries to return wrong results?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Address validation] Oracle addresses are used directly in keys without validation. If the SQL database contains invalid addresses (wrong length, invalid base32), does migration store them with malformed keys that cannot be queried later?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Mixed storage mode] After migration completes, the system reads from both SQL (for metadata like MCI) and KV (for joint content). If these two databases drift out of sync due to concurrent writes during migration, can queries return inconsistent results where MCI from SQL doesn't match the unit content from KV?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Unit metadata loss] By deleting main_chain_index from migrated joints, does the system now depend on SQL for this critical consensus data? If SQL and KV ever diverge, which MCI value is authoritative, and can this cause nodes to disagree on unit ordering?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed metadata consistency] Data feeds are migrated with their MCI at migration time. If a unit's MCI changes after migration (e.g., due to a reorg before stabilization), do the migrated feed keys still point to the old MCI, causing queries by MCI to miss these feeds?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [No migration marker] After migration completes, is there a flag set in the database to indicate migration is complete? Without such a marker, if the node restarts midway, does it attempt to re-migrate, potentially overwriting data or causing duplicate key errors?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Rowid instability] The query uses rowid for pagination, assuming rowid values are stable. If SQLite performs a VACUUM or rebuild that changes rowid values during migration, can this cause units to be skipped or migrated twice?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Migration duration network split] If migration takes several hours during which the node cannot process new units, does the node fall too far behind the network to catch up, effectively creating a permanent split where the migrating node sees a different DAG than active nodes?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Version-gated feature access] Migration is triggered by sqlite_migrations.js when upgrading to version 31. If some nodes fail migration and remain on version 30, do they become incompatible with v31 nodes that read from KV store, creating a hard fork?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Non-deterministic JSON encoding] If JSON.stringify() produces different key ordering on different Node.js versions or architectures, do nodes migrating the same SQL database produce different KV store contents, causing them to compute different hashes when reading joint data and diverge?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed query determinism] The query orders by data_feeds.rowid, which may not be deterministic across different SQL database file copies. Can two nodes starting with identical SQL databases end up with different KV feed data due to non-deterministic rowid ordering?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Upgrade rollback impossibility] Once migration completes and sqlite_migrations advances to version 31, can a node downgrade to version 30 software? If not, is the migration irreversible, and does this mean a buggy migration locks all nodes into a corrupted state with no rollback?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Numeric encoding precision loss] When encoding floats with encodeDoubleInLexicograpicOrder(), if the encoding loses precision beyond IEEE 754 double precision, can AAs that rely on exact decimal values (e.g., price feeds with 18 decimals) get incorrect values from migrated feeds?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [String vs numeric value confusion] The code stores both strValue and numValue for feeds that can be parsed as numbers. If a feed value is '100.00' (string) vs 100 (number), do these get stored with different keys, and can this cause range queries to miss one variant?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [MCI encoding overflow] If encodeMci() uses a fixed-width encoding and MCI grows beyond the encoded range (e.g., > 2^53 for number encoding), does the encoding overflow, causing migrated feeds to have corrupted MCI values?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Lexicographic ordering assumptions] The feed keys are designed for lexicographic range queries. If the encoding functions don't preserve correct sort order (e.g., '9' > '10' in string comparison), can this break queries that filter feeds by value range?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Unit hash encoding] Unit hashes are base64 strings used as KV keys. If a hash contains characters that have special meaning in RocksDB keys (e.g., null byte used as separator), can this corrupt the key or cause retrieval failures?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Reading time measurement] The code measures reading_time separately from total time. If reading from SQL is abnormally slow due to corruption or hardware failure, does this cause timeouts in the async callbacks, or can the migration hang indefinitely waiting for slow reads?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Initialization ordering] The migration calls initializeMinRetrievableMci() before starting unit migration. If initializeMinRetrievableMci() depends on data that hasn't been migrated yet, can this cause initialization to fail or return incorrect values?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Batch commit ordering] Batches are committed sequentially in rowid order. If a unit at higher rowid depends on a unit at lower rowid (via parent references), and the lower unit fails to migrate, can the higher unit be migrated successfully but reference a non-existent parent in KV store?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed migration timing] Data feeds are migrated after units. If an AA execution during this window tries to query a feed that exists in SQL but hasn't been migrated to KV yet, does the query fail and cause the AA to bounce incorrectly?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Migration trigger timing] Migration is triggered during database version upgrade. If new units arrive from peers while migration is running, are they stored only in SQL or also in KV store, and can this create a gap in KV data?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Process.hrtime fallback] The code sets process.hrtime to a no-op if it doesn't exist. If hrtime is unavailable, getTimeDifference() always returns 0. Does this affect migration logic that depends on accurate timing, such as timeout detection or performance monitoring?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Window.cordova detection] The code detects Cordova by checking 'typeof window === object && window.cordova'. If a browser environment mimics this but isn't actually Cordova, does the migration take the wrong code path and write to non-existent tables?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [SQLite PRAGMA platform differences] PRAGMA cache_size behavior differs between SQLite versions and platforms. On some systems, negative values mean KB, on others MB. Can this cause the migration to allocate 400GB instead of 400MB, immediately crashing?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Query syntax compatibility] The query uses SQLite-specific syntax like CROSS JOIN and backtick column quoting. If the same code is accidentally run on MySQL (despite the check), does the query fail with syntax errors?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: commitBatch()] [RocksDB platform availability] RocksDB (via kvstore.js) may not be available on all platforms (e.g., some ARM architectures, WASM). If kvstore.batch() returns null on unsupported platforms, does commitBatch() crash with null reference?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Oracle data loss] If migration fails to migrate some data feeds due to errors, and AAs depend on these feeds for price calculations, can the AA executions produce incorrect results that send funds to wrong addresses or apply wrong exchange rates?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Unit history loss] If some units fail to migrate and are lost from KV store, but their outputs are still recorded in SQL, can these outputs become unspendable because wallet cannot retrieve the unit to construct proofs, permanently freezing funds?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [AA state consistency] If AA state variables are stored in SQL and AAs read joint data from KV after migration, can mismatches between SQL state and KV joint data cause AAs to execute incorrectly, transferring wrong amounts or to wrong recipients?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Definition change units] If a unit containing definition_chg message fails to migrate, but the SQL still records the definition change, can this cause addresses to have incorrect definitions in KV store, allowing unauthorized spending by wrong parties?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Multi-oracle AA dependencies] If an AA requires consensus from multiple oracles by querying multiple feeds, and migration corrupts some feed keys causing queries to return null, can the AA execution fail to reach consensus threshold and permanently halt all operations?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Empty database migration] If the database has 0 units (fresh install), does the migration still call onDone() correctly, or does it hang waiting for rows that never arrive?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Data feeds with null authors] The query joins unit_authors, but if a unit somehow has no authors in the table due to corruption, does the join return 0 rows and skip valid feeds, losing oracle data?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: commitBatch()] [Empty batch handling] If a batch has 0 operations (e.g., all units in chunk already existed), does batch.write() handle empty batches correctly, or does it throw an error that aborts migration?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Integer feed value limits] For int_value feeds, are there checks for INT_MAX overflow? If an oracle posts 2^53+1 which exceeds JavaScript safe integer, does encoding/decoding corrupt the value?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Circular unit references] If the SQL database contains circular parent references due to corruption (unit ABCA), does readJoint() detect this and fail, or does it loop infinitely consuming memory until OOM?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Migration atomicity] If the migrate() function is interrupted after migrateUnits() completes but before migrateDataFeeds() finishes, does the system enter an inconsistent state where units exist in KV store but data feeds remain in SQL only, causing oracle queries to fail and potentially breaking AA execution that depends on data feeds?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Race condition] Can two nodes simultaneously execute migrate() on the same database, causing both to write conflicting data to the KV store and resulting in corrupted joint data or duplicate key writes that diverge node states and create a permanent chain split?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Rollback mechanism] If migration fails midway through processing 500,000 units, is there any rollback mechanism to restore the database to pre-migration state, or does partial migration leave the node in an unusable state requiring manual intervention and potentially causing network partition if other nodes completed migration successfully?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Transaction boundaries] Since migrateUnits() commits data in CHUNK_SIZE batches of 10,000 units, if a crash occurs after batch N is committed but before batch N+1, does the migration resume from the correct offset or does it restart from offset 0, potentially creating duplicate entries in the KV store with conflicting data?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Offset overflow] Can an attacker with a database containing more than 2^31 units cause integer overflow when offset += CHUNK_SIZE is executed repeatedly, making offset wrap to negative values and causing the migration to re-process earlier units, potentially overwriting correct data with stale data?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Unit hash validation bypass] When migrating units, readJoint() is called with bSql=true parameter, which bypasses the normal hash verification in storage.js. Can this allow corrupted units with invalid hashes in the SQL database to be migrated into the KV store, permanently cementing invalid data that would normally be rejected?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Data modification during migration] The code deletes objJoint.unit.timestamp and objJoint.unit.main_chain_index for certain unit versions. If the migration modifies unit data differently than the original storage logic, can this cause hash mismatches when the unit is later read from KV store and compared against the unit hash, breaking unit validation?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Version-specific deletion] When objJoint.unit.version === constants.versionWithoutTimestamp, the timestamp is deleted from the migrated data. If a unit somehow has an incorrect version field in SQL, could deleting the timestamp from a unit that actually requires it cause consensus divergence when other nodes read this unit from KV store?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [MCI deletion] The code unconditionally deletes main_chain_index from units during migration. If other code paths expect MCI to be present in the joint object read from KV store, could this deletion cause null reference errors or incorrect MC calculations that prevent unit validation and halt network consensus?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [JSON serialization inconsistency] When storing joints as JSON.stringify(objJoint), if the JavaScript JSON serializer produces different field ordering or whitespace compared to the original storage format, could this cause hash mismatches or create non-deterministic data that diverges across nodes?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Concurrent reads during migration] While migrate() is running and reading units from SQL with bSql=true, if another process is simultaneously writing new units to the SQL database, can newly written units be skipped by the migration query's rowid-based pagination, leaving them unmigrated and inaccessible after migration completes?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Database connection reuse] The migration uses the same conn object passed from sqlite_migrations.js. If the migration takes hours and the SQL connection times out or is closed by another process, does the migration crash with a connection error that leaves the database in partial migration state?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Data feed consistency] If oracle addresses post new data feeds while migrateDataFeeds() is executing, and these new feeds have rowid values within the range being processed but are inserted after the query executes, can these feeds be skipped during migration, causing AAs that depend on them to malfunction?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: commitBatch()] [Batch write failure handling] If batch.write() fails with an error (e.g., disk full, permission denied), the code throws an Error that aborts migration. Does this leave the KV store in an inconsistent state with some batches committed and others not, potentially causing the node to have incomplete unit history?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Memory exhaustion attack] With CHUNK_SIZE=10000 and PRAGMA cache_size=-400000 (400MB), if an attacker fills the database with extremely large units (maximum message payload), can the migration consume excessive memory when loading 10,000 large units simultaneously, causing OOM crashes that prevent migration completion?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Key format collision] Units are stored with key 'j\\\\n'+unit in the KV store. If a unit hash somehow contains a newline character or null byte due to a bug in object_hash.js, could this create key collisions where multiple units map to the same KV key, causing units to overwrite each other?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Data feed key collision] Data feeds use composite keys like 'df\\\\n'+address+'\\\\n'+feed_name+'\\\\ns\\\\n'+strValue+'\\\\n'+strMci. If any component (address, feed_name, value) contains newline characters, could this cause key parsing ambiguity where different feeds map to the same key and overwrite each other?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Duplicate feed overwrite] The code comment states 'duplicates will be overwritten, that's ok for data feed search'. However, if two data feeds have the same address+feed_name+value+MCI but different units, does overwriting one with the other cause loss of historical data that AAs might need for auditing or time-weighted calculations?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed value encoding collision] When encoding float values with string_utils.encodeDoubleInLexicograpicOrder(), if two different float values produce the same encoded string due to precision loss, do they collide in the KV store, causing queries for one value to incorrectly return data for a different value?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [MCI encoding issues] Using string_utils.encodeMci(row.main_chain_index) to encode MCI as part of the key. If encodeMci() produces non-unique encodings for different MCI values, or if it's not lexicographically sortable as intended, could this break range queries on data feeds by MCI?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [MySQL rejection] The code throws Error('only sqlite migration supported') if conf.storage !== 'sqlite'. However, if a node was previously running on MySQL and attempts to migrate, does this error leave the node unable to start, causing permanent exclusion from the network and reducing decentralization?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Cordova special path] Cordova builds use INSERT INTO joints table instead of KV batch writes. If the joints table schema differs between Cordova and non-Cordova builds, or if the INSERT uses getIgnore() incorrectly, can this cause Cordova nodes to store malformed joint data?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Cordova data divergence] Since Cordova nodes write to SQL joints table while non-Cordova nodes write to RocksDB, do Cordova and non-Cordova nodes effectively use different storage formats, and can this cause them to diverge when reading joints, leading to consensus failures?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Cordova feed migration skip] The code returns early with onDone() if bCordova is true, skipping data feed migration entirely for Cordova builds. Does this mean Cordova nodes cannot query data feeds from KV store, breaking any AAs that rely on oracle data and making Cordova builds incompatible with full nodes?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Light node special handling] The code checks conf.bLight and skips certain data deletions. If a light node migrates its partial database and then switches to full node mode, does the migrated data have incorrect schema (missing or extra fields) that causes validation errors?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [IfNotFound error handling] When storage.readJoint() calls ifNotFound callback, the code throws Error('not found: '+unit). If this occurs for a unit that exists in the units table but whose messages were corrupted or deleted, does this crash abort the entire migration, leaving the database permanently unmigrated?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: commitBatch()] [Batch write error] If batch.write() encounters a non-fatal error (e.g., temporary disk full that resolves), the code still throws Error and aborts migration. Should the migration retry the batch write instead of permanently failing?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Async error propagation] The async.forever loop catches errors in the final callback, but if an exception is thrown inside the readJoint() ifFound callback, does it get properly caught, or does it crash the process without triggering the error callback?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed query failure] If the complex JOIN query selecting from data_feeds+units+unit_authors fails due to missing indexes or corrupted foreign keys, does the migration fail silently by returning 0 rows, or does it throw an error that halts migration?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Initialization failure] If storage.initializeMinRetrievableMci() fails or takes too long, does the migration timeout, and if so, what happens to partially initialized state in the KV store?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Query performance DoS] The query 'SELECT unit FROM units WHERE rowid>=? AND rowid<?' relies on rowid index. If the SQLite database has millions of units and rowid index is missing or corrupted, can this query cause full table scans that take hours per chunk, effectively DoSing the migration indefinitely?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [PRAGMA cache_size memory bomb] Setting PRAGMA cache_size=-400000 allocates 400MB of cache for SQLite. If a node has limited RAM (e.g., 1GB), can this cache allocation combined with loading large units cause OOM killer to terminate the migration process repeatedly?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Batch size optimization] CHUNK_SIZE is hardcoded to 10000. For databases with hundreds of millions of units, does this small chunk size make migration take days or weeks, during which the node cannot participate in consensus, effectively removing it from the network?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Complex JOIN performance] The data feed query joins three tables (data_feeds, units, unit_authors). If indexes on these joins are missing, can this query take exponential time for large databases, causing migration to never complete?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [SetImmediate throttling] The code uses setImmediate(cb) every 1000 feeds to yield to event loop. If the event loop is blocked by other long-running tasks during migration, can this cause the migration to stall indefinitely waiting for the next event loop tick?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [No unit hash verification] Since readJoint() is called with bSql=true, it bypasses hash verification. If the SQL database was corrupted by a bug or attack and contains units whose serialized JSON doesn't match their unit hash, does migration cement these invalid units into KV store?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [JSON parse vulnerability] After reading from KV store, storage.js calls JSON.parse(strJoint). If an attacker previously injected malformed JSON into the SQL database, can this cause JSON.parse() to throw exceptions when other code tries to read the migrated unit, bricking access to that unit?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Null value handling] The code checks if row.value !== null to determine whether to use string or numeric encoding. If both row.value and row.int_value are null due to database corruption, does this cause the feed to be stored with value=null, breaking AA queries that expect valid values?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed name injection] Feed names are concatenated directly into KV keys without sanitization. If a malicious oracle posts a feed_name containing newlines or null bytes, can this break key parsing when reading the feed back, causing queries to return wrong results?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Address validation] Oracle addresses are used directly in keys without validation. If the SQL database contains invalid addresses (wrong length, invalid base32), does migration store them with malformed keys that cannot be queried later?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Mixed storage mode] After migration completes, the system reads from both SQL (for metadata like MCI) and KV (for joint content). If these two databases drift out of sync due to concurrent writes during migration, can queries return inconsistent results where MCI from SQL doesn't match the unit content from KV?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Unit metadata loss] By deleting main_chain_index from migrated joints, does the system now depend on SQL for this critical consensus data? If SQL and KV ever diverge, which MCI value is authoritative, and can this cause nodes to disagree on unit ordering?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed metadata consistency] Data feeds are migrated with their MCI at migration time. If a unit's MCI changes after migration (e.g., due to a reorg before stabilization), do the migrated feed keys still point to the old MCI, causing queries by MCI to miss these feeds?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [No migration marker] After migration completes, is there a flag set in the database to indicate migration is complete? Without such a marker, if the node restarts midway, does it attempt to re-migrate, potentially overwriting data or causing duplicate key errors?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Rowid instability] The query uses rowid for pagination, assuming rowid values are stable. If SQLite performs a VACUUM or rebuild that changes rowid values during migration, can this cause units to be skipped or migrated twice?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Migration duration network split] If migration takes several hours during which the node cannot process new units, does the node fall too far behind the network to catch up, effectively creating a permanent split where the migrating node sees a different DAG than active nodes?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Version-gated feature access] Migration is triggered by sqlite_migrations.js when upgrading to version 31. If some nodes fail migration and remain on version 30, do they become incompatible with v31 nodes that read from KV store, creating a hard fork?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Non-deterministic JSON encoding] If JSON.stringify() produces different key ordering on different Node.js versions or architectures, do nodes migrating the same SQL database produce different KV store contents, causing them to compute different hashes when reading joint data and diverge?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed query determinism] The query orders by data_feeds.rowid, which may not be deterministic across different SQL database file copies. Can two nodes starting with identical SQL databases end up with different KV feed data due to non-deterministic rowid ordering?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Upgrade rollback impossibility] Once migration completes and sqlite_migrations advances to version 31, can a node downgrade to version 30 software? If not, is the migration irreversible, and does this mean a buggy migration locks all nodes into a corrupted state with no rollback?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Numeric encoding precision loss] When encoding floats with encodeDoubleInLexicograpicOrder(), if the encoding loses precision beyond IEEE 754 double precision, can AAs that rely on exact decimal values (e.g., price feeds with 18 decimals) get incorrect values from migrated feeds?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [String vs numeric value confusion] The code stores both strValue and numValue for feeds that can be parsed as numbers. If a feed value is '100.00' (string) vs 100 (number), do these get stored with different keys, and can this cause range queries to miss one variant?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [MCI encoding overflow] If encodeMci() uses a fixed-width encoding and MCI grows beyond the encoded range (e.g., > 2^53 for number encoding), does the encoding overflow, causing migrated feeds to have corrupted MCI values?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Lexicographic ordering assumptions] The feed keys are designed for lexicographic range queries. If the encoding functions don't preserve correct sort order (e.g., '9' > '10' in string comparison), can this break queries that filter feeds by value range?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Unit hash encoding] Unit hashes are base64 strings used as KV keys. If a hash contains characters that have special meaning in RocksDB keys (e.g., null byte used as separator), can this corrupt the key or cause retrieval failures?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Reading time measurement] The code measures reading_time separately from total time. If reading from SQL is abnormally slow due to corruption or hardware failure, does this cause timeouts in the async callbacks, or can the migration hang indefinitely waiting for slow reads?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Initialization ordering] The migration calls initializeMinRetrievableMci() before starting unit migration. If initializeMinRetrievableMci() depends on data that hasn't been migrated yet, can this cause initialization to fail or return incorrect values?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Batch commit ordering] Batches are committed sequentially in rowid order. If a unit at higher rowid depends on a unit at lower rowid (via parent references), and the lower unit fails to migrate, can the higher unit be migrated successfully but reference a non-existent parent in KV store?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Feed migration timing] Data feeds are migrated after units. If an AA execution during this window tries to query a feed that exists in SQL but hasn't been migrated to KV yet, does the query fail and cause the AA to bounce incorrectly?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [Migration trigger timing] Migration is triggered during database version upgrade. If new units arrive from peers while migration is running, are they stored only in SQL or also in KV store, and can this create a gap in KV data?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Process.hrtime fallback] The code sets process.hrtime to a no-op if it doesn't exist. If hrtime is unavailable, getTimeDifference() always returns 0. Does this affect migration logic that depends on accurate timing, such as timeout detection or performance monitoring?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Window.cordova detection] The code detects Cordova by checking 'typeof window === object && window.cordova'. If a browser environment mimics this but isn't actually Cordova, does the migration take the wrong code path and write to non-existent tables?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [SQLite PRAGMA platform differences] PRAGMA cache_size behavior differs between SQLite versions and platforms. On some systems, negative values mean KB, on others MB. Can this cause the migration to allocate 400GB instead of 400MB, immediately crashing?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Query syntax compatibility] The query uses SQLite-specific syntax like CROSS JOIN and backtick column quoting. If the same code is accidentally run on MySQL (despite the check), does the query fail with syntax errors?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: commitBatch()] [RocksDB platform availability] RocksDB (via kvstore.js) may not be available on all platforms (e.g., some ARM architectures, WASM). If kvstore.batch() returns null on unsupported platforms, does commitBatch() crash with null reference?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Oracle data loss] If migration fails to migrate some data feeds due to errors, and AAs depend on these feeds for price calculations, can the AA executions produce incorrect results that send funds to wrong addresses or apply wrong exchange rates?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Unit history loss] If some units fail to migrate and are lost from KV store, but their outputs are still recorded in SQL, can these outputs become unspendable because wallet cannot retrieve the unit to construct proofs, permanently freezing funds?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrate()] [AA state consistency] If AA state variables are stored in SQL and AAs read joint data from KV after migration, can mismatches between SQL state and KV joint data cause AAs to execute incorrectly, transferring wrong amounts or to wrong recipients?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Definition change units] If a unit containing definition_chg message fails to migrate, but the SQL still records the definition change, can this cause addresses to have incorrect definitions in KV store, allowing unauthorized spending by wrong parties?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Multi-oracle AA dependencies] If an AA requires consensus from multiple oracles by querying multiple feeds, and migration corrupts some feed keys causing queries to return null, can the AA execution fail to reach consensus threshold and permanently halt all operations?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Empty database migration] If the database has 0 units (fresh install), does the migration still call onDone() correctly, or does it hang waiting for rows that never arrive?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Data feeds with null authors] The query joins unit_authors, but if a unit somehow has no authors in the table due to corruption, does the join return 0 rows and skip valid feeds, losing oracle data?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: commitBatch()] [Empty batch handling] If a batch has 0 operations (e.g., all units in chunk already existed), does batch.write() handle empty batches correctly, or does it throw an error that aborts migration?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateDataFeeds()] [Integer feed value limits] For int_value feeds, are there checks for INT_MAX overflow? If an oracle posts 2^53+1 which exceeds JavaScript safe integer, does encoding/decoding corrupt the value?",
  "[File: byteball/ocore/migrate_to_kv.js] [Function: migrateUnits()] [Circular unit references] If the SQL database contains circular parent references due to corruption (unit ABCA), does readJoint() detect this and fail, or does it loop infinitely consuming memory until OOM?",
  "[File: byteball/ocore/my_witnesses.js] [Function: readMyWitnesses()] [Race Condition] If multiple concurrent calls to readMyWitnesses() execute simultaneously while witnesses are being deleted (lines 13-19 old witness reset), can some calls receive the empty array before insertion while others receive the old invalid list, causing different nodes to compose units with incompatible witness lists and triggering a permanent chain split?",
  "[File: byteball/ocore/my_witnesses.js] [Function: readMyWitnesses()] [Race Condition] When actionIfEmpty='wait' triggers a 1-second retry loop (lines 23-29), if insertWitnesses() is called during this waiting period, can the callback be invoked multiple times with different witness arrays, causing composer.js to start multiple conflicting unit composition operations with different witness sets?",
  "[File: byteball/ocore/my_witnesses.js] [Function: readMyWitnesses()] [Database Consistency] If the database query 'SELECT address FROM my_witnesses ORDER BY address' (line 10) returns witnesses mid-transaction while another process is executing DELETE FROM my_witnesses (line 17), can the read return a partial witness list (e.g., 5 out of 12 witnesses), bypassing the COUNT_WITNESSES validation and causing units to be composed with invalid witness arrays?",
  "[File: byteball/ocore/my_witnesses.js] [Function: readMyWitnesses()] [Consensus Failure] If the old witness reset logic (lines 13-19) triggers on one node but not others due to timing differences in reading constants.alt or constants.versionWithoutTimestamp, can this cause some nodes to delete their witnesses while others retain them, leading to different witness lists across the network and permanent consensus divergence?",
  "[File: byteball/ocore/my_witnesses.js] [Function: readMyWitnesses()] [Network Halt] If all nodes simultaneously hit the actionIfEmpty='wait' retry loop (lines 23-29) due to coordinated witness list deletion, and no process ever calls insertWitnesses() (e.g., due to a crash or bug in initialization), can the entire network enter an infinite wait state where no units can be composed, causing total network shutdown?",
  "[File: byteball/ocore/my_witnesses.js] [Function: readMyWitnesses()] [Validation Bypass] Does the witness count check (lines 31-32) only throw an Error without preventing the handleWitnesses callback from being invoked, potentially allowing composer.js to receive an invalid witness array (e.g., 11 or 13 witnesses) before the error is thrown, causing invalid units to be composed?",
  "[File: byteball/ocore/my_witnesses.js] [Function: readMyWitnesses()] [DoS Attack] Can a malicious actor repeatedly trigger the old witness reset condition (lines 13-19) by manipulating constants or injecting old witness addresses, causing continuous deletion and re-insertion of witness lists, creating a DoS condition where nodes spend excessive time in witness management instead of processing transactions?",
  "[File: byteball/ocore/my_witnesses.js] [Function: readMyWitnesses()] [State Corruption] If the witness reset logic (line 17) executes DELETE FROM my_witnesses but the process crashes before new witnesses are inserted, can nodes permanently remain in an empty witness state, preventing all unit composition and causing permanent network participation failure for affected nodes?",
  "[File: byteball/ocore/my_witnesses.js] [Function: readMyWitnesses()] [Callback Timing] When actionIfEmpty='ignore' returns an empty array immediately (line 22), can network.js or composer.js mishandle this empty array (e.g., not checking length before use), causing null pointer exceptions or array access errors that crash the node daemon and halt transaction processing?",
  "[File: byteball/ocore/my_witnesses.js] [Function: readMyWitnesses()] [Infinite Loop] If actionIfEmpty='wait' enters the retry loop (lines 25-27) but the database connection is lost or locked, can the setTimeout recursion continue indefinitely without bound, causing memory exhaustion from accumulated timeout handlers and eventually crashing the node?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Validation Bypass] Does the ValidationUtils.isValidAddress check (line 39) only verify the address format (32-char uppercase chash) but not check if the new witness has ever posted any units to the network, allowing replacement with completely inactive or non-existent addresses that will never post witness units, causing main chain progression to stall and network halt?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Race Condition] If two concurrent calls to replaceWitness() attempt to replace different old witnesses with the same new witness address, can both pass the 'new witness already present' check (line 44) simultaneously before either UPDATE executes, resulting in duplicate witness addresses in my_witnesses table and breaking the COUNT_WITNESSES invariant?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Database Atomicity] When the UPDATE query executes (line 47), if another process is simultaneously reading via readMyWitnesses(), can the read occur mid-transaction and return a witness list with both old_witness and new_witness present (13 total), causing validation errors in unit composition?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Authorization Bypass] Does replaceWitness() lack any authorization checks to verify the caller is the node owner or an authorized admin, allowing any process (including potentially compromised plugins or malicious code) to arbitrarily change witness lists and partition the node from the network?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Consensus Attack] Can a malicious actor who gains access to the node's witness replacement mechanism (via compromised admin credentials or API exploit) systematically replace all 12 witnesses with attacker-controlled addresses, causing the node to diverge from the main network and accept a shadow DAG controlled by the attacker?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Removed Validation] The commented-out code (lines 54-66) previously checked for stable messages from the new witness and verified no references in address definitions - since these checks are now disabled (comment: 'no longer required in v4'), can an attacker replace witnesses with addresses that have complex definitions with time-locks or oracle dependencies, causing future witness voting to fail when those definitions become unsatisfiable?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Light Client Risk] The comment 'if (conf.bLight)' and 'absent the full database, there is nothing else to check' (line 51) suggests light clients skip additional validation - can this allow light clients to accept witness replacements that full nodes would reject, causing light clients to diverge from the main chain when they compose units with incompatible witness lists?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Historical Attack] Since the removed validation (lines 54-66) checked 'sequence=good' and 'is_stable=1' for new witnesses, without these checks can an attacker replace witnesses with addresses that authored units on orphaned branches or bad sequences, potentially causing instability calculations to reference invalid witness paths?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Definition References] The removed code checked 'determineIfWitnessAddressDefinitionsHaveReferences' (line 60) - without this check, can witnesses have definitions that reference other addresses or contracts, creating circular dependencies that could deadlock witness voting or make witness stability non-deterministic?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Error Propagation] When handleResult() is called with error strings (lines 40, 43, 45), does the calling code in network.js properly handle these errors, or can they be silently ignored, allowing witness replacement to fail without notification while the node believes it has updated its witness list?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Partial Update] If the UPDATE query (line 47) affects 0 rows (because old_witness was already replaced by another concurrent call), does the function incorrectly call handleResult() with success (no error), causing the caller to believe the replacement succeeded when it actually failed?",
  "[File: byteball/ocore/my_witnesses.js] [Function: replaceWitness()] [Network Synchronization] When network.js calls replaceWitness() during OP list updates (network.js lines 1914-1917), if the replacement fails but the error is not properly propagated, can the node continue operating with an outdated witness list that differs from the network consensus OP list, causing all future units to be rejected by peers?",
  "[File: byteball/ocore/my_witnesses.js] [Function: insertWitnesses()] [Validation Gap] Does insertWitnesses() only validate the witness count (line 71) but not validate individual witness addresses using ValidationUtils.isValidAddress, allowing insertion of malformed addresses (non-uppercase, wrong length, invalid chash) that would later cause validation failures in unit composition?",
  "[File: byteball/ocore/my_witnesses.js] [Function: insertWitnesses()] [Duplicate Detection] Does insertWitnesses() check for duplicate addresses within the arrWitnesses array before insertion, or can a caller provide an array with repeated addresses (e.g., same witness appearing 3 times), bypassing the unique witness requirement and corrupting the witness list?",
  "[File: byteball/ocore/my_witnesses.js] [Function: insertWitnesses()] [Database Constraint] If my_witnesses table lacks a UNIQUE constraint on the address column, can insertWitnesses() successfully insert duplicate witness addresses, causing readMyWitnesses() to return arrays with >12 witnesses and breaking all witness count validations throughout the codebase?",
  "[File: byteball/ocore/my_witnesses.js] [Function: insertWitnesses()] [Race Condition] If insertWitnesses() is called twice concurrently (e.g., from initialization and from OP list update), can both INSERT operations succeed, resulting in 24 witnesses in the database and causing permanent corruption of the witness list?",
  "[File: byteball/ocore/my_witnesses.js] [Function: insertWitnesses()] [Rollback Failure] If the INSERT query (line 75) succeeds but the process crashes before the console.log or onDone callback (lines 76-78), can the database remain in an inconsistent state where witnesses are inserted but initialization is incomplete, causing dependent processes to fail on restart?",
  "[File: byteball/ocore/my_witnesses.js] [Function: insertWitnesses()] [SQL Injection] Although the code uses parameterized queries with placeholders '(?)' (line 73), does the placeholder generation logic properly escape the witness addresses, or can specially crafted addresses containing SQL metacharacters cause SQL injection when the VALUES clause is constructed?",
  "[File: byteball/ocore/my_witnesses.js] [Global State] [Race Condition] If readMyWitnesses() and replaceWitness() execute concurrently, can the read happen after the DELETE in replaceWitness's nested readMyWitnesses call (line 41) but before the UPDATE (line 47), returning an array missing the old_witness, causing the replacement to fail with 'old witness not known' even though it was present moments before?",
  "[File: byteball/ocore/my_witnesses.js] [Global State] [Atomicity] Since my_witnesses table modifications are not wrapped in explicit transactions, can a sequence of replaceWitness() followed by readMyWitnesses() be interleaved with insertWitnesses() from another process, producing non-atomic witness list updates that leave the database in an inconsistent state?",
  "[File: byteball/ocore/my_witnesses.js] [Integration] [Consensus Impact] When composer.js calls readMyWitnesses() to compose a unit (composer.js lines 141-144), if the witness list is modified by replaceWitness() mid-composition, can the composed unit reference a witness array that no longer matches the node's current witness list, causing the unit to be invalid immediately after creation?",
  "[File: byteball/ocore/my_witnesses.js] [Integration] [Network Protocol] When network.js calls readMyWitnesses() for light client history requests (network.js line 2338), if the witness list is empty or corrupted, does the history request send an empty witness array to the light vendor, causing the vendor to reject the request and preventing light clients from syncing?",
  "[File: byteball/ocore/my_witnesses.js] [Integration] [OP List Updates] When network.js updates witnesses based on op_list system variable (network.js lines 1900-1920), if multiple witnesses need replacement and some replacements fail while others succeed, can this result in a partially updated witness list that matches neither the old nor new OP list, causing witness compatibility failures with all network peers?",
  "[File: byteball/ocore/my_witnesses.js] [Database] [Query Performance] Does the 'ORDER BY address' clause in the SELECT query (line 10) have a corresponding index on my_witnesses.address, or can this query perform a full table scan every time readMyWitnesses() is called, causing performance degradation and delays in unit composition during high transaction volume?",
  "[File: byteball/ocore/my_witnesses.js] [Database] [Connection Pool] If the database connection pool is exhausted when readMyWitnesses(), replaceWitness(), or insertWitnesses() are called, do these functions properly handle connection timeout errors, or can they hang indefinitely waiting for a connection, causing the entire node to freeze and halt transaction processing?",
  "[File: byteball/ocore/my_witnesses.js] [Database] [Transaction Isolation] What transaction isolation level is used for the my_witnesses queries - if READ UNCOMMITTED is used, can readMyWitnesses() see partially committed witness updates from replaceWitness(), returning witness lists in transient invalid states?",
  "[File: byteball/ocore/my_witnesses.js] [Database] [Deadlock] If multiple nodes simultaneously attempt to replaceWitness() for different witnesses while others call readMyWitnesses(), can database-level row locks cause deadlocks that block all witness operations, preventing unit composition and causing network-wide transaction delays?",
  "[File: byteball/ocore/my_witnesses.js] [Reset Logic] [Version Detection] The old witness reset checks constants.alt === '2' and constants.versionWithoutTimestamp === '1.0' (lines 13-14) - can an attacker manipulate environment variables or configuration to artificially trigger these conditions, forcing nodes to delete their legitimate witness lists and enter emergency re-initialization mode?",
  "[File: byteball/ocore/my_witnesses.js] [Reset Logic] [Hardcoded Addresses] The hardcoded old witness addresses '5K7CSLTRPC5LFLOS3D34GBHG7RFD4TPO' and '2FF7PSL7FYXVU5UIQHCVDTTPUOOG75GX' (lines 13-14) are checked for deletion - if these addresses are still actively used as witnesses on some legacy networks, can this logic cause nodes bridging multiple networks to incorrectly delete valid witnesses?",
  "[File: byteball/ocore/my_witnesses.js] [Reset Logic] [Array Mutation] The reset logic modifies arrWitnesses by setting it to [] after DELETE (line 18) - does this mutation affect the callback's reference to arrWitnesses, potentially causing use-after-free errors if the callback tries to access witness addresses after reset?",
  "[File: byteball/ocore/my_witnesses.js] [Empty List] [Network Bootstrap] During initial node setup, if readMyWitnesses() is called with actionIfEmpty='ignore' before any witnesses are inserted, does the calling code properly handle the empty array, or can it attempt to compose units with zero witnesses, violating the COUNT_WITNESSES invariant and causing validation rejection?",
  "[File: byteball/ocore/my_witnesses.js] [Empty List] [Initialization Order] If multiple modules call readMyWitnesses() concurrently during node startup, some with actionIfEmpty='wait' and others with actionIfEmpty='ignore', can this create race conditions where some modules proceed with empty witness lists while others wait, causing inconsistent initialization state?",
  "[File: byteball/ocore/my_witnesses.js] [Empty List] [Callback Invocation] When actionIfEmpty='ignore' returns handleWitnesses([]) immediately (line 22), does this happen synchronously before the database query completes, potentially causing callback ordering issues where dependent code executes before database operations finish?",
  "[File: byteball/ocore/my_witnesses.js] [Error Handling] [Uncaught Exceptions] The witness count validation throws Error() (line 32) - is this error caught by callers, or can it propagate up as an uncaught exception, crashing the node daemon when an invalid witness list is detected instead of gracefully handling the error?",
  "[File: byteball/ocore/my_witnesses.js] [Error Handling] [Async Errors] Since all three functions use asynchronous database callbacks, if errors occur within the database operations (query failures, connection errors), are these errors properly propagated to handleWitnesses/handleResult/onDone callbacks, or are they silently swallowed?",
  "[File: byteball/ocore/my_witnesses.js] [Error Handling] [Callback Guarantee] Do all code paths in readMyWitnesses(), replaceWitness(), and insertWitnesses() guarantee exactly one callback invocation, or can error conditions cause callbacks to be invoked multiple times or not at all, leading to resource leaks or deadlocks in calling code?",
  "[File: byteball/ocore/my_witnesses.js] [Consensus Impact] [Witness Compatibility] If different nodes replace witnesses at different times during OP list updates, creating temporary witness list mismatches between peers, can this cause composed units to be rejected by peers due to witness incompatibility, effectively partitioning the network until all nodes synchronize their witness lists?",
  "[File: byteball/ocore/my_witnesses.js] [Consensus Impact] [Main Chain Selection] Since witness lists determine which units are considered for main chain selection, if a node operates with a corrupted witness list (e.g., 11 or 13 witnesses due to database corruption), can this cause the node to calculate different main chain indexes (MCIs) than the network, leading to permanent consensus divergence?",
  "[File: byteball/ocore/my_witnesses.js] [Consensus Impact] [Stability Determination] Witness voting determines unit stability - if witness addresses in my_witnesses table are corrupted or replaced with non-participating addresses, can this cause the node to never reach stability for new units, blocking all confirmations and causing perceived network freeze for the affected node?",
  "[File: byteball/ocore/my_witnesses.js] [Network Impact] [Light Client Divergence] If light clients receive different witness lists from their hubs due to timing of replaceWitness() operations, can light clients end up requesting witness proofs for units that their hub considers invalid (due to witness incompatibility), causing light client sync failures and inability to process transactions?",
  "[File: byteball/ocore/my_witnesses.js] [Validation] [Address Format] ValidationUtils.isValidAddress checks for uppercase 32-character chash (validation_utils.js lines 60-62) - does this ensure the address is a valid Ed25519 public key hash, or can specially crafted addresses that pass chash validation but correspond to no actual private key be inserted, creating unspendable witness positions?",
  "[File: byteball/ocore/my_witnesses.js] [Validation] [Address Existence] Neither replaceWitness() nor insertWitnesses() verify that witness addresses have ever posted units to the DAG or even exist in the units table - can this allow insertion of completely fictional addresses, causing main chain progression to wait indefinitely for witness votes that will never come?",
  "[File: byteball/ocore/my_witnesses.js] [Validation] [Address Definition Complexity] Since the removed validation (lines 60-62) previously checked for definition references, can witness addresses now have arbitrarily complex multi-sig or contract-based definitions, causing witness signature validation to become computationally expensive and creating DoS vectors in main chain processing?",
  "[File: byteball/ocore/my_witnesses.js] [Validation] [Case Sensitivity] ValidationUtils.isValidAddress requires uppercase (validation_utils.js line 61) - if a lowercase witness address is provided to replaceWitness() or insertWitnesses(), does the validation reject it, or can mixed-case addresses be inserted, causing comparison failures when matching against network-provided witness lists?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Exception Handling - Network Halt] When the query wrapper throws an exception on database errors (line 47), does this unhandled exception crash the entire node process, causing a total network halt if a critical query fails during unit validation or storage operations?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Race Condition - Double Spend] If two concurrent queries attempt to spend the same output and both read the unspent state before either commits, can the lack of database-level locking in the query wrapper allow both transactions to commit successfully, enabling a double-spend attack?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Promise Resolution - Fund Loss] In the Promise-based query interface (lines 28-31), if the original callback is never invoked due to a database connection failure, does the Promise remain unresolved indefinitely, potentially freezing fund transfers or unit confirmations that depend on this query?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Buffer Conversion - Data Corruption] When converting VARBINARY fields from Buffer to string (lines 52-54), does this conversion handle multi-byte UTF-8 characters and binary data correctly, or can malformed unit hashes or witness signatures stored as VARBINARY be corrupted, breaking DAG structure validation?",
  "[File: byteball/ocore/mysql_pool.js] [Function: cquery()] [Configuration Bypass - Validation Skip] When conf.bFaster is true (line 71), the cquery function skips query execution entirely and immediately invokes the callback - can an attacker modify configuration to enable bFaster during critical validation queries, bypassing double-spend checks and allowing invalid units to be stored?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Deadlock Handling - Transaction Delay] The commented-out deadlock retry logic (lines 39-46) suggests deadlocks were encountered - without automatic retry, can an attacker craft units that systematically trigger database deadlocks during main chain updates, delaying transaction processing for over 1 hour and meeting Medium severity impact criteria?",
  "[File: byteball/ocore/mysql_pool.js] [Function: takeConnectionFromPool()] [Connection Exhaustion - Network Halt] If the connection pool is exhausted and getConnection blocks indefinitely (line 109), can an attacker flood the network with units requiring expensive queries, exhausting all connections and preventing legitimate units from being validated or stored, causing a total network shutdown?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Error Propagation - Inconsistent State] When a query throws an exception (line 47), does the error propagate before any in-flight database transactions are rolled back, potentially leaving partial state committed (e.g., unit stored but balances not updated), violating transaction atomicity invariants?",
  "[File: byteball/ocore/mysql_pool.js] [Function: addQuery()] [Callback Ordering - Non-determinism] In the addQuery function's callback wrapping logic (lines 92-97), if the mysql callback and async.series callback execute in different orders across nodes due to timing variations, can this cause non-deterministic query execution sequences during main chain selection, leading to permanent chain splits?",
  "[File: byteball/ocore/mysql_pool.js] [Function: escape()] [SQL Injection - Unit Storage] If the escape function wrapper (lines 76-78) fails to properly sanitize user-controlled data in unit messages or AA trigger parameters, can an attacker inject malicious SQL to manipulate the units table, inserting fake units or modifying witness lists to corrupt consensus?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Memory Leak - Connection Pool] When queries with no callback are converted to Promises (lines 27-31) but the Promise is never awaited, does the connection remain locked and never released back to the pool, eventually exhausting all connections and causing network paralysis?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Timing Attack - Witness Identification] The query timing log (lines 57-59) reveals which queries take >25ms - can an attacker analyze these logs to identify expensive witness validation queries, then craft units specifically designed to trigger these slow paths and delay block confirmation times?",
  "[File: byteball/ocore/mysql_pool.js] [Function: getCountUsedConnections()] [Resource Monitoring - DoS] The function directly accesses internal pool properties _allConnections and _freeConnections (line 118) - if these properties are undefined or have been modified by a malicious npm package in the dependency chain, does this cause crashes during connection monitoring, preventing nodes from detecting pool exhaustion?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Result Mutation - State Corruption] The query wrapper mutates results by converting Buffers and using Object.assign (lines 49-56) - if the original result set is shared across multiple query callbacks (possible with connection pooling), can concurrent modifications lead to corrupted data being read during AA state variable updates, causing state divergence?",
  "[File: byteball/ocore/mysql_pool.js] [Function: addTime()] [SQL Injection via Interval] The addTime function (lines 125-127) directly concatenates the interval parameter into SQL without validation - can an attacker pass malicious SQL fragments as interval values (e.g., via AA formula parameters) to inject arbitrary SQL commands during timestamp calculations?",
  "[File: byteball/ocore/mysql_pool.js] [Function: forceIndex()] [SQL Injection via Index Name] The forceIndex function (line 142) concatenates the index parameter directly into SQL - can an attacker control index names through configuration or AA parameters to inject SQL that bypasses query optimization or manipulates query results?",
  "[File: byteball/ocore/mysql_pool.js] [Function: dropTemporaryTable()] [SQL Injection via Table Name] The dropTemporaryTable function (line 146) concatenates table names without validation - can an attacker inject malicious table names (e.g., containing semicolons and additional SQL commands) to drop permanent tables containing unit or balance data?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Promise Chain Deadlock] When a query returns a Promise (lines 28-31) and that Promise is awaited while holding a database connection, can nested query calls within the same connection context cause self-deadlock, blocking critical validation or storage operations indefinitely?",
  "[File: byteball/ocore/mysql_pool.js] [Function: takeConnectionFromPool()] [Recursive Wrapping - Memory Exhaustion] The function recursively wraps connections (line 113) - if a connection is taken from the pool, used, released, and taken again multiple times, does each wrap add another layer of wrapper functions, eventually causing stack overflow or memory exhaustion during high-volume transaction periods?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Unhandled Promise Rejection] When query() returns a Promise and that Promise's rejection is not handled by the caller, does Node.js 15+ crash the process on unhandled rejection, causing network-wide node failures if any database query fails during AA execution?",
  "[File: byteball/ocore/mysql_pool.js] [Function: cquery()] [Conditional Query Skip - Balance Verification] If conf.bFaster is enabled and cquery is used for balance verification queries before spending outputs, can an attacker exploit the query skip (line 72) to bypass balance checks and spend non-existent funds, creating inflation in the asset supply?",
  "[File: byteball/ocore/mysql_pool.js] [Function: addQuery()] [Callback Double-Invocation] In the callback wrapping logic (lines 90-98), if the mysql callback is invoked multiple times (e.g., due to a mysql library bug), does the async.series callback get called multiple times, causing duplicate execution of subsequent queries in the series and potential double-crediting of payments?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [SQL Logging - Credential Leakage] When failed queries are logged with q.sql (line 36), can this expose sensitive data like private payment blinding factors or AA state secrets if they are passed as SQL parameters, allowing attackers monitoring logs to deanonymize transactions?",
  "[File: byteball/ocore/mysql_pool.js] [Function: release()] [Connection Leak - Pool Exhaustion] If release() is called on a connection that was obtained through takeConnectionFromPool but an exception occurs in the code path before release is called, does the connection remain locked forever, eventually exhausting the pool and halting all database operations?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Array Result Modification - Validation Bypass] When query results are mapped to new objects with Object.assign (line 55), if validation logic assumes results are immutable or sealed objects, can an attacker modify result properties after they're returned but before validation completes, bypassing witness signature checks or unit hash verification?",
  "[File: byteball/ocore/mysql_pool.js] [Function: getFromUnixTime()] [Integer Overflow in Timestamp] The getFromUnixTime function (line 134) directly embeds the timestamp parameter - can an attacker pass extremely large timestamp values that cause MySQL's FROM_UNIXTIME to overflow or return invalid dates, corrupting unit timestamp ordering and breaking main chain selection?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Concurrent Query Modification - Race Condition] Since the query wrapper modifies the arguments array (lines 22-31) while the original query may still be referencing it, can concurrent query calls from different event loop ticks corrupt each other's parameters, causing units to be stored with wrong parent references or witness lists?",
  "[File: byteball/ocore/mysql_pool.js] [Function: takeConnectionFromPool()] [Error Handling - Connection Loss] When getConnection fails and throws an error (line 111), does this leave the connection pool in an inconsistent state where the failure count is incremented but recovery is impossible, requiring a node restart and causing network delays exceeding 1 hour?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [start_ts Capture - Timing Race] The start_ts variable is captured before the query executes (line 63) but consumed_time is calculated in the callback (line 57) - can extreme clock skew or NTP adjustments during query execution cause negative or overflowing time measurements that crash the logging code?",
  "[File: byteball/ocore/mysql_pool.js] [Function: addQuery()] [Array Push Race - Incorrect Ordering] If addQuery is called concurrently from multiple async contexts on the same array (line 89), does JavaScript's non-atomic array push operation allow queries to be inserted in non-deterministic order, breaking the expected sequence of unit storage and balance updates?",
  "[File: byteball/ocore/mysql_pool.js] [Function: escape()] [Escaping Bypass - Special Characters] If the original mysql escape function has known bypasses for certain character encodings or MySQL configurations, does the thin wrapper (lines 76-78) inherit these vulnerabilities, allowing SQL injection in unit payload data or AA formula strings?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Buffer Inspection - Type Confusion] The Buffer.isBuffer check (line 52) determines whether to convert fields - can an attacker craft malicious objects that pass Buffer.isBuffer but cause toString() to throw an exception or return non-string values, corrupting unit hashes or addresses stored in VARBINARY columns?",
  "[File: byteball/ocore/mysql_pool.js] [Function: cquery()] [Configuration Injection] If the conf.bFaster flag can be modified at runtime through a configuration reload or AA formula that writes to conf module exports, can an attacker dynamically enable query skipping during specific critical operations like double-spend checks, then disable it afterwards to hide the attack?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Callback Argument Count - Logic Errors] The query wrapper assumes callbacks take (results, fields) parameters (line 60), but MySQL callbacks actually receive (err, results, fields) - if any code path accidentally provides results as the first argument, can this cause validation logic to treat error objects as valid query results?",
  "[File: byteball/ocore/mysql_pool.js] [Function: takeConnectionFromPool()] [Promise-Callback Hybrid - Double Return] The function supports both callback and Promise interfaces (lines 106-107) - if a caller accidentally provides a callback AND awaits the Promise, does the connection get released twice, corrupting the connection pool's free connection tracking and potentially causing connection reuse conflicts?",
  "[File: byteball/ocore/mysql_pool.js] [Function: close()] [Graceful Shutdown - Transaction Loss] When close() is called to shutdown the pool (line 122), does it wait for all in-flight queries to complete, or can it forcefully terminate connections mid-transaction, causing partially committed unit data that breaks DAG referential integrity?",
  "[File: byteball/ocore/mysql_pool.js] [Function: getRandom()] [Non-Deterministic Query Results] The getRandom function returns RAND() for SQL (line 138) - if this is used in queries during consensus-critical operations like parent selection or main chain determination, can different nodes get different query results, causing permanent chain splits?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Long Query Threshold - DoS Detection] The 25ms threshold for logging slow queries (line 58) may be too high for detecting systematic DoS attacks - can an attacker craft queries that take 20-24ms each and flood the network, avoiding detection while still causing cumulative delays exceeding 1 hour?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Load Average Logging - System Info Leak] The query logging exposes os.loadavg() (line 59) - can an attacker use this information to time attacks when the system is already under load, maximizing the impact of additional malicious queries to push the node into denial-of-service?",
  "[File: byteball/ocore/mysql_pool.js] [Function: addQuery()] [Callback Scope Binding - Variable Capture] The callback wrapping function captures the variable 'f' (line 93) in a closure - if the query_args array is modified after addQuery returns but before the query executes, can this cause the wrong callback to be invoked, mixing up results from different queries?",
  "[File: byteball/ocore/mysql_pool.js] [Function: getUnixTimestamp()] [SQL Injection via Date Parameter] The getUnixTimestamp function (line 154) directly embeds the date parameter - can an attacker inject SQL through date strings passed from AA formulas or unit payload data to manipulate timestamp comparisons in stability point calculations?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Exception in Result Processing - Transaction Abort] If an exception occurs during the Buffer-to-string conversion loop (lines 51-55) after the query has succeeded but before the callback is invoked, does the transaction remain uncommitted, causing units to be validated but never stored, creating ghost units that peers expect but can never sync?",
  "[File: byteball/ocore/mysql_pool.js] [Function: takeConnectionFromPool()] [Module Exports Recursion - Circular Dependency] The function checks if new_connection.original_query exists (line 113) to avoid double-wrapping, but if module.exports is called recursively on the same connection through a circular dependency, can this create infinite wrapping layers that exhaust stack space during query execution?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Arguments Object Mutation - Memory Leak] The function modifies the arguments object and creates new_args array (lines 21-26) - does this prevent the JavaScript engine from optimizing the function, causing excessive memory allocation during high-frequency query operations like unit validation, eventually leading to OOM crashes?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Callback Type Check - Code Injection] The check 'typeof last_arg === 'function'' (line 16) only validates that it's a function, not where it came from - can an attacker inject malicious functions through deserialization attacks or prototype pollution that get executed with database results as arguments, leaking sensitive data?",
  "[File: byteball/ocore/mysql_pool.js] [Function: getIgnore()] [INSERT IGNORE Semantics - Silent Failures] The getIgnore function returns 'IGNORE' for SQL (line 150) - if this is used in unit insertion queries, can duplicate unit submissions be silently ignored without error, causing inconsistent propagation where some peers store a unit and others don't, leading to chain splits?",
  "[File: byteball/ocore/mysql_pool.js] [Function: addQuery()] [Async.series Dependency - Version Compatibility] The addQuery function assumes a specific async.series callback signature (line 89) - if the async library version used has different callback semantics, can this cause queries to execute out of order or not at all, breaking atomicity of multi-step transactions like AA secondary triggers?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Error Message Leakage - Database Schema] When query errors are logged with the full SQL (line 36), does this expose database schema details including table names, column names, and relationships that could help an attacker craft more effective SQL injection or timing attacks against the DAG structure?",
  "[File: byteball/ocore/mysql_pool.js] [Function: takeConnectionFromPool()] [Connection Wrapper Cache - Stale State] If connections are recycled by the pool but maintain stale cached state from previous uses (e.g., transaction isolation levels or session variables), can this cause non-deterministic query results when the same connection is reused across different protocol operations?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Object.assign Shadow Properties - Prototype Pollution] The Object.assign({}, row) call (line 55) creates a new object but inherits from Object.prototype - can an attacker pollute Object.prototype with malicious properties that appear in query results, passing validation checks that expect certain fields to be undefined?",
  "[File: byteball/ocore/mysql_pool.js] [Function: release()] [Release Without Transaction Commit - Dirty Reads] If release() is called before a transaction is committed, does the connection return to the pool with an open transaction, allowing other queries to see uncommitted data and violate isolation guarantees during witness vote counting or balance calculations?",
  "[File: byteball/ocore/mysql_pool.js] [Function: addTime()] [Interval String Validation - Code Execution] The interval parameter in addTime (line 126) is directly concatenated - can an attacker pass intervals like '1 DAY); DROP TABLE units; --' to inject arbitrary SQL, or does MySQL's interval parsing provide sufficient protection against this attack vector?",
  "[File: byteball/ocore/mysql_pool.js] [Function: cquery()] [Fast Mode State Inconsistency] When conf.bFaster causes queries to be skipped (lines 71-72), does this leave the application state inconsistent with database state, where in-memory caches expect certain rows to exist but they were never inserted due to skipped queries, causing validation failures on subsequent operations?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Consumed Time Overflow - Negative Timestamps] If Date.now() wraps around or returns values in the past due to system clock manipulation, can the consumed_time calculation (line 57) underflow or overflow, causing the slow query detection to malfunction and hide systematic performance degradation attacks?",
  "[File: byteball/ocore/mysql_pool.js] [Function: getCountUsedConnections()] [Undefined Property Access - Type Error] If the connection pool implementation changes and _allConnections or _freeConnections become undefined (line 118), does the subtraction throw a TypeError that crashes the monitoring code, preventing operators from detecting pool exhaustion before it causes network failures?",
  "[File: byteball/ocore/mysql_pool.js] [Function: takeConnectionFromPool()] [Callback Invocation Context - this Binding] When handleConnection is invoked (line 113), the 'this' context may be different from what the caller expects - can this cause errors when the callback tries to access instance properties or methods, breaking connection management in object-oriented code patterns?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Promise Resolve Value - Interface Mismatch] When queries without callbacks return Promises that resolve with the callback's first argument (line 29), but normal callbacks receive (results, fields), do Promise consumers lose access to the fields parameter, breaking code that relies on column metadata for validation?",
  "[File: byteball/ocore/mysql_pool.js] [Function: query()] [Filter Array Allocation - Memory Pressure] The query logging creates a filtered array of arguments (line 59) for every slow query - during a DoS attack with many slow queries, can this excessive array allocation cause garbage collection pauses that delay critical validation operations, contributing to transaction delays exceeding Medium severity thresholds?",
  "[File: byteball/ocore/network.js] [Function: sendRequest()] [Request Tag Collision] In sendRequest() at lines 217-275, if an attacker can predict or force collisions in the tag generated by objectHash.getBase64Hash(request, true), can they intercept responses intended for legitimate requests by registering their own responseHandler for the same tag, potentially stealing sensitive data like private payment proofs or AA state variables?",
  "[File: byteball/ocore/network.js] [Function: sendRequest()] [Rerouting Race Condition] In sendRequest() at lines 233-257, when a request is rerouted after STALLED_TIMEOUT (5 seconds), if the original peer responds just after rerouting begins but before the rerouted request completes, can both responses be processed simultaneously causing the responseHandler to be called twice with different data, potentially corrupting local state or causing double-processing of critical operations like joint storage?",
  "[File: byteball/ocore/network.js] [Function: sendRequest()] [Rerouting Amplification] In the reroute logic at lines 238-256, if a malicious peer intentionally delays responses to trigger rerouting, and the reroute target also delays, can an attacker force exponential amplification of requests across the network as each timeout triggers another reroute, causing a distributed DoS where the same request is simultaneously pending on dozens of peers?",
  "[File: byteball/ocore/network.js] [Function: sendRequest()] [Response Timeout Bypass] At lines 259-264, non-reroutable requests are canceled after RESPONSE_TIMEOUT (300 seconds) with error '[internal] response timeout'. Can an attacker exploit this by forcing a node into a state where all requests timeout, preventing the node from ever syncing catchup chains or receiving critical joints, effectively isolating it from the network and causing a permanent inability to confirm transactions?",
  "[File: byteball/ocore/network.js] [Function: handleResponse()] [Pending Request Validation] In handleResponse() at lines 303-315, the function checks if ws.assocPendingRequests[tag] exists before processing. If an attacker can trigger deletePendingRequest() via connection close while a legitimate response is in transit, can the response be silently dropped even though the data was received, causing operations like catchup to fail and requiring manual intervention to resume sync?",
  "[File: byteball/ocore/network.js] [Function: deletePendingRequest()] [Reroute Chain Cleanup] In deletePendingRequest() at lines 278-300, when cleaning up rerouted requests (lines 286-295), if a request was rerouted to multiple peers in sequence, does the cleanup properly cancel ALL pending instances, or can orphaned requests remain active on some peers, causing duplicate responses hours later that might conflict with new state?",
  "[File: byteball/ocore/network.js] [Function: cancelRequestsOnClosedConnection()] [Immediate Reroute Exploit] At lines 317-336, when a WebSocket closes, reroutable requests are immediately rerouted (line 325) without checking if they were already rerouted. Can an attacker force-close connections in a pattern that causes the same request to be rerouted multiple times simultaneously to different peers, creating a request storm that exhausts connection limits and prevents legitimate traffic?",
  "[File: byteball/ocore/network.js] [Function: sendRequest()] [Duplicate Handler Accumulation] At lines 225-228, when an identical request is already pending, the new responseHandler is simply appended to the array. If an attacker repeatedly sends the same request before any response arrives, can they cause an unbounded accumulation of responseHandlers in memory, eventually causing an OOM crash when the response finally arrives and all handlers execute?",
  "[File: byteball/ocore/network.js] [Function: findNextPeer()] [Peer Selection Bias] In tryFindNextPeer() at lines 355-365, when selecting the next peer for rerouting, the function uses (peer_index+1)%len which cycles through outbound sources in order. Can an attacker who controls multiple outbound peers arranged sequentially in the array cause all rerouted requests to flow through their controlled nodes, allowing them to selectively drop requests for specific units and prevent the node from syncing critical parts of the DAG?",
  "[File: byteball/ocore/network.js] [Function: findRandomInboundPeer()] [Trusted Peer Exhaustion] At lines 371-396, the function queries peer_hosts table filtering by count_invalid_joints/count_new_good_joints < MAX_TOLERATED_INVALID_RATIO. Can an attacker who initially behaves honestly accumulate a high count_new_good_joints, then later inject many invalid joints to be discovered slowly over time, bypassing the ratio check since their historical good behavior keeps them 'trusted' while they cause damage?",
  "[File: byteball/ocore/network.js] [Function: connectToPeer()] [Connection Timeout Race] At lines 440-446, if a connection attempt times out after 5 seconds and is abandoned, but the actual WebSocket connection succeeds later, the duplicate detection at lines 457-464 will close the new connection. Can an attacker exploit this race by repeatedly connecting/disconnecting to cause the node to close legitimate incoming connections from the same URL, effectively blocking specific peers from ever establishing stable connections?",
  "[File: byteball/ocore/network.js] [Function: addOutboundPeers()] [Recursive Peer Starvation] At lines 504-537, if no good peers are found, the function recursively calls itself with multiplier*2 (line 534), relaxing the MAX_TOLERATED_INVALID_RATIO threshold up to 32x. Can an attacker who controls the database or network state force this function into maximum recursion by ensuring no peers meet even the relaxed criteria, causing exponential query complexity and database lock contention that freezes the node?",
  "[File: byteball/ocore/network.js] [Function: handleNewPeers()] [Peer Injection via get_peers] In handleNewPeers() at lines 677-710, when processing peer URLs received from get_peers response, the function checks if peer is known via database query (line 699) before connecting. Can an attacker who controls a peer inject thousands of malicious peer URLs in the response, forcing the node to perform expensive database queries and connection attempts for each one, causing CPU and network exhaustion?",
  "[File: byteball/ocore/network.js] [Function: addPeer()] [Peer Database Poisoning] At lines 554-563, addPeer() inserts into peers table with learnt_from_peer_host. If an attacker repeatedly advertises the same malicious peer URLs from different sources, can they cause the peers table to grow unboundedly since INSERT IGNORE only prevents duplicate (peer_host, peer) combinations, but the same peer can be inserted multiple times with different learnt_from_peer_host values, eventually causing database bloat?",
  "[File: byteball/ocore/network.js] [Function: purgeDeadPeers()] [Selective Peer Retention] At lines 637-671, purgeDeadPeers() only deletes peers if count_other_events < 20000 AND days_since_last_event < 7. Can an attacker who knows this threshold keep a malicious peer 'alive' in the database by ensuring it generates exactly 1 event every 6.9 days, allowing the peer to remain in the connection pool indefinitely even if it consistently serves invalid data?",
  "[File: byteball/ocore/network.js] [Function: checkIfHaveEnoughOutboundPeersAndAdd()] [Insufficient Peer Threshold] At lines 398-420, the function only requests new peers if count_good_peers < MIN_COUNT_GOOD_PEERS. If all current 'good' peers become malicious after this check passes, but remain under the invalid joints ratio threshold, can the node operate with an entirely compromised peer set without triggering any peer discovery, allowing attackers to feed the node a fabricated version of the DAG?",
  "[File: byteball/ocore/network.js] [Function: handleJoint()] [assocUnitsInWork Race] In handleJoint() at lines 1017-1132, the function checks assocUnitsInWork[unit] at line 1021 and sets it to true at line 1023, but this check is not atomic. If two peers send the same joint simultaneously on different WebSocket connections, can both pass the check before either sets the flag, causing the same joint to be validated twice in parallel and potentially stored twice in the database, corrupting the units table?",
  "[File: byteball/ocore/network.js] [Function: handleJoint()] [Mutex Lock Ordering] At line 1026, handleJoint() acquires mutex.lock(['handleJoint']) before calling validation.validate(). If validation.validate() internally tries to acquire other mutexes that are already held by other operations waiting for 'handleJoint', can this create a deadlock that freezes all joint processing, causing the network to stop confirming transactions?",
  "[File: byteball/ocore/network.js] [Function: handleJoint()] [Validation Callback Confusion] The validate() callback at lines 1027-1112 has multiple exit paths (ifUnitError, ifJointError, ifTransientError, ifNeedHashTree, ifNeedParentUnits, ifOk). If an attacker can craft a joint that triggers multiple callbacks (e.g., ifTransientError followed by ifOk due to async races), can they cause the same unit to be both purged from unhandled_joints AND saved to storage, creating inconsistent database state?",
  "[File: byteball/ocore/network.js] [Function: handleJoint()] [ifNeedParentUnits Storage] At lines 1076-1079, when parents are missing, the joint is passed to joint_storage.saveUnhandledJointAndDependencies(). If an attacker floods the network with joints that reference non-existent parent units, can they fill the unhandled_joints table to database limits, preventing legitimate joints with temporarily missing parents from being stored and causing transaction confirmation delays exceeding 24 hours?",
  "[File: byteball/ocore/network.js] [Function: handleOnlineJoint()] [Error Forwarding Loop] In handleOnlineJoint() at lines 1190-1268, errors are sent back via sendErrorResult() at lines 1200, 1204, 1210. If an attacker crafts a joint that causes transient validation errors across all peers, can they trigger a situation where peers keep forwarding the same invalid joint to each other, each sending error responses, creating an error message storm that saturates WebSocket bandwidth?",
  "[File: byteball/ocore/network.js] [Function: handlePostedJoint()] [Light Client Post Validation] In handlePostedJoint() at lines 1135-1188, light clients can post joints (line 1144) with bPosted=true flag. At lines 1083-1090, posted joints with sequence !== 'good' are rejected. Can a malicious light client post a joint that passes initial validation but becomes non-serial after other units arrive, and since it was posted, it gets propagated to all peers before being rejected, wasting network bandwidth and processing time across the network?",
  "[File: byteball/ocore/network.js] [Function: forwardJoint()] [Forwarding Amplification] In forwardJoint() at lines 1010-1015, the joint is forwarded to ALL subscribed clients except the sender. If an attacker controls multiple nodes and carefully times joint submission to arrive at slightly different times at different hubs, can they cause exponential amplification where each forwarding triggers more forwardings, eventually broadcasting the same joint hundreds of times across the network within seconds?",
  "[File: byteball/ocore/network.js] [Function: handleJoint()] [ifKnownBad Infinite Loop] At lines 1124-1126 in handleJoint(), if a joint is known bad, it just deletes assocUnitsInWork[unit] and returns. If an attacker keeps sending the same known-bad joint repeatedly from different peers, does each attempt trigger a full database query to check if it's known bad, causing cumulative database load that could slow down legitimate joint processing?",
  "[File: byteball/ocore/network.js] [Function: purgeJointAndDependenciesAndNotifyPeers()] [Error Notification Chain] At lines 971-994, when purging a joint and its dependencies, sendErrorResult() is called for each dependent unit (lines 987-990). If an attacker creates a joint with thousands of dependent units in unhandled_joints and then triggers its purge, can the function attempt to send thousands of error notifications simultaneously, exhausting WebSocket write buffers and causing connection drops?",
  "[File: byteball/ocore/network.js] [Function: handleJoint()] [Transient Error Retry Loop] At lines 1054-1066, transient errors trigger setTimeout(rerequestLostJoints, 10 * 1000, true). If an attacker can trigger transient errors repeatedly for different joints, can they cause dozens of overlapping rerequestLostJoints timers to fire simultaneously after 10 seconds, creating a thundering herd that requests hundreds of joints at once and overwhelms network resources?",
  "[File: byteball/ocore/network.js] [Function: requestCatchup()] [Catchup State Race] At lines 1945-1987, requestCatchup() sets bWaitingForCatchupChain=true at line 1972 before sending the catchup request at line 1979. If multiple peers trigger requestCatchup() simultaneously through different code paths (e.g., from findLostJoints and from handleOnlineJoint), can they race to set this flag, causing multiple concurrent catchup requests that conflict with each other and corrupt the catchup state?",
  "[File: byteball/ocore/network.js] [Function: handleCatchupChain()] [Catchup Chain Validation] In handleCatchupChain() at lines 1989-2012, the catchup chain response is processed via catchup.processCatchupChain() at line 1998. If the peer returns a malicious catchup chain that passes validation but references units that don't exist on the network, can the node enter a permanent state where bCatchingUp=true (line 2005) but it can never complete catchup because the required units are unfindable, causing all new incoming joints to be rejected?",
  "[File: byteball/ocore/network.js] [Function: requestNextHashTree()] [Hash Tree Duplicate Request] At lines 2033-2037, requestNextHashTree() checks if ws.assocPendingRequests already contains a get_hash_tree command to avoid duplicates. However, this only checks the current peer's pending requests. If an attacker forces reconnection mid-catchup, causing the node to switch to a different peer for hash tree requests, can the old request still be pending on the disconnected peer, and when it eventually times out and reroutes, cause duplicate hash tree processing?",
  "[File: byteball/ocore/network.js] [Function: handleHashTree()] [Hash Tree Memory Exhaustion] In handleHashTree() at lines 2042-2060, the hash tree balls are stored via catchup.processHashTree() at line 2050. If an attacker peer sends a valid but enormous hash tree (e.g., thousands of balls), and since there's no size limit checked here, can they cause the node to allocate excessive memory for storage.assocHashTreeUnitsByBall, eventually triggering OOM crashes?",
  "[File: byteball/ocore/network.js] [Function: waitTillHashTreeFullyProcessedAndRequestNext()] [Unhandled Ball Threshold] At lines 2075-2088, the function only requests the next hash tree if !haveManyUnhandledHashTreeBalls() (line 2079), where 'many' is defined as >30 at lines 2062-2073. Can an attacker who controls the peer serving hash trees send exactly 30 unhandled balls repeatedly, keeping the node stuck in this wait loop indefinitely while never triggering the 'too many' threshold, preventing catchup completion and causing transaction confirmation delays exceeding 24 hours?",
  "[File: byteball/ocore/network.js] [Function: requestCatchup()] [Last Stable MCI Manipulation] At lines 1975-1979, requestCatchup() reads last_stable_mci and last_known_mci and sends them in the catchup request. If these values are stale due to caching or delayed updates, can an attacker peer exploit the outdated values to send a catchup chain that conflicts with the actual current state, causing the node to reject all subsequent incoming joints as 'out of order' and permanently preventing sync?",
  "[File: byteball/ocore/network.js] [Function: handleHashTree()] [Hash Tree Error Recovery] At lines 2044-2046 and 2052-2053, if hash tree processing fails, waitTillHashTreeFullyProcessedAndRequestNext() is called after 1 second. If the same error occurs repeatedly (e.g., due to database corruption), does this create an infinite retry loop that never escalates to a higher-level error handler, leaving the node in a zombie state where it appears to be catching up but never makes progress?",
  "[File: byteball/ocore/network.js] [Function: checkCatchupLeftovers()] [Leftover State Conflict] At lines 1926-1943, checkCatchupLeftovers() queries hash_tree_balls and catchup_chain_balls to check for incomplete catchup from a previous run. If these tables contain conflicting data (e.g., hash tree balls from a different chain fork), can resuming catchup from this state cause the node to build an inconsistent DAG that diverges from the rest of the network?",
  "[File: byteball/ocore/network.js] [Function: handleOnlinePrivatePayment()] [Private Payment Injection] In handleOnlinePrivatePayment() at lines 2114-2179, the function validates arrPrivateElements at lines 2115-2126 with basic checks, then either saves or validates the payment. If an attacker sends a well-formed but malicious private payment chain where the payload hash doesn't match the public unit's payload_hash, can this bypass validation here and only be caught later in privatePayment.validateAndSavePrivatePaymentChain(), causing the unhandled_private_payments table to fill with invalid entries that are never cleaned up?",
  "[File: byteball/ocore/network.js] [Function: handleOnlinePrivatePayment()] [Private Payment Race] At lines 2129-2139, private payments are saved to unhandled_private_payments with INSERT IGNORE. If two identical private payment chains arrive simultaneously from different peers (or same peer twice), can they both be saved (since IGNORE only prevents PK violations) but with different timestamps, causing handleSavedPrivatePayments() to process the same payment twice and potentially credit funds twice to the recipient?",
  "[File: byteball/ocore/network.js] [Function: handleSavedPrivatePayments()] [Mutex Deadlock] At line 2189, handleSavedPrivatePayments() acquires mutex lock ['saved_private']. If this function is called recursively or from multiple threads, and it internally calls code that tries to acquire other mutexes (e.g., validation mutexes), can this create a deadlock especially during high private payment volume?",
  "[File: byteball/ocore/network.js] [Function: updateLinkProofsOfPrivateChain()] [Link Proof Bypass] At lines 2432-2448, updateLinkProofsOfPrivateChain() checks if arrPrivateElements form a valid chain via checkThatEachChainElementIncludesThePrevious(). If this check returns null (undefined result) at line 2440, the function calls onFailure() which just returns. Does this leave the private payment in unhandled_private_payments table permanently, causing the table to grow unboundedly with payments that can never be validated or rejected?",
  "[File: byteball/ocore/network.js] [Function: handleSavedPrivatePayments()] [Private Payment Validation Loop] At lines 2182-2259, the function processes all saved private payments. At lines 2237-2239, if the chain is waiting (light client case), it just calls cb() without removing the payment from the database. Can an attacker force many private payments into this 'waiting' state by sending chains that reference units that will never become stable, causing the table to fill up and handleSavedPrivatePayments() to repeatedly process the same payments forever, wasting CPU?",
  "[File: byteball/ocore/network.js] [Function: requestUnfinishedPastUnitsOfPrivateChains()] [History Request Amplification] At lines 2304-2330, this function finds unfinished units and calls requestHistoryFor(). If an attacker sends many incomplete private payment chains to a light client, each triggering a full history request, can they cause the light client to request and process gigabytes of history data from the light vendor, eventually exhausting bandwidth or storage?",
  "[File: byteball/ocore/network.js] [Function: cleanBadSavedPrivatePayments()] [Delayed Cleanup Exploit] At lines 2268-2282, cleanBadSavedPrivatePayments() only deletes private payments older than 1 day where the unit doesn't exist. Can an attacker keep sending invalid private payment chains continuously, and since they're only cleaned after 24 hours, cause the unhandled_private_payments table to grow to millions of rows over time, eventually slowing down all queries against it and causing transaction processing delays?",
  "[File: byteball/ocore/network.js] [Function: handleOnlinePrivatePayment()] [Private Payment Storage Bypass] At lines 2142-2147, light clients with arrPrivateElements.length > 1 immediately save the payment and call updateLinkProofsOfPrivateChain(). If the link proof validation fails, the payment remains in unhandled_private_payments but is never associated with a peer (line 2133 uses empty string for peer). Does this prevent the payment from ever being requested again since there's no peer to request from, causing lost private payments?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('light/get_history')] [History Size DoS] At lines 3314-3358, light/get_history is processed with mutex.lock(['get_history_request']). If a malicious light client requests history for thousands of addresses with addresses parameter, and each address has thousands of transactions, can they cause light.prepareHistory() to allocate gigabytes of memory and consume hours of CPU time while holding the mutex, blocking all other history requests and causing denial of service for legitimate light clients?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('light/get_history')] [Large History Tag Tracking] At lines 3315-3316, if history is too large, the tag is marked in largeHistoryTags[tag]=true and future requests with the same tag return an error. However, largeHistoryTags is never cleaned up. Can an attacker repeatedly request large histories with unique tags, causing largeHistoryTags to grow unboundedly and eventually consume all available memory?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('light/get_link_proofs')] [Link Proof Forgery] At lines 3360-3375, light/get_link_proofs is processed via light.prepareLinkProofs(). If the full node is compromised or malicious, can it send fake link proofs that appear valid but actually link to units on a minority fork, causing the light client to accept an alternative version of history and potentially spend funds that don't exist on the real main chain?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('light/pick_divisible_coins_for_amount')] [Coin Selection Manipulation] At lines 3439-3477, the function picks coins via inputs.pickDivisibleCoinsForAmount() with amount + size parameter at line 3472. Can a malicious light vendor deliberately return a coin selection that includes coins that will soon become invalid (e.g., being spent in another transaction the vendor knows about), causing the light client's transaction to fail with double-spend error after submission?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('light/get_aa_state_vars')] [State Var Query Limit] At lines 3629-3660, light/get_aa_state_vars accepts a limit parameter (default MAX_STATE_VARS = 2000). If an attacker requests exactly 2000 state vars repeatedly with slightly different var_prefix_from values, can they enumerate the entire AA state by making multiple requests, and if the AA has millions of state variables, does this cause excessive database load on the full node serving the requests?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('light/dry_run_aa')] [Dry Run State Pollution] At lines 3605-3627, light/dry_run_aa executes aa_composer.dryRunPrimaryAATrigger() which may modify in-memory state. At lines 3619-3622, if COUNT_WITNESSES === 1, the memory is reset via storage.resetMemory(). Can an attacker on a testnet (where COUNT_WITNESSES might be 1) repeatedly call dry_run_aa with triggers that create massive temporary state, forcing the node to repeatedly reset memory and rebuild state, causing severe performance degradation?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('light/execute_getter')] [Getter Execution Timeout] At lines 3672-3693, light/execute_getter calls formulaEvaluation.executeGetter() with no timeout parameter visible. If an attacker submits a getter that takes hours to execute (e.g., complex loops or recursive formulas), can they tie up execution resources indefinitely, preventing other getters from running and causing DoS for legitimate users trying to read AA state?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('light/get_aas_by_base_aas')] [Base AA Query Injection] At lines 3695-3732, the function accepts aa_params with comparison operators ['=', '!=', '>', '>=', '<', '<='] at line 3713. If the AA parameter value is carefully crafted (e.g., SQL injection patterns in string comparisons), can this bypass the satisfiesSearchCriteria() validation at line 3725 and cause unintended AA matches to be returned, leaking information about AAs that shouldn't match the search?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('light/get_aa_responses')] [AA Response Pagination Exploit] At lines 3734-3768, responses are limited to 100 but ordered by mci. If an attacker creates an AA that generates thousands of responses at the same MCI, and the light client requests them with that MCI as max_mci, does the LIMIT 100 cut off in the middle of that MCI's responses, and the note about filtering duplicates at line 3753 suggests pagination might return duplicates, causing the light client to miss responses?",
  "[File: byteball/ocore/network.js] [Function: handleJustsaying('hub/login')] [Authentication Challenge Replay] At lines 2703-2758, hub/login validates objLogin.challenge against ws.challenge set when the connection opened. If an attacker captures a valid login signature and can force the hub to assign the same challenge (e.g., by manipulating random number generation or timing), can they replay the login and impersonate the original device?",
  "[File: byteball/ocore/network.js] [Function: handleJustsaying('hub/login')] [Max Message Length Bypass] At lines 2717-2718, max_message_length validation only checks if it's a positive integer. If an attacker sets max_message_length to Number.MAX_SAFE_INTEGER (9007199254740991), can they bypass the intent of limiting message size and cause hub/deliver at lines 3239 to deliver enormous messages that exhaust memory when stringified?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('hub/deliver')] [Device Message Flooding] At lines 3199-3259, hub/deliver inserts messages into device_messages table with INSERT IGNORE at line 3234. If an attacker repeatedly sends slightly different messages (different encrypted content but same recipient), can they fill the device_messages table with millions of rows for a single recipient, causing database bloat and slowing down message retrieval in sendStoredDeviceMessages()?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('hub/deliver')] [Message Notification DoS] At lines 3247-3255, after delivering a message, the hub emits 'peer_sent_new_message' event if push is enabled. If an attacker sends thousands of messages per second to multiple recipients, can they trigger thousands of event emissions per second, and if the event handlers (e.g., push notification services) are slow, cause event queue buildup and eventual memory exhaustion?",
  "[File: byteball/ocore/network.js] [Function: handleJustsaying('my_url')] [URL Verification Bypass] At lines 2634-2698, peers can advertise their URL which is verified via echo test at lines 2660-2664. If an attacker controls both the advertised URL and can intercept the reverse connection, can they pass the echo test even though they don't actually operate at that URL, allowing them to inject false routing information into the peer_host_urls table?",
  "[File: byteball/ocore/network.js] [Function: sendStoredDeviceMessages()] [Message Retrieval Limit] At lines 2479-2490, sendStoredDeviceMessages() queries with LIMIT (line 2482) of ws.max_message_count or 100. If an attacker fills the device_messages table with 100 messages for their own device, then sends 1 legitimate message to a victim device, does the victim's messages get pushed out of the query results, causing them never to receive their legitimate message?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('hub/temp_pubkey')] [Temp Pubkey Update Race] At lines 3282-3312, hub/temp_pubkey updates the temp_pubkey_package at line 3302. If a device logs in on multiple connections simultaneously and updates its temp_pubkey from both connections, can they race and cause the final stored temp_pubkey to be inconsistent, breaking future pairing attempts that try to retrieve this key via hub/get_temp_pubkey?",
  "[File: byteball/ocore/network.js] [Function: deleteOverlengthMessagesIfLimitIsSet()] [Overlength Message Purge Timing] At lines 2469-2476, messages exceeding max_message_length are deleted. If an attacker knows a victim's max_message_length is small, can they repeatedly send messages just under the limit to fill the victim's message box, then have a legitimate party send an important large message, which gets deleted immediately upon the victim's next login, causing message loss?",
  "[File: byteball/ocore/network.js] [Function: handleJustsaying('joint')] [Joint Archive Race] At lines 2583-2605, when receiving a 'joint' justsaying, the function first checks if the unit is in archived_joints at line 2591. If a unit is being archived in a background thread while simultaneously being received as a new joint, can this race cause the joint to be both archived and processed as new, creating duplicate entries or inconsistent state?",
  "[File: byteball/ocore/network.js] [Function: handleJustsaying('joint')] [Object Length Ratio Check] At line 2594, getRatio() checks if the joint's key-to-value ratio exceeds 3. If an attacker crafts a joint with a ratio of exactly 3.0 or uses floating point manipulation to bypass this check, can they submit joints with abnormally large key names that waste storage space and slow down JSON serialization across the network?",
  "[File: byteball/ocore/network.js] [Function: handleJustsaying('version')] [Version Downgrade Attack] At lines 2511-2549, the version handler checks library_version against minCoreVersion and minCoreVersionForFullNodes. If an attacker can modify these constants in conf.js or constants.js, can they force the node to accept connections from outdated peers with known vulnerabilities, allowing those peers to exploit old bugs?",
  "[File: byteball/ocore/network.js] [Function: handleJustsaying('bugreport')] [Bug Report Email Bomb] At lines 2566-2581, bug reports are sent via mail.sendBugEmail() at line 2580, with deduplication based on prev_bugreport_hash (line 2575). Can an attacker send bug reports with slightly different 'message' fields that hash to different values, bypassing deduplication and causing the hub to send thousands of emails to the bug_sink_email address, overwhelming the email system?",
  "[File: byteball/ocore/network.js] [Function: handleJustsaying('watch_system_vars')] [System Vars Broadcast Storm] At lines 2908-2911, when a client requests to watch system vars, ws.bWatchingSystemVars is set to true and sendSysVars() is called. If an attacker connects with thousands of WebSocket connections and all request watch_system_vars, does each system var update trigger thousands of broadcasts via sendUpdatedSysVarsToAllLight() at lines 162-167, causing network saturation?",
  "[File: byteball/ocore/network.js] [Function: handleJustsaying('exchange_rates')] [Rate Update Authority] At lines 2913-2918, exchange_rates are accepted from any peer where ws.bLoggingIn || ws.bLoggedIn. If a malicious peer can set these flags (e.g., by exploiting a hub login vulnerability), can they inject false exchange rates that get broadcast to all clients via eventBus.emit('rates_updated'), causing applications to make financial decisions based on incorrect prices?",
  "[File: byteball/ocore/network.js] [Function: handleJustsaying('upgrade_required')] [Force Disconnect Attack] At lines 2934-2939, if a peer sends 'upgrade_required', the node closes the connection and throws an error. Can an attacker who controls a hub force all connected clients to disconnect and crash by sending this message, causing widespread service disruption?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('subscribe')] [Subscription ID Collision] At lines 2980-3016, the subscribe command checks if subscription_id already exists across all peers at line 2986. If the subscription_id is only 30 random bytes (base64 encoded, ~40 chars) generated at line 773, can an attacker with high connection volume force a collision by repeatedly connecting until they match an existing subscription_id, causing legitimate peers to be disconnected for 'self-connect'?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('subscribe')] [Old Core Connection Leak] At lines 3001-3007, if the peer has old_core=true (set in version handler or here), the connection is closed. However, the peer is already in the subscription flow. Can this create a state where the peer is marked as subscribed (line 3008) but then immediately disconnected, leaving stale subscription state that causes joints to be forwarded to a dead connection?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('get_joint')] [Joint Response Manipulation] At lines 3018-3037, get_joint reads a joint and conditionally removes the ball and skiplist_units at lines 3027-3030 if objJoint.ball exists and main_chain_index > getMinRetrievableMci(). Can an attacker requesting a joint at exactly minRetrievableMci+1 receive a joint without ball data, but if they request it again a moment later after the MCI threshold moves, receive the same joint WITH ball data, creating confusion about stability status?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('post_joint')] [Post Joint Object Key Ratio] At lines 3039-3048, post_joint checks objectLength.getRatio() > 3 at line 3043. This is the same check as in 'joint' justsaying handler. If an attacker knows the exact formula for getRatio(), can they craft a joint with ratio exactly 3.0 that passes this check but has abnormally large keys, and since it's posted by a light client, it gets special handling that might bypass other size checks?",
  "[File: byteball/ocore/network.js] [Function: handleRequest('catchup')] [Catchup Mutex Timeout] At lines 3050-3068, catchup requests acquire mutex.lock(['catchup_request']). If catchup.prepareCatchupChain() at line 3057 takes an extremely long time (e.g., due to complex database queries), can subsequent catchup requests from other peers queue up behind the mutex, and if the first request never completes due to a bug, does this permanently block all catchup operations across the entire network?",
  "[File: byteball/ocore/object_hash.js] [Function: getChash160()] [AA Address Derivation] The function uses special JSON-based hashing for 'autonomous agent' arrays (line 11) - can an attacker craft a non-AA object that gets JSON-hashed due to matching the pattern [length=2, first='autonomous agent'], resulting in address collision with legitimate AA addresses and allowing theft of funds sent to that address?",
  "[File: byteball/ocore/object_hash.js] [Function: getChash160()] [Non-deterministic Hashing] Since getChash160() switches between getJsonSourceString() and getSourceString() based on object structure (line 11), can an attacker exploit differences in key ordering or encoding between these two methods to generate the same chash160 for two different objects, causing address collision and fund theft?",
  "[File: byteball/ocore/object_hash.js] [Function: getChash160()] [Type Confusion] If an attacker passes an object that is Array.isArray() === true with obj[0] === 'autonomous agent' but obj.length !== 2, does the function still use getJsonSourceString() and potentially create unexpected hashing behavior that could be exploited for address collision?",
  "[File: byteball/ocore/object_hash.js] [Function: getChash288()] [Chash Length Mismatch] The getChash288() function always uses getSourceString() (line 16) - can an attacker exploit the fact that it doesn't have the special AA handling that getChash160() has to create non-deterministic hashing across nodes if some mistake AA definitions for regular objects?",
  "[File: byteball/ocore/object_hash.js] [Function: getChash160()] [Unicode Normalization] Does the chash.getChash160() implementation normalize Unicode strings consistently across platforms, or can an attacker exploit Unicode normalization differences (NFC vs NFD) to generate the same chash160 for visually identical but byte-different strings, enabling phishing or address collision attacks?",
  "[File: byteball/ocore/object_hash.js] [Function: getBase64Hash()] [Conditional JSON Hashing] The bJsonBased parameter switches between getJsonSourceString() and getSourceString() (line 24) - can an attacker exploiting calling code that incorrectly sets this flag cause hash collisions by hashing the same object with different encoding methods in different parts of the system?",
  "[File: byteball/ocore/object_hash.js] [Function: getHexHash()] [No JSON Mode] getHexHash() always uses getSourceString() (line 20) and never getJsonSourceString() - can this inconsistency with getBase64Hash() be exploited to create units that hash differently when the same object is hashed with hex vs base64, breaking consensus or allowing signature bypass?",
  "[File: byteball/ocore/object_hash.js] [Function: getBase64Hash()] [Base64 Padding] Does the base64 encoding include proper padding, and can an attacker exploit implementations that strip or mishandle padding characters to create hash collisions or bypass signature verification when hashes are compared?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Deep Clone Mutation] The function uses _.cloneDeep() (line 30) - if lodash's cloneDeep has vulnerabilities with prototype pollution or fails to clone certain object types (Symbols, getters/setters), can an attacker craft a unit that mutates during cloning and produces different hashes on different nodes, causing permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Version-Specific Field Deletion] The function only deletes 'timestamp' if version === versionWithoutTimestamp (lines 38-39) - can an attacker exploit units with undefined/null version to cause non-deterministic deletion of timestamp field across nodes, resulting in different unit hashes and permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Message Payload Deletion] Lines 41-46 delete payload and payload_uri from messages - if an attacker includes both 'payload' and 'payload_uri' in a message, are both guaranteed to be deleted consistently, or can race conditions or object property ordering cause one to remain in some nodes, breaking consensus?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Actual TPS Fee Retention] Line 36 deletes 'actual_tps_fee' but the commented line 35 shows 'tps_fee' is NOT deleted - can an attacker exploit the presence of both tps_fee and actual_tps_fee fields to manipulate fee calculations while maintaining valid unit hashes, stealing fees or causing validation discrepancies?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Commission Field Deletion] Lines 32-34 delete headers_commission, payload_commission, and oversize_fee - if these fields contain BigInt or non-standard number types, can incomplete deletion or type coercion during cloning cause hash mismatches across nodes?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Empty Messages Array] If objUnit.messages is defined but empty (length=0), the loop (lines 42-46) doesn't execute - does this create an edge case where an empty messages array is hashed differently than undefined messages, allowing unit hash manipulation?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Message Index Manipulation] The message payload deletion iterates by index (line 42) - if an attacker crafts a unit where messages array has gaps (sparse array with undefined elements), can the iteration skip malicious payloads that should be stripped, causing hash mismatches?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitContentHash()] [Version Check Inversion] Line 53 checks objUnit.version !== constants.versionWithoutTimestamp to determine JSON hashing - can an attacker craft a unit with version explicitly set to undefined or null, bypassing the version check and causing different nodes to use different hashing methods, resulting in permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitContentHash()] [Naked Unit Reuse] getUnitContentHash() calls getNakedUnit() (line 53) which uses _.cloneDeep() - if the same objUnit is hashed multiple times, can mutations between calls cause different content hashes for the same logical unit, enabling double-spend attacks?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHash()] [Content Hash Bypass] Lines 58-59 use different code paths if objUnit.content_hash exists vs not - can an attacker inject a fake content_hash field into a full unit to force the getNakedUnit() path instead of getStrippedUnit(), creating hash collisions or bypassing validation?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHash()] [Version Check Duplication] Both content_hash path (line 59) and stripped unit path (line 60) calculate bVersion2 separately - if an attacker mutates objUnit.version between line 57 and line 60, can they cause inconsistent version handling and hash mismatches?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHash()] [Stripped Unit Validation Gap] When content_hash exists (line 58), the function assumes the unit is already stripped and uses getNakedUnit() - but does validation.js verify that units with content_hash don't also have message payloads, or can an attacker include both to bypass payload size limits while maintaining valid hash?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Author Address Mapping] Line 69 maps authors to only their addresses - if the original authors array contains duplicate addresses or addresses in non-deterministic order, can the mapping produce different stripped units on different nodes, causing permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Witness List Conditional] Lines 71-74 conditionally include witness_list_unit OR witnesses - if an attacker provides both fields in objUnit, which takes precedence, and can this be exploited to create units that validate differently on nodes with different validation logic versions?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Parent Units Conditional] Lines 75-79 only include parent_units, last_ball, and last_ball_unit if parent_units exists - can an attacker craft a genesis-like unit with last_ball but no parent_units to bypass last ball validation while maintaining a valid stripped unit hash?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Timestamp Inclusion] Line 80-81 includes timestamp only if bVersion2 is true - if an attacker submits a version 2+ unit but manually sets version to versionWithoutTimestamp after initial validation, can they manipulate the stripped unit structure and create hash collisions?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Content Hash Replacement] Line 66 replaces the entire unit content with content_hash - if getUnitContentHash() has any non-determinism (floating point, date objects, etc.), can different nodes generate different content_hashes for the same unit, causing permanent divergence?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Alt Field Inclusion] Line 68 includes objUnit.alt in stripped unit - if alt is undefined in some units, does the stripped unit include 'alt: undefined' or omit the field entirely, and can this difference cause hash mismatches across nodes?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Author Order Preservation] Line 69 maps authors and comments 'already sorted' - but what guarantees authors are sorted before this function is called, and can an attacker exploit unsorted author arrays to create units with valid hashes but non-deterministic author ordering?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Authentifier Deletion] Lines 87-88 delete authentifiers from all authors - if an author object has authentifiers nested deeply or stored with alternate property names, can incomplete deletion leave signature data in the hash-to-sign, breaking signature verification?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Version String Coercion] Line 89 checks 'typeof objUnit.version === undefined' using string comparison - does this correctly handle objUnit.version = 'undefined' (string) vs undefined (type), and can an attacker exploit type coercion to bypass version checks?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Hash-to-Sign Format] Line 90 returns raw Buffer digest() without encoding - if consuming code expects base64 or hex and performs conversion inconsistently, can signature verification fail for valid signatures or accept invalid ones?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Naked Unit Mutation] getUnitHashToSign() modifies objNakedUnit in place (lines 87-88) after getNakedUnit() returns a cloned object - if getNakedUnit() has shallow clone bugs, can this modification affect the original objUnit and cause hash mismatches in subsequent operations?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Version Undefined Handling] Line 89 checks if version is undefined OR equals versionWithoutTimestamp - can an attacker submit a unit with version = null or version = 0 to bypass this check and cause non-deterministic JSON/source string selection?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Source String Selection] The function chooses between getSourceString() and getJsonSourceString() based on version (line 89) - if different nodes have different constants.versionWithoutTimestamp values due to configuration drift, can they generate different hash-to-sign values and reject valid signatures?",
  "[File: byteball/ocore/object_hash.js] [Function: getSignedPackageHashToSign()] [Deep Clone Reuse] Lines 94-98 duplicate the logic from getUnitHashToSign() almost exactly - if there's a bug in authentifier deletion or version handling, it affects both functions, but can inconsistencies between these two functions be exploited to bypass signature verification in one context but not another?",
  "[File: byteball/ocore/object_hash.js] [Function: getSignedPackageHashToSign()] [Package vs Unit Semantics] This function is used for signed_message.js but uses identical logic to getUnitHashToSign() - can an attacker craft a signed package that validates as a unit or vice versa, bypassing type-specific validation and causing authorization bypass?",
  "[File: byteball/ocore/object_hash.js] [Function: getBallHash()] [Empty Array Handling] Lines 105-110 only include parent_balls and skiplist_balls if arrays exist AND length > 0 - if an attacker provides empty arrays, are they omitted from the hash completely, and can this be exploited to create ball hash collisions for balls with empty vs undefined parent/skiplist arrays?",
  "[File: byteball/ocore/object_hash.js] [Function: getBallHash()] [Nonserial Flag] Line 109-110 conditionally includes is_nonserial=true only if bNonserial is truthy - if bNonserial is false/undefined, the field is omitted - can an attacker exploit the asymmetry (true included, false omitted) to create ball hash collisions by flipping the nonserial flag?",
  "[File: byteball/ocore/object_hash.js] [Function: getBallHash()] [Ball Object Construction] Lines 102-111 build objBall incrementally - if JavaScript property insertion order is non-deterministic in some VMs, can the ball hash vary across nodes, causing last_ball chain divergence and permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Function: getBallHash()] [Array Content Validation] The function accepts arrParentBalls and arrSkiplistBalls without validating their contents - if these arrays contain objects instead of strings or have inconsistent ordering, can different nodes hash them differently, breaking ball chain consensus?",
  "[File: byteball/ocore/object_hash.js] [Function: getBallHash()] [Unit Parameter Type] The 'unit' parameter (line 103) is included as-is in the ball object - if 'unit' is not a string but an object or number, can type coercion during hashing cause non-deterministic ball hashes?",
  "[File: byteball/ocore/object_hash.js] [Function: getJointHash()] [JSON.stringify Non-determinism] Line 116 uses JSON.stringify() directly instead of getSourceString() or getJsonSourceString() - this bypasses key ordering and canonicalization, so can an attacker craft joints with identical logical content but different JSON serialization that hash differently, causing network sync failures?",
  "[File: byteball/ocore/object_hash.js] [Function: getJointHash()] [Error Swallowing Comment] Line 115 comments 'we use JSON.stringify, we can't use objectHash here because it might throw errors' - does this mean joints can contain data structures that would fail objectHash validation (null, empty arrays, undefined), and can an attacker exploit this to create invalid joints that still hash correctly?",
  "[File: byteball/ocore/object_hash.js] [Function: getJointHash()] [Joint Structure Validation] Since getJointHash() doesn't use the same validation as getSourceString(), can an attacker include circular references, functions, or other invalid JavaScript objects in joints that crash nodes during JSON.stringify() or cause denial of service?",
  "[File: byteball/ocore/object_hash.js] [Function: getJointHash()] [UTF-8 Encoding Assumption] Line 116 explicitly specifies 'utf8' encoding - if the input objJoint contains binary data or invalid UTF-8 sequences, can JSON.stringify() handle them consistently across platforms, or will encoding errors cause hash mismatches?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNulls()] [Shallow vs Deep] cleanNulls() only removes null at the top level (lines 120-123) while cleanNullsDeep() recurses (lines 126-132) - if consuming code calls the wrong function, can deep null values survive and cause hash inconsistencies, especially in nested unit structures?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNullsDeep()] [Array Null Preservation] Line 130 checks 'typeof obj[key] === object' which includes arrays - but arrays are iterated by index, so if an array contains null elements [1, null, 3], are the nulls preserved or removed, and can this inconsistency be exploited?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNullsDeep()] [Recursive Mutation] cleanNullsDeep() mutates the input object in place (line 129) - if the same object is used in multiple places (shallow copies), can cleaning nulls in one location affect hash calculations in another, causing non-deterministic behavior?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNullsDeep()] [Prototype Pollution] Lines 127-132 iterate Object.keys() and recursively process values - if an attacker pollutes Object.prototype with null-valued properties, can cleanNullsDeep() remove prototype properties and cause unexpected behavior in other parts of the code?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNullsDeep()] [Circular Reference Handling] If obj contains circular references (obj.child.parent = obj), cleanNullsDeep() will recurse infinitely (line 131) - can an attacker crash nodes by submitting device messages or other objects with circular references that undergo null cleaning?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNulls()] [Non-Object Input] If cleanNulls() is called with a non-object input (string, number, null itself), Object.keys() (line 120) will fail or return empty - can this cause crashes or undefined behavior in code paths that expect null cleaning to always succeed?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceAddress()] [Leading Zero Prefix] Line 142 prepends '0' to the chash160 to create device addresses - the comment (lines 138-140) states this prevents confusion with payment addresses, but can an attacker strip the '0' prefix and use the remaining string as a payment address to redirect funds?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceAddress()] [Public Key Format] The function accepts b64_pubkey without validating it's valid base64 or a valid public key - can an attacker pass arbitrary strings to generate device addresses that collide with payment addresses or other device addresses?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceAddress()] [Base32 Collision] Device addresses use base32 encoding (via chash160) while payment addresses might use base64 - even with the '0' prefix, can an attacker find strings where '0' + base32(X) visually resembles a payment address, enabling phishing attacks?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceAddress()] [Raw Public Key Hashing] Line 142 hashes the raw public key without any address definition structure - does this mean device addresses are single-sig only, and can an attacker exploit this by tricking users to send funds to device addresses (which lack the definition layer protection)?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceMessageHashToSign()] [Signature Deletion] Line 147 uses _.clone() (shallow) then deletes signature (line 147) - if the original objDeviceMessage.signature is a nested object or the message has signature fields in nested structures, can incomplete deletion allow signature malleability attacks?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceMessageHashToSign()] [Free Format Comment] Line 148 comments 'device messages have free format' - does this mean device messages can contain arbitrary structure including functions, getters, or proxy objects that behave differently during cloning vs hashing, enabling signature bypass?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceMessageHashToSign()] [CleanNullsDeep Call] Line 148 calls cleanNullsDeep() on device messages 'to avoid malicious fields' - but if cleanNullsDeep() has the circular reference vulnerability, can an attacker DoS nodes by sending device messages with circular references?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceMessageHashToSign()] [Malicious Field Handling] The comment mentions preventing 'malicious fields' but cleanNullsDeep() only removes null-valued fields - can an attacker include fields with undefined, NaN, Infinity, or other special values that pass null cleaning but cause hash inconsistencies?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceMessageHashToSign()] [Shallow Clone Limitation] Line 146 uses _.clone() which is shallow - if objDeviceMessage has nested objects with signature fields at deeper levels, are those preserved in the hash-to-sign, allowing signature reuse attacks?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: getUnitHash()  getStrippedUnit()  getUnitContentHash()] [Hash Chain Integrity] If an attacker modifies objUnit between the content_hash check (line 58) and the getStrippedUnit() call (line 60), can they bypass content hash verification while producing a valid unit hash, enabling payload manipulation attacks?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: getUnitHashToSign() and getUnitHash()] [Signature Binding] getUnitHashToSign() removes authentifiers (line 88) before hashing, while getUnitHash() includes them (via getNakedUnit) - if validation checks unit_hash but signs unit_hash_to_sign, can an attacker modify authentifiers after signing without invalidating the unit hash, enabling signature malleability?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: getBase64Hash() with bJsonBased flag] [Inconsistent Encoding] If some code paths call getBase64Hash(obj, true) and others call getBase64Hash(obj, false) for the same object type, can the resulting hashes differ, and can an attacker exploit this by submitting objects that pass validation with one encoding but execute with another?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: cleanNullsDeep()  getDeviceMessageHashToSign()] [Null Cleaning Side Effects] Since cleanNullsDeep() mutates the input object (line 129), does calling getDeviceMessageHashToSign() modify the original device message, and can this cause signature verification to fail if the message is signed before cleaning but verified after?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: getNakedUnit()  _.cloneDeep()] [Clone Depth Limit] If _.cloneDeep() has a recursion depth limit, can an attacker craft deeply nested unit structures that partially clone, resulting in shared mutable state between original and naked units that causes hash inconsistencies?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: getChash160() for AA addresses] [AA Definition Injection] Since getChash160() treats ['autonomous agent', definition] specially (line 11), can an attacker inject a legitimate-looking but malicious definition that still hashes to the same address as a benign AA, stealing funds through address collision?",
  "[File: byteball/ocore/object_hash.js] [Version handling across functions] [Version Constant Mismatch] Multiple functions check objUnit.version against constants.versionWithoutTimestamp (lines 38, 53, 57, 80, 89, 97) - if different nodes load different constant values due to configuration errors or network split between testnet/mainnet, can they compute different hashes for the same unit, causing permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Version handling: getNakedUnit()] [Version Field Mutation] If getNakedUnit() deletes the timestamp field conditionally (line 39), but the input objUnit is later reused, can the presence/absence of timestamp field cause different hashes in subsequent operations, enabling replay attacks?",
  "[File: byteball/ocore/object_hash.js] [Version handling: getStrippedUnit()] [Timestamp Inclusion Logic] Line 80 includes timestamp for version 2+, but what happens if objUnit.timestamp is undefined in a v2 unit - does the stripped unit include 'timestamp: undefined' or omit the field, and can this cause hash mismatches?",
  "[File: byteball/ocore/object_hash.js] [Version upgrade path] [Cross-Version Hash Compatibility] When the protocol upgrades from version 1.0 to 2.0+, nodes running different versions will hash units differently (with/without timestamp) - can an attacker exploit the upgrade window to create units that validate on old nodes but not new nodes or vice versa, causing temporary chain split?",
  "[File: byteball/ocore/object_hash.js] [Encoding: getSourceString() vs getJsonSourceString()] [Key Ordering Differences] getSourceString() (from string_utils.js) uses Object.keys().sort() while getJsonSourceString() also sorts - but if JavaScript sorting is locale-dependent or handles Unicode differently, can key ordering differ across nodes, causing permanent hash mismatches and chain split?",
  "[File: byteball/ocore/object_hash.js] [Encoding: getJsonSourceString()] [Empty Array/Object Handling] string_utils.js getJsonSourceString() throws on empty arrays/objects by default (line 204-210 in string_utils.js) unless bAllowEmpty is true - but object_hash.js calls it without bAllowEmpty parameter - can units with empty arrays cause crashes during hashing?",
  "[File: byteball/ocore/object_hash.js] [Encoding: getSourceString()] [Null Value Errors] string_utils.js getSourceString() throws Error on null values (line 15 in string_utils.js) - but object_hash.js doesn't sanitize inputs - can an attacker submit units with null fields to crash all nodes during hash computation, causing network-wide DoS?",
  "[File: byteball/ocore/object_hash.js] [Encoding: getJsonSourceString()] [Well-formed JSON Stringify] string_utils.js uses toWellFormedJsonStringify() (line 187) to escape lone surrogates - if an attacker includes lone Unicode surrogates in unit fields, can different JavaScript engines handle them inconsistently, causing hash mismatches across nodes?",
  "[File: byteball/ocore/object_hash.js] [Encoding: UTF-8] All hash functions use 'utf8' encoding (lines 20, 25, 90, 98, 116, 149) - if input strings contain invalid UTF-8 sequences or NULL bytes, does Node.js crypto module handle them consistently across platforms (Linux, Windows, Mac), or can platform differences cause hash mismatches?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Empty unit] If objUnit is an empty object {}, getNakedUnit() will return {} after deletions - does getSourceString({}) throw an error for empty objects, or return a consistent hash that could collide with other empty structures?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Undefined version] If objUnit.version is explicitly set to undefined (not missing), does the version check (line 38) correctly handle it, or does typeof undefined === 'string' cause unexpected behavior?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Authors array mutation] getStrippedUnit() maps authors to {address} objects (line 69) - if the original authors array is modified concurrently during this operation, can the resulting stripped unit have inconsistent author lists, breaking consensus?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Large numbers] If unit fields contain numbers exceeding Number.MAX_SAFE_INTEGER or include BigInt values, does getSourceString() handle them consistently, or can precision loss cause hash differences across nodes?",
  "[File: byteball/ocore/object_hash.js] [Edge case: NaN and Infinity] If objUnit contains NaN or Infinity in numeric fields, does getSourceString() throw an error (line 22 in string_utils.js checks !isFinite), and can an attacker cause DoS by submitting units with invalid numbers?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Sparse arrays] If objUnit.messages is a sparse array with undefined holes, does the iteration (line 42) handle them correctly, or can gaps in the array cause some messages to skip payload deletion, breaking content hash calculation?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Frozen objects] If objUnit is a frozen object (Object.freeze()), can _.cloneDeep() in getNakedUnit() properly clone it, or will the clone also be frozen, preventing field deletions and causing hash calculation to fail?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Symbolic properties] If objUnit has Symbol-keyed properties, do they get included in hashing via Object.keys() or getOwnPropertySymbols(), and can different handling cause hash mismatches across nodes?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Getter properties] If objUnit.messages has a getter that returns different values on each call, will getNakedUnit() and getStrippedUnit() produce consistent hashes, or can dynamic getters cause non-deterministic hashing?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Proxy objects] If objUnit is wrapped in a Proxy that intercepts property access, can the proxy return different values during cloning vs hashing, bypassing validation and enabling signature forgery?",
  "[File: byteball/ocore/object_hash.js] [DoS: Deep recursion in cleanNullsDeep()] If an attacker crafts a device message with 10,000 levels of nesting, will cleanNullsDeep() (lines 126-132) exhaust the call stack and crash the node, or does JavaScript have tail call optimization that prevents this?",
  "[File: byteball/ocore/object_hash.js] [DoS: Large object cloning] If objUnit is extremely large (approaching MAX_UNIT_LENGTH of 5MB), does _.cloneDeep() in getNakedUnit() consume excessive memory or CPU, and can an attacker DoS nodes by flooding with maximum-size units that require full cloning before hashing?",
  "[File: byteball/ocore/object_hash.js] [DoS: SHA256 collision attacks] While SHA256 preimage resistance is strong, if an attacker finds near-collisions or uses birthday attacks, can they create units with identical hashes that differ in content, enabling double-spend attacks through hash collision?",
  "[File: byteball/ocore/object_hash.js] [DoS: JSON.stringify bomb] In getJointHash() (line 116), if objJoint contains circular references or deeply nested structures, can JSON.stringify() crash with 'converting circular structure' error, and can an attacker DoS nodes by broadcasting malicious joints?",
  "[File: byteball/ocore/object_hash.js] [DoS: String concatenation in getSourceString()] string_utils.js builds the source string by concatenating array elements (line 55) - if objUnit has thousands of fields, can repeated string concatenation cause O(n) performance and DoS nodes during validation?",
  "[File: byteball/ocore/object_hash.js] [Crypto: SHA256 parameter mismatch] All functions use crypto.createHash('sha256') - if the Node.js crypto module is compromised or uses weak PRNG for salts (though SHA256 has no salt), can hash predictability enable preimage attacks?",
  "[File: byteball/ocore/object_hash.js] [Crypto: Buffer encoding] getUnitHashToSign() returns raw Buffer digest (line 90) while getBase64Hash() returns base64 string (line 25) - if signature verification code mismatches the expected format, can valid signatures be rejected or invalid signatures accepted?",
  "[File: byteball/ocore/object_hash.js] [Consensus: Hash uniqueness] Does the protocol guarantee that unit hashes are globally unique, or can different units with different content legitimately produce the same hash (e.g., genesis units, witness heartbeat units), and can this be exploited for replay attacks?",
  "[File: byteball/ocore/object_hash.js] [Consensus: Deterministic hashing] If JavaScript object property enumeration order is non-deterministic in some edge cases (e.g., numeric string keys '1' vs integer keys 1), can getSourceString() produce different hashes for the same logical object on different nodes?",
  "[File: byteball/ocore/object_hash.js] [Consensus: Ball hash chain] getBallHash() creates a hash chain through parent_balls (line 106) - if an attacker creates a ball with corrupted parent_balls references, can they fork the ball chain without forking the unit DAG, breaking last_ball consensus?",
  "[File: byteball/ocore/object_hash.js] [Integration: validation.js usage] validation.js calls getUnitHash() to verify unit hash matches - if validation.js passes a partially validated unit to getUnitHash(), can field injection or mutation between validation and hashing allow invalid units to be accepted?",
  "[File: byteball/ocore/object_hash.js] [Integration: composer.js usage] composer.js calls getUnitHashToSign() to generate hash for signing - if composer doesn't properly sanitize unit structure before calling this function, can malformed units produce valid-looking hashes that fail validation later?",
  "[File: byteball/ocore/object_hash.js] [Integration: storage.js stripping] main_chain.js strips old units using setContentHash() - if the content_hash calculated during stripping differs from the content_hash calculated during original validation, can stripped units fail re-validation, causing database corruption?",
  "[File: byteball/ocore/object_hash.js] [Integration: signature.js verification] signature.js verifies signatures against hash-to-sign from getUnitHashToSign() - if signature.js and definition.js use different authentifier deletion logic, can signatures validate incorrectly, enabling unauthorized spending?",
  "[File: byteball/ocore/object_hash.js] [Integration: aa_addresses.js] aa_addresses.js uses getChash160() for AA address derivation - if AA definition contains floating point parameters that round differently across platforms, can the same AA definition map to different addresses\n\n### Citations\n\n**File:** object_hash.js (L1-171)\n```javascript\n/*jslint node: true */",
  "[File: byteball/ocore/object_hash.js] [Function: getChash160()] [AA Address Derivation] The function uses special JSON-based hashing for 'autonomous agent' arrays (line 11) - can an attacker craft a non-AA object that gets JSON-hashed due to matching the pattern [length=2, first='autonomous agent'], resulting in address collision with legitimate AA addresses and allowing theft of funds sent to that address?",
  "[File: byteball/ocore/object_hash.js] [Function: getChash160()] [Non-deterministic Hashing] Since getChash160() switches between getJsonSourceString() and getSourceString() based on object structure (line 11), can an attacker exploit differences in key ordering or encoding between these two methods to generate the same chash160 for two different objects, causing address collision and fund theft?",
  "[File: byteball/ocore/object_hash.js] [Function: getChash160()] [Type Confusion] If an attacker passes an object that is Array.isArray() === true with obj[0] === 'autonomous agent' but obj.length !== 2, does the function still use getJsonSourceString() and potentially create unexpected hashing behavior that could be exploited for address collision?",
  "[File: byteball/ocore/object_hash.js] [Function: getChash288()] [Chash Length Mismatch] The getChash288() function always uses getSourceString() (line 16) - can an attacker exploit the fact that it doesn't have the special AA handling that getChash160() has to create non-deterministic hashing across nodes if some mistake AA definitions for regular objects?",
  "[File: byteball/ocore/object_hash.js] [Function: getChash160()] [Unicode Normalization] Does the chash.getChash160() implementation normalize Unicode strings consistently across platforms, or can an attacker exploit Unicode normalization differences (NFC vs NFD) to generate the same chash160 for visually identical but byte-different strings, enabling phishing or address collision attacks?",
  "[File: byteball/ocore/object_hash.js] [Function: getBase64Hash()] [Conditional JSON Hashing] The bJsonBased parameter switches between getJsonSourceString() and getSourceString() (line 24) - can an attacker exploiting calling code that incorrectly sets this flag cause hash collisions by hashing the same object with different encoding methods in different parts of the system?",
  "[File: byteball/ocore/object_hash.js] [Function: getHexHash()] [No JSON Mode] getHexHash() always uses getSourceString() (line 20) and never getJsonSourceString() - can this inconsistency with getBase64Hash() be exploited to create units that hash differently when the same object is hashed with hex vs base64, breaking consensus or allowing signature bypass?",
  "[File: byteball/ocore/object_hash.js] [Function: getBase64Hash()] [Base64 Padding] Does the base64 encoding include proper padding, and can an attacker exploit implementations that strip or mishandle padding characters to create hash collisions or bypass signature verification when hashes are compared?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Deep Clone Mutation] The function uses _.cloneDeep() (line 30) - if lodash's cloneDeep has vulnerabilities with prototype pollution or fails to clone certain object types (Symbols, getters/setters), can an attacker craft a unit that mutates during cloning and produces different hashes on different nodes, causing permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Version-Specific Field Deletion] The function only deletes 'timestamp' if version === versionWithoutTimestamp (lines 38-39) - can an attacker exploit units with undefined/null version to cause non-deterministic deletion of timestamp field across nodes, resulting in different unit hashes and permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Message Payload Deletion] Lines 41-46 delete payload and payload_uri from messages - if an attacker includes both 'payload' and 'payload_uri' in a message, are both guaranteed to be deleted consistently, or can race conditions or object property ordering cause one to remain in some nodes, breaking consensus?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Actual TPS Fee Retention] Line 36 deletes 'actual_tps_fee' but the commented line 35 shows 'tps_fee' is NOT deleted - can an attacker exploit the presence of both tps_fee and actual_tps_fee fields to manipulate fee calculations while maintaining valid unit hashes, stealing fees or causing validation discrepancies?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Commission Field Deletion] Lines 32-34 delete headers_commission, payload_commission, and oversize_fee - if these fields contain BigInt or non-standard number types, can incomplete deletion or type coercion during cloning cause hash mismatches across nodes?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Empty Messages Array] If objUnit.messages is defined but empty (length=0), the loop (lines 42-46) doesn't execute - does this create an edge case where an empty messages array is hashed differently than undefined messages, allowing unit hash manipulation?",
  "[File: byteball/ocore/object_hash.js] [Function: getNakedUnit()] [Message Index Manipulation] The message payload deletion iterates by index (line 42) - if an attacker crafts a unit where messages array has gaps (sparse array with undefined elements), can the iteration skip malicious payloads that should be stripped, causing hash mismatches?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitContentHash()] [Version Check Inversion] Line 53 checks objUnit.version !== constants.versionWithoutTimestamp to determine JSON hashing - can an attacker craft a unit with version explicitly set to undefined or null, bypassing the version check and causing different nodes to use different hashing methods, resulting in permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitContentHash()] [Naked Unit Reuse] getUnitContentHash() calls getNakedUnit() (line 53) which uses _.cloneDeep() - if the same objUnit is hashed multiple times, can mutations between calls cause different content hashes for the same logical unit, enabling double-spend attacks?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHash()] [Content Hash Bypass] Lines 58-59 use different code paths if objUnit.content_hash exists vs not - can an attacker inject a fake content_hash field into a full unit to force the getNakedUnit() path instead of getStrippedUnit(), creating hash collisions or bypassing validation?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHash()] [Version Check Duplication] Both content_hash path (line 59) and stripped unit path (line 60) calculate bVersion2 separately - if an attacker mutates objUnit.version between line 57 and line 60, can they cause inconsistent version handling and hash mismatches?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHash()] [Stripped Unit Validation Gap] When content_hash exists (line 58), the function assumes the unit is already stripped and uses getNakedUnit() - but does validation.js verify that units with content_hash don't also have message payloads, or can an attacker include both to bypass payload size limits while maintaining valid hash?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Author Address Mapping] Line 69 maps authors to only their addresses - if the original authors array contains duplicate addresses or addresses in non-deterministic order, can the mapping produce different stripped units on different nodes, causing permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Witness List Conditional] Lines 71-74 conditionally include witness_list_unit OR witnesses - if an attacker provides both fields in objUnit, which takes precedence, and can this be exploited to create units that validate differently on nodes with different validation logic versions?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Parent Units Conditional] Lines 75-79 only include parent_units, last_ball, and last_ball_unit if parent_units exists - can an attacker craft a genesis-like unit with last_ball but no parent_units to bypass last ball validation while maintaining a valid stripped unit hash?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Timestamp Inclusion] Line 80-81 includes timestamp only if bVersion2 is true - if an attacker submits a version 2+ unit but manually sets version to versionWithoutTimestamp after initial validation, can they manipulate the stripped unit structure and create hash collisions?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Content Hash Replacement] Line 66 replaces the entire unit content with content_hash - if getUnitContentHash() has any non-determinism (floating point, date objects, etc.), can different nodes generate different content_hashes for the same unit, causing permanent divergence?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Alt Field Inclusion] Line 68 includes objUnit.alt in stripped unit - if alt is undefined in some units, does the stripped unit include 'alt: undefined' or omit the field entirely, and can this difference cause hash mismatches across nodes?",
  "[File: byteball/ocore/object_hash.js] [Function: getStrippedUnit()] [Author Order Preservation] Line 69 maps authors and comments 'already sorted' - but what guarantees authors are sorted before this function is called, and can an attacker exploit unsorted author arrays to create units with valid hashes but non-deterministic author ordering?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Authentifier Deletion] Lines 87-88 delete authentifiers from all authors - if an author object has authentifiers nested deeply or stored with alternate property names, can incomplete deletion leave signature data in the hash-to-sign, breaking signature verification?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Version String Coercion] Line 89 checks 'typeof objUnit.version === undefined' using string comparison - does this correctly handle objUnit.version = 'undefined' (string) vs undefined (type), and can an attacker exploit type coercion to bypass version checks?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Hash-to-Sign Format] Line 90 returns raw Buffer digest() without encoding - if consuming code expects base64 or hex and performs conversion inconsistently, can signature verification fail for valid signatures or accept invalid ones?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Naked Unit Mutation] getUnitHashToSign() modifies objNakedUnit in place (lines 87-88) after getNakedUnit() returns a cloned object - if getNakedUnit() has shallow clone bugs, can this modification affect the original objUnit and cause hash mismatches in subsequent operations?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Version Undefined Handling] Line 89 checks if version is undefined OR equals versionWithoutTimestamp - can an attacker submit a unit with version = null or version = 0 to bypass this check and cause non-deterministic JSON/source string selection?",
  "[File: byteball/ocore/object_hash.js] [Function: getUnitHashToSign()] [Source String Selection] The function chooses between getSourceString() and getJsonSourceString() based on version (line 89) - if different nodes have different constants.versionWithoutTimestamp values due to configuration drift, can they generate different hash-to-sign values and reject valid signatures?",
  "[File: byteball/ocore/object_hash.js] [Function: getSignedPackageHashToSign()] [Deep Clone Reuse] Lines 94-98 duplicate the logic from getUnitHashToSign() almost exactly - if there's a bug in authentifier deletion or version handling, it affects both functions, but can inconsistencies between these two functions be exploited to bypass signature verification in one context but not another?",
  "[File: byteball/ocore/object_hash.js] [Function: getSignedPackageHashToSign()] [Package vs Unit Semantics] This function is used for signed_message.js but uses identical logic to getUnitHashToSign() - can an attacker craft a signed package that validates as a unit or vice versa, bypassing type-specific validation and causing authorization bypass?",
  "[File: byteball/ocore/object_hash.js] [Function: getBallHash()] [Empty Array Handling] Lines 105-110 only include parent_balls and skiplist_balls if arrays exist AND length > 0 - if an attacker provides empty arrays, are they omitted from the hash completely, and can this be exploited to create ball hash collisions for balls with empty vs undefined parent/skiplist arrays?",
  "[File: byteball/ocore/object_hash.js] [Function: getBallHash()] [Nonserial Flag] Line 109-110 conditionally includes is_nonserial=true only if bNonserial is truthy - if bNonserial is false/undefined, the field is omitted - can an attacker exploit the asymmetry (true included, false omitted) to create ball hash collisions by flipping the nonserial flag?",
  "[File: byteball/ocore/object_hash.js] [Function: getBallHash()] [Ball Object Construction] Lines 102-111 build objBall incrementally - if JavaScript property insertion order is non-deterministic in some VMs, can the ball hash vary across nodes, causing last_ball chain divergence and permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Function: getBallHash()] [Array Content Validation] The function accepts arrParentBalls and arrSkiplistBalls without validating their contents - if these arrays contain objects instead of strings or have inconsistent ordering, can different nodes hash them differently, breaking ball chain consensus?",
  "[File: byteball/ocore/object_hash.js] [Function: getBallHash()] [Unit Parameter Type] The 'unit' parameter (line 103) is included as-is in the ball object - if 'unit' is not a string but an object or number, can type coercion during hashing cause non-deterministic ball hashes?",
  "[File: byteball/ocore/object_hash.js] [Function: getJointHash()] [JSON.stringify Non-determinism] Line 116 uses JSON.stringify() directly instead of getSourceString() or getJsonSourceString() - this bypasses key ordering and canonicalization, so can an attacker craft joints with identical logical content but different JSON serialization that hash differently, causing network sync failures?",
  "[File: byteball/ocore/object_hash.js] [Function: getJointHash()] [Error Swallowing Comment] Line 115 comments 'we use JSON.stringify, we can't use objectHash here because it might throw errors' - does this mean joints can contain data structures that would fail objectHash validation (null, empty arrays, undefined), and can an attacker exploit this to create invalid joints that still hash correctly?",
  "[File: byteball/ocore/object_hash.js] [Function: getJointHash()] [Joint Structure Validation] Since getJointHash() doesn't use the same validation as getSourceString(), can an attacker include circular references, functions, or other invalid JavaScript objects in joints that crash nodes during JSON.stringify() or cause denial of service?",
  "[File: byteball/ocore/object_hash.js] [Function: getJointHash()] [UTF-8 Encoding Assumption] Line 116 explicitly specifies 'utf8' encoding - if the input objJoint contains binary data or invalid UTF-8 sequences, can JSON.stringify() handle them consistently across platforms, or will encoding errors cause hash mismatches?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNulls()] [Shallow vs Deep] cleanNulls() only removes null at the top level (lines 120-123) while cleanNullsDeep() recurses (lines 126-132) - if consuming code calls the wrong function, can deep null values survive and cause hash inconsistencies, especially in nested unit structures?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNullsDeep()] [Array Null Preservation] Line 130 checks 'typeof obj[key] === object' which includes arrays - but arrays are iterated by index, so if an array contains null elements [1, null, 3], are the nulls preserved or removed, and can this inconsistency be exploited?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNullsDeep()] [Recursive Mutation] cleanNullsDeep() mutates the input object in place (line 129) - if the same object is used in multiple places (shallow copies), can cleaning nulls in one location affect hash calculations in another, causing non-deterministic behavior?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNullsDeep()] [Prototype Pollution] Lines 127-132 iterate Object.keys() and recursively process values - if an attacker pollutes Object.prototype with null-valued properties, can cleanNullsDeep() remove prototype properties and cause unexpected behavior in other parts of the code?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNullsDeep()] [Circular Reference Handling] If obj contains circular references (obj.child.parent = obj), cleanNullsDeep() will recurse infinitely (line 131) - can an attacker crash nodes by submitting device messages or other objects with circular references that undergo null cleaning?",
  "[File: byteball/ocore/object_hash.js] [Function: cleanNulls()] [Non-Object Input] If cleanNulls() is called with a non-object input (string, number, null itself), Object.keys() (line 120) will fail or return empty - can this cause crashes or undefined behavior in code paths that expect null cleaning to always succeed?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceAddress()] [Leading Zero Prefix] Line 142 prepends '0' to the chash160 to create device addresses - the comment (lines 138-140) states this prevents confusion with payment addresses, but can an attacker strip the '0' prefix and use the remaining string as a payment address to redirect funds?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceAddress()] [Public Key Format] The function accepts b64_pubkey without validating it's valid base64 or a valid public key - can an attacker pass arbitrary strings to generate device addresses that collide with payment addresses or other device addresses?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceAddress()] [Base32 Collision] Device addresses use base32 encoding (via chash160) while payment addresses might use base64 - even with the '0' prefix, can an attacker find strings where '0' + base32(X) visually resembles a payment address, enabling phishing attacks?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceAddress()] [Raw Public Key Hashing] Line 142 hashes the raw public key without any address definition structure - does this mean device addresses are single-sig only, and can an attacker exploit this by tricking users to send funds to device addresses (which lack the definition layer protection)?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceMessageHashToSign()] [Signature Deletion] Line 147 uses _.clone() (shallow) then deletes signature (line 147) - if the original objDeviceMessage.signature is a nested object or the message has signature fields in nested structures, can incomplete deletion allow signature malleability attacks?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceMessageHashToSign()] [Free Format Comment] Line 148 comments 'device messages have free format' - does this mean device messages can contain arbitrary structure including functions, getters, or proxy objects that behave differently during cloning vs hashing, enabling signature bypass?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceMessageHashToSign()] [CleanNullsDeep Call] Line 148 calls cleanNullsDeep() on device messages 'to avoid malicious fields' - but if cleanNullsDeep() has the circular reference vulnerability, can an attacker DoS nodes by sending device messages with circular references?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceMessageHashToSign()] [Malicious Field Handling] The comment mentions preventing 'malicious fields' but cleanNullsDeep() only removes null-valued fields - can an attacker include fields with undefined, NaN, Infinity, or other special values that pass null cleaning but cause hash inconsistencies?",
  "[File: byteball/ocore/object_hash.js] [Function: getDeviceMessageHashToSign()] [Shallow Clone Limitation] Line 146 uses _.clone() which is shallow - if objDeviceMessage has nested objects with signature fields at deeper levels, are those preserved in the hash-to-sign, allowing signature reuse attacks?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: getUnitHash()  getStrippedUnit()  getUnitContentHash()] [Hash Chain Integrity] If an attacker modifies objUnit between the content_hash check (line 58) and the getStrippedUnit() call (line 60), can they bypass content hash verification while producing a valid unit hash, enabling payload manipulation attacks?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: getUnitHashToSign() and getUnitHash()] [Signature Binding] getUnitHashToSign() removes authentifiers (line 88) before hashing, while getUnitHash() includes them (via getNakedUnit) - if validation checks unit_hash but signs unit_hash_to_sign, can an attacker modify authentifiers after signing without invalidating the unit hash, enabling signature malleability?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: getBase64Hash() with bJsonBased flag] [Inconsistent Encoding] If some code paths call getBase64Hash(obj, true) and others call getBase64Hash(obj, false) for the same object type, can the resulting hashes differ, and can an attacker exploit this by submitting objects that pass validation with one encoding but execute with another?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: cleanNullsDeep()  getDeviceMessageHashToSign()] [Null Cleaning Side Effects] Since cleanNullsDeep() mutates the input object (line 129), does calling getDeviceMessageHashToSign() modify the original device message, and can this cause signature verification to fail if the message is signed before cleaning but verified after?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: getNakedUnit()  _.cloneDeep()] [Clone Depth Limit] If _.cloneDeep() has a recursion depth limit, can an attacker craft deeply nested unit structures that partially clone, resulting in shared mutable state between original and naked units that causes hash inconsistencies?",
  "[File: byteball/ocore/object_hash.js] [Cross-function: getChash160() for AA addresses] [AA Definition Injection] Since getChash160() treats ['autonomous agent', definition] specially (line 11), can an attacker inject a legitimate-looking but malicious definition that still hashes to the same address as a benign AA, stealing funds through address collision?",
  "[File: byteball/ocore/object_hash.js] [Version handling across functions] [Version Constant Mismatch] Multiple functions check objUnit.version against constants.versionWithoutTimestamp (lines 38, 53, 57, 80, 89, 97) - if different nodes load different constant values due to configuration errors or network split between testnet/mainnet, can they compute different hashes for the same unit, causing permanent chain split?",
  "[File: byteball/ocore/object_hash.js] [Version handling: getNakedUnit()] [Version Field Mutation] If getNakedUnit() deletes the timestamp field conditionally (line 39), but the input objUnit is later reused, can the presence/absence of timestamp field cause different hashes in subsequent operations, enabling replay attacks?",
  "[File: byteball/ocore/object_hash.js] [Version handling: getStrippedUnit()] [Timestamp Inclusion Logic] Line 80 includes timestamp for version 2+, but what happens if objUnit.timestamp is undefined in a v2 unit - does the stripped unit include 'timestamp: undefined' or omit the field, and can this cause hash mismatches?",
  "[File: byteball/ocore/object_hash.js] [Version upgrade path] [Cross-Version Hash Compatibility] When the protocol upgrades from version 1.0 to 2.0+, nodes running different versions will hash units differently (with/without timestamp) - can an attacker exploit the upgrade window to create units that validate on old nodes but not new nodes or vice versa, causing temporary chain split?",
  "[File: byteball/ocore/object_hash.js] [Encoding: getSourceString() vs getJsonSourceString()] [Key Ordering Differences] getSourceString() (from string_utils.js) uses Object.keys().sort() while getJsonSourceString() also sorts - but if JavaScript sorting is locale-dependent or handles Unicode differently, can key ordering differ across nodes, causing permanent hash mismatches and chain split?",
  "[File: byteball/ocore/object_hash.js] [Encoding: getJsonSourceString()] [Empty Array/Object Handling] string_utils.js getJsonSourceString() throws on empty arrays/objects by default (line 204-210 in string_utils.js) unless bAllowEmpty is true - but object_hash.js calls it without bAllowEmpty parameter - can units with empty arrays cause crashes during hashing?",
  "[File: byteball/ocore/object_hash.js] [Encoding: getSourceString()] [Null Value Errors] string_utils.js getSourceString() throws Error on null values (line 15 in string_utils.js) - but object_hash.js doesn't sanitize inputs - can an attacker submit units with null fields to crash all nodes during hash computation, causing network-wide DoS?",
  "[File: byteball/ocore/object_hash.js] [Encoding: getJsonSourceString()] [Well-formed JSON Stringify] string_utils.js uses toWellFormedJsonStringify() (line 187) to escape lone surrogates - if an attacker includes lone Unicode surrogates in unit fields, can different JavaScript engines handle them inconsistently, causing hash mismatches across nodes?",
  "[File: byteball/ocore/object_hash.js] [Encoding: UTF-8] All hash functions use 'utf8' encoding (lines 20, 25, 90, 98, 116, 149) - if input strings contain invalid UTF-8 sequences or NULL bytes, does Node.js crypto module handle them consistently across platforms (Linux, Windows, Mac), or can platform differences cause hash mismatches?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Empty unit] If objUnit is an empty object {}, getNakedUnit() will return {} after deletions - does getSourceString({}) throw an error for empty objects, or return a consistent hash that could collide with other empty structures?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Undefined version] If objUnit.version is explicitly set to undefined (not missing), does the version check (line 38) correctly handle it, or does typeof undefined === 'string' cause unexpected behavior?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Authors array mutation] getStrippedUnit() maps authors to {address} objects (line 69) - if the original authors array is modified concurrently during this operation, can the resulting stripped unit have inconsistent author lists, breaking consensus?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Large numbers] If unit fields contain numbers exceeding Number.MAX_SAFE_INTEGER or include BigInt values, does getSourceString() handle them consistently, or can precision loss cause hash differences across nodes?",
  "[File: byteball/ocore/object_hash.js] [Edge case: NaN and Infinity] If objUnit contains NaN or Infinity in numeric fields, does getSourceString() throw an error (line 22 in string_utils.js checks !isFinite), and can an attacker cause DoS by submitting units with invalid numbers?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Sparse arrays] If objUnit.messages is a sparse array with undefined holes, does the iteration (line 42) handle them correctly, or can gaps in the array cause some messages to skip payload deletion, breaking content hash calculation?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Frozen objects] If objUnit is a frozen object (Object.freeze()), can _.cloneDeep() in getNakedUnit() properly clone it, or will the clone also be frozen, preventing field deletions and causing hash calculation to fail?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Symbolic properties] If objUnit has Symbol-keyed properties, do they get included in hashing via Object.keys() or getOwnPropertySymbols(), and can different handling cause hash mismatches across nodes?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Getter properties] If objUnit.messages has a getter that returns different values on each call, will getNakedUnit() and getStrippedUnit() produce consistent hashes, or can dynamic getters cause non-deterministic hashing?",
  "[File: byteball/ocore/object_hash.js] [Edge case: Proxy objects] If objUnit is wrapped in a Proxy that intercepts property access, can the proxy return different values during cloning vs hashing, bypassing validation and enabling signature forgery?",
  "[File: byteball/ocore/object_hash.js] [DoS: Deep recursion in cleanNullsDeep()] If an attacker crafts a device message with 10,000 levels of nesting, will cleanNullsDeep() (lines 126-132) exhaust the call stack and crash the node, or does JavaScript have tail call optimization that prevents this?",
  "[File: byteball/ocore/object_hash.js] [DoS: Large object cloning] If objUnit is extremely large (approaching MAX_UNIT_LENGTH of 5MB), does _.cloneDeep() in getNakedUnit() consume excessive memory or CPU, and can an attacker DoS nodes by flooding with maximum-size units that require full cloning before hashing?",
  "[File: byteball/ocore/object_hash.js] [DoS: SHA256 collision attacks] While SHA256 preimage resistance is strong, if an attacker finds near-collisions or uses birthday attacks, can they create units with identical hashes that differ in content, enabling double-spend attacks through hash collision?",
  "[File: byteball/ocore/object_hash.js] [DoS: JSON.stringify bomb] In getJointHash() (line 116), if objJoint contains circular references or deeply nested structures, can JSON.stringify() crash with 'converting circular structure' error, and can an attacker DoS nodes by broadcasting malicious joints?",
  "[File: byteball/ocore/object_hash.js] [DoS: String concatenation in getSourceString()] string_utils.js builds the source string by concatenating array elements (line 55) - if objUnit has thousands of fields, can repeated string concatenation cause O(n) performance and DoS nodes during validation?",
  "[File: byteball/ocore/object_hash.js] [Crypto: SHA256 parameter mismatch] All functions use crypto.createHash('sha256') - if the Node.js crypto module is compromised or uses weak PRNG for salts (though SHA256 has no salt), can hash predictability enable preimage attacks?",
  "[File: byteball/ocore/object_hash.js] [Crypto: Buffer encoding] getUnitHashToSign() returns raw Buffer digest (line 90) while getBase64Hash() returns base64 string (line 25) - if signature verification code mismatches the expected format, can valid signatures be rejected or invalid signatures accepted?",
  "[File: byteball/ocore/object_hash.js] [Consensus: Hash uniqueness] Does the protocol guarantee that unit hashes are globally unique, or can different units with different content legitimately produce the same hash (e.g., genesis units, witness heartbeat units), and can this be exploited for replay attacks?",
  "[File: byteball/ocore/object_hash.js] [Consensus: Deterministic hashing] If JavaScript object property enumeration order is non-deterministic in some edge cases (e.g., numeric string keys '1' vs integer keys 1), can getSourceString() produce different hashes for the same logical object on different nodes?",
  "[File: byteball/ocore/object_hash.js] [Consensus: Ball hash chain] getBallHash() creates a hash chain through parent_balls (line 106) - if an attacker creates a ball with corrupted parent_balls references, can they fork the ball chain without forking the unit DAG, breaking last_ball consensus?",
  "[File: byteball/ocore/object_hash.js] [Integration: validation.js usage] validation.js calls getUnitHash() to verify unit hash matches - if validation.js passes a partially validated unit to getUnitHash(), can field injection or mutation between validation and hashing allow invalid units to be accepted?",
  "[File: byteball/ocore/object_hash.js] [Integration: composer.js usage] composer.js calls getUnitHashToSign() to generate hash for signing - if composer doesn't properly sanitize unit structure before calling this function, can malformed units produce valid-looking hashes that fail validation later?",
  "[File: byteball/ocore/object_hash.js] [Integration: storage.js stripping] main_chain.js strips old units using setContentHash() - if the content_hash calculated during stripping differs from the content_hash calculated during original validation, can stripped units fail re-validation, causing database corruption?",
  "[File: byteball/ocore/object_hash.js] [Integration: signature.js verification] signature.js verifies signatures against hash-to-sign from getUnitHashToSign() - if signature.js and definition.js use different authentifier deletion logic, can signatures validate incorrectly, enabling unauthorized spending?",
  "[File: byteball/ocore/object_hash.js] [Integration: aa_addresses.js] aa_addresses.js uses getChash160() for AA address derivation - if AA definition contains floating point parameters that round differently across platforms, can the same AA definition map to different addresses\n\n### Citations\n\n**File:** object_hash.js (L1-171)\n```javascript\n/*jslint node: true */",
  "[File: byteball/ocore/paid_witnessing.js] [Function: calcWitnessEarnings()] [Stability validation bypass] If the stability check at lines 17-21 is satisfied (exactly COUNT_MC_BALLS_FOR_PAID_WITNESSING+2 units), but units become unstable between the count query and the actual mc_outputs.calcEarnings() call, can an attacker claim witness earnings for unstable MCI ranges, violating the stability invariant and potentially causing consensus divergence?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: calcWitnessEarnings()] [Integer boundary attack] Can an attacker pass to_main_chain_index = MAX_SAFE_INTEGER causing the addition 'to_main_chain_index+constants.COUNT_MC_BALLS_FOR_PAID_WITNESSING+1' at line 18 to overflow beyond Number.MAX_SAFE_INTEGER, resulting in incorrect stability checks and allowing premature spending of witness earnings?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: calcWitnessEarnings()] [MCI range manipulation] If from_main_chain_index > to_main_chain_index is passed to calcWitnessEarnings(), does the function validate this condition before querying, or can negative ranges cause SQL errors or return incorrect earnings amounts that could lead to fund loss?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: calcWitnessEarnings()] [Race condition in stability] Between the COUNT query at lines 17-21 verifying stability and the mc_outputs.calcEarnings() call at line 22, if new units arrive making the range no longer have exactly COUNT_MC_BALLS_FOR_PAID_WITNESSING+2 units, can this cause inconsistent earnings calculations across nodes leading to consensus failure?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: calcWitnessEarnings()] [Type validation missing] The 'type' parameter is passed directly to mc_outputs.calcEarnings() without validation - can an attacker pass unexpected type values (e.g., SQL injection strings, null, undefined) to bypass earnings calculations or corrupt database state?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: calcWitnessEarnings()] [Address validation missing] The 'address' parameter at line 15 is not validated before being passed to mc_outputs.calcEarnings() - can passing malformed addresses, excessively long strings, or SQL injection payloads cause database errors or security vulnerabilities?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: calcWitnessEarnings()] [Error handling abuse] If the count check at line 20 fails with 'not enough stable MC units', does callbacks.ifError() properly prevent further processing, or can the caller ignore this error and proceed to claim unearned witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: readUnitOnMcIndex()] [Multiple units on MCI] The throw at line 57 occurs when rows.length !== 1, but what if a database corruption or race condition causes multiple units to have is_on_main_chain=1 for the same main_chain_index? Does this throw halt all witness payment processing permanently, causing network-wide freeze of witnessing_outputs?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: readUnitOnMcIndex()] [Missing unit handling] If rows.length === 0 (no unit on MC index), the throw at line 57 occurs - but during network catchup or reorganization edge cases, can this throw interrupt updatePaidWitnesses() causing witness payment calculations to permanently halt until manual intervention?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: readUnitOnMcIndex()] [Synchronous throw in async context] The throw Error() at line 57 is synchronous while the function uses asynchronous callbacks - can this cause unhandled promise rejections or break the async.eachSeries() flow in buildPaidWitnessesForMainChainIndex(), leading to incomplete witness payment processing?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: readUnitOnMcIndex()] [SQL injection potential] Although using parameterized query at line 55, can the main_chain_index parameter be manipulated to return unexpected results if it's not properly validated as an integer before reaching this function?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: updatePaidWitnesses()] [Race condition on last_stable_mci] If readLastStableMcIndex() at line 65 returns last_stable_mci value, but before getMaxSpendableMciForLastBallMci() executes at line 67, new units advance the last_stable_mci, can this cause witness payments to be calculated for MCIs that should not yet be spendable, violating the stability guarantee?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: updatePaidWitnesses()] [Negative max_spendable_mc_index] If getMaxSpendableMciForLastBallMci() at line 67 returns max_spendable_mc_index <= 0, the function calls cb() and exits - but does this leave some MCIs unprocessed, causing witnesses to permanently lose earnings for those early MCIs?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: updatePaidWitnesses()] [Callback not called on error] If storage.readLastStableMcIndex() encounters an error and never calls its callback, does updatePaidWitnesses() hang indefinitely without calling its cb(), potentially deadlocking the entire witness payment system?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: updatePaidWitnesses()] [Concurrent invocation] Can updatePaidWitnesses() be called concurrently from multiple threads or event handlers? If so, can two simultaneous executions both process the same MCIs, causing duplicate witness payment entries in witnessing_outputs table?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesTillMainChainIndex()] [NULL min_main_chain_index] The query at lines 75-77 uses MIN() which returns NULL if no rows match - if all balls already have count_paid_witnesses set, does main_chain_index become NULL at line 79, causing the comparison at line 80 to behave unexpectedly and potentially skip processing?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesTillMainChainIndex()] [Query planner manipulation] The 'CROSS' hint at line 74 forces SQLite query planner behavior - can differences between SQLite and MySQL query execution cause non-deterministic witness payment calculations, leading to consensus divergence between nodes using different databases?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesTillMainChainIndex()] [Infinite loop potential] The onIndexDone() recursive callback at lines 83-93 increments main_chain_index and continues - if buildPaidWitnessesForMainChainIndex() always succeeds but never properly sets count_paid_witnesses in the database, can this create an infinite loop consuming resources and halting the network?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesTillMainChainIndex()] [Error handling suppression] The comment 'if (err) // impossible' at line 84 assumes errors cannot occur - but if buildPaidWitnessesForMainChainIndex() does return an error, the throw at line 85 crashes the entire process - can an attacker craft malicious units that trigger this throw, causing network-wide daemon crashes?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesTillMainChainIndex()] [MCI gap handling] If to_main_chain_index is much larger than min_main_chain_index (e.g., after long network downtime), can the sequential processing of thousands of MCIs cause this function to block for extended periods, freezing transaction confirmation for hours (Medium severity - temporary freeze 1 hour)?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesTillMainChainIndex()] [Early termination bypass] The check at line 80-81 returns early if min_main_chain_index > to_main_chain_index - but what if min_main_chain_index is undefined/NULL? Does JavaScript coercion cause unexpected behavior allowing the function to proceed incorrectly?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [COUNT constant mismatch] The validation at lines 115-116 requires exactly 'constants.COUNT_MC_BALLS_FOR_PAID_WITNESSING+2' units - if this constant changes between nodes or after a protocol upgrade, can nodes disagree on whether a MCI is processable, causing permanent consensus divergence and chain split?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [RAM vs DB inconsistency] Lines 109-123 compare countRAM from storage.assocStableUnits against database count - if they differ, throwError() is called at line 122 but only when !conf.bFaster - can an attacker manipulate RAM cache to cause inconsistencies that are not detected in bFaster mode, leading to incorrect witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [Stability assumption violation] Line 119 checks count_on_stable_mc === count, but what if units become unstable between the query and this check due to DAG reorganization? Can this throw at line 120 halt witness payment processing permanently?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [Temporary table collision] The CREATE TEMPORARY TABLE at lines 128-130 doesn't use 'IF NOT EXISTS' - if buildPaidWitnessesForMainChainIndex() is called concurrently or if a previous execution didn't clean up, can the table creation fail, breaking witness payment processing?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [Witness list manipulation] Line 126 reads witnesses from MC unit via readMcUnitWitnesses() - can a malicious unit author manipulate their witness list on side chains to flip the witness list used for payment calculations, directing commissions to their own witnesses instead of the legitimate ones?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [Division by zero in payment] At lines 156-164, payments are divided by countPaidWitnesses[v.unit] - if countPaidWitnesses is somehow 0 for a unit, does Math.round(objUnit.payload_commission / 0) return Infinity or NaN, corrupting the witnessing_outputs table with invalid amounts?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [Rounding error accumulation] Line 162 uses Math.round(objUnit.payload_commission / countPaidWitnesses[v.unit]) which can lose fractional bytes - if this rounding error accumulates across millions of units, can it create significant inflation or deflation in total witness payments compared to actual payload_commission amounts?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [Sequence filtering bypass] Line 161 checks 'objUnit.sequence == 'good'' - can an attacker craft units with sequence='temp-bad' or other non-'good' values that bypass this check due to loose equality (== vs ===), allowing bad sequence units to generate witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [SQL injection in bFaster mode] At line 169, when conf.bFaster=true, the query is constructed by string concatenation with db.escape() - can escaping be bypassed if address contains special characters, allowing SQL injection to manipulate witnessing_outputs?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [Determinism failure] Lines 183-186 compare database results with RAM-calculated arrPaidAmounts2 - if they differ, throwError() is called - but does this properly handle floating-point precision differences that might occur legitimately, or can precision errors cause false positives that crash nodes unnecessarily?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [Temporary table cleanup failure] Line 187 drops the temporary table paid_witness_events_tmp - if this DROP fails due to database lock or error, does the table persist and cause CREATE TABLE failure on next invocation, permanently breaking witness payment processing?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [RAM cache poisoning] Lines 135-139 use storage.assocStableUnitsByMci[main_chain_index] - if an attacker can manipulate this RAM cache to add/remove units, can they cause different witness payment amounts to be calculated without detection (when conf.bFaster=true), leading to fund theft?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [Async.eachSeries ordering] The async.eachSeries at lines 141-195 processes units sequentially - but if unit order in RAM differs from database order (lines 136-139), can this cause non-deterministic execution order, leading to different paidWitnessEvents arrays and consensus divergence?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnessesForMainChainIndex()] [Global variable mutation] Line 140 sets 'paidWitnessEvents = []' which is a module-level global (line 13) - if buildPaidWitnessesForMainChainIndex() is called concurrently, can race conditions on this shared array cause payments to be assigned to wrong MCIs or witnesses?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: readMcUnitWitnesses()] [v4UpgradeMci boundary] At line 206, if main_chain_index >= constants.v4UpgradeMci, it uses storage.getOpList() which returns operators instead of witnesses - can units at exactly the v4UpgradeMci boundary be processed inconsistently across nodes that upgraded at slightly different times, causing consensus divergence?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: readMcUnitWitnesses()] [Witness list unit selection] Lines 208-218 select witness_list_unit from MC, using the unit itself if witness_list_unit is NULL (line 214) - can an attacker craft units with manipulated witness_list_unit references pointing to units with favorable witness lists to redirect witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: readMcUnitWitnesses()] [RAM inconsistency not caught in bFaster] Lines 215-216 check witness_list_unit consistency between DB and RAM, throwing if different - but this check is skipped when conf.bFaster=true (line 209-210) - can bFaster mode allow RAM corruption to go undetected, causing incorrect witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: readMcUnitWitnesses()] [Multiple MC units] The query at line 211 expects exactly 1 row with is_on_main_chain=1 (check at line 212) - but if database corruption causes multiple rows, the throw at line 213 crashes the entire witness payment process - can this be triggered intentionally to DoS the network?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: readMcUnitWitnesses()] [storage.readWitnessList() trust] Both code paths (lines 210 and 217) call storage.readWitnessList() without validating the returned witness array - can this function return invalid witness lists (wrong length, duplicate addresses, null values) that corrupt witness payment calculations?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Unit hash validation missing] The objUnitProps.unit at line 231 is used directly in database queries without validating it's a proper 44-character base64 unit hash - can passing malformed unit values cause SQL errors or injection attacks?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Integer overflow in to_main_chain_index] Line 232 calculates 'objUnitProps.main_chain_index + constants.COUNT_MC_BALLS_FOR_PAID_WITNESSING' - if main_chain_index is near MAX_SAFE_INTEGER, can this overflow, causing graph.readDescendantUnitsByAuthorsBeforeMcIndex() to query incorrect MCI ranges?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [strUnitsList SQL injection] Lines 239-240 construct strUnitsList by joining conn.escape(unit) - if arrUnits contains malicious strings that bypass escaping, can this enable SQL injection in the query at lines 242-250?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Empty arrUnits handling] When arrUnits.length === 0, strUnitsList is set to 'NULL' at line 239 - does the SQL query at lines 245-250 with 'WHERE unit IN(NULL)' return empty results or cause SQL error, and can this be exploited to skip witness payment processing?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Force index manipulation] Line 238 uses 'FORCE INDEX (PRIMARY)' for MySQL - can this query hint cause performance issues or incorrect results if the primary key structure changes, leading to DoS or payment calculation errors?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Address filtering bypass] The query at line 248 filters '+address IN(?)' using unary + operator - can this optimization bypass be exploited to include non-witness addresses in the results, allowing non-witnesses to receive witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Sequence check loose equality] Line 248 uses '+sequence='good'' with unary + - can units with sequence='temp-good' or numeric sequence values bypass this check through type coercion, allowing bad sequences to generate witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [RAM cache miss] Lines 257-259 throw Error if storage.assocStableUnits[_unit] is not found - but during network catchup or cache invalidation, can legitimate stable units be missing from cache, causing the witness payment process to crash?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Non-deterministic intersection] Line 260 uses _.intersection(unitProps.author_addresses, arrWitnesses) - if arrWitnesses contains duplicates or is in different order on different nodes, can this cause non-deterministic payment distribution?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Zero paid witnesses fallback] Lines 268-271 handle count_paid_witnesses === 0 by paying all witnesses equally - but does this accurately reflect the protocol's intention, or can attackers deliberately create units with no witness descendants to manipulate payment distribution?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Division of payload_commission] When count_paid_witnesses === 0 and all witnesses get paid equally (lines 268-271), the division of payload_commission by arrWitnesses.length at line 162 may differ from the division by actual paid witnesses - can this create payment amount mismatches?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Temporary table INSERT injection] Lines 280 constructs INSERT with arrValues joining escaped values - if escaping fails or values contain unexpected data, can SQL injection occur when inserting into paid_witness_events_tmp?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [Count mismatch between branches] The count_paid_witnesses is set to rows.length (line 267) or arrWitnesses.length (line 269) - can edge cases cause these counts to differ from what's later used in payment calculations at line 162, causing inflation/deflation?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [paidWitnessEvents array mutation] Lines 271 and 275 mutate the global paidWitnessEvents array with _.concat() - can concurrent executions or race conditions cause events to be duplicated or lost, leading to incorrect witness payment amounts?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: buildPaidWitnesses()] [updateCountPaidWitnesses not atomic] The function updateCountPaidWitnesses() at lines 224-229 updates balls.count_paid_witnesses separately from inserting witnessing_outputs - if the process crashes between these operations, can partial state cause witness payments to be recalculated incorrectly on restart?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: getMaxSpendableMciForLastBallMci()] [Integer underflow] The calculation at line 290 subtracts 'last_ball_mci - 1 - constants.COUNT_MC_BALLS_FOR_PAID_WITNESSING' - if last_ball_mci is less than (1 + COUNT_MC_BALLS_FOR_PAID_WITNESSING), can the result become negative, and how do callers handle negative max_spendable_mci values?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: getMaxSpendableMciForLastBallMci()] [Early network bootstrap] During initial network startup when last_ball_mci is very small (e.g., < 102), this function returns negative values - does updatePaidWitnesses() properly handle this at line 68, or can it attempt to process invalid MCI ranges?",
  "[File: byteball/ocore/paid_witnessing.js] [Function: getMaxSpendableMciForLastBallMci()] [Constant change impact] If constants.COUNT_MC_BALLS_FOR_PAID_WITNESSING changes via governance or fork, does this function's calculation remain consistent across nodes, or can different constants cause consensus divergence in which MCIs are considered spendable?",
  "[File: byteball/ocore/paid_witnessing.js] [Module-level] [paidWitnessEvents global state] The paidWitnessEvents array at line 13 is module-level global state that gets mutated - can multiple concurrent invocations of updatePaidWitnesses() cause race conditions where events from different MCIs get mixed together, corrupting witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Module-level] [et/rt global timing variables] Lines 134 and 221 declare 'var et, rt' globals used for timing measurements - can concurrent function invocations cause these timing variables to interfere with each other, and could manipulation of these affect payment calculations?",
  "[File: byteball/ocore/paid_witnessing.js] [Module-level] [throwError() behavior difference] The throwError() function at lines 293-300 either throws or emits 'nonfatal_error' depending on window existence - can the window-based branch in browser environments allow errors to be silently suppressed, causing consensus divergence between desktop and browser nodes?",
  "[File: byteball/ocore/paid_witnessing.js] [Cross-function] [Transaction isolation] None of the functions explicitly begin/commit database transactions - can partial updates during crashes leave the database in inconsistent state where some units have count_paid_witnesses set but no corresponding witnessing_outputs entries?",
  "[File: byteball/ocore/paid_witnessing.js] [Cross-function] [Callback error propagation] Most functions use callback-based error handling with callbacks.ifError() or throwing - can error propagation failures cause some errors to be silently ignored, allowing invalid states to persist?",
  "[File: byteball/ocore/paid_witnessing.js] [Cross-function] [Storage module dependency] Heavy reliance on storage.assocStableUnits and storage.assocStableUnitsByMci (lines 109, 135, 158, 208, 257) - if these caches become desynchronized from database state, can it cause systematic incorrect witness payments across multiple MCIs?",
  "[File: byteball/ocore/paid_witnessing.js] [Cross-function] [graph.readDescendantUnitsByAuthorsBeforeMcIndex dependency] Line 235 calls this graph traversal function - if it has bugs returning incorrect descendant sets, can witnesses be systematically underpaid or overpaid, accumulating to significant fund loss over time?",
  "[File: byteball/ocore/paid_witnessing.js] [Cross-function] [mc_outputs.calcEarnings dependency] Line 22 delegates earnings calculation to mc_outputs module - if that module has vulnerabilities (overflow, rounding errors, SQL injection), can they be exploited through the calcWitnessEarnings() wrapper to steal witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Database] [Witnessing_outputs integrity] The INSERT at lines 169-179 adds witnessing_outputs rows - if database crashes after insert but before count_paid_witnesses update at line 225, can witnesses claim the same payments twice on recovery?",
  "[File: byteball/ocore/paid_witnessing.js] [Database] [Foreign key constraints] The witnessing_outputs table is populated without explicit foreign key checks - if referenced units or addresses become invalid, can orphaned payment records corrupt the earnings calculation system?",
  "[File: byteball/ocore/paid_witnessing.js] [Database] [Duplicate payment prevention] Is there a unique constraint on (main_chain_index, address) in witnessing_outputs? If buildPaidWitnessesForMainChainIndex() runs twice for same MCI, can it create duplicate payment records, inflating witness earnings?",
  "[File: byteball/ocore/paid_witnessing.js] [Database] [Index coverage] The queries at lines 17, 55, 76, 104, 132, 170, 211 rely on database indexes - if indexes are missing or corrupted, can query performance degrade to point of causing network freeze (Medium severity - 1 hour delay)?",
  "[File: byteball/ocore/paid_witnessing.js] [Database] [Connection pool exhaustion] Multiple nested queries (e.g., lines 103-196) hold database connections - can deep nesting or concurrent executions exhaust the connection pool, causing deadlocks that freeze witness payment processing?",
  "[File: byteball/ocore/paid_witnessing.js] [Database] [SQLite vs MySQL differences] The code has SQLite-specific (line 74 'CROSS') and MySQL-specific (line 238 'FORCE INDEX') optimizations - can behavioral differences between databases cause non-deterministic witness payment amounts, leading to consensus failure?",
  "[File: byteball/ocore/paid_witnessing.js] [Database] [Temporary table persistence] If process crashes while temporary table paid_witness_events_tmp exists (created at line 128), does it persist across restarts causing CREATE TABLE to fail and permanently break witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Database] [cquery vs query inconsistency] The code uses both conn.query() and conn.cquery() - if these have different transaction semantics or error handling, can mixing them cause consistency issues in witness payment processing?",
  "[File: byteball/ocore/paid_witnessing.js] [Concurrency] [Multiple updatePaidWitnesses() calls] If updatePaidWitnesses() is called concurrently from different event handlers (e.g., new stable unit notifications), can two executions process the same MCIs simultaneously, causing duplicate or conflicting witnessing_outputs entries?",
  "[File: byteball/ocore/paid_witnessing.js] [Concurrency] [RAM cache invalidation timing] If storage.assocStableUnits is modified while buildPaidWitnessesForMainChainIndex() iterates through units (lines 141-195), can iterator see partial/inconsistent state leading to incorrect payment calculations?",
  "[File: byteball/ocore/paid_witnessing.js] [Concurrency] [Last stable MCI advancement] Between readLastStableMcIndex() at line 65 and processing at lines 72-98, if last_stable_mci advances significantly, can the function process MCIs that are no longer at the stability boundary, violating the stability invariant?",
  "[File: byteball/ocore/paid_witnessing.js] [Concurrency] [buildPaidWitnesses() parallelization] Although async.eachSeries() at line 141 processes units sequentially, if buildPaidWitnesses() itself has async operations that overlap, can race conditions in paidWitnessEvents array cause payment mixing between units?",
  "[File: byteball/ocore/paid_witnessing.js] [Concurrency] [Database transaction isolation] Without explicit transaction BEGIN/COMMIT, can read-write conflicts between concurrent operations cause inconsistent reads, where stability checks pass but unit state has changed?",
  "[File: byteball/ocore/paid_witnessing.js] [Consensus] [Floating-point precision] Math.round() at line 162 can have platform-dependent precision - can different hardware (x86 vs ARM) or JavaScript engines (Node.js vs browser) produce different rounding results, causing nodes to calculate different witness payment amounts?",
  "[File: byteball/ocore/paid_witnessing.js] [Consensus] [Array ordering non-determinism] Lines 109-113, 135-139, 183-186 compare arrays using _.isEqual() which is order-sensitive - if database query result ordering differs between nodes (different DB versions, locale settings), can this cause throwError() on some nodes but not others, creating chain split?",
  "[File: byteball/ocore/paid_witnessing.js] [Consensus] [conf.bFaster mode divergence] Lines 114, 121, 136, 142, 168, 209, 262, 264 have different code paths based on conf.bFaster flag - if nodes have different configurations, can they calculate different witness payments, leading to consensus failure?",
  "[File: byteball/ocore/paid_witnessing.js] [Consensus] [Timestamp dependencies] The profiler calls (e.g., lines 64, 66, 73, 124) use Date.now() for timing - while this shouldn't affect payments, can any logic accidentally depend on timing, causing non-deterministic behavior?",
  "[File: byteball/ocore/paid_witnessing.js] [Consensus] [Lodash library version differences] Heavy use of Lodash functions (_.countBy, _.reduce, _.map, etc.) - can different Lodash versions on different nodes produce different results for edge cases, causing consensus divergence?",
  "[File: byteball/ocore/paid_witnessing.js] [Consensus] [Database collation differences] The queries at lines 245-250 compare addresses - if database collations differ between nodes (case-sensitive vs case-insensitive), can witness filtering produce different results?",
  "[File: byteball/ocore/paid_witnessing.js] [Validation] [arrWitnesses validation missing] The arrWitnesses parameter in buildPaidWitnesses() (line 222) and multiple other functions is used directly without validating array length = 12 or that addresses are valid - can passing invalid witness arrays corrupt witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Validation] [objUnitProps validation] The objUnitProps parameter in buildPaidWitnesses() (line 222) is assumed to have .unit and .main_chain_index properties - can passing malformed objects cause undefined behavior or crashes?",
  "[File: byteball/ocore/paid_witnessing.js] [Validation] [MCI value range] Main_chain_index values are used without validation - can negative MCIs, MCIs exceeding current network state, or non-integer MCIs cause SQL errors or incorrect calculations?",
  "[File: byteball/ocore/paid_witnessing.js] [Validation] [Address format validation] Addresses used in queries (lines 22, 157, 169, 248) are not validated for proper length (32 chars) or character set - can malformed addresses cause SQL errors or security issues?",
  "[File: byteball/ocore/paid_witnessing.js] [Validation] [Type parameter in calcWitnessEarnings] The 'type' parameter (line 15) is passed to mc_outputs.calcEarnings() without validation - can arbitrary type strings access unintended database tables or cause errors?",
  "[File: byteball/ocore/paid_witnessing.js] [Payment correctness] [Rounding loss accumulation] Using Math.round() at line 162 for each unit's payment can accumulate rounding errors - over millions of units, can the total paid differ significantly from total payload_commission, creating inflation or deflation in witness rewards?",
  "[File: byteball/ocore/paid_witnessing.js] [Payment correctness] [Zero payload_commission units] If a unit has payload_commission = 0, line 162 calculates 0 / count_paid_witnesses = 0 - but does the witnessing_outputs table still get entries, and can empty entries accumulate causing storage bloat?",
  "[File: byteball/ocore/paid_witnessing.js] [Payment correctness] [Negative payload_commission] Can corrupted or malicious units have negative payload_commission values? If so, does line 162 create negative witness payments that could drain the witnessing_outputs table?",
  "[File: byteball/ocore/paid_witnessing.js] [Payment correctness] [Count_paid_witnesses overflow] If count_paid_witnesses becomes very large (e.g., database corruption), can the division at line 162 produce near-zero or zero amounts, effectively stealing witness payments?",
  "[File: byteball/ocore/paid_witnessing.js] [Payment correctness] [Payload_commission overflow] If payload_commission values are near Number.MAX_SAFE_INTEGER, can the division at line 162 lose precision, causing incorrect payment amounts?",
  "[File: byteball/ocore/paid_witnessing.js] [Payment correctness] [Equal distribution fairness] When count_paid_witnesses === 0 (lines 268-271), all witnesses get paid equally regardless of their actual network contribution - can attackers deliberately create units with no witness descendants to manipulate payment distribution unfairly?",
  "[File: byteball/ocore/paid_witnessing.js] [Payment correctness] [Double payment risk] If count_paid_witnesses in balls table is set but witnessing_outputs insert fails (e.g., constraint violation), can the unit be reprocessed, causing witnesses to be paid twice for the same unit?",
  "[File: byteball/ocore/paid_witnessing.js] [Payment correctness] [Witness eligibility timing] If a witness address becomes disqualified between when buildPaidWitnesses() queries descendants (line 235) and when payments are calculated (line 162), can ineligible witnesses still receive payments?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnits()] [Witness compatibility bypass] In the query at line 22-31 that selects free units with matching witnesses, can an attacker flood the network with units that have exactly COUNT_WITNESSES - MAX_WITNESS_LIST_MUTATIONS matching witnesses but are on incompatible witness lists, causing legitimate transactions to select incompatible parents and create a permanent chain split?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnits()] [Version/alt network attack] At lines 35-36, if an attacker manages to get a unit with unsupported version or wrong alt value stored in the database with sequence='good' and is_free=1, does the 'wrong network' error cause all subsequent parent selection attempts to fail, leading to network-wide transaction halt?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnits()] [Timestamp manipulation] At lines 20-21, the timestamp condition 'timestamp<=' is only applied when storage.getMinRetrievableMci() >= constants.timestampUpgradeMci. Can an attacker submit units with future timestamps before this upgrade point to bypass timestamp checks and cause units to reference parents that shouldn't be reachable, breaking temporal ordering?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnits()] [Archived joint bypass] At line 30, archived joints are excluded with 'archived_joints.unit IS NULL'. If an attacker can cause a unit to be archived and then received again without proper cleanup, can this unit be selected as a parent despite being archived, potentially causing consensus issues when other nodes reject it?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnits()] [Empty parent set] At lines 39-40, if all free units have count_matching_witnesses < count_required_matches, the function calls pickDeepParentUnits. Can an attacker deliberately create many incompatible free units to force all nodes to pick deep parents simultaneously, causing a network-wide slowdown (Medium severity: 1+ day delay)?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnits()] [Race condition in witness counting] The subquery at lines 25-27 counts matching witnesses. If witness_list_unit is being modified concurrently for a unit, can this cause non-deterministic witness counts across different nodes, leading to different parent selection decisions and a chain split?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnits()] [SQL injection via witness list] At line 33, arrWitnesses is passed directly to the SQL query. If arrWitnesses contains maliciously crafted address strings (e.g., with SQL metacharacters), can this cause SQL injection or query errors that prevent parent selection?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnits()] [Index hint manipulation] At line 29, the query uses 'INDEXED BY byFree' for SQLite. If this index is corrupted or missing, does the query fail silently or return incorrect results, causing nodes to select invalid parents?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustParentsToNotRetreatWitnessedLevel()] [Infinite loop] At lines 87-88, if arrExcludedUnits.length === 0 after iterations > 0, an error is thrown to prevent infinite cycles. However, can an attacker craft a DAG structure where arrExcludedUnits never becomes empty but the function keeps iterating indefinitely, causing a DoS?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustParentsToNotRetreatWitnessedLevel()] [MAX_PARENT_DEPTH bypass] At lines 89-90, if iterations >= conf.MAX_PARENT_DEPTH, an error is returned. Can an attacker set conf.MAX_PARENT_DEPTH to an extremely high value or null through configuration manipulation, allowing infinite loops that halt transaction processing?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustParentsToNotRetreatWitnessedLevel()] [Empty parent set error] At lines 77-78, if arrNewParents.length === 0, the function throws an error. Can this occur in legitimate scenarios where all parents must be excluded, causing valid transactions to fail permanently and potentially freezing funds if no alternative parent set exists?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustParentsToNotRetreatWitnessedLevel()] [replaceExcludedParent() race condition] At lines 54-83, replaceExcludedParent performs multiple database queries. If units are being added/removed from the database concurrently, can this cause arrCandidateReplacements or arrReplacementParents to include invalid units, leading to consensus divergence?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustParentsToNotRetreatWitnessedLevel()] [Parent replacement consistency] At lines 62-82, when replacing an excluded parent with its parents, the logic excludes candidates that have other children. Can an attacker create a specific DAG topology where this exclusion logic removes all valid replacement candidates, causing the function to throw an error and halt transaction creation?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustParentsToNotRetreatWitnessedLevel()] [Best parent manipulation] At lines 93-101, if arrCurrentParentUnits.length <= MAX_PARENTS_PER_UNIT, parents are returned immediately. Otherwise, best_parent_unit is moved to position 0 and the list is sliced. Can an attacker craft parents where the best_parent_unit changes between determineWitnessedLevels calls, causing non-deterministic parent ordering across nodes?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustParentsToNotRetreatWitnessedLevel()] [Witnessed level retreat detection] At lines 93-95, the function checks if child_witnessed_level >= max_parent_wl. If this condition passes but best_parent_unit is null, does the function return successfully with inconsistent state, potentially allowing witnessed level retreat?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustParentsToNotRetreatWitnessedLevel()] [SQL string escaping] At line 67, arrExcludedUnits is mapped through db.escape and joined. If db.escape has a bug or doesn't handle certain edge cases, can malicious unit hashes in arrExcludedUnits cause SQL injection or query errors?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustParentsToNotRetreatWitnessedLevel()] [Concurrent modification] At line 60, arrExcludedUnits is concatenated with arrNewExcludedUnits. If multiple threads/processes call this function concurrently with overlapping parent sets, can arrExcludedUnits become corrupted, leading to incorrect parent replacement decisions?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsUnderWitnessedLevel()] [Timestamp bypass] At lines 114-115, the timestamp condition is only applied if storage.getMinRetrievableMci() >= constants.timestampUpgradeMci. Can units with future timestamps be selected as parents before this upgrade, allowing attackers to manipulate parent selection timing?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsUnderWitnessedLevel()] [Witnessed level boundary] At line 119, units with witnessed_level < max_wl are selected. Can an attacker create units with witnessed_level exactly equal to max_wl - 1 and flood the database, causing this query to return attacker-controlled parents exclusively?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsUnderWitnessedLevel()] [Empty result set] At lines 128-129, if rows.length === 0, pickDeepParentUnits is called. Can an attacker create a scenario where no free units exist under max_wl but deep parent selection also fails, causing an infinite recursion or transaction failure?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsUnderWitnessedLevel()] [Witness compatibility count] At line 126, the query requires COUNT_WITNESSES - MAX_WITNESS_LIST_MUTATIONS matching witnesses. Can an attacker exploit the exact boundary condition by creating units with exactly this many matching witnesses but incompatible overall witness lists?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsUnderWitnessedLevel()] [ORDER BY manipulation] At line 125, results are ordered by 'witnessed_level DESC, level DESC'. Can an attacker flood the database with units at specific witnessed_level and level values to manipulate which units get selected as parents, potentially causing all nodes to select the same attacker-controlled parents?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsUnderWitnessedLevel()] [LIMIT bypass] At line 125, results are limited to MAX_PARENTS_PER_UNIT. If MAX_PARENTS_PER_UNIT is set to 1 in configuration, does this force all units to have single parents, breaking the DAG structure and potentially causing chain split?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickDeepParentUnits()] [Main chain requirement] At line 143, when max_wl is not null, the query requires 'is_on_main_chain=1'. Can an attacker cause the main chain determination to be delayed or incorrect, making this query return no results and causing pickDeepParentUnits to fail repeatedly?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickDeepParentUnits()] [No deep units error] At lines 158-159, if no compatible deep units are found, an error 'failed to find compatible parents: no deep units' is returned. Can an attacker create a situation where all compatible deep units are archived or invalidated, causing all new transactions to fail permanently (Critical severity: network shutdown)?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickDeepParentUnits()] [Latest included MC index ordering] At line 155, results are ordered by 'latest_included_mc_index DESC LIMIT 1'. Can an attacker manipulate latest_included_mc_index values to control which deep unit gets selected, potentially causing nodes to select different deep parents based on database state timing?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickDeepParentUnits()] [Single parent vulnerability] At lines 160-161, pickDeepParentUnits returns a single parent unit. Can forcing all units to use a single deep parent create a bottleneck where all transactions must reference the same parent, slowing confirmation times (Medium severity: 1+ hour delay)?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickDeepParentUnits()] [Timestamp condition consistency] At lines 144-145, the timestamp condition is only applied if bWithTimestamp is true. Can nodes with different storage.getMinRetrievableMci() values select different deep parents, causing a chain split?",
  "[File: byteball/ocore/parent_composer.js] [Function: determineWitnessedLevels()] [Best parent race condition] At lines 168-181, storage.determineWitnessedLevelAndBestParent is called followed by a query for max witnessed_level. If units are being added concurrently, can best_parent_unit become outdated between these calls, causing incorrect parent_with_max_wl selection?",
  "[File: byteball/ocore/parent_composer.js] [Function: determineWitnessedLevels()] [No best parent handling] At lines 175-176, if best_parent_unit is null, handleResult is called without it. Can this null value propagate through subsequent logic and cause errors or incorrect witnessed level comparisons?",
  "[File: byteball/ocore/parent_composer.js] [Function: determineWitnessedLevels()] [Witnessed level consistency] At lines 177-180, if bestParentProps.witnessed_level equals max_parent_wl, parent_with_max_wl is updated. Can a race condition cause bestParentProps to be stale, leading to incorrect parent_with_max_wl identification and witnessed level retreat?",
  "[File: byteball/ocore/parent_composer.js] [Function: determineWitnessedLevels()] [Version parameter] At line 168, constants.version3 is passed to determineWitnessedLevelAndBestParent. If different nodes use different version constants due to upgrade timing, can this cause different witnessed level calculations and chain split?",
  "[File: byteball/ocore/parent_composer.js] [Function: determineWitnessedLevels()] [Multiple parents with max WL] At lines 170-174, the query selects the unit with maximum witnessed_level. If multiple parents have the same max witnessed_level, which one is selected, and can this cause non-deterministic parent ordering across nodes?",
  "[File: byteball/ocore/parent_composer.js] [Function: checkWitnessedLevelNotRetreatingAndLookLower()] [Hub early exit] At lines 196-197, if conf.bServeAsHub is true, the function returns an error immediately without retrying. Can attackers exploit this by sending malicious requests to hubs, causing hubs to fail parent selection for legitimate users?",
  "[File: byteball/ocore/parent_composer.js] [Function: checkWitnessedLevelNotRetreatingAndLookLower()] [Retry logic divergence] At lines 198-200, bRetryDeeper determines whether to call pickDeepParentUnits or pickParentUnitsUnderWitnessedLevel. Can this boolean flag be in different states on different nodes due to timing, causing nodes to select different parent sets?",
  "[File: byteball/ocore/parent_composer.js] [Function: checkWitnessedLevelNotRetreatingAndLookLower()] [No best parent scenario] At line 194, if best_parent_unit is null, the error message says 'no best parent'. Can this occur in legitimate scenarios, and does it cause permanent transaction failure for certain DAG topologies?",
  "[File: byteball/ocore/parent_composer.js] [Function: checkWitnessedLevelNotRetreatingAndLookLower()] [Witnessed level retreat message] At lines 192-195, the function checks if child_witnessed_level >= max_parent_wl. If this check fails multiple times, can the repeated 'will look for older parents' messages lead to infinite recursion between this function and pickDeepParentUnits/pickParentUnitsUnderWitnessedLevel?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastStableMcBall()] [bAdvanceLastStableUnit flag] At line 209, the comparison operator is '>=' if bAdvanceLastStableUnit is true, '=' otherwise. Can inconsistent values of this constant across nodes cause different last stable ball selection, leading to chain split?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastStableMcBall()] [No stable ball found] At lines 220-221, if no stable ball is found, the error 'failed to find last stable ball' is returned. Can an attacker manipulate the witness list or max_parent_last_ball_mci to make this condition always true, preventing all new transactions (Critical severity: network halt)?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastStableMcBall()] [Witness count requirement] At line 218, the query requires COUNT_WITNESSES - MAX_WITNESS_LIST_MUTATIONS matching witnesses. Can an attacker exploit witness list mutations to make no stable MC units meet this requirement, causing findLastStableMcBall to fail?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastStableMcBall()] [IFNULL latest_included_mc_index] At line 210, IFNULL returns 0 if no unit in arrParentUnits has latest_included_mc_index. Can this cause the query to return a very old stable ball when it should fail, leading to incorrect last ball selection?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastStableMcBall()] [ORDER BY DESC with LIMIT 1] At line 216, the query orders by main_chain_index DESC and limits to 1. If multiple units have the same max main_chain_index, which one is selected, and can this cause non-deterministic last ball selection?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastStableMcBall()] [Max parent last ball MCI] At line 205, storage.readMaxLastBallMci is called. If this function has a race condition or returns stale data, can it cause findLastStableMcBall to select an inconsistent last stable ball across nodes?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustLastStableMcBallAndParents()] [Stability check race condition] At line 230, main_chain.determineIfStableInLaterUnitsWithMaxLastBallMciFastPath checks if last_stable_mc_ball_unit is stable. If stability changes between this check and the subsequent ball query, can this cause incorrect last ball selection?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustLastStableMcBallAndParents()] [Not 1 ball by unit error] At lines 234-235, if rows.length !== 1, an error is thrown. Can a unit have multiple balls due to database corruption, or zero balls if the ball hasn't been created yet, causing this function to fail?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustLastStableMcBallAndParents()] [Recursive adjustment infinite loop] At line 256, the function recursively calls itself with next_last_ball_unit. Can an attacker craft a DAG where this recursion never terminates, causing stack overflow or infinite loop (Critical severity: network halt)?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustLastStableMcBallAndParents()] [Best parent not found] At lines 251-252, if objUnitProps.best_parent_unit is null, an error is thrown. Can legitimate genesis units or units with special properties lack a best parent, causing this function to fail for valid transactions?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustLastStableMcBallAndParents()] [Graph inclusion check] At line 254, graph.determineIfIncluded checks if next_last_ball_unit is included in arrParentUnits. If this function has a bug or race condition, can it return incorrect results, causing the adjustment logic to diverge across nodes?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustLastStableMcBallAndParents()] [Parent last ball unit ordering] At lines 258-268, the function queries for the parent unit with the highest last_ball_unit main_chain_index. Can multiple parents have the same main_chain_index, causing non-deterministic next_last_ball_unit selection?",
  "[File: byteball/ocore/parent_composer.js] [Function: adjustLastStableMcBallAndParents()] [Commented out single parent selection] At lines 242-249, there's commented-out code for selecting only one parent. If this code is uncommented in production, can it break multi-parent DAG structure and cause consensus issues?",
  "[File: byteball/ocore/parent_composer.js] [Function: trimParentList()] [Single parent bypass] At lines 276-277, if arrParentUnits.length === 1, the function returns immediately without trimming. Can an attacker force all transactions to have single parents by manipulating the parent selection logic earlier, breaking DAG structure?",
  "[File: byteball/ocore/parent_composer.js] [Function: trimParentList()] [AA address filtering] At lines 282-284, AA addresses with latest_included_mc_index > last_stable_mci are excluded from trimming. Can an attacker create many AA addresses to prevent certain parents from being trimmed, manipulating the final parent set?",
  "[File: byteball/ocore/parent_composer.js] [Function: trimParentList()] [Random ordering] At line 285, db.getRandom() is used for random ordering. If different database implementations return different random values for the same seed, can this cause non-deterministic parent trimming across nodes with different DB engines (SQLite vs MySQL)?",
  "[File: byteball/ocore/parent_composer.js] [Function: trimParentList()] [Witness address priority] At line 285, units authored by addresses in arrWitnesses are prioritized. Can an attacker who controls a witness address ensure their units are always included in the parent set, potentially manipulating confirmation times?",
  "[File: byteball/ocore/parent_composer.js] [Function: trimParentList()] [SQL escaping] At line 283, arrParentUnits is mapped through db.escape. If any parent unit hash contains SQL metacharacters, can this cause query errors or inconsistent trimming results?",
  "[File: byteball/ocore/parent_composer.js] [Function: trimParentList()] [Limit enforcement] At line 286, results are limited to MAX_PARENTS_PER_UNIT. If this constant is changed mid-operation, can different nodes trim to different parent counts, causing consensus divergence?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBallBeforeOpVote()] [Infinite depth loop] At lines 309-311, if depth > conf.MAX_PARENT_DEPTH, an error is returned. Can conf.MAX_PARENT_DEPTH be set to undefined or Infinity, allowing infinite recursion in pickParentsDeeper and causing a DoS?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBallBeforeOpVote()] [findLastBallAndAdjust error handling] At lines 300-302, if findLastBallAndAdjust returns an error, pickParentsDeeper is called. Can this error condition be triggered repeatedly, causing the function to dig deeper indefinitely until MAX_PARENT_DEPTH is reached?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBallBeforeOpVote()] [Nested callback race condition] The function uses nested callbacks at lines 296-306 and 312-322. Can concurrent calls to this function with overlapping parent selections cause race conditions in the shared depth counter or database state?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBallBeforeOpVote()] [Secondary pickParentsDeeper] At lines 317-318, a secondary call to pickParentsDeeper can occur if the first deep parent selection fails. Can an attacker create conditions where this secondary call always fails, causing legitimate transactions to never find suitable parents?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastBallAndAdjust()] [Witness list unit determination] At line 335, storage.findWitnessListUnit is called to determine the witness_list_unit. Can this function return different results on different nodes due to timing, causing objFakeUnit to have different witness_list_unit values and leading to chain split?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastBallAndAdjust()] [Fake unit construction] At lines 336-338, a fake unit objFakeUnit is constructed with parent_units and optional witness_list_unit. Can this fake unit fail validation in storage.determineIfHasWitnessListMutationsAlongMc if the constructed object doesn't match real unit structure?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastBallAndAdjust()] [Version constant] At line 336, constants.version3 is hardcoded. If nodes are running different versions and use different version constants, can this cause different witness list mutation checking results?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastBallAndAdjust()] [Witness list mutations error] At lines 340-342, if determineIfHasWitnessListMutationsAlongMc returns an error, it's propagated. Can an attacker craft a DAG topology where witness list mutations are detected incorrectly, causing valid transactions to be rejected?",
  "[File: byteball/ocore/parent_composer.js] [Function: findLastBallAndAdjust()] [Nested function call chain] This function calls findLastStableMcBall  adjustLastStableMcBallAndParents  trimParentList  findWitnessListUnit  determineIfHasWitnessListMutationsAlongMc. Can errors in any of these nested calls propagate incorrectly, causing transaction failures?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [Promise wrapper race condition] At lines 354-362, if onDone is not provided, a Promise wrapper is created. Can concurrent calls with and without callbacks cause race conditions in the shared database connection?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [No usable free units] At lines 376-377, if prows.length === 0, the error 'no usable free units' is returned. Can an attacker flood the database with archived or invalid units, causing this condition to always be true and preventing all new transactions (Critical severity: network halt)?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [All AA responses] At lines 378-379, if all free units are AA responses, the error 'no usable non-AA free units' is returned. Can an attacker trigger many AA responses to fill the free unit pool, preventing normal users from creating transactions?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [v4 upgrade boundary] At lines 381-382, if max_parent_last_ball_mci < constants.v4UpgradeMci, the old parent selection logic is used. Can nodes with different cached values of v4UpgradeMci select parents using different algorithms, causing chain split?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [TPS fee filtering] At line 383, filterParentsByTpsFeeAndReplace is called asynchronously. Can this async operation complete in different orders on different nodes, causing non-deterministic parent selection?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [Last ball info failure] At lines 386-388, if lb (last ball info) is null after getLastBallInfo, the function tries a subset of parents. Can this fallback logic cause different nodes to select different parent subsets based on timing?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [OP list comparison] At lines 391-398, uniform_prows are selected based on having the same OP list as the top parent. Can nodes with different cached OP lists (storage.getOpList) select different parent sets, causing chain split?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [Empty uniform prows] At lines 399-400, if uniform_prows.length === 0, an error is thrown. Can this occur in legitimate scenarios where OP lists change frequently, causing transaction failures?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [OP list unchanged] At lines 410-412, if prev_ops equals top_ops (OP list didn't change), an error is returned. Can an attacker prevent OP list changes to make this condition always true, blocking all transactions?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [Older OP list filtering] At lines 414-416, filterParentsWithOlderOpListAndReplace is called to find parents with older OP lists. Can this cause all nodes to revert to older parents simultaneously, slowing network confirmation times (Medium severity: 1+ hour delay)?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [AA response timestamp filter] At line 368, AA responses created within the last 30 seconds are excluded. Can attackers exploit this timing window to create many recent AA responses that prevent valid parent selection?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [ORDER BY last_ball_mci DESC] At line 369, results are ordered by last_ball_mci DESC. Can an attacker manipulate last_ball_mci values to control which units are selected as parents?",
  "[File: byteball/ocore/parent_composer.js] [Function: pickParentUnitsAndLastBall()] [LIMIT MAX_PARENTS_PER_UNIT] At line 372, the query is limited to MAX_PARENTS_PER_UNIT candidates. If many units have the same last_ball_mci, which ones are selected, and can this cause non-deterministic parent selection?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsByTpsFeeAndReplace()] [TPS fee bypass via from addresses] At lines 444-447, if a low-fee parent is authored by one of arrFromAddresses, it's included anyway. Can an attacker monitor arrFromAddresses and create units from those addresses to bypass TPS fee requirements?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsByTpsFeeAndReplace()] [Recursive filtering loop] At lines 456-457, if new parents are added by replaceParents, the function recursively calls itself. Can an attacker create a DAG structure where this recursion never terminates, causing stack overflow?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsByTpsFeeAndReplace()] [All parents underpay] At lines 459-460, if filtered_prows.length === 0, an error is thrown. Can an attacker ensure all potential parents underpay TPS fees, preventing legitimate transactions from finding valid parents?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsByTpsFeeAndReplace()] [TPS fee calculation race] At lines 437-440, paid_tps_fee and count_units are read from storage. Can concurrent updates to TPS fee state cause different nodes to calculate different paid_tps_fee_per_unit values, leading to different parent filtering decisions?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsByTpsFeeAndReplace()] [AA response exemption] At lines 433-436, AA responses are automatically included without TPS fee checks. Can an attacker create many AA responses to flood the parent pool and bypass TPS fee requirements?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsByTpsFeeAndReplace()] [Min parentable multiplier] At lines 427-428, min_parentable_tps_fee_multiplier defaults to 3 if not configured. Can nodes with different multiplier configurations select different parent sets, causing consensus divergence?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsByTpsFeeAndReplace()] [getCurrentTpsFee timing] At line 426, storage.getCurrentTpsFee() is called. If this function returns different values on different nodes due to timing or state differences, can it cause different parent filtering results?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsWithOlderOpListAndReplace()] [AA response skipping] At lines 470-473, AA responses are skipped in this filter. Can this cause all parents to be excluded if the free unit pool is dominated by AA responses, leading to transaction failure?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsWithOlderOpListAndReplace()] [OP list comparison] At line 474, the OP list is compared with top_ops. If storage.getOpList returns different results on different nodes, can this cause different parent filtering and chain split?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsWithOlderOpListAndReplace()] [From addresses bypass] At lines 479-482, units from arrFromAddresses are included even if their OP list equals top_ops. Can an attacker exploit this by controlling addresses in arrFromAddresses?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsWithOlderOpListAndReplace()] [All parents have top OP list] At lines 494-495, if filtered_prows.length === 0, an error is thrown. Can a scenario where all parents have the new OP list cause legitimate transactions to fail?",
  "[File: byteball/ocore/parent_composer.js] [Function: filterParentsWithOlderOpListAndReplace()] [Recursive replacement] At lines 490-492, if new parents are added, the function recursively calls itself. Can an attacker create conditions where this recursion continues indefinitely?",
  "[File: byteball/ocore/parent_composer.js] [Function: replaceParents()] [Max parent LIMCI calculation] At line 500, max_parent_limci is calculated from filtered_prows or defaults to -1. Can this -1 default value cause the subsequent query to return all units in the database, leading to performance issues or incorrect replacement parents?",
  "[File: byteball/ocore/parent_composer.js] [Function: replaceParents()] [Inclusion check loop] At lines 509-518, for each replacement parent, graph.determineIfIncludedOrEqual is called. Can this loop be exploited to cause O(n) complexity if many replacement parents exist, causing DoS?",
  "[File: byteball/ocore/parent_composer.js] [Function: replaceParents()] [Other parents calculation] At line 511, other_parents is calculated by concatenating filtered_prows units and remaining replacement parents. Can this array become very large if many replacements exist, causing memory issues?",
  "[File: byteball/ocore/parent_composer.js] [Function: replaceParents()] [Replacement parent query] At lines 501-506, the query finds parent units of excluded parents. Can this query return duplicate parents if multiple excluded parents share the same parent, and does this cause issues in subsequent logic?",
  "[File: byteball/ocore/parent_composer.js] [Function: replaceParents()] [Units not on main chain] At line 504, the query includes units where 'main_chain_index IS NULL OR main_chain_index > max_parent_limci'. Can including non-MC units as replacement parents cause consensus issues?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Input validation bypass] If arrPrivateElements is an empty array [], the isNonemptyArray check at line 24 will fail, but what happens if an attacker passes an array with a single null or undefined element - can this bypass validation and reach asset reading logic, potentially causing downstream crashes or undefined behavior in divisibleAsset/indivisibleAsset modules?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset type confusion] At lines 39-40, the code checks if objAsset.fixed_denominations matches the presence of headElement.payload.denomination - if an attacker crafts a private payment with denomination field present for a divisible asset (or absent for indivisible), can they bypass this check by manipulating the payload structure before it reaches this validation, causing the wrong asset module (divisible vs indivisible) to process the payment at line 76-77?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Missing message_index validation] At line 32-33, only non-negative integer validation is performed on message_index, but there's no upper bound check - can an attacker supply an extremely large message_index value (e.g., 2^31-1) that could cause integer overflow in downstream SQL queries at lines 58-64 or in the asset-specific validation modules, potentially corrupting the outputs table or causing database errors?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Missing output_index validation] At lines 61-64, output_index validation only checks isNonnegativeInteger for fixed_denominations assets - can an attacker provide an extremely large output_index value that exceeds the actual number of outputs in the unit, causing the SQL query to insert invalid references into the outputs table and potentially enabling double-spend by referencing non-existent outputs?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Null/undefined asset] If headElement.payload.asset is explicitly set to null or undefined (bypassing line 30 check somehow), will the storage.readAsset() call at line 36 handle this gracefully, or could it cause the callback to never fire, resulting in a connection leak when db.takeConnectionFromPool() at line 41 never releases the connection?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Race condition on duplicate detection] At lines 58-74, the duplicate detection query checks if an output already exists, then inserts if not - if two identical private payment chains arrive simultaneously from different peers and both execute this code concurrently, can both pass the SELECT check before either INSERT commits, causing duplicate outputs to be stored and enabling a double-spend of the same private payment?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Transaction rollback failure] At lines 45-48, if conn.query('ROLLBACK') fails due to connection loss or database error, the connection is still released at line 46 without verifying the rollback succeeded - can this leave the database in a partially committed state where some outputs/inputs from the private payment chain are stored but not all, causing permanent inconsistency and potential fund loss?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Connection leak on error] If the asset-specific validateAndSavePrivatePaymentChain() call at line 77 throws an exception instead of calling transaction_callbacks.ifError(), the connection obtained at line 41 will never be released (no conn.release() in catch block), potentially exhausting the connection pool and causing network-wide transaction processing delays exceeding 1 day?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Non-atomic commit/callback] At lines 51-54, callbacks.ifOk() is called inside the COMMIT callback - if the COMMIT succeeds but callbacks.ifOk() triggers an exception (e.g., in event emission code), is the connection still released properly, or could this cause the connection to be returned to the pool in an undefined transaction state, corrupting subsequent queries?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Nested transaction BEGIN without check] Line 42 executes BEGIN unconditionally after taking a connection from the pool - if the connection was already in a transaction state (due to connection pool bug or improper release), can this cause nested transaction errors that crash the validation process and prevent all private payments from being processed, causing temporary network freeze?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Duplicate detection bypass via NULL address] At lines 72-74, the code considers an output duplicate only if rows[0].address is truthy - if an attacker can somehow cause a NULL address to be stored in the outputs table for their private payment, can they then send the same private payment again and bypass the duplicate check, enabling unlimited double-spends?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Incomplete duplicate check for divisible assets] At lines 58-64, the duplicate detection query for divisible assets (non-fixed_denominations) does not include output_index in the WHERE clause - if a single unit/message has multiple outputs, can an attacker replay the same private payment chain multiple times, each time revealing a different output_index, and have all of them accepted as non-duplicates, inflating the asset supply?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Multiple rows exception] At lines 70-71, if more than one row is returned from the duplicate check query, an Error is thrown but not caught - can an attacker intentionally corrupt the database state to create duplicate outputs that trigger this condition, causing all subsequent private payment validations to crash and freeze private payment processing network-wide?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Early return on duplicate without proper cleanup] At line 74, if a duplicate is detected, transaction_callbacks.ifOk() is called directly without rolling back the transaction started at line 42 - does this mean the transaction is committed even though no work was done, potentially causing issues if the connection is reused with uncommitted state, or leading to deadlocks in high-concurrency scenarios?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset module selection timing attack] At line 76, assetModule is selected based on objAsset.fixed_denominations, then line 77 calls its validateAndSavePrivatePaymentChain() - if objAsset data is cached and becomes stale (asset definition changed from divisible to indivisible), can this cause the wrong module to process the payment, leading to incorrect output format in database (amount+blinding vs denomination+output_hash) and permanent corruption of asset balance tracking?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset module callback contract violation] The code assumes divisibleAsset and indivisibleAsset modules will call either transaction_callbacks.ifError or transaction_callbacks.ifOk exactly once - if a buggy or malicious asset module calls both callbacks, or neither, can this cause double-rollback/double-commit errors or connection leaks that accumulate over time and eventually halt all transaction processing?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset module exception propagation] If the asset-specific validateAndSavePrivatePaymentChain() at line 77 validates successfully but then throws an exception during the database write phase, will the transaction be rolled back properly by the BEGIN/ROLLBACK logic at lines 42-48, or could the exception bypass the rollback mechanism and leave partial writes in the outputs/inputs tables?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Light client premature validation] At lines 85-90, in light client mode (conf.bLight), if findUnfinishedPastUnitsOfPrivateChains returns an empty array (no unfinished units), validation proceeds immediately - can an attacker craft a private payment chain that references future units not yet received by the light client, bypass the waiting logic, and have the payment validated against incomplete DAG state, potentially accepting invalid payments?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Missing asset definition validation in light client] At line 14, the function adds the asset definition unit to assocUnits, but in light client mode, if this asset definition unit is not yet stable or not received, and filterNewOrUnstableUnits() at line 19 doesn't properly detect this, can the subsequent validateAndSave() proceed without having the asset definition, causing validation errors or accepting payments for undefined assets?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Light client vs full node inconsistency] Lines 85-90 implement different logic for light clients (checking unfinished units) vs full nodes (direct validation) - can this create a scenario where a private payment is accepted by light clients but rejected by full nodes, or vice versa, causing disagreement on valid asset balances and potential chain splits between light and full nodes?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [includeLatestElement parameter inconsistency] At line 15, the loop starts at index 0 if includeLatestElement is true, else 1 - however, at line 86, this function is called with includeLatestElement=false, skipping the head element - if the head element itself is unstable, will storage.filterNewOrUnstableUnits() still catch it via the asset definition check at line 14, or could unstable head elements be validated prematurely?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Asset definition unit ambiguity] At line 14, assocUnits[arrPrivateElements[0].payload.asset] = true treats the asset hash as a unit identifier - but asset is a hash of the asset definition unit, not the unit hash itself - does storage.filterNewOrUnstableUnits() at line 19 correctly interpret this as needing to check the asset definition unit's stability, or will it fail to find the unit and incorrectly return it as 'unfinished'?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Empty chain handling] If arrChains is an empty array, or all elements have empty arrPrivateElements, lines 13-17 will produce an empty assocUnits object - will storage.filterNewOrUnstableUnits([]) at line 19 handle an empty array correctly, or could it trigger database errors, undefined behavior, or bypass filtering and call handleUnits with unexpected results?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Duplicate unit handling across chains] If arrChains contains multiple chains that reference the same intermediate units (overlapping chains), lines 13-17 will add the same unit to assocUnits multiple times (last write wins) - can this cause storage.filterNewOrUnstableUnits() to behave incorrectly, or does the use of object keys handle this safely?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Missing validation of arrPrivateElements structure] The function iterates through arrPrivateElements at lines 15-16 without validating that each element has the required 'unit' property - if an attacker provides a chain with malformed elements (missing .unit), can this cause undefined values to be added to assocUnits and passed to storage.filterNewOrUnstableUnits(), potentially causing database query errors?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Unbounded assocUnits object] At lines 13-17, assocUnits is populated from all units in all chains without size limits - if an attacker sends a private payment chain with thousands of elements (or multiple chains), can they cause excessive memory allocation in the assocUnits object and the arrUnits array at line 18, potentially leading to out-of-memory errors and node crashes?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Storage.readAsset unbounded callback delay] At line 36, storage.readAsset() is called without timeout - if the storage layer is experiencing issues or the asset doesn't exist, can this callback never fire, causing the function to never return and the database connection at line 41 to remain held indefinitely, leading to connection pool exhaustion?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Nested callback stack overflow] The validation flow involves multiple nested callbacks: validateAndSave -> storage.readAsset -> db.takeConnectionFromPool -> conn.query -> asset module validation - if an attacker triggers deep recursion by crafting chains that reference each other, could this cause stack overflow and crash the node, preventing any private payments from being processed?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Missing headElement.payload null check] At line 27, the code checks if (!headElement.payload) and returns error, but at line 29, it immediately accesses headElement.payload.asset - if payload exists but is not an object (e.g., payload is a string or number), can this cause a TypeError that crashes the validation process and is not caught by the error handling at lines 44-48?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [storage.readAsset error not specific] At line 37, if storage.readAsset() returns an error, it's passed directly to callbacks.ifError() without context - if the error is due to asset not existing vs database error vs invalid asset format, can this cause the caller to handle all errors identically, potentially retrying non-retryable errors or not retrying transient errors, leading to lost private payments?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Undefined objAsset handling] If storage.readAsset() succeeds but objAsset is null/undefined (asset doesn't exist), line 39 will attempt to access objAsset.fixed_denominations, causing TypeError - is this caught by try/catch in the calling code, or will it crash the node and prevent all subsequent private payment processing?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [ifWaitingForChain callback missing implementation] At line 87, callbacks.ifWaitingForChain() is called but there's no corresponding implementation in the transaction_callbacks object defined at lines 43-56 - if the calling code doesn't provide this callback, will this cause an undefined function call error that crashes the private payment processing?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [SQL injection via unit/message_index] At lines 58-64, the SQL query uses parameterized queries with headElement.unit and headElement.message_index - however, if these values are not properly validated earlier (only isNonnegativeInteger check for message_index), could specially crafted values cause SQL injection, allowing an attacker to modify the query logic and bypass duplicate detection or corrupt the outputs table?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Dynamic SQL construction risk] The SQL query at line 58 is modified at line 63 by appending additional WHERE clauses - if objAsset.fixed_denominations is manipulated or incorrectly cached, can this cause the query to be constructed incorrectly (missing output_index check when needed, or including it when not), leading to false duplicate detection or allowing true duplicates to pass?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Non-deterministic validation order] The validation flow depends on storage.readAsset() which queries the database - if two nodes have different asset cache states or database query execution orders, could they validate the same private payment chain differently, causing some nodes to accept it while others reject it, leading to permanent chain split?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Light client conditional execution non-determinism] Lines 85-90 execute different code paths for conf.bLight vs full nodes - if a node's configuration changes (bLight toggled), can previously validated private payments become invalid or vice versa, causing the node to diverge from consensus and reject otherwise valid units, contributing to network partition?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Storage.filterNewOrUnstableUnits timing sensitivity] At line 19, storage.filterNewOrUnstableUnits() checks current unit stability - if this is called during a stability point transition (unit becoming stable), different nodes might get different results based on timing, causing some nodes to wait for the chain while others proceed with validation, potentially leading to divergent private payment acceptance?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Dependency on external module state] The code delegates to divisibleAsset or indivisibleAsset modules at line 77 - if these modules have their own internal state or caches that can become inconsistent with the database, can an attacker exploit this by sending private payments that are validated correctly by private_payment.js but fail in asset-specific validation, causing transaction_callbacks.ifError() to be called after the transaction BEGIN, and leaving the database transaction open?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Network.js integration - missing validation] This function is called from network.js without prior validation of the arrPrivateElements structure beyond the checks at lines 24-33 - can an attacker craft a malicious network message with a private payment chain that passes network.js validation but exploits weaknesses in the asset-specific modules, causing node crashes or database corruption?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Callback contract violation propagation] If the calling code (network.js or wallet.js) provides callbacks object that doesn't implement all three expected callbacks (ifError, ifOk, ifWaitingForChain), but private_payment.js doesn't validate this, can calling a non-existent callback cause exceptions that bypass transaction rollback logic and leave database in inconsistent state?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Time-of-check-time-of-use in duplicate detection] At lines 66-79, there's a gap between the SELECT query checking for duplicates (lines 66-69) and the INSERT performed by the asset module (line 77) - during this window, can another thread/process insert the same output, causing both insertions to succeed and enabling double-spend of the private payment?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Missing spent output verification] The duplicate detection at lines 58-74 checks if an output exists and has an address, but doesn't verify if the output is already marked as spent (is_spent=1) - can an attacker replay a private payment chain after the output has been spent, and if the address was previously hidden (NULL), have it accepted again, enabling double-spending of the same private funds?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset issuance vs transfer confusion] The code doesn't distinguish between private payments that are asset issuance vs transfers - can an attacker craft a private payment chain that claims to be issuing new assets (with properly formatted issuance inputs) but actually references existing outputs as if they were transfers, bypassing supply cap checks and inflating asset supply beyond max_cap?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Incomplete rollback on asset module error] If the asset-specific validateAndSavePrivatePaymentChain() at line 77 performs some database writes (e.g., updating spend_proofs table for divisible assets) before calling transaction_callbacks.ifError(), will the ROLLBACK at line 45 properly undo those writes, or could there be cross-table inconsistencies if some tables were not included in the transaction?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Nested transaction commit failure] If COMMIT at line 51 fails (e.g., due to constraint violation or deadlock), the code doesn't catch this error - will the connection be released in a failed transaction state, and can subsequent queries on that connection execute in undefined transaction context, causing data corruption?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Error callback recursion] If callbacks.ifError() at line 47 internally triggers another call to validateAndSavePrivatePaymentChain() (e.g., retry logic), and that also fails, can this create deep callback recursion that exhausts the stack or connection pool, causing node-wide failure to process private payments?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Cross-chain state dependency] The function validates a single chain in isolation, but if multiple private payment chains for the same asset/address arrive concurrently and are processed in parallel (different database connections), can they both pass validation independently but collectively violate balance constraints when committed, enabling double-spending across chains?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset definition race condition] Between storage.readAsset() at line 36 and the actual validation at line 77, if the asset definition changes (e.g., asset is capped or frozen via a new unit), can the validation proceed with stale asset info, allowing operations that should be forbidden under the new definition?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Partial chain acceptance] If arrPrivateElements contains multiple elements (for indivisible assets), and validation succeeds for some elements but fails for others, does the rollback at line 45 ensure that no partial state is committed, or could intermediate elements be saved while later elements fail, creating broken chain references in the database?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Private payment deanonymization via timing] The duplicate detection logic at lines 72-74 returns immediately if a duplicate is found with existing address - can an attacker probe the network by sending the same private payment multiple times with slight variations and measuring response times to determine if a specific output has already been revealed, breaking the privacy guarantee of private payments?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset definition leak via error messages] If storage.readAsset() fails at line 37, the error message is propagated to callbacks.ifError() - if this error contains sensitive information about the asset structure or ownership, can an attacker learn private asset details by intentionally triggering validation failures?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Connection pool exhaustion] If an attacker sends many private payment chains that fail validation late in the process (after db.takeConnectionFromPool() at line 41 but during asset module validation at line 77), and these validations are slow, can they hold database connections for extended periods, exhausting the connection pool and preventing legitimate transactions from being processed for >1 day?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Storage.readAsset cache poisoning] If storage.readAsset() at line 36 uses a cache, can an attacker flood the network with private payments for many different assets, evicting legitimate asset definitions from cache and causing cache misses that slow down all private payment validation, delaying transaction processing for >1 hour?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Expensive filterNewOrUnstableUnits query] At line 19, storage.filterNewOrUnstableUnits() executes a database query with a potentially large IN clause (all units from all chains) - can an attacker send private payment chains with thousands of referenced units, causing this query to be extremely slow and blocking the validation thread, delaying all subsequent private payment processing?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Input validation bypass] If arrPrivateElements is an empty array [], the isNonemptyArray check at line 24 will fail, but what happens if an attacker passes an array with a single null or undefined element - can this bypass validation and reach asset reading logic, potentially causing downstream crashes or undefined behavior in divisibleAsset/indivisibleAsset modules?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset type confusion] At lines 39-40, the code checks if objAsset.fixed_denominations matches the presence of headElement.payload.denomination - if an attacker crafts a private payment with denomination field present for a divisible asset (or absent for indivisible), can they bypass this check by manipulating the payload structure before it reaches this validation, causing the wrong asset module (divisible vs indivisible) to process the payment at line 76-77?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Missing message_index validation] At line 32-33, only non-negative integer validation is performed on message_index, but there's no upper bound check - can an attacker supply an extremely large message_index value (e.g., 2^31-1) that could cause integer overflow in downstream SQL queries at lines 58-64 or in the asset-specific validation modules, potentially corrupting the outputs table or causing database errors?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Missing output_index validation] At lines 61-64, output_index validation only checks isNonnegativeInteger for fixed_denominations assets - can an attacker provide an extremely large output_index value that exceeds the actual number of outputs in the unit, causing the SQL query to insert invalid references into the outputs table and potentially enabling double-spend by referencing non-existent outputs?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Null/undefined asset] If headElement.payload.asset is explicitly set to null or undefined (bypassing line 30 check somehow), will the storage.readAsset() call at line 36 handle this gracefully, or could it cause the callback to never fire, resulting in a connection leak when db.takeConnectionFromPool() at line 41 never releases the connection?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Race condition on duplicate detection] At lines 58-74, the duplicate detection query checks if an output already exists, then inserts if not - if two identical private payment chains arrive simultaneously from different peers and both execute this code concurrently, can both pass the SELECT check before either INSERT commits, causing duplicate outputs to be stored and enabling a double-spend of the same private payment?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Transaction rollback failure] At lines 45-48, if conn.query('ROLLBACK') fails due to connection loss or database error, the connection is still released at line 46 without verifying the rollback succeeded - can this leave the database in a partially committed state where some outputs/inputs from the private payment chain are stored but not all, causing permanent inconsistency and potential fund loss?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Connection leak on error] If the asset-specific validateAndSavePrivatePaymentChain() call at line 77 throws an exception instead of calling transaction_callbacks.ifError(), the connection obtained at line 41 will never be released (no conn.release() in catch block), potentially exhausting the connection pool and causing network-wide transaction processing delays exceeding 1 day?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Non-atomic commit/callback] At lines 51-54, callbacks.ifOk() is called inside the COMMIT callback - if the COMMIT succeeds but callbacks.ifOk() triggers an exception (e.g., in event emission code), is the connection still released properly, or could this cause the connection to be returned to the pool in an undefined transaction state, corrupting subsequent queries?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Nested transaction BEGIN without check] Line 42 executes BEGIN unconditionally after taking a connection from the pool - if the connection was already in a transaction state (due to connection pool bug or improper release), can this cause nested transaction errors that crash the validation process and prevent all private payments from being processed, causing temporary network freeze?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Duplicate detection bypass via NULL address] At lines 72-74, the code considers an output duplicate only if rows[0].address is truthy - if an attacker can somehow cause a NULL address to be stored in the outputs table for their private payment, can they then send the same private payment again and bypass the duplicate check, enabling unlimited double-spends?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Incomplete duplicate check for divisible assets] At lines 58-64, the duplicate detection query for divisible assets (non-fixed_denominations) does not include output_index in the WHERE clause - if a single unit/message has multiple outputs, can an attacker replay the same private payment chain multiple times, each time revealing a different output_index, and have all of them accepted as non-duplicates, inflating the asset supply?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Multiple rows exception] At lines 70-71, if more than one row is returned from the duplicate check query, an Error is thrown but not caught - can an attacker intentionally corrupt the database state to create duplicate outputs that trigger this condition, causing all subsequent private payment validations to crash and freeze private payment processing network-wide?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Early return on duplicate without proper cleanup] At line 74, if a duplicate is detected, transaction_callbacks.ifOk() is called directly without rolling back the transaction started at line 42 - does this mean the transaction is committed even though no work was done, potentially causing issues if the connection is reused with uncommitted state, or leading to deadlocks in high-concurrency scenarios?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset module selection timing attack] At line 76, assetModule is selected based on objAsset.fixed_denominations, then line 77 calls its validateAndSavePrivatePaymentChain() - if objAsset data is cached and becomes stale (asset definition changed from divisible to indivisible), can this cause the wrong module to process the payment, leading to incorrect output format in database (amount+blinding vs denomination+output_hash) and permanent corruption of asset balance tracking?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset module callback contract violation] The code assumes divisibleAsset and indivisibleAsset modules will call either transaction_callbacks.ifError or transaction_callbacks.ifOk exactly once - if a buggy or malicious asset module calls both callbacks, or neither, can this cause double-rollback/double-commit errors or connection leaks that accumulate over time and eventually halt all transaction processing?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset module exception propagation] If the asset-specific validateAndSavePrivatePaymentChain() at line 77 validates successfully but then throws an exception during the database write phase, will the transaction be rolled back properly by the BEGIN/ROLLBACK logic at lines 42-48, or could the exception bypass the rollback mechanism and leave partial writes in the outputs/inputs tables?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Light client premature validation] At lines 85-90, in light client mode (conf.bLight), if findUnfinishedPastUnitsOfPrivateChains returns an empty array (no unfinished units), validation proceeds immediately - can an attacker craft a private payment chain that references future units not yet received by the light client, bypass the waiting logic, and have the payment validated against incomplete DAG state, potentially accepting invalid payments?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Missing asset definition validation in light client] At line 14, the function adds the asset definition unit to assocUnits, but in light client mode, if this asset definition unit is not yet stable or not received, and filterNewOrUnstableUnits() at line 19 doesn't properly detect this, can the subsequent validateAndSave() proceed without having the asset definition, causing validation errors or accepting payments for undefined assets?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Light client vs full node inconsistency] Lines 85-90 implement different logic for light clients (checking unfinished units) vs full nodes (direct validation) - can this create a scenario where a private payment is accepted by light clients but rejected by full nodes, or vice versa, causing disagreement on valid asset balances and potential chain splits between light and full nodes?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [includeLatestElement parameter inconsistency] At line 15, the loop starts at index 0 if includeLatestElement is true, else 1 - however, at line 86, this function is called with includeLatestElement=false, skipping the head element - if the head element itself is unstable, will storage.filterNewOrUnstableUnits() still catch it via the asset definition check at line 14, or could unstable head elements be validated prematurely?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Asset definition unit ambiguity] At line 14, assocUnits[arrPrivateElements[0].payload.asset] = true treats the asset hash as a unit identifier - but asset is a hash of the asset definition unit, not the unit hash itself - does storage.filterNewOrUnstableUnits() at line 19 correctly interpret this as needing to check the asset definition unit's stability, or will it fail to find the unit and incorrectly return it as 'unfinished'?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Empty chain handling] If arrChains is an empty array, or all elements have empty arrPrivateElements, lines 13-17 will produce an empty assocUnits object - will storage.filterNewOrUnstableUnits([]) at line 19 handle an empty array correctly, or could it trigger database errors, undefined behavior, or bypass filtering and call handleUnits with unexpected results?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Duplicate unit handling across chains] If arrChains contains multiple chains that reference the same intermediate units (overlapping chains), lines 13-17 will add the same unit to assocUnits multiple times (last write wins) - can this cause storage.filterNewOrUnstableUnits() to behave incorrectly, or does the use of object keys handle this safely?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Missing validation of arrPrivateElements structure] The function iterates through arrPrivateElements at lines 15-16 without validating that each element has the required 'unit' property - if an attacker provides a chain with malformed elements (missing .unit), can this cause undefined values to be added to assocUnits and passed to storage.filterNewOrUnstableUnits(), potentially causing database query errors?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Unbounded assocUnits object] At lines 13-17, assocUnits is populated from all units in all chains without size limits - if an attacker sends a private payment chain with thousands of elements (or multiple chains), can they cause excessive memory allocation in the assocUnits object and the arrUnits array at line 18, potentially leading to out-of-memory errors and node crashes?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Storage.readAsset unbounded callback delay] At line 36, storage.readAsset() is called without timeout - if the storage layer is experiencing issues or the asset doesn't exist, can this callback never fire, causing the function to never return and the database connection at line 41 to remain held indefinitely, leading to connection pool exhaustion?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Nested callback stack overflow] The validation flow involves multiple nested callbacks: validateAndSave -> storage.readAsset -> db.takeConnectionFromPool -> conn.query -> asset module validation - if an attacker triggers deep recursion by crafting chains that reference each other, could this cause stack overflow and crash the node, preventing any private payments from being processed?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Missing headElement.payload null check] At line 27, the code checks if (!headElement.payload) and returns error, but at line 29, it immediately accesses headElement.payload.asset - if payload exists but is not an object (e.g., payload is a string or number), can this cause a TypeError that crashes the validation process and is not caught by the error handling at lines 44-48?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [storage.readAsset error not specific] At line 37, if storage.readAsset() returns an error, it's passed directly to callbacks.ifError() without context - if the error is due to asset not existing vs database error vs invalid asset format, can this cause the caller to handle all errors identically, potentially retrying non-retryable errors or not retrying transient errors, leading to lost private payments?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Undefined objAsset handling] If storage.readAsset() succeeds but objAsset is null/undefined (asset doesn't exist), line 39 will attempt to access objAsset.fixed_denominations, causing TypeError - is this caught by try/catch in the calling code, or will it crash the node and prevent all subsequent private payment processing?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [ifWaitingForChain callback missing implementation] At line 87, callbacks.ifWaitingForChain() is called but there's no corresponding implementation in the transaction_callbacks object defined at lines 43-56 - if the calling code doesn't provide this callback, will this cause an undefined function call error that crashes the private payment processing?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [SQL injection via unit/message_index] At lines 58-64, the SQL query uses parameterized queries with headElement.unit and headElement.message_index - however, if these values are not properly validated earlier (only isNonnegativeInteger check for message_index), could specially crafted values cause SQL injection, allowing an attacker to modify the query logic and bypass duplicate detection or corrupt the outputs table?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Dynamic SQL construction risk] The SQL query at line 58 is modified at line 63 by appending additional WHERE clauses - if objAsset.fixed_denominations is manipulated or incorrectly cached, can this cause the query to be constructed incorrectly (missing output_index check when needed, or including it when not), leading to false duplicate detection or allowing true duplicates to pass?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Non-deterministic validation order] The validation flow depends on storage.readAsset() which queries the database - if two nodes have different asset cache states or database query execution orders, could they validate the same private payment chain differently, causing some nodes to accept it while others reject it, leading to permanent chain split?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Light client conditional execution non-determinism] Lines 85-90 execute different code paths for conf.bLight vs full nodes - if a node's configuration changes (bLight toggled), can previously validated private payments become invalid or vice versa, causing the node to diverge from consensus and reject otherwise valid units, contributing to network partition?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Storage.filterNewOrUnstableUnits timing sensitivity] At line 19, storage.filterNewOrUnstableUnits() checks current unit stability - if this is called during a stability point transition (unit becoming stable), different nodes might get different results based on timing, causing some nodes to wait for the chain while others proceed with validation, potentially leading to divergent private payment acceptance?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Dependency on external module state] The code delegates to divisibleAsset or indivisibleAsset modules at line 77 - if these modules have their own internal state or caches that can become inconsistent with the database, can an attacker exploit this by sending private payments that are validated correctly by private_payment.js but fail in asset-specific validation, causing transaction_callbacks.ifError() to be called after the transaction BEGIN, and leaving the database transaction open?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Network.js integration - missing validation] This function is called from network.js without prior validation of the arrPrivateElements structure beyond the checks at lines 24-33 - can an attacker craft a malicious network message with a private payment chain that passes network.js validation but exploits weaknesses in the asset-specific modules, causing node crashes or database corruption?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Callback contract violation propagation] If the calling code (network.js or wallet.js) provides callbacks object that doesn't implement all three expected callbacks (ifError, ifOk, ifWaitingForChain), but private_payment.js doesn't validate this, can calling a non-existent callback cause exceptions that bypass transaction rollback logic and leave database in inconsistent state?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Time-of-check-time-of-use in duplicate detection] At lines 66-79, there's a gap between the SELECT query checking for duplicates (lines 66-69) and the INSERT performed by the asset module (line 77) - during this window, can another thread/process insert the same output, causing both insertions to succeed and enabling double-spend of the private payment?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Missing spent output verification] The duplicate detection at lines 58-74 checks if an output exists and has an address, but doesn't verify if the output is already marked as spent (is_spent=1) - can an attacker replay a private payment chain after the output has been spent, and if the address was previously hidden (NULL), have it accepted again, enabling double-spending of the same private funds?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset issuance vs transfer confusion] The code doesn't distinguish between private payments that are asset issuance vs transfers - can an attacker craft a private payment chain that claims to be issuing new assets (with properly formatted issuance inputs) but actually references existing outputs as if they were transfers, bypassing supply cap checks and inflating asset supply beyond max_cap?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Incomplete rollback on asset module error] If the asset-specific validateAndSavePrivatePaymentChain() at line 77 performs some database writes (e.g., updating spend_proofs table for divisible assets) before calling transaction_callbacks.ifError(), will the ROLLBACK at line 45 properly undo those writes, or could there be cross-table inconsistencies if some tables were not included in the transaction?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Nested transaction commit failure] If COMMIT at line 51 fails (e.g., due to constraint violation or deadlock), the code doesn't catch this error - will the connection be released in a failed transaction state, and can subsequent queries on that connection execute in undefined transaction context, causing data corruption?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Error callback recursion] If callbacks.ifError() at line 47 internally triggers another call to validateAndSavePrivatePaymentChain() (e.g., retry logic), and that also fails, can this create deep callback recursion that exhausts the stack or connection pool, causing node-wide failure to process private payments?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Cross-chain state dependency] The function validates a single chain in isolation, but if multiple private payment chains for the same asset/address arrive concurrently and are processed in parallel (different database connections), can they both pass validation independently but collectively violate balance constraints when committed, enabling double-spending across chains?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset definition race condition] Between storage.readAsset() at line 36 and the actual validation at line 77, if the asset definition changes (e.g., asset is capped or frozen via a new unit), can the validation proceed with stale asset info, allowing operations that should be forbidden under the new definition?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Partial chain acceptance] If arrPrivateElements contains multiple elements (for indivisible assets), and validation succeeds for some elements but fails for others, does the rollback at line 45 ensure that no partial state is committed, or could intermediate elements be saved while later elements fail, creating broken chain references in the database?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Private payment deanonymization via timing] The duplicate detection logic at lines 72-74 returns immediately if a duplicate is found with existing address - can an attacker probe the network by sending the same private payment multiple times with slight variations and measuring response times to determine if a specific output has already been revealed, breaking the privacy guarantee of private payments?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Asset definition leak via error messages] If storage.readAsset() fails at line 37, the error message is propagated to callbacks.ifError() - if this error contains sensitive information about the asset structure or ownership, can an attacker learn private asset details by intentionally triggering validation failures?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Connection pool exhaustion] If an attacker sends many private payment chains that fail validation late in the process (after db.takeConnectionFromPool() at line 41 but during asset module validation at line 77), and these validations are slow, can they hold database connections for extended periods, exhausting the connection pool and preventing legitimate transactions from being processed for >1 day?",
  "[File: byteball/ocore/private_payment.js] [Function: validateAndSavePrivatePaymentChain()] [Storage.readAsset cache poisoning] If storage.readAsset() at line 36 uses a cache, can an attacker flood the network with private payments for many different assets, evicting legitimate asset definitions from cache and causing cache misses that slow down all private payment validation, delaying transaction processing for >1 hour?",
  "[File: byteball/ocore/private_payment.js] [Function: findUnfinishedPastUnitsOfPrivateChains()] [Expensive filterNewOrUnstableUnits query] At line 19, storage.filterNewOrUnstableUnits() executes a database query with a potentially large IN clause (all units from all chains) - can an attacker send private payment chains with thousands of referenced units, causing this query to be extremely slow and blocking the validation thread, delaying all subsequent private payment processing?",
  "[File: byteball/ocore/profiler.js] [Function: start()] [Race condition] If two concurrent validation threads call profiler.start() simultaneously before either calls stop(), the second call throws 'profiler already started' error - can this crash the validation pipeline in validation.js during concurrent unit processing, causing a network halt by preventing new units from being confirmed?",
  "[File: byteball/ocore/profiler.js] [Function: stop()] [Race condition] If profiler.stop(tag) is called without a prior profiler.start() due to race conditions or exception in validation code, it throws 'profiler not started' error - can this exception propagate to validation.js async.series() error handler and cause units to be incorrectly rejected, leading to consensus divergence?",
  "[File: byteball/ocore/profiler.js] [Function: start_sl1()] [Race condition] The start_ts_sl1 variable is checked and set without atomic operations - if multiple concurrent operations call start_sl1() simultaneously, can this cause incorrect timing measurements or error throwing that disrupts critical protocol operations in main_chain.js or paid_witnessing.js?",
  "[File: byteball/ocore/profiler.js] [Function: stop_sl1()] [Race condition] When stop_sl1() updates times_sl1[tag] and counters_sl1[tag] without synchronization, can concurrent calls from different validation threads cause data races that result in corrupted timing statistics or lost counter increments?",
  "[File: byteball/ocore/profiler.js] [Function: mark_start()] [Race condition] The function checks if timers[tag][id] exists and throws an error for 'multiple start marks' - can an attacker trigger concurrent operations with the same tag/id combination to cause this error to be thrown during critical validation steps, crashing the node?",
  "[File: byteball/ocore/profiler.js] [Global State] [Race condition] The global variables times, counters, timers, times_sl1, counters_sl1 are all accessed without locks - can concurrent modifications from parallel validation/storage/writer operations cause memory corruption or non-deterministic behavior that leads to chain splits between nodes?",
  "[File: byteball/ocore/profiler.js] [Function: start()] [Error propagation] Line 75 throws Error('profiler already started') if start_ts is already set - when this error is thrown during validation.js profiler.start() calls in the async.series pipeline, does it bypass the validation error handlers and crash the entire validation process?",
  "[File: byteball/ocore/profiler.js] [Function: stop()] [Error propagation] Line 81 throws Error('profiler not started') if start_ts is 0 - if an exception occurs between profiler.start() and profiler.stop() in validation.js causing stop() to be called without start(), does this error crash the validation and prevent unit acceptance?",
  "[File: byteball/ocore/profiler.js] [Function: start_sl1()] [Error propagation] Line 93 throws Error('profiler already started') for start_ts_sl1 - can this error be triggered in paid_witnessing.js or main_chain.js operations and cause witness payment calculations or MC updates to fail, disrupting consensus?",
  "[File: byteball/ocore/profiler.js] [Function: stop_sl1()] [Error propagation] Line 99 throws Error('profiler not started') - if main_chain.js calls this without matching start_sl1() due to early returns in conditional logic, can the thrown error cause main chain updates to abort and prevent MCI advancement?",
  "[File: byteball/ocore/profiler.js] [Function: mark_start()] [Error propagation] Line 51 throws Error for multiple start marks - although the function has early return on line 47, if profiling is enabled and concurrent writer.js operations use the same mark_start ID, can this crash the unit writing process and block network confirmation?",
  "[File: byteball/ocore/profiler.js] [Global State] [Memory exhaustion] The times, counters, timers, times_sl1, counters_sl1, and timers_results objects are never bounded in size - can an attacker flood the network with diverse validation tag names to cause unbounded memory growth in these objects, eventually causing node crashes via OOM and network shutdown?",
  "[File: byteball/ocore/profiler.js] [Function: add_result()] [Memory exhaustion] Line 70 pushes consumed_time values into timers_results[tag] array without any size limits - if validation.js or writer.js generates millions of results over time, can this cause memory exhaustion that crashes the node during peak network activity?",
  "[File: byteball/ocore/profiler.js] [Function: mark_end()] [Memory leak] Line 61 pushes timing results into timers_results[tag] array but line 62 sets timers[tag][id] = 0 instead of deleting it - does this cause the timers object to accumulate entries indefinitely, leading to memory leaks over long-running nodes?",
  "[File: byteball/ocore/profiler.js] [Event Handler] [Memory leak] Line 123 registers an event listener on eventBus for 'mci_became_stable' but never removes it - if the profiler module is reloaded or disabled, does this event handler persist and cause memory leaks or unexpected behavior?",
  "[File: byteball/ocore/profiler.js] [Function: setInterval] [Resource leak] Line 44 calls setInterval(print_on_screen, ...) but never stores the interval ID or clears it - if the node runs indefinitely or the profiler configuration changes, can this cause resource leaks with unclearable intervals consuming CPU?",
  "[File: byteball/ocore/profiler.js] [Event Handler] [Unbounded accumulation] The mci_became_stable event handler writes files for every printOnFileMciPeriod MCI but fs.mkdir and fs.writeFile callbacks at lines 122-139 don't handle errors - can an attacker cause the file system to fill up by triggering frequent MCI advancement, leading to disk exhaustion and node crashes?",
  "[File: byteball/ocore/profiler.js] [File Operations] [Directory traversal] Line 122 creates directory appDataDir + '/' + directoryName where directoryName is set to 'profiler' - if configuration allows directoryName to be user-controlled or modified, can an attacker use directory traversal sequences (../) to create directories outside appDataDir?",
  "[File: byteball/ocore/profiler.js] [File Operations] [Path injection] Line 128 writes files with name 'mci-' + mci + '-' + (total/count).toFixed(2) + ' ms' where mci comes from the blockchain - if an attacker can manipulate MCI values or the event bus, can they inject path traversal characters or overwrite critical system files?",
  "[File: byteball/ocore/profiler.js] [File Operations] [Disk exhaustion] Lines 128-136 write profiling results to files every printOnFileMciPeriod without size limits or rotation - can an attacker spam the network to rapidly advance MCI and fill the disk with profiling files, causing node crashes when disk space is exhausted?",
  "[File: byteball/ocore/profiler.js] [File Operations] [Unhandled errors] Lines 122 and 128 use fs.mkdir and fs.writeFile with empty error callbacks () => {} - if file operations fail silently (permissions, disk full, etc.), can this cause the profiler state to become inconsistent with assumptions in validation code that expects profiling to work correctly?",
  "[File: byteball/ocore/profiler.js] [File Operations] [Race condition] Lines 128-136 reset profiling state (count=0, times={}, etc.) after writing files - if concurrent validation operations are accessing these variables during reset, can this cause race conditions where timing data is corrupted or lost?",
  "[File: byteball/ocore/profiler.js] [Prototype Modification] [Global pollution] Lines 227-238 modify String.prototype.padding globally - can this affect other modules' string operations and cause unexpected behavior in validation.js, object_hash.js, or signature.js where string manipulation must be deterministic?",
  "[File: byteball/ocore/profiler.js] [Prototype Modification] [Non-determinism] The String.prototype.padding function uses Math.abs and Array.join which may have different implementations across Node.js versions - can this cause non-deterministic string formatting in profiler output that, if somehow used in protocol logic, leads to chain splits?",
  "[File: byteball/ocore/profiler.js] [Prototype Modification] [Security risk] Adding methods to built-in prototypes can be exploited if any protocol code iterates over string properties using for-in loops without hasOwnProperty checks - can this cause validation or hashing logic to process unexpected properties?",
  "[File: byteball/ocore/profiler.js] [Function: Date.now()] [Non-determinism] The profiler uses Date.now() at lines 41, 52, 61, 76, 84, 94, 102, 136, 191-192 for timing measurements - if profiler results are logged or influence any conditional logic in validation or consensus code, can timestamp differences across nodes cause non-deterministic behavior leading to chain splits?",
  "[File: byteball/ocore/profiler.js] [Function: add_result()] [Information disclosure] Line 70 collects consumed_time values from validation.js and other critical components - can timing data reveal sensitive information about transaction processing patterns, validation complexity, or system performance that aids side-channel attacks?",
  "[File: byteball/ocore/profiler.js] [Function: print_on_screen()] [Information disclosure] Line 114 logs formatted profiling results to console.error including timing breakdowns - if console output is monitored by attackers, can this reveal which validation steps are slow and guide DoS attacks targeting expensive operations?",
  "[File: byteball/ocore/profiler.js] [Function: getFormattedResults()] [Information disclosure] Lines 143-176 calculate and format detailed timing statistics including per-operation and per-unit averages - can this data expose protocol inefficiencies or reveal which types of units are most expensive to validate?",
  "[File: byteball/ocore/profiler.js] [Function: print_results_on_log()] [Information disclosure] Lines 189-190 log tag.padding(50), avg, max, min timing statistics - can an attacker use this information to craft malicious units that maximize validation time and execute DoS attacks?",
  "[File: byteball/ocore/profiler.js] [Export: time_in_db] [Information disclosure] Line 256 exports profiler.time_in_db variable that tracks database operation time - if this is logged publicly, can it reveal database performance characteristics that help attackers optimize database-level DoS attacks?",
  "[File: byteball/ocore/profiler.js] [Configuration] [Undefined behavior] Lines 22-27 define configuration variables bPrintOnExit, printOnScreenPeriodInSeconds, printOnFileMciPeriod that are hardcoded to false/0 - if these are dynamically set at runtime via conf.js, can changing them mid-operation cause state inconsistencies or errors?",
  "[File: byteball/ocore/profiler.js] [Configuration] [State inconsistency] Line 27 calculates bOn = bPrintOnExit || printOnScreenPeriodInSeconds > 0 at module load time - if configuration changes after module initialization, does bOn remain stale while actual profiling behavior changes, causing mismatches?",
  "[File: byteball/ocore/profiler.js] [Conditional Exports] [API inconsistency] Lines 243-250 conditionally export real implementations only if bOn is true, otherwise exports are no-ops - if code calls profiler functions expecting side effects but bOn is false, can this cause logic errors where validation assumes profiling occurred?",
  "[File: byteball/ocore/profiler.js] [Event Bus Dependency] [Module loading] Line 18 requires event_bus.js which may have circular dependencies with other modules - if event_bus initialization fails or is delayed, can the profiler event listener registration at line 123 fail silently and cause profiling files to never be written despite printOnFileMciPeriod > 0?",
  "[File: byteball/ocore/profiler.js] [Desktop App Dependency] [Module loading] Lines 19-20 require desktop_app.js and call getAppDataDir() - if desktop_app is not available (in server environments), can this cause the module to crash on load and break all code that imports profiler.js?",
  "[File: byteball/ocore/profiler.js] [Integration: validation.js] [Error propagation] validation.js calls profiler.start() at line 248 within async.series before checkDuplicate - if profiler.start() throws an error due to already being started, does this bypass checkDuplicate and allow duplicate units to pass validation?",
  "[File: byteball/ocore/profiler.js] [Integration: validation.js] [State corruption] validation.js calls profiler.stop() with different tags throughout the validation pipeline (lines 252-341) - if a validation error occurs mid-pipeline leaving profiler in started state, can subsequent validations fail with 'profiler already started' errors causing a cascade of unit rejections?",
  "[File: byteball/ocore/profiler.js] [Integration: validation.js] [Error masking] validation.js checks profiler.isStarted() at line 313 to conditionally stop profiling - if this check is wrong due to race conditions, can incorrect profiler state mask validation errors or cause incorrect error handling paths to execute?",
  "[File: byteball/ocore/profiler.js] [Integration: writer.js] [Crash risk] writer.js uses profiler extensively (34 calls) during unit writing to storage - if profiler errors occur during atomic database transactions, can this cause transaction rollbacks that leave the DAG in an inconsistent state with partially written units?",
  "[File: byteball/ocore/profiler.js] [Integration: main_chain.js] [Consensus impact] main_chain.js has 27 profiler calls during main chain index calculation and stability determination - if profiler errors interrupt MC updates, can this cause nodes to have different MCI assignments leading to permanent chain splits?",
  "[File: byteball/ocore/profiler.js] [Integration: paid_witnessing.js] [Witness payments] paid_witnessing.js uses profiler (17 calls) during witness reward distribution - if profiler errors crash witness payment calculations, can this cause witnesses to not receive payments and stop posting units, freezing the network?",
  "[File: byteball/ocore/profiler.js] [Function: increment()] [State corruption] Line 214 increments count without checking for integer overflow - can an extremely long-running node eventually overflow count causing division by zero errors in getFormattedResults() at line 146 or line 165?",
  "[File: byteball/ocore/profiler.js] [Function: stop()] [State corruption] Lines 82-87 update times[tag] and counters[tag] - if these operations are interrupted mid-execution by errors or crashes, can partial updates cause counters to be incremented without corresponding time additions, corrupting average calculations?",
  "[File: byteball/ocore/profiler.js] [Function: getFormattedResults()] [Division by zero] Line 146 checks if count === 0 but line 152 calculates times_for_tag/counter_for_tag without checking if counter_for_tag is 0 - can a scenario where times[tag] exists but counters[tag] is 0 cause NaN or division by zero errors?",
  "[File: byteball/ocore/profiler.js] [Function: getFormattedResults()] [Division by zero] Line 153 calculates times_for_tag/count where count could be 0 if increment() is never called - although line 146 returns early, can the early return be bypassed if times is populated but count is 0?",
  "[File: byteball/ocore/profiler.js] [Global State Reset] [Race condition] Lines 129-135 reset all profiling state variables after MCI file writing - if concurrent validation threads are reading these variables during reset, can this cause them to see inconsistent state (e.g., times[tag] exists but counters[tag] is undefined)?",
  "[File: byteball/ocore/profiler.js] [Function: pad_left()] [Type coercion] Line 207 coerces str to string with str+'' - if numeric values or objects are passed, can this cause unexpected string representations that break formatting in console output or file writing?",
  "[File: byteball/ocore/profiler.js] [Function: pad_right()] [String operations] Lines 201-204 use String.repeat() which may fail for very large padding lengths - can an attacker cause tag names or formatting to require excessive padding lengths, causing memory exhaustion or CPU spikes?",
  "[File: byteball/ocore/profiler.js] [Function: print_results_on_log()] [Number overflow] Lines 182-189 calculate sum, max, min over timing results arrays - for very large result sets accumulated over long periods, can sum overflow Number.MAX_SAFE_INTEGER causing incorrect statistics?",
  "[File: byteball/ocore/profiler.js] [Function: print_results_on_log()] [CPU usage calculation] Lines 194-197 use process.cpuUsage() to calculate CPU percentages - if the profiler runs for very long periods, can integer overflow in usage.user or usage.system cause incorrect or negative percentage calculations?",
  "[File: byteball/ocore/profiler.js] [Function: mark_start()] [ID collision] Line 48 defaults id to 0 if not provided - if multiple operations use mark_start(tag) without specifying unique IDs, can they collide and cause 'multiple start marks' errors even for logically separate operations?",
  "[File: byteball/ocore/profiler.js] [Function: mark_end()] [Missing start] Line 57 returns early if timers[tag] doesn't exist - can this silently fail to record timing data if mark_start was never called, causing incomplete profiling results that hide performance issues?",
  "[File: byteball/ocore/profiler.js] [Console Override] [Debugging artifact] Line 240 saves original console.log to clog and line 241 (commented out) would override console.log - if the commented line is uncommented in production, can this suppress critical error logs from validation.js, storage.js, or other modules?",
  "[File: byteball/ocore/profiler.js] [Console Override] [Information suppression] Line 219 restores console.log = clog in SIGINT handler - if console.log was overridden and SIGINT is never received, can important validation errors or security warnings be permanently suppressed?",
  "[File: byteball/ocore/profiler.js] [Function: print_on_screen()] [Console flooding] Line 114 uses console.error to print profiling results - if printOnScreenPeriodInSeconds is set very low, can this flood the console and degrade performance or make it impossible to see critical error messages?",
  "[File: byteball/ocore/profiler.js] [Signal Handler] [Uncaught exception] Lines 217-225 register SIGINT handler that calls print_on_log() and process.exit() - if profiler state is corrupted when SIGINT occurs, can print_on_log() throw an exception that prevents graceful shutdown and leaves database transactions uncommitted?",
  "[File: byteball/ocore/profiler.js] [Signal Handler] [Process termination] Line 223 calls process.exit() after printing results - does this immediate exit prevent database connections from closing properly or in-flight validation operations from completing, potentially corrupting the database?",
  "[File: byteball/ocore/profiler.js] [Signal Handler] [State assumption] The SIGINT handler assumes profiler state is consistent and printable - if signal arrives during a profiler operation (e.g., mid-stop()), can race conditions cause the handler to access inconsistent state and crash during shutdown?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChain()] [Null MCI handling] When earlier_mci is null, the function throws an error at line 10-11, but what happens if a malicious caller provides earlier_mci=null for a unit that legitimately exists but hasn't been assigned an MCI yet? Could this cause legitimate light client proof requests to fail, resulting in temporary network partition where light clients cannot verify valid transactions (Medium severity - transaction delay)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChain()] [MCI equality edge case] When later_mci === earlier_mci at line 12, the code skips buildProofChainOnMc and goes directly to buildLastMileOfProofChain. Can an attacker exploit this by requesting proof chains with equal MCIs to bypass certain validation steps or produce incomplete proof chains that light clients incorrectly accept (Critical severity - incorrect chain verification)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [MCI underflow] At line 23-24, if mci < 0, an error is thrown. However, what happens during skiplist traversal at line 61 when addBall(next_mci) is called with a computed next_mci that could be negative due to integer underflow or malicious skiplist_mci values? Could this crash the node or create infinite recursion (Critical severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [MCI ordering violation] At line 69-70, the code checks if earlier_mci > later_mci and throws an error. But what if the database contains corrupted data where a unit's MCI is incorrectly assigned (e.g., through a previous bug)? Would this check prevent proof chain construction, causing all light clients to fail verification for legitimate transactions (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [MCI equality short-circuit] At line 71-72, if earlier_mci === later_mci, onDone() is called immediately without adding any balls to arrBalls. Could an attacker craft a proof chain request where earlier_mci === later_mci to receive an empty proof chain, then use this to convince light clients that a unit is valid without any actual proof (Critical severity - direct fund loss via fake proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Missing MC unit] The database query at line 25 expects exactly one unit with main_chain_index=mci and is_on_main_chain=1, throwing an error at line 26-27 if rows.length !== 1. Can an attacker manipulate the database (e.g., via SQL injection in another component or database corruption) to have zero or multiple units claiming the same MCI, causing all proof chain construction to fail and halting light client operations (Critical severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Non-deterministic query results] If two units somehow have the same main_chain_index and is_on_main_chain=1 (database consistency violation), the query at line 25 would return multiple rows. Would different nodes potentially select different units from these results, creating non-deterministic proof chains that cause permanent chain split (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Missing unit in last mile] At line 79-81, the query expects exactly one unit with the given unit hash. If a malicious peer requests a proof chain for a unit that doesn't exist in the local database, the error thrown here propagates up. Could an attacker flood nodes with proof chain requests for non-existent units to cause DoS via exception handling overhead (Medium severity - transaction delay)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [MC unit uniqueness] At line 143-145, the query retrieves the unit at main_chain_index=mci with is_on_main_chain=1. If database corruption results in rows.length !== 1, an error is thrown. Could this error propagate to light clients in a way that makes them unable to verify any transactions, causing permanent operational failure requiring hard fork (Critical severity - permanent fund freezing)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Parent balls missing] At line 36-37, the code checks if any parent units don't have balls (i.e., parent_row.ball is null). What happens if a unit's parent was marked as final-bad or nonserial after the unit was created? Would this throw an error and prevent proof chain construction for all descendants of that unit, permanently freezing funds in those units (High severity - permanent fund freezing)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Partial ball assignment] The query at line 33-34 uses LEFT JOIN, meaning parent units without balls will return null in parent_row.ball. If the balls table is inconsistent (e.g., some stable units missing ball entries due to database corruption), could this cause the some() check at line 36 to throw errors unpredictably, causing non-deterministic proof chain failures across nodes (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Skiplist ball completeness] At line 46-47, the code verifies all skiplist units have balls. If a skiplist_unit entry points to a unit that is not yet stable (no ball assigned), would this throw an error? Could an attacker exploit skiplist construction logic to insert skiplist references to unstable units, causing proof chain construction to fail for the entire chain (Critical severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Last mile parent balls] At line 90-91, parent balls are checked for existence similar to buildProofChainOnMc. In the last mile section (off-MC units), are there any edge cases where a unit's parents might legitimately not have balls yet (e.g., if they're in different branches)? Would this prevent proof chain completion and make certain units unverifiable by light clients (High severity - permanent fund freezing)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Last mile skiplist balls] At line 100-101, skiplist balls in the last mile are checked. Since last mile units are not on the main chain, their skiplist references might point to units in different branches. Could this create situations where proof chains cannot be completed because skiplist units in other branches don't have balls from the perspective of the current chain (Critical severity - permanent fund freezing)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Skiplist-free chain] At line 53-54, if there are no skiplist units (srows.length === 0), the code falls back to linear traversal with addBall(mci-1). Could an attacker manipulate the skiplist construction (in the unit creation phase) to create long chains without skiplist entries, forcing proof chain construction to traverse every single MCI sequentially? This could cause DoS by making proof chain construction take O(N) time instead of O(log N) where N is MCI distance (Medium severity - transaction delay)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Skiplist MCI calculation] At line 55-61, the code calculates next_mci by finding the minimum skiplist MCI that is still >= earlier_mci. If skiplist MCIs are maliciously crafted to all be either < earlier_mci or >>> later_mci, could this cause inefficient traversal or skip critical validation points in the proof chain (Medium severity - incorrect proof construction)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Skiplist infinite loop] At line 56-60, the loop iterates through skiplist entries to find next_mci. If the skiplist contains circular references (e.g., unit A has skiplist to unit B which has skiplist back to A), could this cause the proof chain construction to loop infinitely or revisit the same MCIs, never reaching earlier_mci (Critical severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Skiplist boundary conditions] When next_skiplist_mci < next_mci && next_skiplist_mci >= earlier_mci at line 58, the code updates next_mci. What happens if a skiplist entry has main_chain_index = earlier_mci exactly? Would this be included in the proof chain or skipped? Could this ambiguity lead to different nodes producing different proof chains for the same MCI range (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Missing skiplist MCI coverage] If skiplist units are supposed to provide O(log N) traversal but some ranges have no skiplist coverage (e.g., gaps in MCI assignments), could this degrade to O(N) traversal in worst case? While not a direct security issue, could an attacker exploit this to create proof chains that take excessive time to construct, causing DoS (Medium severity - transaction delay)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Parent selection on MC] The findParent() function at line 115-140 queries for parent units that have the same main_chain_index as the current interim_unit (line 117-118). What happens if multiple parents exist at the same MCI? The code uses graph.determineIfIncluded() to find which parent includes the target unit. Could an attacker create a DAG structure where multiple parents at the same MCI include the target unit, causing non-deterministic path selection (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Single parent optimization] At line 123-124, if there is only one parent, it is selected immediately without calling determineIfIncluded(). Could an attacker exploit this by creating units with only one parent that doesn't actually include the target unit, causing the proof chain to select an incorrect path (Critical severity - fake proof allowing fund theft)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [No valid parent found] At line 133-134, if no parent includes the target unit, an error is thrown. Could this occur in legitimate scenarios (e.g., during reorganizations or if the target unit is in a different branch)? Would this cause proof chain requests to fail, making certain units permanently unverifiable by light clients (High severity - permanent fund freezing)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [determineIfIncluded dependency] The path selection relies on graph.determineIfIncluded() at line 128-130. If this function has bugs or returns inconsistent results under certain DAG structures, could different nodes build different proof chains for the same unit, causing chain splits (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Parent iteration order] The async.eachSeries at line 125-137 iterates through parents in array order and returns the first parent that includes the target unit (line 129: cb(parent_unit) terminates iteration). If the parent order from the database query is non-deterministic (e.g., dependent on database implementation), could different nodes select different parents, creating divergent proof chains (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChain()] [Callback ordering] The main buildProofChain function at line 14-16 calls buildProofChainOnMc, then buildLastMileOfProofChain in sequence. If the onDone callback from buildProofChainOnMc is called before arrBalls is fully populated (e.g., due to async timing), could buildLastMileOfProofChain receive an incomplete array? Would this create incomplete proof chains (Critical severity - fake proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Recursive addBall calls] The addBall function at line 22-67 recursively calls itself at lines 54 and 61. If database queries are slow or if the recursion depth is very large (e.g., earlier_mci = 0, later_mci = 1000000), could this cause stack overflow or exceed callback limits in Node.js (Critical severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Nested callback hell] The addBall function has three nested database queries (lines 25, 32-34, 40-44) with callbacks. If one of these queries hangs or times out, would the entire proof chain construction hang indefinitely? Could an attacker exploit this by causing database query delays (e.g., via resource exhaustion) to DoS proof chain construction (Medium severity - transaction delay)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [findParent recursion] The findParent function at line 115-140 calls addBall, which calls findParent again at line 107, creating mutual recursion. If the DAG structure has very long off-chain paths (many units between MC unit and target unit), could this cause stack overflow (Critical severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [async.eachSeries timing] The async.eachSeries at line 125-137 is used to find the first parent that includes the target unit. If graph.determineIfIncluded() is very slow for some parents, could an attacker create DAG structures that cause this loop to take excessive time, DoSing proof chain construction (Medium severity - transaction delay)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [content_hash presence] At line 29-30, if objBall.content_hash exists, is_nonserial is set to true. The content_hash field is then deleted at line 31. What happens if content_hash is set maliciously in the database (e.g., for a unit that should not be nonserial)? Would this cause incorrect ball hash calculations in verification, allowing fake proofs to be accepted (Critical severity - direct fund loss via fake proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Nonserial flag mutation] The is_nonserial flag is set based on content_hash existence, but then content_hash is deleted from objBall before adding to arrBalls (line 31). Could race conditions in concurrent proof chain constructions cause the content_hash field to be read inconsistently, leading to some proof chains having is_nonserial=true and others false for the same unit (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Last mile content_hash] At line 83-85, the same content_hash  is_nonserial conversion occurs for last mile units. Are there scenarios where a unit in the last mile (off-MC) could have content_hash but shouldn't be treated as nonserial for proof chain purposes? Would this create invalid proof chains (Critical severity - fake proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc() & buildLastMileOfProofChain()] [content_hash consistency] The content_hash field is queried from the database in both functions (lines 25, 79). If the database is modified between these queries (e.g., a unit transitions from serial to nonserial after stability), could this cause the main chain portion and last mile portion of the same proof chain to have inconsistent is_nonserial flags (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChain()] [arrBalls shared reference] The arrBalls array is passed by reference to buildProofChainOnMc and buildLastMileOfProofChain. If these functions are called concurrently (e.g., for different proof chain requests), could they mutate the same array, causing cross-contamination of proof chains (Critical severity - fake proofs sent to wrong light clients)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [arrBalls.push ordering] At line 50, objBall is pushed to arrBalls. The proof chain must be in order from later_mci to earlier_mci. If the recursive addBall calls complete out of order (e.g., due to database query timing), could balls be added to arrBalls in incorrect order (Critical severity - incorrect proof chain verification)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [parent_balls array construction] At line 39, parent_balls is constructed from parent_rows using map(). If the ORDER BY ball clause in the query at line 33 produces non-deterministic ordering (e.g., if multiple parents have the same ball hash), could different nodes produce different parent_balls arrays, leading to different ball hashes (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [skiplist_balls array construction] At line 49, skiplist_balls is constructed similarly. The ORDER BY ball clause at line 43 must produce deterministic ordering. If skiplist units can have duplicate balls or if the ordering is database-dependent, could this cause non-deterministic proof chains (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Last mile arrBalls order] At line 104, balls are pushed to arrBalls during last mile traversal. The traversal starts from MC unit and works backwards to target unit (line 107: findParent  addBall). Is the order in arrBalls from target unit to MC unit or vice versa? If the order is ambiguous or inconsistent with buildProofChainOnMc, could this cause verification failures (Critical severity - incorrect proof validation)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChain()] [Null MCI exception] At line 10-11, if earlier_mci is null, an Error is thrown synchronously. Does the calling code (light.js, catchup.js) properly catch this exception? If uncaught, could this crash the Node.js process, causing network halt (Critical severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Multiple error throw points] The code throws errors at lines 24, 27, 37, 47, 70. Are all these exceptions caught and handled gracefully by callers? If any exception propagates to the top level, could it crash the node (Critical severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Last mile error handling] Errors are thrown at lines 81, 91, 101, 134, 145. If these occur during light client proof chain construction, would the light client receive an error response or would the connection be terminated? Could this be exploited to DoS light clients by requesting proofs for edge-case units (Medium severity - transaction delay)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc() & buildLastMileOfProofChain()] [Database error handling] None of the database query callbacks (lines 25, 32, 40, 79, 86, 94, 116, 143) check for database errors (e.g., connection loss, query timeout). If a database error occurs, would the callback be invoked with an error parameter that is ignored, causing undefined behavior (Critical severity - network halt or data corruption)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Silent failure modes] At line 51-52, if mci === earlier_mci, onDone() is called. But what if the objBall that was just pushed is malformed or incomplete? Would the proof chain be accepted even though it's invalid because no validation occurs before calling onDone (Critical severity - fake proof acceptance)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [MCI assignment verification] The query at line 25 selects units WHERE main_chain_index=? AND is_on_main_chain=1. If a unit has main_chain_index set but is_on_main_chain=0 (database inconsistency), would this be excluded from proof chains? Could this cause proof chains to skip units that should be included, creating invalid proofs (Critical severity - fake proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [MCI gap detection] The code traverses from later_mci-1 down to earlier_mci (line 73, then recursive calls). If there are gaps in MCI assignments (e.g., MCI 100, 101, 103 but no unit at MCI 102), would the query at line 25 return 0 rows and throw an error? Could an attacker exploit this by causing MCI gaps to DoS proof chain construction (Critical severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [MCI constraint in findParent] The findParent query at line 116-118 requires parent_unit to have main_chain_index=mci. What if a unit has parents at different MCIs (which is expected in DAG)? Would only parents at the specific mci be considered, potentially excluding valid paths to the target unit (High severity - permanent fund freezing)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Off-chain unit MCI] The last mile traversal assumes the target unit has main_chain_index=mci (passed as parameter). What if the target unit's actual MCI differs from the mci parameter due to database inconsistency? Would the proof chain construction fail or produce an invalid proof (Critical severity - fake proofs or permanent fund freezing)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [MC unit identification] At line 143-145, the MC unit at the given mci is retrieved. If there are multiple units at this MCI (database corruption), the error thrown would prevent proof chain construction. But what if the wrong MC unit is selected by the database (e.g., due to non-deterministic query results)? Would different nodes build proof chains starting from different MC units (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Target unit on MC] At line 147-148, if the MC unit equals the target unit (mc_unit === unit), onDone() is called immediately. Could an attacker request proof chains where the target unit is claimed to be on MC but actually isn't, causing empty proof chains to be generated and accepted (Critical severity - fake proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Path uniqueness] The findParent logic finds one valid path from MC unit to target unit. If multiple valid paths exist (common in DAG structures), could different nodes select different paths, resulting in different proof chains that are all technically valid but have different ball sequences (Critical severity - permanent chain split due to divergent verification)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Inclusion determination correctness] At line 128-130, graph.determineIfIncluded() is used to check if a parent includes the target unit. If this function has bugs (e.g., returns true for units that don't actually include the target), would invalid proof chains be constructed (Critical severity - fake proofs enabling fund theft)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Cycle detection in last mile] The findParent  addBall  findParent recursion could potentially cycle if the DAG has cycles (which shouldn't exist but could due to bugs). Is there any cycle detection? Could an attacker create cyclic DAG structures that cause infinite loops in proof chain construction (Critical severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Parameterized query safety] The query at line 25 uses parameterized query with [mci], which is safe from SQL injection. However, is the mci value validated to be an integer before being passed to the query? Could non-integer values cause database errors or unexpected behavior (Medium severity - DoS)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Unit hash query] The query at line 32-34 uses [objBall.unit] as parameter. The objBall.unit comes from the previous database query result (line 28), so it should be safe. But what if objBall.unit is null or malformed due to database corruption? Would this cause query errors (Medium severity - DoS)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Unit parameter validation] The unit parameter is used directly in queries at lines 79 and 117-118 via [_unit] and [interim_unit]. If the unit parameter is attacker-controlled (e.g., from a light client request), could malicious unit hashes cause database errors or be used to probe the database structure (Medium severity - information disclosure or DoS)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [MCI parameter in queries] The mci parameter is used in multiple queries (lines 117, 143). If mci is attacker-controlled and not validated, could negative or extremely large MCI values cause database performance issues or errors (Medium severity - DoS)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChain()] [Proof chain completeness] The proof chain is built by appending balls to arrBalls. Does the calling code (light.js) verify that the proof chain is complete (no missing balls between later_mci and earlier_mci)? If gaps exist in the returned arrBalls, could light clients accept incomplete proofs (Critical severity - fake proofs enabling fund theft)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChain()] [Ball hash verification] The code constructs ball objects with unit, parent_balls, skiplist_balls, and is_nonserial. Does the verification code (light.js:processHistory, light.js:processLinkProofs) recompute ball hashes and compare them? If not, could malicious nodes send proof chains with incorrect ball data (Critical severity - fake proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Skiplist validation by light clients] Light clients receive proof chains with skiplist_balls arrays (line 49). Do light clients verify that the skiplist references are correct and that the skiplist chain is valid? If not, could malicious nodes send fake skiplist entries to make light clients accept invalid MCIs (Critical severity - fake proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Last mile path validation] Light clients receive last mile portions of proof chains showing the path from MC unit to target unit. Do light clients verify that this path is the shortest or canonical path? Could malicious nodes send unnecessarily long paths that include invalid intermediate units (Critical severity - fake proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Catchup chain construction] The buildProofChainOnMc function is used in catchup.js:prepareCatchupChain. If a syncing node receives a catchup chain with gaps or incorrect balls, would the processCatchupChain validation catch these errors? Could malicious nodes send fake catchup chains to corrupt newly syncing nodes (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Catchup stability points] Catchup chains are built between stable MCIs. If the earlier_mci or later_mci are not actually stable (e.g., due to database corruption or attack), could this cause syncing nodes to accept unstable units as part of the stable chain (Critical severity - permanent chain split)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChain()] [Large MCI range DoS] If an attacker requests a proof chain with a very large MCI range (e.g., later_mci=1000000, earlier_mci=0), even with skiplist optimization, the proof chain construction could take significant time and memory. Could this be exploited to DoS nodes by flooding them with expensive proof chain requests (Medium severity - transaction delay)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Memory exhaustion via arrBalls] The arrBalls array grows as proof chain construction proceeds (line 50). For very long chains, could this array consume excessive memory, potentially causing out-of-memory errors and node crashes (Medium severity - network halt)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Deep DAG structure DoS] If the target unit is very far off the main chain (many hops from MC unit), the last mile traversal could be very deep. Could an attacker create or request proofs for units with extremely long off-chain paths to cause excessive database queries and processing (Medium severity - transaction delay)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [determineIfIncluded performance] The graph.determineIfIncluded() function is called for each parent in the async.eachSeries loop (line 128). If this function is computationally expensive and an attacker creates units with many parents, could this cause DoS (Medium severity - transaction delay)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChain()] [Genesis unit handling] What happens when earlier_mci = 0 (genesis unit)? The proof chain construction should handle this gracefully, but are there any edge cases in skiplist traversal or parent finding that break at MCI 0 (High severity - inability to verify genesis transactions)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildProofChainOnMc()] [Single MCI range] When later_mci = earlier_mci + 1 (adjacent MCIs), the code should add one ball and terminate. Does the skiplist logic correctly handle this case, or could there be off-by-one errors (Medium severity - incorrect proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Unit equals MC unit] At line 147-148, if mc_unit === unit, onDone is called immediately. But what if the unit parameter is incorrect and doesn't actually match the MC unit at the given mci? Would this cause an empty proof chain to be generated when a full proof is needed (Critical severity - incomplete proofs)?",
  "[File: byteball/ocore/proof_chain.js] [Function: buildLastMileOfProofChain()] [Target unit as parent] In findParent, at line 121-122, if the target unit is found directly in arrParents, addBall is called for it. What if the target unit is both a parent and has other parents that also need to be included in the proof chain? Would the proof chain be incomplete (Critical severity - incomplete proofs)?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [SQL Injection] In the setField() function, the field parameter is validated against a whitelist but then directly concatenated into the SQL query string. Can an attacker bypass the whitelist check by exploiting race conditions or by modifying the field variable after the validation but before the query execution, allowing arbitrary SQL injection?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [SQL Injection] The setField() function uses string concatenation to build the SQL UPDATE query with the field parameter. Even with the whitelist check, could database-specific features (e.g., SQLite's column name handling or MySQL's special characters) allow an attacker to inject malicious SQL by crafting a hash value that escapes query context?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [SQL Injection] If the whitelist in setField() is ever extended to include user-controlled field names in the future, could the current string concatenation approach create a critical SQL injection vulnerability that allows attackers to modify arbitrary database columns or drop tables?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getHash()] [Hash Collision] The getHash() function uses SHA256 on a simple string concatenation (title + text + creation_date) without any delimiters or length prefixing. Can an attacker create two different contracts with colliding hashes by exploiting ambiguity in the concatenation (e.g., title='AB', text='C' vs title='A', text='BC' both hash to 'ABC')?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getHash() vs getHashV1()] [Hash Migration] Two different hash functions exist (getHash using crypto.createHash and getHashV1 using objectHash.getBase64Hash). Can an attacker exploit the difference between these hash algorithms to create a contract that validates with one hash function but produces different output with the other, causing contract disputes or replay attacks?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getHash()] [Preimage Attack] The getHash() function creates a hash from concatenated title, text, and creation_date strings without salting or any secret. Can an attacker precompute rainbow tables or use birthday attacks to find colliding contract hashes that allow them to replace legitimate contracts with malicious ones?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getHash()] [Length Extension Attack] Since getHash() uses plain SHA256 without HMAC on concatenated strings, could an attacker exploit SHA256's length extension property to forge valid contract hashes by appending data to existing contracts without knowing the original creation_date?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()] [Input Validation] The createAndSend() function accepts title and text parameters without any length validation or sanitization before storing them in the database. Can an attacker send extremely large title/text values (e.g., multi-GB strings) that cause database bloat, memory exhaustion, or denial of service when other nodes sync these contracts?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()] [Address Validation] The createAndSend() function stores peer_address and my_address without validating they are properly formatted Obyte addresses. Can an attacker provide malformed addresses that corrupt database queries, bypass foreign key constraints, or cause crashes in downstream address validation logic?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: store()] [NULL Injection] The store() function accepts objContract.shared_address and objContract.status as optional fields without null/undefined validation. Can an attacker exploit this by sending contracts with crafted null values that bypass database constraints or cause SQL errors when these fields are later queried?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()] [TTL Validation] The createAndSend() function accepts a ttl parameter without validating it's a positive number or within reasonable bounds. Can an attacker set ttl to negative values, zero, Infinity, or extremely large numbers (e.g., Number.MAX_SAFE_INTEGER) that cause integer overflow, expiration logic bypass, or timestamp calculation errors?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: store()] [JSON Injection] The store() function stores cosigners without validating the array structure before inserting. If objContract.cosigners is not provided or is malformed, can an attacker cause JSON.stringify() to produce invalid JSON that corrupts the database or breaks decodeRow() parsing later?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [Race Condition] The setField() function performs an UPDATE query without any locking or transaction isolation. If two concurrent calls try to update the same contract hash with different field values (e.g., one sets status='accepted', another sets status='declined'), can this create an inconsistent state where the contract's final status is non-deterministic?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend() + store()] [Race Condition] If two devices simultaneously call createAndSend() with the same contract hash, both database inserts might succeed (since there's no unique constraint enforcement before the query). Can this create duplicate contract records that cause confusion when getByHash() returns an arbitrary duplicate?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: respond()] [Race Condition] The respond() function calls composeAuthorsAndMciForAddresses() and then sends a device message, but these are not atomic operations. If the device connection drops between author composition and message sending, can the contract enter an inconsistent state where one party believes a response was sent but the other never received it?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [TOCTOU] The setField() function validates the field parameter in a whitelist check, then uses it in a SQL query. If there's a time gap between these operations and the field variable is mutable, can an attacker exploit a time-of-check-to-time-of-use vulnerability to inject a malicious field name after validation passes?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: store()] [Foreign Key Violation] The store() function inserts a contract with peer_address, peer_device_address, and my_address, but only the prosaic_contracts table schema shows a foreign key constraint on my_address. Can an attacker provide invalid peer_address or peer_device_address values that don't exist in correspondent or device tables, creating orphaned records that break referential integrity?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [Inconsistent State] The setField() function allows updating status, shared_address, or unit independently without cross-field validation. Can an attacker set shared_address or unit on a contract that has status='declined' or 'revoked', creating logically invalid states that confuse wallet logic expecting these fields to only exist on accepted contracts?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()] [Primary Key Collision] The createAndSend() function uses the hash as the primary key, but if two contracts have the same title, text, and creation_date (same second), they'll have identical hashes. Can an attacker intentionally create hash collisions by sending multiple contracts in the same second with identical content, causing INSERT to fail or overwrite existing contracts?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: store()] [INSERT IGNORE Semantics] The store() function uses INSERT IGNORE (via db.getIgnore()) which silently fails if the hash already exists. Can an attacker exploit this to prevent legitimate contract storage by front-running and inserting a malicious contract with the same hash first, effectively censoring the victim's contract?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [Authorization Bypass] The setField() function allows updating any contract's status, shared_address, or unit without verifying the caller has permission to modify that contract. Can any attacker call setField() with an arbitrary hash to maliciously change contract states (e.g., setting status='accepted' on a declined contract)?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: share()] [Information Disclosure] The share() function retrieves a contract by hash and sends it to an arbitrary device_address without checking if that device has permission to view the contract. Can an attacker call share() with a victim's contract hash and their own device address to steal confidential contract details (title, text, cosigners)?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: respond()] [Device Impersonation] The respond() function sends a contract response to objContract.peer_device_address without verifying that peer_device_address is still the legitimate owner of peer_address. If a device key is compromised or transferred, can an attacker intercept contract responses intended for the original device?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getByHash() + getAllByStatus()] [Privacy Leak] These query functions don't filter results by caller identity, allowing any code with database access to retrieve all contracts. Can a malicious module or compromised dependency query all pending contracts and extract sensitive business terms, party identities, or negotiation details?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()] [Replay Attack] The createAndSend() function generates a contract hash based only on title, text, and creation_date without including any nonce or sender identity. Can an attacker replay a legitimate contract offer to multiple victims by re-sending the same contract object with different peer_device_address values?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: respond()] [Response Replay] The respond() function sends a signed_message but doesn't include any expiration timestamp or nonce in the response structure. Can an attacker capture a legitimate acceptance response and replay it later (e.g., after the contract has been revoked) to falsely claim the contract was accepted?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()] [Message Tampering] The createAndSend() function sends a contract object to peer_device_address via device.sendMessageToDevice() but doesn't verify the message was delivered or signed by the sender's device key. Can a man-in-the-middle attacker intercept and modify the contract object (e.g., changing peer_address to steal contract benefits)?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: share()] [Unsolicited Sharing] The share() function sends contract details to an arbitrary device_address without the recipient requesting it. Can an attacker spam victims by repeatedly calling share() with the same contract hash, causing denial of service through message queue flooding or notification spam?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: respond()] [Signature Validation Gap] The respond() function calls composer.composeAuthorsAndMciForAddresses() when status='accepted' but doesn't verify the resulting authors array is valid or matches expected addresses. Can a malicious composer module inject fake author data that allows impersonation or unauthorized contract acceptance?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()] [Callback Error Propagation] The createAndSend() function's database insert callback doesn't check for errors before calling device.sendMessageToDevice(). If the database insert fails (e.g., due to constraint violation), can the contract message still be sent, creating a state mismatch where the peer receives a contract that doesn't exist in the sender's database?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: respond()] [Error Callback Missing] The respond() function sets a default empty callback (cb = function(){}) when cb is not provided, causing errors to be silently swallowed. If composer.composeAuthorsAndMciForAddresses() returns an error, can the contract enter an inconsistent state where status remains 'pending' but the peer believes it was declined?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: store()] [Insert Failure Ignored] The store() function calls the callback with the result object but doesn't check if the insert succeeded (affectedRows > 0). Can an attacker exploit INSERT IGNORE failures to make the caller believe a contract was stored when it actually failed, leading to logic errors in wallet.js that assumes storage succeeded?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getByHash() + getBySharedAddress()] [Null Callback] Both query functions call cb(null) when no rows are found, but calling code might not distinguish between 'not found' and 'error occurred'. Can this ambiguity cause wallet logic to mishandle missing contracts, treating them as errors or vice versa?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: decodeRow()] [JSON Parse Error] The decodeRow() function calls JSON.parse(row.cosigners) without try-catch error handling. If the database contains malformed JSON (e.g., due to direct SQL manipulation or migration bugs), can this cause an unhandled exception that crashes the node when iterating through contracts via getAllByStatus()?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()] [JSON Stringify Injection] The createAndSend() function calls JSON.stringify(cosigners) without validating the cosigners array structure. Can an attacker provide a cosigners object with circular references, getters, or prototype pollution that causes JSON.stringify() to throw, hang, or produce malicious JSON?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: decodeRow()] [Prototype Pollution] The decodeRow() function parses JSON cosigners and assigns it directly to row.cosigners. If the parsed JSON contains __proto__ or constructor properties, can an attacker pollute the Object prototype when this row object is later used, affecting all JavaScript objects in the process?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: decodeRow()] [Date Parsing] The decodeRow() function creates a Date object by replacing spaces with 'T' and appending '.000Z', assuming the database stores dates in 'YYYY-MM-DD HH:MM:SS' format. Can database timezone differences, daylight saving time, or SQLite vs MySQL date format inconsistencies cause creation_date_obj to be incorrect, breaking TTL expiration logic?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getHash()] [Timestamp Precision] The getHash() function hashes the creation_date string which only has second precision. Can an attacker create multiple contracts within the same second with identical title and text, all producing the same hash and colliding in the database primary key?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getAllByStatus()] [Query Performance] The getAllByStatus() function queries contracts by status with DESC ordering but no LIMIT clause. If an attacker creates millions of contracts in 'pending' status, can this query cause database slowdown, memory exhaustion when loading all rows, or lock contention that delays other transactions?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: decodeRow()] [Infinite Loop] The getAllByStatus() function iterates through rows and calls decodeRow() on each, but the iteration result is not used (row = decodeRow(row) doesn't modify the original rows array). If decodeRow() modifies row state in a way that causes the iteration to never complete or triggers repeated calls, can this create an infinite loop or resource exhaustion?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getHash()] [Hash Computation Cost] The getHash() function computes SHA256 on potentially large title and text strings. Can an attacker create contracts with multi-megabyte titles/texts that cause hash computation to consume excessive CPU, creating a denial of service when other nodes validate these contracts?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()  device.sendMessageToDevice()] [Message Injection] The createAndSend() function constructs objContract with user-controlled fields (title, text, peer_address) and sends it via device messaging. Can an attacker inject special characters or escape sequences in these fields that break the device message protocol or allow message spoofing when the peer parses the contract?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: respond()  composer.composeAuthorsAndMciForAddresses()] [Composer Exploit] The respond() function passes objContract.my_address to composer.composeAuthorsAndMciForAddresses() without validating it's owned by the current wallet. Can an attacker craft a contract with my_address set to a victim's address, causing the composer to leak the victim's signing paths or attempt to create unauthorized signatures?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: store()  wallet.js validation] [Validation Bypass] The store() function is called by wallet.js after validation, but store() itself performs no validation. If an attacker can call store() directly (e.g., through a different code path or compromised module), can they insert contracts with invalid addresses, malformed fields, or malicious content that bypasses all wallet validation checks?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [Invalid Status Transition] The setField() function allows changing status to any value in the CHECK constraint (pending, revoked, accepted, declined) without validating the transition is legal (e.g., a contract can't go from 'revoked' back to 'pending'). Can an attacker exploit this to resurrect revoked contracts or downgrade accepted contracts back to pending, causing confusion in multi-party negotiations?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [Concurrent Status Changes] If two parties simultaneously call setField() to change a contract's status (e.g., one accepts, one declines), the final status depends on which UPDATE executes last. Can this race condition cause contracts to enter invalid states where both parties believe their action succeeded but only one status prevails, leading to disputes?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [Shared Address Hijacking] The setField() function allows setting shared_address to any value without verifying the address was jointly created by both contract parties. Can an attacker unilaterally set shared_address to an address they fully control, stealing any funds sent to what the victim believes is a multi-sig escrow address?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getBySharedAddress()] [Address Collision] The getBySharedAddress() function assumes shared_address is unique across contracts, but the database schema doesn't enforce a UNIQUE constraint on this field. Can two unrelated contracts share the same shared_address, causing getBySharedAddress() to return the wrong contract and allowing attackers to impersonate or interfere with unrelated contract execution?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [Unit Validation Missing] The setField() function allows setting the unit field to any 44-character string without verifying it's a valid unit hash that exists in the DAG. Can an attacker set unit to a non-existent or malicious unit hash that causes wallet logic to incorrectly believe contract execution occurred, enabling fund theft or double-spending?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField()] [Unit Replay] The setField() function doesn't prevent the same unit hash from being assigned to multiple contracts. Can an attacker reuse a single unit hash across multiple unrelated contracts, making it appear that one on-chain transaction fulfilled many off-chain contracts simultaneously, allowing the attacker to claim multiple payments for a single unit?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()] [Cosigners Type Confusion] The createAndSend() function calls JSON.stringify(cosigners) without verifying cosigners is an array or validating its contents. Can an attacker provide cosigners as a string, number, or object with malicious properties that cause unexpected behavior when decodeRow() later parses it back?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: decodeRow()] [Missing Cosigners Validation] The decodeRow() function parses row.cosigners only if it's truthy, but doesn't validate the parsed result is an array of valid addresses. Can an attacker store a contract with cosigners='[]' or cosigners='null' that causes wallet logic expecting a populated cosigners array to crash or malfunction?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: respond()] [CSRF in Device Messages] The respond() function sends contract responses to peer_device_address without any anti-replay token or request-response matching. Can an attacker trick a victim into sending a response message by crafting a fake contract offer that appears legitimate, causing the victim to unknowingly accept a malicious contract?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: createAndSend()] [State Divergence] The createAndSend() function inserts a contract into the database with certain fields (hash, my_address, peer_address) but constructs objContract for device messaging with potentially different values due to field order or transformation. Can these two representations diverge, causing the stored contract to have different properties than what was sent to the peer?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: share()] [Stale Data] The share() function retrieves a contract via getByHash() and immediately sends it, but doesn't use database transactions or locking. If the contract is modified between retrieval and sending, can the recipient receive outdated contract information (e.g., old status='pending' when it's actually 'accepted')?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: setField() + respond()] [Expired Contract Modification] The prosaic_contract.js module stores TTL in the database but never enforces TTL expiration before allowing status changes or other updates. Can an attacker call setField() or respond() on contracts that expired weeks ago, modifying them long after they should have become immutable?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: getByHash() + getAllByStatus()] [Expired Contract Query] Query functions return all contracts regardless of TTL expiration. Can an attacker exploit expired contracts by interacting with them through wallet.js, potentially causing the wallet to attempt operations on contracts that should have been automatically archived or deleted?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: store()] [Validation Mismatch] The store() function is designed to be called after wallet.js validation, but accepts all contract fields without re-validating. If wallet.js validation logic has bugs or is bypassed, can malicious contracts with invalid hashes, mismatched addresses, or malformed dates be persisted to the database?",
  "[File: byteball/ocore/prosaic_contract.js] [Function: respond()  composeAuthorsAndMciForAddresses()] [MCI Manipulation] The respond() function includes authors with MCI information in the response. Can an attacker manipulate timing to include an outdated or incorrect MCI that causes the peer to accept a response based on stale main chain state, potentially enabling double-spending or timeline manipulation?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Signature Verification Bypass] Can an attacker submit a unit with an invalid signature that causes the secp256k1.ecdsaVerify() call to throw an exception, which is caught and returns false, but if definition.js does not properly handle the false return in a multi-sig 'or' condition, could this allow unauthorized spending by exploiting short-circuit evaluation logic?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Exception Handling] If Buffer.from(b64_sig, 'base64') fails to decode due to malformed base64 input, does the try-catch block guarantee that false is returned, or could an edge case in the secp256k1 library cause undefined behavior that bypasses signature checks in definition.js line 685?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Signature Malleability] Does the ECDSA signature verification using secp256k1.ecdsaVerify() enforce low-S values to prevent signature malleability, and if not, could an attacker create multiple valid signatures for the same unit hash, potentially causing the same unit to be processed multiple times with different signatures, leading to consensus divergence?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Base64 Decoding] If the b64_sig parameter contains whitespace, null bytes, or other non-standard base64 characters that Buffer.from() silently ignores during decoding, could two signatures with different string representations but identical decoded values both verify successfully, breaking the assumption that each signature string is unique and potentially enabling replay attacks?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Public Key Validation] Does the verify() function validate that b64_pub_key decodes to a valid 33-byte compressed or 65-byte uncompressed secp256k1 public key before passing to ecdsaVerify(), or can an attacker supply a malformed public key that causes ecdsaVerify() to throw an exception, return true unexpectedly, or exhibit non-deterministic behavior across different Node.js versions?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Signature Length] If b64_sig decodes to a buffer that is not exactly 64 bytes (32 bytes for r + 32 bytes for s), does secp256k1.ecdsaVerify() reject it deterministically, or could certain lengths (e.g., 63, 65 bytes) pass verification on some nodes but fail on others due to library version differences, causing a permanent chain split?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Hash Validation] Does verify() validate that the hash parameter is exactly 32 bytes before calling ecdsaVerify(), or can an attacker pass a truncated or extended hash that causes non-deterministic verification results across nodes, leading to units being accepted by some nodes and rejected by others?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Exception Logging Side Channel] The catch block logs 'signature verification exception: '+e.toString() to console at line 18, potentially exposing timing information about which types of malformed inputs cause exceptions versus normal rejection - could an attacker use this timing side channel to fingerprint node implementations or craft signatures that exploit specific exception paths?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Return Value Ambiguity] If ecdsaVerify() returns a value other than true/false (e.g., undefined, null, 1, 0) due to a library bug or version mismatch, does the verify() function explicitly coerce the return value to boolean, or could definition.js line 685 misinterpret truthy/falsy values and accept invalid signatures?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Concurrent Modification] If multiple threads or callbacks simultaneously call verify() with the same b64_sig or b64_pub_key strings while Buffer.from() is executing, could race conditions in Buffer allocation or the secp256k1 library's internal state cause non-deterministic verification results?",
  "[File: byteball/ocore/signature.js] [Function: sign()] [Private Key Exposure] Does the sign() function validate that priv_key is a 32-byte buffer before passing to secp256k1.ecdsaSign(), or could an attacker cause an exception by passing malformed private key data that gets logged in error messages, potentially exposing key material?",
  "[File: byteball/ocore/signature.js] [Function: sign()] [Signature Determinism] Does secp256k1.ecdsaSign() use deterministic ECDSA (RFC 6979) to ensure the same hash+privkey always produces the same signature, or could non-deterministic k-values cause different nodes to generate different signatures for the same unit, breaking unit hash consistency and causing consensus failure?",
  "[File: byteball/ocore/signature.js] [Function: sign()] [Signature Encoding] The function converts the signature to base64 at line 9 - if the resulting base64 string contains characters that are later mishandled during URL encoding, database storage, or JSON serialization in other modules, could this cause signature verification to fail intermittently, freezing funds in addresses that require these signatures?",
  "[File: byteball/ocore/signature.js] [Function: sign()] [Error Handling] If secp256k1.ecdsaSign() throws an exception (e.g., due to invalid private key), sign() does not have a try-catch block and will propagate the exception - could this cause wallet.js or composer.js to crash mid-transaction, potentially creating partially signed units that corrupt the local database?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Length Bypass] At line 101, the function checks if contentAloneB64.length > 736 to reject oversized keys - can an attacker craft a PEM key with exactly 736 base64 characters that decodes to a buffer large enough to cause memory exhaustion or buffer overflow in subsequent crypto operations when used in formula/evaluation.js line 1605?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [ASN.1 Parsing Vulnerability] Lines 113-130 manually parse ASN.1 sequence length tags (0x7F, 0x81, 0x82) without validating that identifiersStart and identifiersLength stay within buffer bounds - could an attacker craft a malformed PEM key where identifiersLength is larger than the remaining buffer, causing out-of-bounds reads at line 138 that leak memory contents or crash the node?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Curve Identifier Spoofing] The function extracts typeIdentifiersHex at line 138 and validates it against objSupportedPemTypes at line 140 - but if an attacker crafts a PEM key with valid ASN.1 structure but typeIdentifiersHex that matches a weak or deprecated curve (e.g., secp112r1, sect113r1 with only 56-bit security), could AAs using is_valid_sig accept signatures from keys that can be brute-forced, allowing attackers to forge oracle data or authorization proofs?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Algo Parameter Bypass] Lines 143-148 check if algo parameter is 'ECDSA' or 'RSA' and reject mismatches - but if algo is set to 'any', the function accepts any key type in objSupportedPemTypes - could an attacker exploit formula/evaluation.js by providing an RSA key where an ECDSA key was intended (or vice versa), causing is_valid_sig operations to succeed with incompatible key types and break AA logic assumptions?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Key Length Validation] At line 150, ECDSA keys are validated to have correct hex_pub_key_length, but RSA keys (line 346-349) have no length validation - could an attacker supply a malformed RSA key with arbitrary length that passes validation but causes verifyMessageWithPemPubKey() to exhibit non-deterministic behavior across different OpenSSL versions, breaking AA execution consensus?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Identifier Length Validation] At line 133, identifiersLength is checked against fixed values (13, 16, 19, 20), but the error message at line 134 includes the actual identifiersLength value - could an attacker use different malformed lengths to fingerprint the exact OpenSSL version or Node.js build on a target node, then craft exploits specific to that version's bugs?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Whitespace Normalization] Lines 99 removes all whitespace using .replace(/\\\\s/g, '') - if this regex fails to match certain Unicode whitespace characters (e.g., zero-width spaces, non-breaking spaces), could two PEM keys that are identical except for exotic whitespace both pass validation but produce different formatted_pem_key outputs, causing non-deterministic is_valid_sig results in AAs?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Base64 Validation Bypass] At line 104, the function calls ValidationUtils.isValidBase64() - if this validation can be bypassed by base64 strings with non-standard characters that Buffer.from() at line 107 silently ignores, could an attacker create a PEM key that passes string validation but decodes to unexpected bytes, causing buffer[0] != 0x30 check at line 109 to fail intermittently depending on how Buffer.from() handles the invalid input?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Second Sequence Check] Lines 114, 119, 124 check that buffer[2], buffer[3], or buffer[4] equals 0x30 (second sequence marker) depending on length encoding - if an attacker provides a PEM key where these checks pass but the actual sequence is malformed, could subsequent crypto operations using this key cause undefined behavior in the Node.js crypto module, potentially accepting invalid signatures?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Type Confusion] If objSupportedPemTypes contains a maliciously added entry (through prototype pollution or other means) that maps an identifier to algo: 'ECDSA' but with RSA key structure, could validateAndFormatPemPubKey() accept the key as ECDSA, then have verifyMessageWithPemPubKey() process it as RSA, causing signature verification to succeed incorrectly?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Encoding Detection] At line 27, encoding is determined by ValidationUtils.isValidHexadecimal(signature) - if the signature string is valid hex but was intended to be base64 (or vice versa), could the wrong encoding be selected, causing verify.verify() to fail silently and return false when the signature is actually valid, breaking AA is_valid_sig operations that should succeed?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Node.js API Compatibility] Lines 29-42 attempt two different crypto.verify() call signatures to handle Node.js version differences - if a node runs on an unsupported Node.js version where both signatures fail, could the double try-catch return false for all signatures (even valid ones), causing all AA is_valid_sig checks to fail and freezing any funds controlled by AAs that use PEM signature verification?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [TypeError Handling] At line 32, the code specifically checks for TypeError to switch API styles - but if the first verify.verify() call throws a different error type (e.g., RangeError, SecurityError) due to malformed pem_key, this error won't be caught by the second try-catch and will propagate, potentially crashing the AA evaluation in formula/evaluation.js and causing the entire unit validation to fail?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Message Encoding] The function calls verify.update(message) at line 25 without specifying encoding - does crypto.createVerify() treat message as UTF-8 string or raw bytes, and if formula/evaluation.js passes a binary message that gets mangled by string encoding, could valid signatures be rejected, freezing funds in AAs that use is_valid_sig for authorization?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Signature Length] Formula/evaluation.js validates signature length  1024 bytes at line 1595, but verifyMessageWithPemPubKey() has no such check - if a future code change removes the upstream check, could an attacker supply an extremely large signature that causes crypto.verify() to consume excessive memory or CPU, creating a DoS attack that delays unit processing for hours?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Exception Logging] Lines 35, 39 log exceptions to console - if these logs contain parts of the pem_key or signature that were malformed, could sensitive cryptographic material be exposed in logs, allowing an attacker who gains read access to logs to extract private keys or forge signatures?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Non-Deterministic Verification] If the crypto.verify() implementation in different Node.js versions or OpenSSL builds produces different results for the same message/signature/key triple (e.g., due to different curve implementations), could nodes running different versions reach different consensus on whether an AA is_valid_sig check passes, causing a permanent chain split where half the network accepts a unit and half rejects it?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Return Type Validation] Does verify.verify() always return a strict boolean true/false, or could it return truthy/falsy values that get misinterpreted when returned at line 29/33, causing formula/evaluation.js line 1606 to incorrectly evaluate the result?",
  "[File: byteball/ocore/signature.js] [Function: signMessage()] [Default Encoding] At lines 73-74, if encoding parameter is falsy, it defaults to 'base64' - but if caller passes encoding=null or encoding=undefined explicitly, does JavaScript's truthiness check treat these differently than omitting the parameter, potentially causing inconsistent signature encodings across different calling contexts?",
  "[File: byteball/ocore/signature.js] [Function: signMessage()] [PEM Key Validation] signMessage() accepts any pem_key without validation - could an attacker call this function directly (or through vrfGenerate/signMessageWithRsaPemPrivKey) with a malformed PEM key that causes sign.sign() at line 79 to throw an exception containing the private key contents, leaking the key material?",
  "[File: byteball/ocore/signature.js] [Function: signMessage()] [Node.js API Compatibility] Lines 79-86 use double try-catch to handle different Node.js API versions - if the first sign.sign(pem_key, encoding) succeeds on one node version but the second sign.sign({key: pem_key}, encoding) succeeds on another version, and these produce different signature formats, could signatures generated on different nodes be incompatible, causing validation failures?",
  "[File: byteball/ocore/signature.js] [Function: signMessage()] [Null Return] If both sign.sign() calls at lines 79, 82 throw exceptions, the function returns null at line 85 - do all callers of signMessage() properly check for null, or could null signatures propagate to validation code causing units to be accepted without valid signatures?",
  "[File: byteball/ocore/signature.js] [Function: signMessageWithEcPemPrivKey()] [PEM Formatting] Lines 47-51 reconstruct the PEM key by removing and re-adding headers/footers with specific newline formatting - if the original pem_key had different whitespace (e.g., \\\\r\\\\n vs \\\\n, extra spaces), does this normalization ensure that the private key material is identical, or could subtle differences in ASN.1 padding cause different signing results?",
  "[File: byteball/ocore/signature.js] [Function: signMessageWithEcPemPrivKey()] [Header Validation] The regex at line 47 matches both '-----BEGIN EC PRIVATE KEY-----' headers, but what if pem_key contains multiple headers or malformed headers - does replace() remove all of them or just the first occurrence, potentially leaving malicious content in the key?",
  "[File: byteball/ocore/signature.js] [Function: signMessageWithRsaPemPrivKey()] [Conditional PEM Formatting] Lines 61-68 only reformat the PEM key if it includes 'BEGIN RSA PRIVATE KEY' - but if an RSA private key is provided in PKCS#8 format (BEGIN PRIVATE KEY) instead of PKCS#1 (BEGIN RSA PRIVATE KEY), the formatting is skipped - could this cause signMessage() to fail with certain valid RSA keys, breaking VRF generation in formula/evaluation.js?",
  "[File: byteball/ocore/signature.js] [Function: signMessageWithRsaPemPrivKey()] [VRF Security] The vrfGenerate() function at line 55-57 simply calls signMessageWithRsaPemPrivKey(seed, 'hex', privkey) - but true VRF (Verifiable Random Function) requires additional properties like unpredictability and collision resistance - does this implementation actually provide VRF security, or is it just a regular signature that could be exploited by attackers who can predict VRF outputs?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Integration with definition.js] When definition.js line 685 calls ecdsaSig.verify() during 'sig' evaluation, if the unit_hash_to_sign was computed incorrectly in object_hash.js due to non-deterministic JSON serialization, could verify() return true for an invalid signature because it's checking against the wrong hash, allowing unauthorized spending?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Placeholder Signature] Definition.js line 683 allows signatures starting with '-' as placeholders when bUnsigned=true - if this flag is set incorrectly during validation (e.g., during catchup), could nodes accept unsigned units as valid, allowing anyone to spend from addresses defined with 'sig' operators?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [AA Formula Integration] Formula/evaluation.js line 1605 uses verifyMessageWithPemPubKey() for is_valid_sig operations - if the evaluated_message contains malicious Unicode or control characters that are normalized differently by crypto.createVerify() versus the AA formula string handling, could an attacker create a signature that verifies in is_valid_sig but fails when actually used, breaking AA logic?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Formula Integration] Formula/evaluation.js validates signature length  1024 but not PEM key length - if an attacker provides a massive PEM key (up to 736 base64 chars = ~552 bytes) that passes validateAndFormatPemPubKey(), could the subsequent verifyMessageWithPemPubKey() consume excessive CPU during cryptographic operations, delaying AA execution and causing network-wide slowdown?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Network.js Authentication] Network.js uses verify() for device authentication - if an attacker can cause verify() to return true for invalid signatures through exception handling bugs, could they impersonate any device and send malicious units/messages to other peers, potentially executing DoS or eclipse attacks?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [VRF Verification] Formula/evaluation.js line 1637 uses verifyMessageWithPemPubKey() to verify VRF proofs in vrf_verify operations - but if the 'proof' is just a normal RSA signature (not a real VRF proof), could an oracle manipulate vrf_verify results by generating multiple signatures until finding one that produces a desired output, breaking the unpredictability guarantee of VRFs?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [secp256k1 Library] The verify() function uses the 'secp256k1' npm package at line 3 - if this library has a critical vulnerability (e.g., non-constant-time operations leaking private keys via timing attacks), could an attacker who controls network timing observe signature verification times and extract private keys from witness or oracle nodes?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [SHA256 Weakness] The function uses crypto.createVerify('SHA256') at line 24 - if a SHA256 collision is discovered (birthday attack requiring ~2^128 operations), could an attacker create two different messages with the same SHA256 hash, allowing them to sign one message legitimately then substitute another message that also verifies, breaking oracle data integrity or AA authorization?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Weak Curves] objSupportedPemTypes includes weak curves like secp112r1 (56-bit security), sect113r1 (60-bit security), and secp128r1 (64-bit security) - could an attacker brute-force private keys for these curves in hours/days on modern hardware, then forge signatures for AAs that use is_valid_sig with these weak curves, stealing all funds controlled by such AAs?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Binary Field Curves] objSupportedPemTypes includes binary field curves (sect113r1, sect131r1, etc.) which have been deprecated due to security concerns - could these curves have implementation bugs in OpenSSL that cause non-deterministic verification results across different nodes, leading to permanent chain splits?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Brainpool Curves] objSupportedPemTypes includes Brainpool curves (brainpoolP160r1, etc.) which have controversial origin and potential backdoors - could state-level attackers who know the curve generation parameters exploit structural weaknesses to forge signatures, bypassing AA access controls?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [OpenSSL Version Differences] If different nodes run different OpenSSL versions (e.g., OpenSSL 1.0.2 vs 1.1.1 vs 3.0), could subtle differences in RSA padding validation, curve implementation, or hash computation cause verifyMessageWithPemPubKey() to return different results for the same inputs, leading to permanent chain split when validating AA units?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Library Version Pinning] Does package.json pin the exact version of the 'secp256k1' library, or could nodes running different versions (e.g., 4.x vs 5.x) have different validation behavior, causing some nodes to accept signatures that others reject, leading to network partition?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Normalization Non-Determinism] The whitespace removal at line 99 uses regex /\\\\s/g which matches different characters in different JavaScript engines - could Node.js updates change which Unicode codepoints are considered whitespace, causing the same PEM key to normalize differently pre/post-update and breaking signature verification for existing AAs?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Encoding Detection Non-Determinism] ValidationUtils.isValidHexadecimal() at line 27 determines encoding - if this function's behavior changes across validation_utils.js versions, could the same signature string be interpreted as hex on some nodes and base64 on others, causing verification to pass on some nodes and fail on others?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Buffer.from() Behavior] Does Buffer.from(b64_sig, 'base64') behave identically across all Node.js versions when handling invalid base64 (e.g., missing padding, invalid characters) - or could version differences cause the same b64_sig to decode to different byte arrays, leading to different verification results?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [CPU Exhaustion] If an attacker creates an AA that calls is_valid_sig with a 4096-bit RSA key (maximum size allowed by line 101 check), how long does a single verification take, and could an attacker trigger thousands of such verifications by sending many trigger units, causing all nodes to become CPU-bound and unable to process normal transactions for hours?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Quadratic Parsing] Lines 138 uses string.slice() on contentAloneHex which requires copying the substring - if an attacker provides many PEM keys near the 736-character limit, could the repeated string operations cause quadratic time complexity, slowing down unit validation and delaying transaction confirmation?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Signature Verification Cost] Each verify() call invokes secp256k1.ecdsaVerify() which requires elliptic curve point multiplication - if a unit has many authors each with 'sig' definitions, and each author's address requires multiple signature verifications through nested 'or'/'and' operators, could the total verification time exceed acceptable limits, causing such units to be rejected and freezing funds?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Exception Spam] Lines 35, 39 log every exception to console - could an attacker flood the network with units containing malformed PEM signatures that trigger these logs thousands of times per second, filling up disk with log files and causing node crashes due to out-of-disk-space errors?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Memory Allocation] Buffer.from(contentAloneB64, 'base64') at line 107 allocates a buffer that could be up to ~552 bytes - if an attacker creates thousands of AAs each using is_valid_sig with maximum-size PEM keys, and sends many trigger units simultaneously, could the memory allocation for validating all these keys cause nodes to run out of memory and crash?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Regex Injection] The whitespace removal at line 99 uses /\\\\s/g - if an attacker can influence the regex through prototype pollution (e.g., by setting String.prototype.replace), could they cause the regex to match unexpected characters or behave maliciously, allowing malformed PEM keys to pass validation?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Header/Footer Injection] Lines 96 removes PEM headers using simple string replace - if an attacker provides a PEM key with multiple headers or nested headers (e.g., '-----BEGIN PUBLIC KEY----------BEGIN PUBLIC KEY-----'), could the replace() only remove the first occurrence, leaving malicious content that passes validation but fails during crypto operations?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [ASN.1 Integer Overflow] When computing identifiersStart + identifiersLength at line 138, if identifiersLength is 255 (maximum value for a single byte) and identifiersStart is near the buffer length, could integer overflow cause the slice operation to read from before the start of the buffer, potentially leaking memory?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Message Encoding Injection] If the message parameter contains UTF-8 characters that crypto.createVerify() normalizes differently than the AA formula's string handling (e.g., different Unicode normalization forms NFC vs NFD), could an attacker create signatures that verify in the AA but fail when replayed, or vice versa?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Parameter Type Confusion] Does verify() validate that hash is a Buffer and b64_sig/b64_pub_key are strings, or if an attacker passes objects/arrays/functions as parameters, could type coercion in Buffer.from() or ecdsaVerify() cause unexpected behavior, crashes, or security bypasses?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Uncaught Exceptions] If secp256k1.ecdsaVerify() throws an exception type not caught by the generic catch block (e.g., OutOfMemoryError, StackOverflowError in edge cases), could this crash the validation process in definition.js, causing the unit to be neither accepted nor rejected and leaving it in limbo, freezing any inputs spent in that unit?",
  "[File: byteball/ocore/signature.js] [Function: signMessage()] [Exception Propagation] If crypto.createSign() throws an exception before the try-catch at lines 78-86 (e.g., if 'SHA256' algorithm is not available), the exception propagates uncaught - could this crash composer.js or wallet.js during transaction creation, leaving a partially composed unit in the database that corrupts future operations?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Early Return Errors] If any validation check fails (lines 93, 102, 105, 110, 129, 134, 141, 145, 147, 151), handle() is called with an error - but if the callback accidentally calls handle(null, value) after handle(error), could this cause double-callback bugs in formula/evaluation.js that lead to undefined behavior?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [TypeError Specificity] Line 32 checks 'if (e1 instanceof TypeError)' to distinguish between API version differences and actual errors - but if a malformed pem_key causes TypeError for a different reason (e.g., accessing undefined property), could the code incorrectly attempt the second API call, masking the real error and returning false for all signatures?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [Callback Error Handling] If the handle callback function throws an exception when called with an error at lines 93, 102, etc., does this crash the validation process, or is there error handling in the caller (formula/evaluation.js) that catches these exceptions and safely rejects the AA execution?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [ECDSA Malleability] For any valid ECDSA signature (r, s), the signature (r, -s mod n) is also valid - does secp256k1.ecdsaVerify() enforce canonical s values (s <= n/2), or could an attacker create two different signature strings for the same unit_hash_to_sign, allowing the same unit to be published twice with different signatures, potentially confusing unit tracking or replay detection?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Public Key Malleability] ECDSA public keys can be represented in compressed (33 bytes) or uncompressed (65 bytes) format - if b64_pub_key in a 'sig' definition uses uncompressed format, can an attacker create an equivalent compressed pubkey that produces different address definitions but validates the same signatures, potentially bypassing access controls?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [RSA Signature Padding] Does crypto.createVerify() enforce a specific RSA padding scheme (e.g., PKCS#1 v1.5 vs PSS), and if an attacker can create signatures with different padding that both verify successfully, could they replay signatures across different contexts or exploit padding oracle attacks?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Base64 Padding Malleability] Base64 encoding can have optional padding ('=' characters) - if the same signature encodes to 'ABC=' and 'ABC' (with/without padding), and both decode to the same bytes, could an attacker create units with slightly different signature strings that are all considered valid but appear to be different signatures in tracking systems?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [secp256k1 Library State] Does the secp256k1 library maintain any global state between verify() calls, and if so, could concurrent calls from multiple units being validated simultaneously corrupt this state, leading to incorrect verification results for some signatures?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [crypto Module State] Does crypto.createVerify() maintain state between calls, and if verify.verify() is called multiple times on the same verify object (which shouldn't happen given the code structure), could this produce incorrect results?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [objSupportedPemTypes Mutation] If any code mutates the objSupportedPemTypes object at runtime (lines 160-350) by adding/removing entries or modifying properties, could this cause validateAndFormatPemPubKey() to reject previously valid keys or accept previously invalid keys, breaking existing AAs that rely on specific curve support?",
  "[File: byteball/ocore/signature.js] [Module-Level State] Does signature.js maintain any module-level state that persists across function calls, and if multiple parts of the code import this module simultaneously, could they interfere with each other's operations, causing non-deterministic verification results?",
  "[File: byteball/ocore/signature.js] [Function: verify()] [Buffer Modification] After Buffer.from(b64_sig, 'base64') decodes the signature at line 14, but before ecdsaVerify() uses it at line 15, if another thread or callback modifies the signature buffer contents, could this cause the verification to check a different signature than what was intended, leading to incorrect authentication?",
  "[File: byteball/ocore/signature.js] [Function: validateAndFormatPemPubKey()] [PEM Key Modification] After contentAloneBuffer is created at line 107, multiple checks access different parts of the buffer (lines 109, 113-126, 137) - if the buffer is modified between these checks (though Buffer should be immutable), could later validation steps pass even if earlier steps should have rejected the key?",
  "[File: byteball/ocore/signature.js] [Function: verifyMessageWithPemPubKey()] [Message Modification] Between verify.update(message) at line 25 and verify.verify() at line 29/33, if the message variable is mutated (though this shouldn't happen with proper scoping), could the verification check a different message than was hashed?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Signature Bypass] In the signMessage() function at lines 77-86, when signer.sign() returns the special string '[refused]', the code treats this as an error and aborts signing. However, can an attacker craft a malicious custom signer that returns a valid-looking signature instead of '[refused]' to bypass multi-party approval requirements in multi-signature scenarios, allowing unauthorized message signing?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Authentifier Placeholder Attack] At lines 66-67, the code creates placeholder authentifiers using repeatString('-', length). If an attacker can manipulate the assocLengthsBySigningPaths values to return extremely large lengths (e.g., Integer.MAX_VALUE), can this cause memory exhaustion or integer overflow when creating placeholder strings, leading to denial of service or corrupted authentifier structures?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition Hash Bypass] At lines 189-190 and 205-206, the code validates that objectHash.getChash160(objAuthor.definition) matches the expected definition_chash or address. Can an attacker exploit hash collision vulnerabilities in the chash160 function to provide a malicious definition that hashes to the same value, allowing them to bypass authentication requirements and sign messages as another address?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Authentifier Validation Bypass] At lines 229-238, the code calls Definition.validateAuthentifiers() to verify signatures. If the validateAuthentifiers() function has a vulnerability that allows it to return true for invalid signatures under certain conditions (e.g., race conditions, type confusion), can an attacker craft a signed message that passes validation despite having forged signatures, leading to unauthorized actions?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Last Ball MCI Manipulation] At line 179, the code reads the address definition at a specific last_ball_mci point in time. If an attacker can manipulate or delay the last_ball_unit lookup (lines 160-175) to reference an MCI where the victim's address had a different, weaker definition (e.g., single-sig instead of multi-sig), can they bypass the current strong authentication requirements?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Text-to-Sign Manipulation] At line 69, the code generates text_to_sign using objectHash.getSignedPackageHashToSign(objUnit). If objUnit has been partially modified between lines 42-60 (definition/last_ball_unit setting) and line 69 (hash calculation) due to race conditions or callback timing, can this result in signing a different message than intended, leading to signature malleability?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Author Array Manipulation] At lines 136-146, the code iterates through all authors but only validates the one matching the expected address (or first author if no address specified). If an attacker includes multiple author objects with the same address but different definitions/authentifiers, can they exploit array iteration logic to have a malicious author validated instead of the legitimate one?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition Provider Attack] At lines 180-192, when a definition is not found in storage, the code expects it to be provided in objAuthor.definition and validates the hash. If an attacker can race the storage lookup to make the definition appear 'not found' when it actually exists with different content, can they force acceptance of a malicious definition that would otherwise be rejected?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Signing Path Manipulation] At lines 63-67, the code reads signing paths from signer.readSigningPaths() and creates authentifiers for each path. If an attacker can manipulate the signing paths returned (e.g., injecting duplicate paths, paths with special characters, or extremely long path strings), can this cause the signing process to create malformed authentifiers that bypass validation or cause crashes?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Version Bypass] At lines 128-129, the code checks if the version is in constants.supported_versions but only if version field exists. If an attacker omits the version field entirely (which passes this check), but downstream code assumes a default version with different validation rules, can they bypass stricter validation requirements of newer versions?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Catchup Race Condition] At lines 163-173, when last_ball_unit is not found and the node is catching up, the code waits for 'catching_up_done' event and retries. If an attacker times their signed message submission to arrive during catchup, and the last_ball_unit becomes valid during catchup but with different MCI than expected, can this cause non-deterministic validation results across different nodes, leading to chain split?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition Read Race] At lines 179-198, the code reads the definition from storage at a specific MCI. If another transaction is concurrently updating the definition or the units table, can a race condition cause the definition read to return inconsistent or partially updated data, leading to incorrect validation decisions?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Parallel Signing Race] At lines 70-101, multiple authors and multiple signing paths are processed in parallel using async.each. If two signing paths for the same author execute concurrently and both try to update author.authentifiers[path] simultaneously, can this cause one signature to overwrite another, resulting in incomplete or corrupted authentifier sets?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Light Client History Race] At lines 165-168 and 185-187, light clients request history and retry validation. If the history response arrives while the validation is still processing the retry, can this cause duplicate validation attempts with inconsistent state, potentially accepting a message that should be rejected or vice versa?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Definition Read Race in Non-Network-Aware Mode] At lines 53-58, the code reads the definition using signer.readDefinition() and throws an error if it fails. If the definition is being modified concurrently by another process, can the read return stale or corrupted data, causing the signed message to be created with an outdated definition that won't validate later?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Last Ball Timestamp Race] At line 178 and line 221, the last_ball_timestamp is read from the database and used in validation state. If the units table is updated between the read and the validation, can this cause timestamp inconsistencies that lead to different validation results on different nodes, breaking consensus?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Retry Flag Race] At lines 163-176, the bRetrying flag is used to control retry behavior, but it's set to false at line 176 after successful lookup. If multiple validation attempts for the same message are running concurrently (e.g., from different peers), can they interfere with each other's retry logic, causing infinite retry loops or premature validation failures?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Author Array Modification Race] At lines 44-48, the objUnit.authors array is replaced with authors from composer.composeAuthorsAndMciForAddresses(). If the original objAuthor reference (line 32) is still being accessed elsewhere in the code during this replacement, can this cause use-after-free or stale reference bugs?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Event Bus Race Condition] At line 170, the code registers a listener on eventBus for 'catching_up_done'. If multiple signed messages are being validated concurrently and all waiting for catchup, can they all wake up simultaneously and overwhelm the database with concurrent queries (lines 160, 179), causing deadlocks or validation failures?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Database Connection Race] The function accepts a 'conn' parameter (line 116) that can be a custom database connection or default to db. If multiple validations are running on the same connection object concurrently, and the connection doesn't properly serialize queries, can this cause query result mixing or transaction isolation violations?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Signing Path Amplification DoS] At lines 63-67 and 74-96, the code iterates over all signing paths for each author. If an attacker can register an address with thousands of signing paths (e.g., through a complex 'r of set' definition with many alternatives), can they cause exponential time complexity in the signing loop, leading to CPU exhaustion and denial of service?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Infinite Retry Loop DoS] At lines 163-173, the code retries validation when last_ball_unit is not found. If conf.bLight is false but network.isCatchingUp() keeps returning true indefinitely (e.g., due to network issues), the code will retry indefinitely without the bRetrying flag check. Can this cause infinite recursion or event listener accumulation, exhausting memory?",
  "[File: byteball/ocore/signed_message.js] [Function: repeatString()] [Memory Exhaustion via String Repetition] At lines 17-21, the repeatString() function creates a string by repeating the input 'times' times. If an attacker provides a signing path with length value in billions, can this cause gigabytes of memory allocation for placeholder authentifiers at line 67, crashing the node?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Authors Array DoS] At lines 130-146, the code iterates through all authors without a length limit check. If an attacker submits a signed message with millions of author objects, can this cause excessive CPU usage during iteration and validation, delaying processing of legitimate transactions for hours?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Deep Definition Recursion DoS] At line 229-238, the code calls Definition.validateAuthentifiers() which recursively evaluates address definitions. If an attacker provides a definition with extremely deep nesting (e.g., hundreds of nested 'and'/'or' operators), can this cause stack overflow during recursive evaluation, crashing the validation process?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Multi-Author Amplification DoS] At lines 70-101, the code processes multiple authors in parallel. While validateSignedMessage() limits authors to 1 (line 133-134) when no specific address is provided, signMessage() has no such limit. Can an attacker call signMessage() with thousands of authors, each with many signing paths, causing exponential work in the nested async loops?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Database Query Flooding] At lines 160 and 179, the code makes database queries during validation. If an attacker floods the network with thousands of signed messages with non-existent last_ball_units, can they cause massive database query load, slowing down all other database operations and freezing the network for hours?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Light Client History Request DoS] At lines 166-168 and 185-187, light clients request history when data is missing. If an attacker repeatedly sends signed messages with missing last_ball_units or address history, can they cause the light client to spam history requests to the hub, overwhelming both the client and hub, or causing the client to store excessive historical data?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Validation State Object DoS] At lines 218-223, the code creates an objValidationState object. If the signed message contains extremely large nested structures (e.g., huge authentifier objects), and these are copied into the validation state, can this cause memory exhaustion during the validation process?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Exception Handling DoS] At lines 207-208 and 225-226, the code has try-catch blocks that return errors. If calculating definition hash or unit_hash_to_sign throws exceptions rapidly (e.g., due to malformed input), can the exception handling overhead accumulate across thousands of concurrent validations, degrading performance?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Field Injection via hasFieldsExcept Bypass] At line 124, the code checks for unexpected fields using ValidationUtils.hasFieldsExcept(). If the hasFieldsExcept() function has vulnerabilities that allow certain field names (e.g., with null bytes, Unicode tricks, or prototype pollution patterns) to bypass the check, can an attacker inject malicious fields that corrupt the validation process?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Address Validation Bypass] At line 142, the code validates author addresses using ValidationUtils.isValidAddress(). If an attacker provides an address that passes isValidAddress() but is actually a special value (e.g., '__proto__', 'constructor', or a very long string that causes buffer overflow in downstream code), can they exploit prototype pollution or memory corruption?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Last Ball Unit Injection] At line 154-155, the code validates last_ball_unit using ValidationUtils.isValidBase64(). If an attacker provides a valid base64 string that is actually SQL injection payload or contains special characters that break database queries at line 160, can they inject malicious SQL or cause query errors that bypass validation?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Signed Message Type Confusion] At line 122-123, the code checks if objSignedMessage is an object. However, arrays are objects in JavaScript. If an attacker passes an array instead of an object, can this cause type confusion in downstream code that assumes object properties, leading to undefined behavior or crashes?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Message Parameter Injection] At line 27, the signMessage() function accepts a 'message' parameter but doesn't validate its type or content before embedding it in objUnit.signed_message (line 38). If an attacker provides a message with circular references, prototype pollution properties, or extremely large objects, can this cause JSON serialization failures or hash calculation errors?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Authentifiers Object Injection] At line 144-145, the code checks if author.authentifiers is a non-empty object but doesn't validate the keys or values. If an attacker provides authentifiers with keys like '__proto__' or 'constructor', or values that are objects instead of strings, can they exploit prototype pollution or cause type confusion in Definition.validateAuthentifiers()?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Version Field Injection] At line 128, the code checks the version field against constants.supported_versions. If an attacker provides a version value that is not a string but a number or object that matches one of the supported versions when coerced, can they bypass version-specific validation logic?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Author Definition Injection] At line 158, the code checks if 'definition' exists in objAuthor. If an attacker provides a definition that is an empty array, empty object, or contains only whitespace, does it pass the existence check but cause failures in downstream definition validation, potentially bypassing authentication?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Timestamp Field Injection] At line 124, timestamp is allowed in the signed message object. If an attacker provides a timestamp that is extremely far in the future or past, or not a number, can this cause integer overflow in timestamp comparisons or break time-based validation logic elsewhere in the system?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [From Address Injection] At line 27, the from_address parameter is not validated before use. If an attacker provides a from_address with special characters, extremely long string, or SQL injection payload, can they cause errors in database queries at line 53 (signer.readDefinition) or line 44 (composer.composeAuthorsAndMciForAddresses)?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Hash-to-Sign Manipulation] At lines 218-226, the code calculates unit_hash_to_sign using objectHash.getSignedPackageHashToSign(objSignedMessage). If an attacker can modify objSignedMessage between the validation checks (lines 122-155) and the hash calculation (line 219), can they cause the hash to be calculated over different data than what was validated, leading to signature verification of wrong content?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Signature Malleability via Clone] At line 215 in validateSignedMessage(), the code uses _.clone(objSignedMessage) before adding messages property. If _.clone() is a shallow clone and objSignedMessage contains nested objects that get mutated during validation, can this cause the hash calculated at line 219 to differ from the hash that was originally signed, allowing signature malleability?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Private Key Exposure via Error] At lines 89-94, the code reads private keys using signer.readPrivateKey() and signs with ecdsaSig.sign(). If an error occurs and gets logged (line 105 uses console.log with full objUnit inspection), can private keys or signatures be exposed in error logs, allowing attackers to extract keys?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition Hash Collision] At lines 189-190 and 205-206, the code compares definition hashes using objectHash.getChash160(). Since chash160 is only 160 bits, can an attacker perform a birthday attack to find two different definitions that hash to the same value, allowing them to substitute a malicious definition for a legitimate one?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Text-to-Sign Canonicalization] At line 69, the code generates text_to_sign which will be signed. If the objectHash.getSignedPackageHashToSign() function has inconsistencies in JSON canonicalization (e.g., different ordering of object keys, handling of Unicode characters, or float precision), can different nodes generate different hashes for the same logical message, breaking signature verification?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Signature Replay Across Networks] The validateSignedMessage() function doesn't include any network identifier or chain ID in the validation. If an attacker captures a valid signed message from testnet and replays it on mainnet (or vice versa), can they cause unauthorized actions since the signature would technically be valid for the same address/definition on both networks?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Weak Randomness in Signatures] At line 92, the code calls ecdsaSig.sign(text_to_sign, privKey). If the ECDSA signature implementation uses weak randomness for the nonce (k value), can attackers extract private keys through signature analysis (e.g., nonce reuse attacks or bias attacks)?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition Template Injection] When reading the definition from storage at line 179, if the address uses a definition template that includes parameterized values, and those parameters aren't properly validated, can an attacker inject malicious parameters that change the definition's authentication requirements after it's been validated?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Signature Encoding Vulnerability] The code stores signatures in author.authentifiers[path] (lines 84, 92) as strings. If the signature encoding (e.g., base64) has vulnerabilities or allows multiple encodings for the same signature, can an attacker exploit this to create signature malleability, where different encoded versions of the same signature pass validation?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Hash Length Validation Bypass] At line 154-155, the code validates last_ball_unit length using constants.HASH_LENGTH. If constants.HASH_LENGTH is defined incorrectly or can be modified at runtime, can an attacker bypass the length check and provide truncated or extended hashes that cause downstream issues?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [MCI-Based Timing Attack] At line 177 and 221, the code uses last_ball_mci from the database to read the definition at a specific point in time. If an attacker can predict or control the timing of when their signed message is validated relative to MCI advancement, can they exploit a window where the definition has changed but the last_ball_unit still points to the old MCI, allowing authentication with outdated credentials?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Catchup State Timing Attack] At line 163, the code checks network.isCatchingUp() to decide whether to wait. If an attacker can cause the node to enter catchup mode (e.g., by withholding units), and then submit signed messages during catchup, can they exploit different validation behavior during catchup versus normal operation?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Definition Change Timing Race] In network-aware mode (lines 43-50), the code gets last_ball_unit from composer.composeAuthorsAndMciForAddresses(). If the definition for from_address changes between this call and when the message is validated, can the signature be valid at signing time but invalid at validation time, or vice versa, causing non-deterministic behavior?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Last Ball Unit Reorg Attack] At line 160, the code looks up the last_ball_unit in the units table. If the last_ball_unit references a unit that later becomes orphaned due to a mini-reorg or witness incompatibility, can the signed message validation behave differently before and after the reorg, causing non-deterministic state?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Timestamp Validation Timing] At line 178, the code reads last_ball_timestamp but only uses it in validation state (line 221). If there's a significant time delay between reading the timestamp and using it, and the timestamp is used for time-sensitive validation (e.g., time-locked conditions), can an attacker exploit this gap?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Async Callback Timing Attack] At lines 70-108, signatures are collected asynchronously. If an attacker can delay one of the signing callbacks (e.g., by controlling a remote signer in multi-sig setup), can they cause the signing process to timeout or complete with partial signatures, creating invalid signed messages?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Event Bus Timing Race] At line 170-173, the code waits for 'catching_up_done' event. If an attacker can trigger false 'catching_up_done' events or prevent the event from firing, can they cause validation to proceed with stale state or hang indefinitely, freezing message validation?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Light Client Sync Timing] At lines 166-168 and 185-187, light clients request history before retrying. If an attacker can control the hub's response timing or provide partial history, can they cause the light client to make validation decisions based on incomplete state, accepting invalid messages or rejecting valid ones?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Retry Timing Exploitation] At line 167 and 186, the code calls validateOrReadDefinition() recursively after requesting history. If an attacker repeatedly sends messages that trigger history requests, can they cause exponential retries with increasing delays, effectively DoSing the validation process through retry amplification?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Database Transaction Timing] The code makes multiple database calls (lines 160, 179) without explicit transaction boundaries. If an attacker times their signed message submission to coincide with other database writes (e.g., new units being saved), can they exploit transaction isolation level inconsistencies to read uncommitted or inconsistent data?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Last Ball Unit Not Found Exploitation] At lines 161-174, when last_ball_unit is not found, the code has different behavior for light clients vs full nodes. If an attacker provides a last_ball_unit that will never exist (e.g., a random hash), can they cause full nodes to wait indefinitely for catchup to complete, while light clients might accept it after requesting history, creating divergent validation results?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Network Mode Inconsistency] At line 153, the code determines bNetworkAware based on presence of last_ball_unit field. If an attacker includes last_ball_unit in some copies of the message but not others when broadcasting to different peers, can they cause some nodes to validate in network-aware mode and others in non-network-aware mode, leading to inconsistent validation results?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Network-Aware Signing Race] At lines 43-50, in network-aware mode, the code calls composer.composeAuthorsAndMciForAddresses() to get last_ball_unit. If the last stable unit changes between when this is called and when the message is broadcast, can the message reference an old last_ball_unit that causes validation failures or allows manipulation?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition Inclusion Rule Bypass] At lines 180-192, the code expects definition to be provided when it's the first use, and rejects it when it's already known (lines 194-195). Can an attacker exploit timing to include/exclude the definition inappropriately, either forcing unnecessary definition storage or bypassing definition validation?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [MCI Reference Manipulation] At line 177 and 221, the code uses last_ball_mci for definition lookup and validation state. If an attacker can reference a last_ball_unit with a very old MCI (close to genesis), can they access ancient definitions that had weaker security requirements, bypassing modern authentication standards?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Light Client Partial History Attack] At lines 166-168, light clients request history for the last_ball_unit and author address. If an attacker is the hub or MitM, can they provide partial history that makes the light client think a definition exists when it doesn't (or vice versa), causing incorrect validation decisions?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Catchup Done Event Spoofing] At line 170, the code listens for 'catching_up_done' event. If the event bus allows events from untrusted sources, or if an attacker can trigger events through other means (e.g., causing a brief catchup to complete), can they cause premature validation retry that fails due to incomplete state?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition Storage Race in Network-Aware Mode] At line 179-198, the code uses storage.readDefinitionByAddress() with callbacks for found/not-found cases. If there's a race between when the definition is stored and when this validation occurs, can different nodes get different results (some finding the definition, others not), causing non-deterministic validation?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Composer Integration Attack] At line 44, the code calls composer.composeAuthorsAndMciForAddresses(). If this function has vulnerabilities or can be manipulated to return incorrect authors or last_ball_unit, can an attacker cause signMessage() to create signed messages with mismatched author definitions or invalid last_ball references?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [bNoReferences Flag Manipulation] At line 222, the code sets bNoReferences: !bNetworkAware in validation state. If downstream validation code makes security decisions based on this flag (e.g., allowing/disallowing certain operations), can an attacker manipulate the network-aware status to bypass restrictions?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Definition Read Error Handling] At lines 53-55, when signer.readDefinition() returns an error, the code throws an exception instead of calling the callback. This inconsistent error handling could cause unhandled promise rejections or crashes. Can an attacker trigger this error path repeatedly to crash the signing process?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Callback Double-Call] The validateSignedMessage() function calls handleResult (the callback) in multiple places (lines 123-155 for validation errors, line 164 for missing last_ball, line 233-236 for validation results). If an error occurs after a callback has already been called, can this cause double-callback bugs that corrupt application state?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessageSync()] [Synchronous Assumption Violation] At lines 243-253, validateSignedMessageSync() assumes the validation callback will be called synchronously and throws if not (line 251). However, if network-aware validation with last_ball_unit lookup is used, the callback will be async. Can this cause crashes or incorrect error handling in code that assumes synchronous validation?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Exception in Try-Catch Swallowing] At lines 217-227, the code wraps hash calculation in try-catch but only returns the error message string, losing the stack trace. If the exception contains important debugging information or is caused by memory corruption, can this mask serious underlying issues that need investigation?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Partial Signing State] At lines 70-107, if signing fails partway through (e.g., one of multiple authors fails to sign), the objUnit is left in a partially signed state. If this objUnit object is reused or inspected elsewhere, can the partial signatures cause confusion or allow partial authentication bypass?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Storage Callback Error Propagation] At lines 179-198, storage.readDefinitionByAddress() uses callbacks (ifDefinitionNotFound, ifFound) that may call handleResult to propagate errors. If storage itself throws an exception (e.g., database connection error), is it properly caught and converted to callback error, or can it crash the validation process?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Network Require in Callback] At lines 162 and 184, the code requires './network.js' inside the callback. If this require() fails (e.g., circular dependency issue or module not found), it will throw an exception that bypasses the callback error handling, potentially crashing the process. Can an attacker trigger conditions that cause module loading to fail?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition.validateAuthentifiers Error Ambiguity] At lines 229-238, Definition.validateAuthentifiers() can call back with error or false (wrong signature) but both are treated as validation failure. If there's a difference in security implications between actual errors (e.g., database failure) vs invalid signatures, can this ambiguity cause inappropriate error responses?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Unvalidated Database Query Results] At line 160, the code queries units table but doesn't validate the structure of returned rows beyond checking length. If the database schema is corrupted or returns unexpected data types, can this cause type errors in subsequent code (e.g., accessing rows[0].main_chain_index when it's not a number)?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Console.log Information Disclosure] At line 105, the code uses console.log to output the complete objUnit including all authentifiers (signatures). In production environments where logs might be captured, can this expose sensitive signature data that could be used for replay attacks or signature analysis?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition vs Address Mismatch] At lines 189-190 (network-aware first use) and 205-206 (non-network-aware), the code validates that the definition hash matches the expected value. If an attacker provides a valid definition for a different address and exploits a hash collision or validation race, can they authenticate as the wrong address?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [First Use Definition Injection] At lines 180-192, when a definition is not found in storage (first use), the code requires it to be provided. If an attacker can make an existing definition appear as 'not found' (e.g., through database manipulation or race condition), can they inject a malicious replacement definition?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Definition Update Race in Non-Network-Aware] At lines 53-58, non-network-aware signing reads the current definition without reference to any specific MCI. If the address definition is updated via definition_chg message between signing and validation, can the signature become invalid, or worse, can the new definition be exploited to bypass authentication?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Multiple Author Definition Conflicts] At lines 136-146, the code iterates through multiple authors but only tracks one (the_author). If an attacker includes the same address multiple times with different definitions, can they exploit which definition gets validated, potentially using a weaker definition?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition Template Parameter Injection] When reading definitions at line 179 or validating them at line 189/205, if the definition uses templates with parameters, and those parameters aren't properly sanitized, can an attacker inject malicious parameters that change the authentication requirements (e.g., changing required threshold from 2-of-3 to 1-of-3)?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Definition Chain Attack] Address definitions can reference other addresses. If the validation at line 229-238 doesn't properly track which addresses have been evaluated in the recursion chain, can an attacker create circular definition references that cause infinite loops or allow authentication bypass through repeated evaluation?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Authentifiers Path Validation] The authentifiers are validated by Definition.validateAuthentifiers() at line 229-238, but the code doesn't validate that the paths in authentifiers match the expected paths from the definition. Can an attacker provide authentifiers for paths that don't exist in the definition, causing validation errors or bypasses?",
  "[File: byteball/ocore/signed_message.js] [Function: signMessage()] [Signing Paths Injection] At lines 63-67, the code gets signing paths from signer.readSigningPaths() and creates authentifiers for each. If an attacker can manipulate readSigningPaths() to return unexpected paths (e.g., empty strings, paths with SQL injection, or paths that don't match the definition), can they create malformed signatures that bypass validation?",
  "[File: byteball/ocore/signed_message.js] [Function: validateSignedMessage()] [Address Definition Caching Race] The storage.readDefinitionByAddress() call at line 179 might use cached definitions. If the cache is stale (definition was updated but cache not invalidated), can an attacker exploit the timing window to\n\n### Citations\n\n**File:** signed_message.js (L1-259)\n```javascript\n/*jslint node: true */",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Version comparison attack] If an attacker can manipulate the PRAGMA user_version result to return a value greater than VERSION (46), the migration throws an error suggesting 'new database with old client', but could this error handling be exploited to prevent legitimate nodes from upgrading their database schema, causing a network-wide inability to process new units and leading to total network shutdown?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Version rollback vulnerability] When checking version at line 19-22, if the database reports user_version > VERSION, the code throws an error - but does this prevent a scenario where a node downgrades from a future version to an older version, potentially causing the node to accept invalid units that were rejected by newer validation rules, leading to chain split?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [PRAGMA injection] At line 13, the code executes 'PRAGMA user_version' without parameterization - if the connection.db object is compromised or the query method is overridden, could an attacker inject malicious SQL that returns a fake version number to skip critical security-related migrations, allowing double-spend or balance manipulation attacks?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Race condition in migration check] Between reading the version (line 13-19) and starting migrations (line 34-607), if another process or thread simultaneously initiates a migration, could both processes execute overlapping schema changes, causing database corruption that prevents unit storage and results in permanent network halt?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Partial migration failure] If a migration query fails midway through the arrQueries execution (line 598), and some queries have already committed changes while others haven't, could this leave the database in an inconsistent state where critical indexes or foreign keys are missing, allowing double-spend attacks or violating referential integrity?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 10] [Transaction atomicity] Lines 80-94 wrap chat_messages table migration in BEGIN/COMMIT, but if the COMMIT fails after data is inserted into the new table (line 91) and the old table is dropped (line 92), could the database lose all chat message history, and more critically, if similar patterns exist for critical tables, could financial data be lost?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 18] [Attestation data integrity] Lines 194-213 migrate attestation data by parsing JSON payloads and inserting into attested_fields table - if the JSON parsing throws an exception for malformed attestation payloads that were somehow stored in an earlier version, does the migration fail completely, preventing nodes from upgrading and causing network fragmentation?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 18] [Uncaught JSON parse error] At line 198, JSON.parse(row.payload) is called without try-catch - if a corrupt database contains an attestation with invalid JSON, the migration crashes with an unhandled exception - does this permanently brick nodes that have this corruption, preventing them from ever upgrading and causing permanent chain split?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 24] [Asset attestor migration] Lines 255-269 create asset_attestors_new table, copy data, drop old table, and rename - if the COMMIT fails at line 269 after dropping the original table (line 267), are all asset attestor records permanently lost, potentially allowing unauthorized asset issuance if attestor verification relies on this data?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [AA infrastructure creation] Lines 294-341 create critical AA tables (aa_addresses, aa_triggers, aa_balances, aa_responses) - if these migrations fail partway through, could some nodes have incomplete AA infrastructure, causing them to reject valid AA trigger units from other nodes and leading to permanent chain split?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 31] [KV store migration] Lines 346-355 call migrate_to_kv.js after executing all prior arrQueries - if the KV migration fails but the SQL migrations already committed, could the database be left in a state where AA state variables are inaccessible, permanently freezing all funds locked in AAs?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 34] [Storage size initialization] Lines 370-373 call initStorageSizes() which reads from kvstore and updates aa_addresses.storage_size - if this migration is interrupted, could some AAs have incorrect storage_size values, allowing attackers to exceed storage limits or bypass storage fees, leading to DoS via unbounded state growth?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: initStorageSizes()] [KV stream race condition] Lines 627-636 read from kvstore stream and accumulate sizes in assocSizes object - if new state variables are written to kvstore by another process during this read, could the storage_size calculations be incorrect, either over-counting (preventing legitimate AA operations) or under-counting (allowing storage DoS)?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: initStorageSizes()] [Unbounded memory consumption] Lines 618-632 load all AA state variable sizes into memory (assocSizes object) - if a malicious actor previously created millions of state variables across many AAs, could this migration consume excessive memory and crash the node during upgrade, preventing nodes from upgrading and causing network split?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: addTypesToStateVars()] [Type inference vulnerability] Lines 653-654 use getNumericFeedValue() to determine if a state variable should be typed as numeric or string - if this function has edge cases where it misclassifies values, could migrated nodes interpret state variables differently than pre-migration nodes, causing AA execution divergence and permanent chain split?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: addTypesToStateVars()] [Batch write failure] Lines 665-667 write all type-prefixed state variables in a single batch.write() - if this fails after the stream has already read all data, does the migration retry from the beginning or skip the upgrade, potentially leaving some nodes with typed state vars and others without, causing non-deterministic AA execution?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 35] [AA balance recalculation] Lines 377-386 recalculate AA balances from outputs table - if this query incorrectly sums balances due to concurrent unit storage operations, could AAs end up with wrong balance records, allowing overspending or preventing legitimate withdrawals (permanent fund freezing)?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [System tables creation] Lines 518-591 create system_votes, op_votes, numerical_votes, system_vars, tps_fees_balances, and node_vars tables only for non-light nodes - if a node switches from light to full mode after this migration, are these tables missing, causing the node to crash or malfunction when attempting to process governance votes?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [Column addition check] Lines 574-586 check if units table already has 'oversize_fee' column before adding new fee-related columns - if the string matching on units_sql (line 574) fails to detect the column due to SQL formatting differences, could the migration attempt to add duplicate columns, causing migration failure and preventing node upgrades?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [UPDATE without WHERE clause safety] Lines 587-591 update units table to set is_aa_response and count_primary_aa_triggers for existing units - if these queries are slow due to large table size, could the migration take hours/days, blocking all database operations and causing temporary network freeze (>1 day transaction delay)?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Event bus timing] Line 26 emits 'started_db_upgrade' event and line 599 emits 'finished_db_upgrade' - if other modules rely on these events to pause/resume critical operations, and an event is missed due to timing issues, could units be written to the database during migration, causing corruption?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Long upgrade warning] Lines 25-31 warn about long upgrades for version < 31 on full nodes - but is there a timeout or watchdog that could kill the migration process, leaving the database partially upgraded and permanently corrupting it?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 2] [Known bad joints deletion] Lines 51, 69, 73, 95, 111, 145, 222, 292, 417 all delete from known_bad_joints table - if this table is used to prevent re-processing of previously rejected units, could repeated deletion allow an attacker to resubmit malicious units that were already marked as bad, leading to double-spend or consensus violations?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 2] [Index creation timing] Lines 48-50 create unique indexes on headers_commission_outputs and witnessing_outputs by (address, main_chain_index) - if duplicate entries exist in these tables from a previous bug, will the index creation fail and prevent migration, or silently ignore duplicates, potentially allowing double-claiming of witness rewards?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 6] [Foreign key constraint] Lines 57-65 create chat_messages table with FOREIGN KEY to correspondent_devices - if correspondent_devices records are missing for some chat messages, does the migration fail, and does this prevent node upgrades, causing network fragmentation?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 10] [ON DELETE CASCADE] Line 89 adds ON DELETE CASCADE to chat_messages foreign key - if correspondent_devices records are deleted during migration, could this cascade delete chat messages that contain critical pairing or payment information, leading to fund loss?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 13] [NULL mci values] Line 113 adds _mci column to unit_authors with NULL default - before version 14 populates this (line 117), are there operations that assume _mci is non-null, potentially causing crashes or incorrect behavior during the migration window?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 14] [Subquery performance] Line 117 updates unit_authors._mci using a subquery to units table - for large databases, could this query take extremely long or lock tables, causing the migration to timeout or deadlock with other database operations?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 15] [Asset metadata foreign keys] Lines 121-132 create asset_metadata with FOREIGN KEY to assets and units - if these referenced tables are missing entries due to archiving or pruning, does the migration fail when trying to establish referential integrity?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 17] [Private profile auto-increment] Line 149 uses AUTOINCREMENT for private_profile_id - if the sequence overflows or wraps around (after 2^63 profiles), could new private profiles get duplicate IDs, allowing one user to access another's private attestation data?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 18] [Light node conditional FK] Line 181 conditionally includes a foreign key constraint only for full nodes (conf.bLight check) - if a node switches from light to full mode, is this constraint missing, allowing orphaned attestation records that violate referential integrity?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 18] [Field length validation] Lines 203-208 check field/value lengths against constants.MAX_PROFILE_FIELD_LENGTH and MAX_PROFILE_VALUE_LENGTH before inserting - if these constants change between versions, could previously valid attestations be excluded from the migrated table, causing attestation data loss?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 18] [INSERT IGNORE semantics] Lines 205-207 use connection.getIgnore() for INSERT - does this silently skip duplicate attestations without warning, potentially hiding data corruption where the same (unit, message_index, field) combination appears multiple times in the source data?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 23] [Prosaic contracts status check] Lines 237-252 create prosaic_contracts table with status CHECK constraint - if invalid status values exist in any system attempting to sync this data, does the constraint violation prevent data import, causing sync failures?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [AA responses uniqueness] Lines 323-337 create aa_responses with UNIQUE(trigger_unit, aa_address) - if an AA is somehow triggered multiple times by the same unit (via different execution paths), could the uniqueness constraint prevent storing all responses, causing AA state divergence?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [Light node AA responses] Line 334 conditionally includes foreign key to aa_addresses only for full nodes - could light nodes store aa_responses for non-existent aa_addresses, and when upgraded to full node, violate referential integrity?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [Response unit null handling] Line 330 allows response_unit to be NULL with UNIQUE constraint - could this allow multiple bounced AA responses (where response_unit is NULL) for the same trigger_unit and aa_address, violating the business logic that each trigger should produce exactly one response?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 33] [Default storage size zero] Line 364 adds storage_size with DEFAULT 0 - if this default is used for existing AA addresses before initStorageSizes() runs, could AAs bypass storage fee checks until the migration completes, allowing free unbounded state storage?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 37] [Base AA circular reference] Lines 398-399 add base_aa column with self-referential foreign key constraint - could an AA be defined with base_aa pointing to itself or creating a circular chain, causing infinite recursion when resolving AA inheritance and crashing nodes?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 39] [State var type migration failure] Lines 406-409 call addTypesToStateVars() to add type prefixes to all state variables - if this fails silently (no error thrown), could half the network have typed state vars and half not, causing deterministic execution to become non-deterministic and creating permanent chain split?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: addTypesToStateVars()] [Old format detection] Lines 649-664 detect old format by checking if value has fewer than 2 newline-separated parts - could a legitimate state variable value containing no newlines be incorrectly detected as old format and get incorrectly prefixed again, corrupting AA state?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 40] [Getters column addition] Line 413 adds getters TEXT column to aa_addresses - if this column is populated later with invalid JSON, could AA getter evaluation fail, preventing read access to AA state and effectively freezing funds locked in the AA?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 42] [Light client unprocessed addresses] Lines 418-422 create unprocessed_addresses table only for light clients - if a full node downgrades to light mode, is this table missing, causing crashes when the light client tries to track unprocessed addresses?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 43] [Arbiter contract status values] Lines 425-461 create wallet_arbiter_contracts with extensive status CHECK constraint - if status transitions are not properly validated elsewhere in the codebase, could an invalid status update bypass the CHECK constraint through direct SQL, corrupting contract state?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 43] [Asset metadata table drop] Line 486 drops asset_metadata table without backup - if this table contains data not migrated to the new schema (lines 487-498), is metadata permanently lost, potentially breaking asset display or validation in wallets?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 44] [Testnet-specific balance fix] Lines 500-510 recalculate AA balance for specific address 'SLBA27JAT5UJBMQGDQLAT3FQ467XDOGF' only on testnet - if this address had balance corruption on mainnet too, does it remain corrupted, potentially allowing withdrawal of non-existent funds or preventing withdrawal of real funds?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [Constants dependency] Line 572 references constants.v4UpgradeMci - if this constant is changed in a future version but old databases are migrated, could nodes have inconsistent last_temp_data_purge_mci values, causing divergent behavior in temporary data cleanup?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [ALTER TABLE cascade] Lines 576-583 add multiple new columns to units table - if any of these columns have triggers or computed logic in other parts of the codebase that assume they exist, could the window between column additions cause runtime errors or corrupted data?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [Units table update deadlock] Line 587 updates units table where unit IN (SELECT from aa_responses) - if aa_responses is also being written to by another process, could this create a deadlock, blocking the migration indefinitely?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Async series execution] Lines 34-607 use async.series() to execute migration steps sequentially - if any callback is never called (hanging), does the migration hang forever, preventing the node from starting and causing permanent node failure?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Connection parameter trust] The connection parameter is passed in and trusted throughout migrations - if this connection object is malicious or compromised, could it execute arbitrary SQL during migrations, allowing an attacker to corrupt critical tables like outputs or units, enabling double-spends?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Cordova path divergence] Line 10 detects Cordova environment and uses different query methods (line 13: 'query' vs 'all') - could this cause different migration behavior on mobile vs desktop, leading to schema differences and network incompatibility?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 1] [Index IF NOT EXISTS] Lines 43-45 use CREATE INDEX IF NOT EXISTS - if indexes already exist with different definitions, does IF NOT EXISTS skip creating the correct index, leaving outdated or incorrect indexes that cause slow queries or incorrect results?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [AA addresses MCI tracking] Line 302 stores mci when AA is first defined - if this MCI is incorrect due to timing issues during unit storage, could the AA be considered available before it actually is, allowing triggers to reference it before validation is complete?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [AA balances base asset] Line 316 uses 'base' string for bytes asset (comment says 'NULL would not work for uniqueness') - could this special-casing cause confusion with an actual asset named 'base', allowing balance manipulation or incorrect asset transfers?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: initStorageSizes()] [Stream error handling] Lines 634-636 throw an error on stream error - does this terminate the entire migration, preventing nodes from upgrading, or is the error caught and handled gracefully?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: initStorageSizes()] [KV key parsing] Line 620 parses key as address (substr 3, 32) and var_name (substr 36) - if keys are malformed or have different formats, could this parse incorrectly, causing storage_size to be calculated for wrong addresses or with wrong values?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: initStorageSizes()] [Concurrent modifications] Lines 630-631 update aa_addresses.storage_size after stream completes - if new state variables are added between stream completion and UPDATE execution, are they missing from storage_size calculations?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: addTypesToStateVars()] [Numeric conversion rules] Line 653 uses string_utils.getNumericFeedValue() with comment 'use old rules' - if these old rules differ from current rules, could nodes that migrate at different times have different type assignments for the same state variables, causing AA execution divergence?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: addTypesToStateVars()] [Batch clear on skip] Lines 660-663 clear the batch if already upgraded - does clearing the batch have any side effects if operations were already queued, potentially causing partial updates or lost writes to kvstore?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 10] [Dependencies cleanup] Lines 96-99 delete from unhandled_joints, dependencies, hash_tree_balls, catchup_chain_balls - if these tables are critical for network sync, could deleting them cause nodes to lose track of sync state and be unable to catchup, permanently disconnecting them from the network?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 18] [Attestation address validation] Line 199 checks attestation.address === row.address with throw on mismatch - if this validation fails, does it abort the entire migration, and could a single corrupt attestation prevent all nodes with that data from upgrading, causing network split?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [PRAGMA user_version manual updates] Lines 114, 289, 341, 365, 399, 414, 514 manually set PRAGMA user_version at specific checkpoints - if the final PRAGMA at line 597 fails but these intermediate ones succeeded, could the database be marked as partially upgraded, causing re-running of some migrations and skipping others on next restart?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Error propagation] Throughout the file, errors are thrown (lines 15, 18, 22, 200, 635, 667) - are these errors caught by the caller, and if not, could an uncaught error during migration crash the node permanently, preventing it from ever starting again?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [Joints table creation] Lines 294-298 create joints table to store full unit JSON - if this table grows unbounded, could it consume all disk space, causing database corruption or preventing future unit storage (DoS attack via disk exhaustion)?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [System vars vote_count_mci] Lines 552-559 create system_vars with PRIMARY KEY (subject, vote_count_mci DESC) - could this descending order in primary key cause inefficient queries or index corruption in some SQLite versions?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [TPS fees negative balance] Line 563 allows tps_fees_balance to be negative (comment explicitly states 'can be negative') - could integer underflow in TPS fee calculations result in extremely large positive balances after wraparound, allowing unlimited transaction throughput without payment?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [Node vars last update] Line 570 stores last_update timestamp - if system clock is manipulated or incorrect, could this cause nodes to have wrong ideas about when data was last purged, leading to either premature data deletion (breaking catchup) or unbounded data growth (DoS)?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 31] [KV migration blocking] Lines 346-355 execute all SQL migrations in arrQueries before calling migrate_to_kv.js, then clear arrQueries - if migrate_to_kv fails, are the SQL migrations rolled back, or does the database end up in an inconsistent state where SQL schema is v31+ but KV data is still in old format?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Version equality check] Line 23 returns early if version === VERSION - but does this check happen before or after eventBus.emit('started_db_upgrade')? If modules are waiting for finished_db_upgrade event that never comes, could this cause deadlock?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 6] [ALTER TABLE ADD COLUMN] Lines 67-68 use ALTER TABLE ADD COLUMN - if these columns already exist from a previous failed migration, does SQLite return an error, and does this prevent migration retry, permanently bricking the node?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 28] [Timestamp default value] Line 288 adds timestamp column with DEFAULT 0 - could all existing units having timestamp=0 cause issues with time-based queries, witness selection, or stability calculations that assume timestamps are real Unix times?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [AA triggers composite primary key] Line 311 uses PRIMARY KEY (mci, unit, address) for aa_triggers - could the ordering of this key cause inefficient queries when looking up triggers by address or unit, significantly slowing down AA execution?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Connection.addQuery assumptions] Throughout the file, connection.addQuery() is called to build arrQueries array - if this method doesn't properly escape parameters or has SQL injection vulnerabilities, could migration code be exploited to inject malicious SQL?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: initStorageSizes()] [Cordova early return] Line 612 returns early for Cordova without doing anything - do Cordova nodes end up with incorrect storage_size values, and could this allow mobile nodes to accept different AA transactions than desktop nodes, causing chain split?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: addTypesToStateVars()] [Light client early return] Line 640 returns early for light clients - do light clients end up with state variables in old format, and when they query AAs, could type interpretation differ from full nodes, causing incorrect AA evaluation?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 18] [CROSS JOIN usage] Line 195 uses CROSS JOIN between attestations and messages - if this produces a Cartesian product due to missing join conditions, could the query return duplicate or incorrect rows, causing attestation data corruption?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 35] [Balance aggregation timing] Lines 377-386 aggregate AA balances using SUM(amount) - if outputs table is being modified during this query execution, could the SUM be incorrect, leading to AA balance mismatches that prevent withdrawals or allow overdrafts?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 35] [EXISTS subquery performance] Lines 383-384 check if output unit is authored by an AA using EXISTS subquery - for large databases, could this cause the migration query to run for hours, locking the outputs table and preventing any unit processing?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 36] [Watched light AAs table] Lines 388-395 create watched_light_aas table - if a light client watches too many AAs, could this table grow unbounded, and when upgrading, could the migration timeout due to index creation on a huge table?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 37] [Base AA null handling] Line 398 allows base_aa to be NULL - could this cause issues in AA inheritance resolution where NULL is treated differently than an AA with no base, leading to execution differences?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 43] [Wallet arbiter contracts shared_address] Line 454 has shared_address CHAR(32) NULL UNIQUE - could multiple contracts with shared_address=NULL violate the uniqueness constraint in some SQLite versions, or does NULL not participate in uniqueness checks, potentially hiding duplicate contracts?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [UPDATE with subquery] Lines 588-591 use UPDATE with subquery to set count_primary_aa_triggers - if aa_responses table is locked by another transaction, could this UPDATE block indefinitely, hanging the migration?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Async callback timing] Line 604 calls onDone() after all migrations complete - if async.series() has already called onDone earlier due to an error, could this result in double-callback execution, causing undefined behavior in the calling code?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [Creation date defaults] Multiple tables use TIMESTAMP DEFAULT CURRENT_TIMESTAMP - if the system clock is wrong or manipulated during migration, could all migrated records have incorrect timestamps, breaking time-based queries or expiration logic?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Event bus dependency] Lines 26 and 599 emit events on eventBus - if eventBus is not properly initialized or has been corrupted, could event emission fail silently, causing other modules to never receive migration status updates and hang waiting?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 10] [Chat messages autoincrement] Line 83 changes chat_messages.id from INTEGER PRIMARY KEY to INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT - could this change affect existing message IDs, potentially creating gaps or duplicates that break message threading?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 24] [Temporary table rename] Lines 256-268 use CREATE/INSERT/DROP/RENAME pattern without explicit transaction control - could another process access asset_attestors_new before the rename, seeing inconsistent data?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [Conditional table creation] Lines 517-573 create governance tables only if !conf.bLight - if conf.bLight is a runtime configuration that can change, could nodes end up missing these tables after upgrading from light to full mode?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Version increment at end] Line 597 sets PRAGMA user_version to VERSION only at the very end - if the node crashes between completing migrations and setting this PRAGMA, will all migrations re-run on next start, potentially causing duplicate data or constraint violations?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 18] [Loop variable closure] Lines 197-213 iterate over rows and for each field in attestation.profile - if JavaScript closure captures variables incorrectly in the nested loops, could this cause race conditions where the wrong field/value combinations are inserted?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: initStorageSizes()] [Key format assumption] Lines 615-616 assume kvstore keys start with 'st\\\\n' prefix - if this prefix format changes or kvstore contains keys with different formats, could the stream return unexpected data, causing incorrect storage_size calculations?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: addTypesToStateVars()] [Type prefix format] Line 655 adds type prefix as 'n' or 's' followed by newline - if any code elsewhere expects state variables to be stored without this prefix, could migrated state become inaccessible, freezing AA funds?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [AA responses bounced flag] Line 329 stores bounced as TINYINT NOT NULL - if bounce status is determined asynchronously after response storage, could there be a timing window where bounced is incorrect, causing nodes to have different views of AA execution results?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [Index creation IF NOT EXISTS] Lines 528-530, 540, 551 use CREATE INDEX IF NOT EXISTS - similar to earlier question, if indexes exist with slightly different definitions, does IF NOT EXISTS prevent updating them to correct definitions?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Require statement in migration] Line 348 requires './migrate_to_kv.js' during migration execution - if this file is missing or has been modified maliciously, could this execute arbitrary code during migration with database access privileges?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: initStorageSizes()] [Require statement in helper] Line 626 requires './kvstore.js' - similar to above, could a compromised kvstore module execute malicious code during storage size initialization with full database access?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: addTypesToStateVars()] [Multiple requires in helper] Lines 642-643 require string_utils and kvstore - could either of these modules be replaced with malicious versions to corrupt state variable types during migration?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [AA addresses definition TEXT] Line 303 stores AA definition as TEXT without length limit - could extremely large AA definitions cause storage issues or query timeouts, and during migration, could this cause nodes to hang when creating indexes on this column?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 30] [AA responses response TEXT] Line 331 stores AA response as TEXT (json) without length limit - could unbounded response sizes cause similar issues as definitions, and could this be exploited to DoS nodes during migration by forcing them to process huge JSON blobs?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 43] [Arbiter disputes contract_content TEXT] Line 473 stores full contract content as TEXT - could this unbounded field cause storage exhaustion, and during migration, could creating indexes on tables with huge TEXT fields cause out-of-memory errors?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Connection.query vs connection.db.query] Line 36 uses connection.query(), line 13 uses connection.db.query() - could inconsistent query methods cause some queries to bypass connection pooling or transaction management, leading to race conditions?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 18] [Callback within query] Lines 194-213 execute connection.query() with a callback that adds more queries to arrQueries - could this cause arrQueries to be modified while async.series() is iterating over it, leading to skipped or duplicate migrations?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Nested async.series] Lines 34-607 use multiple nested async.series calls - if inner series completes but doesn't call its callback, could the outer series hang, blocking migration forever?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 31] [arrQueries clear and reassignment] Line 349 sets arrQueries = [] after async.series(arrQueries) - could this cause memory issues if arrQueries contained closures or references that are not properly garbage collected?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [units_sql variable scope] Lines 33, 36-38 define units_sql in outer scope and populate in async callback - could this variable be undefined if the callback isn't executed, causing errors in line 574 where it's used in includes() check?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 46] [SQL string includes check] Line 574 checks if units_sql.includes('oversize_fee') - could SQL formatting variations (extra spaces, newlines, comments) cause this check to fail incorrectly, leading to attempted duplicate column additions?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: migrateDb()] [Console.error and console.log] Lines 29-30, 575, 586, 601-602, 661, 668 use console logging - if console is not available (e.g., in some embedded environments), could these throw errors that abort migration?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: initStorageSizes()] [Stream pause/resume] The kvstore.createReadStream() doesn't explicitly handle backpressure - if assocSizes grows very large, could memory pressure cause the stream to behave unpredictably, losing data or causing incomplete storage_size calculations?",
  "[File: byteball/ocore/sqlite_migrations.js] [Function: addTypesToStateVars()] [Stream data handling] Lines 650-656 handle each stream data event synchronously - if batch.put() is slow or blocking, could this cause stream events to queue up in memory, leading to OOM crashes during migration of large state variable sets?",
  "[File: byteball/ocore/sqlite_migrations.js] [Migration version 35] [IFNULL in aggregate] Line 378 uses IFNULL(asset, 'base') in balance aggregation - could this cause assets with ID 'base' to be incorrectly grouped with bytes balances, leading to AA balance corruption?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Connection Pool Exhaustion DoS] Can an attacker submit queries that hold connections indefinitely without calling connection.release(), exhausting all MAX_CONNECTIONS and preventing legitimate transactions from being processed, causing a network halt lasting >24 hours?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Queue Overflow DoS] Is the arrQueue array unbounded, allowing an attacker to flood the system with millions of pending connection requests that consume all available memory, crashing the node and preventing network transaction confirmation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Long Query DoS] Can an attacker craft SQL queries with extremely expensive operations (e.g., cross joins on large tables, complex subqueries) that consume connection resources beyond the busy_timeout of 30 seconds, causing database locks and preventing other nodes from confirming transactions for >1 hour?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Connection Leak] If sqlite_migrations.migrateDb() fails or hangs during database initialization, does the connection remain marked as bInUse=true permanently, leaking connections until MAX_CONNECTIONS is reached and causing eventual network halt?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.release()] [Race Condition in Release] If two threads simultaneously call connection.release() on the same connection object, can both threads mark bInUse=false and process different handlers from arrQueue, causing one connection to serve two concurrent queries and creating database corruption via non-serialized writes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Connection State Race] When checking !arrConnections[i].bInUse in the loop, if another thread sets bInUse=true between the check and the assignment, can two handlers receive the same connection, leading to interleaved query execution and database inconsistency that breaks double-spend prevention?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Database Lock at Startup] If multiple node instances attempt to open the same SQLite database file simultaneously with PRAGMA journal_mode=WAL, can conflicting WAL file locks cause some nodes to permanently fail initialization, creating a partial network partition?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: query()] [Promise Memory Leak] When queries are called without callbacks, new Promise objects are created but if the connection is never released due to an error in the callback chain, do these promises accumulate in memory, eventually causing OOM crashes and network-wide unavailability?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: escape()] [Null Byte Injection Bypass] The escape function checks for \\\\0 characters and converts to hex, but can an attacker inject UTF-8 sequences that decode to null bytes after SQLite's internal processing, bypassing the check and terminating SQL strings prematurely to inject malicious SQL?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: escape()] [Single Quote Doubling Logic] The escape function replaces ' with '', but if the resulting escaped string is concatenated into a LIKE pattern or other context where '' has special meaning, can an attacker craft inputs that break out of the string literal and inject arbitrary SQL?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Parameter Count Mismatch] If expandArrayPlaceholders() is called with a SQL string containing question marks in SQL comments (e.g., /* ? */), does the placeholder expansion incorrectly count these as parameters, causing params.length mismatch and either throwing an error that reveals database structure or silently corrupting the query?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Empty Array to NULL Conversion] When an array parameter is empty (length 0), the function replaces ? with NULL. Can an attacker use this to bypass NOT NULL constraints or inject NULL into security-critical fields like unit signatures, allowing unsigned transactions to be stored?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Array Flattening Attack] If an attacker passes nested arrays as parameters (e.g., [[value1, value2]]), does _.flatten() recursively flatten them, causing parameter count mismatches that could lead to SQL injection if the flattened array length doesn't match the expanded placeholder count?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: escape()] [Buffer Hex Encoding] When strings contain null bytes and are converted to hex with Buffer.from(str, 'utf8').toString('hex'), can an attacker exploit encoding edge cases where invalid UTF-8 sequences are normalized, causing the hex representation to differ from the original string and bypass validation checks?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [SQL Injection via Object Parameters] If parameters include JavaScript objects that are implicitly converted to strings (e.g., {toString: () =>",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Regex Injection in SQL Split] The function splits SQL on '?' characters without considering escaped question marks or question marks in string literals. Can an attacker craft SQL with strategically placed ? inside string literals to cause incorrect placeholder expansion that results in parameter misalignment and SQL injection?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [TOCTOU Race on Database File] On desktop platforms, the function checks if the database file exists with fs.stat() then creates it. Can two node instances simultaneously pass the stat check and both attempt to copy the initial database, causing file corruption that prevents any node from starting and halting the network?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [Directory Creation Race] When creating parent_dir and path directories with fs.mkdir(), if multiple processes race to create the same directory structure, can EEXIST errors be ignored incorrectly, causing one process to write the database file while another is mid-creation, resulting in a corrupted database that breaks consensus?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [Initial Database File Substitution] On Cordova platforms, the function copies from 'www/' + initial_db_filename without verifying the file's integrity. Can an attacker replace the initial database file in the app bundle with a malicious version containing pre-confirmed fraudulent transactions, causing all new installations to start with corrupted state?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Readonly Flag Bypass] When bReadOnly is true, the database is opened with sqlite3.OPEN_READONLY, but if the database file permissions allow writing or if WAL mode is already enabled, can write operations still succeed, violating the readonly contract and causing unexpected state mutations in supposedly readonly nodes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [Cordova Device Ready Race] The function waits for the 'deviceready' event before accessing the file system. If an attacker can trigger device pairing or unit validation before deviceready fires, do these operations fail silently or throw unhandled exceptions that crash the node, preventing transaction processing?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [File Permission Exploitation] On desktop platforms, directories are created with mode 0700 (owner-only access). If the user's umask is misconfigured or the parent directory has insecure permissions, can other users on the system read the database file and extract private keys, witness lists, or other sensitive data?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Database Path Traversal] The database path is constructed as path + db_name where path comes from desktop_app.getAppDataDir(). Can an attacker manipulate the environment or configuration to make db_name contain '../' sequences, causing the database to be opened/created outside the intended directory and potentially overwriting system files?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Foreign Keys Disabled Window] PRAGMA foreign_keys=1 is set after database open. During the brief window before this pragma is executed, can an attacker insert records that violate foreign key constraints (e.g., units referencing non-existent parent units), causing permanent DAG corruption that breaks consensus?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [WAL Mode Concurrency Issues] PRAGMA journal_mode=WAL enables Write-Ahead Logging. If multiple processes open the same database (e.g., during migration or backup), can conflicting WAL checkpoint operations cause database corruption where some transactions are lost, leading to double-spend vulnerabilities?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Synchronous FULL Performance DoS] PRAGMA synchronous=FULL forces disk sync after every transaction. Can an attacker flood the network with many small transactions that each trigger expensive fsync() calls, causing severe performance degradation where transaction confirmation takes >1 day, meeting the Immunefi medium severity criteria?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Busy Timeout Deadlock] PRAGMA busy_timeout=30000 sets a 30-second timeout for lock acquisition. Can an attacker submit a long-running transaction (e.g., updating MC index for all units) that holds locks for >30 seconds, causing all other connections to timeout and throw errors that crash dependent modules like validation.js?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Cache Size Memory Exhaustion] For full nodes, PRAGMA cache_size=-200000 sets a 200MB page cache. Can an attacker trigger queries that load massive amounts of data into the cache (e.g., scanning all historical units), exhausting system memory and causing OOM kills that halt the network?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Temp Store Memory DoS] PRAGMA temp_store=MEMORY forces temporary tables into RAM. Can an attacker craft queries with large temporary result sets (e.g., complex JOINs or GROUP BY operations on millions of rows) that consume all available memory, crashing the node and preventing transaction confirmation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Migration Failure Recovery] If sqlite_migrations.migrateDb() fails partway through schema changes, does the connection remain in an inconsistent state where some tables have new schemas and others have old schemas, causing validation queries to return incorrect results and breaking double-spend prevention?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [No Explicit Transaction Support] The connection object doesn't expose BEGIN/COMMIT/ROLLBACK methods. Can calling modules like storage.js perform multi-step operations (e.g., inserting a unit + updating balances + marking inputs as spent) without transaction protection, causing partial commits during crashes that create inconsistent database state?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Autocommit Between Queries] SQLite in autocommit mode commits after each query. If a module executes multiple related queries on the same connection (e.g., validating inputs, then inserting outputs), can a crash between queries leave the database in a state where inputs are marked spent but outputs don't exist, permanently locking funds?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Non-Deterministic Query Ordering] If multiple connections execute queries concurrently without proper locking, can the order of operations (e.g., inserting unit A vs unit B) differ across nodes, causing non-deterministic MC index assignment and permanent chain splits?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.release()] [Connection Release Before Commit] If a module calls connection.release() immediately after connection.query() without waiting for the callback, can the connection be reused for a different query before the first query's WAL buffer is flushed to disk, causing commits to be lost during crashes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: query()] [Callback vs Promise Inconsistency] The query() function supports both callbacks and promises. If a module mixes these patterns (e.g., uses promise for one query, callback for another), can error handling differences cause some database errors to be silently swallowed, allowing invalid units to be stored?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [SQL Error Information Disclosure] When a query fails, the error is thrown with the full SQL string and parameters. Can an attacker trigger validation errors that expose database schema, table names, and constraint details, providing reconnaissance information for crafting more sophisticated attacks?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Database Open Error Exposure] If database opening fails, the function throws Error(err) which may contain file system paths, permission details, or disk corruption information. Can an attacker intentionally corrupt the database file to trigger these errors and extract sensitive path information or system configuration?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Parameter Logging Security] When consumed_time > 25ms, the function logs query details including parameters. Can an attacker submit queries that deliberately exceed this threshold to force logging of sensitive data (e.g., private payment amounts, AA state variable keys) to disk, where it can be extracted later?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Unhandled Promise Rejections] When using promises without callbacks, if the query fails, does the promise rejection propagate correctly, or can unhandled promise rejections cause silent failures where critical validation queries fail but the node continues processing, accepting invalid units?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Migration Error Masking] If sqlite_migrations.migrateDb() encounters errors during schema upgrades, does it call the handleConnection callback anyway with a partially migrated database, causing subsequent queries to fail unpredictably and potentially accepting units that should be rejected?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.release()] [Double Release Attack] If connection.release() is called twice on the same connection, can the second call pop a handler from arrQueue and assign the same connection to two different operations, causing query interleaving where results from query A are returned to the callback for query B, corrupting validation logic?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [bInUse Check Bypass] The query() method throws an error if !this.bInUse, but this check isn't atomic. Can an attacker race two threads where one calls release() and another calls query() simultaneously, bypassing the check and executing a query on a released connection that's being used elsewhere?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Queue Starvation] When all connections are busy, new requests are queued in arrQueue. If long-running queries monopolize all connections, can queued requests starve indefinitely, causing transaction confirmation delays >1 hour even though the queue isn't full?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [CurrentQuery Race Condition] The currentQuery field is set before query execution and cleared after. If printLongQuery() reads this field concurrently, can it capture a partially-written array, causing crashes when trying to log undefined elements or exposing memory addresses via toString() coercion?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: close()] [Incomplete Shutdown] The close() function only closes arrConnections[0] and shifts the array. If multiple connections are open, do the remaining connections stay open indefinitely with active queries, preventing clean shutdown and potentially corrupting the database when the process is forcefully terminated?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Ready State Race] If takeConnectionFromPool() is called before onDbReady() fires, it queues the request on the eventEmitter. If the database initialization fails and onDbReady() never fires, do all queued requests leak memory and never execute, causing gradual memory exhaustion?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [SELECT vs Non-SELECT Detection] The code uses regex /^\\\\s*SELECT/i to detect SELECT queries. Can an attacker craft queries that don't match this pattern but still perform reads (e.g., WITH ... SELECT, or /* comment */ SELECT), causing the wrong execution path (db.run vs db.all) and returning incorrect result formats?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Result Transformation Cordova] On Cordova, result.affectedRows is always 1 even for multi-row inserts. Can this cause validation logic that checks affectedRows to incorrectly conclude that only one row was inserted when multiple were, breaking balance calculations and allowing asset inflation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [This Context Binding] The callback uses 'this.changes' and 'this.lastID' which come from sqlite3's db.run() context. Can an attacker manipulate the execution environment to corrupt the 'this' binding, causing affectedRows or insertId to return values from a previous query and breaking unit storage logic?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.cquery()] [conf.bFaster Validation Bypass] When conf.bFaster is true, cquery() skips the actual query and immediately calls the callback. Can an attacker enable this configuration during critical validation queries (e.g., checking if an output is already spent), allowing double-spends to pass validation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: addQuery()] [Async.series Callback Injection] The addQuery() function wraps callbacks for async.series(). If the original callback doesn't call callback() to signal completion, does the async.series chain hang, preventing subsequent queries in the batch from executing and causing transaction confirmation delays?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Undefined Parameter Handling] If parameters array contains undefined values, are they bound as NULL in SQL? Can an attacker exploit this to bypass NOT NULL constraints or cause unexpected NULL equality checks in WHERE clauses, potentially retrieving or modifying unintended records?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: addTime()] [SQL Injection in Time Intervals] The addTime() function constructs SQL like datetime('now', '-8 SECOND') by string concatenation. Can an attacker pass interval values containing SQL injection payloads (e.g., '0 SECOND'); DROP TABLE units; --') that execute arbitrary SQL when the query is run?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getUnixTimestamp()] [Date Parameter Injection] The getUnixTimestamp() function concatenates the date parameter into SQL like strftime('%s', date). Can an attacker pass malicious date values (e.g., datetime('now') || '; DROP TABLE units; --') that inject SQL commands?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getFromUnixTime()] [Timestamp Injection] The getFromUnixTime() function constructs datetime(ts, 'unixepoch') by concatenating ts. Can an attacker provide a string like '0) || (SELECT password FROM users) || (' that extracts sensitive data from the database via SQL injection?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: forceIndex()] [Index Name Injection] The forceIndex() function returns 'INDEXED BY ' + index without escaping. Can an attacker pass index names containing SQL keywords or operators (e.g., 'idx; DROP TABLE units;') that execute arbitrary SQL when the query is built?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: dropTemporaryTable()] [Table Name Injection] The dropTemporaryTable() function constructs 'DROP TABLE IF EXISTS ' + table. Can an attacker pass table names with SQL injection payloads (e.g., 'temp; DROP TABLE units; --') that drop permanent tables instead of temporary ones, corrupting the entire database?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: escape()] [Array Escaping Recursion] The escape() function recursively escapes array members. Can an attacker pass deeply nested arrays that cause stack overflow during recursion, crashing the node and preventing transaction processing?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Large Result Set Memory] When executing SELECT queries with db.all(), all rows are loaded into memory. Can an attacker craft queries that return millions of rows (e.g., SELECT * FROM units), exhausting available memory and crashing the node with OOM errors?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Large Array Parameters] If an attacker passes array parameters with millions of elements, does the placeholder expansion create SQL strings with millions of '?' placeholders, consuming excessive memory during string concatenation and causing crashes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Query History Accumulation] The connection.currentQuery field stores the full query and parameters. If these contain large binary blobs or very long strings, does the memory accumulate over time across all connections, eventually causing memory exhaustion?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Connection Object Leak] Each connection object has a setInterval timer for printLongQuery(). If connections are created but never properly closed, do these timers continue running indefinitely, gradually accumulating timers that consume CPU and prevent garbage collection?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [EventEmitter Memory Leak] When !bReady, listeners are registered on eventEmitter.once('ready'). If onDbReady() fails to fire due to database initialization errors, do these listeners accumulate with each failed connection attempt, causing a memory leak that eventually crashes the node?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Cordova SQLite Plugin Unavailable] The code checks 'window.cordova' to detect Cordova environment but doesn't verify that cordova-sqlite-plugin is actually installed. Can an app launch in Cordova mode without the plugin, causing cordovaSqlite constructor to be undefined and all database operations to fail silently?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Cordova Query Path Differences] On Cordova, queries use self.db.query() while on desktop they use db.all()/db.run(). Can subtle differences in parameter binding or error handling between these implementations cause queries to behave differently, breaking consensus between mobile and desktop nodes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getParentDirPath()] [Platform Detection Bypass] The platform detection uses window.cordova.platformId which can be 'ios', 'android', or default. Can an attacker run on an unsupported platform (e.g., Windows Phone, browser) that defaults to Android paths, causing database operations to fail or write to incorrect locations?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [Cordova File System Permissions] On Android, the database is stored in applicationStorageDirectory/databases/. Can this location be readable by other apps with storage permissions, allowing malicious apps to clone the database and extract private keys or transaction history?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [iOS Library Backup] On iOS, files in Library/ are backed up to iCloud by default. Does this cause the database file (containing private keys) to be uploaded to iCloud, where it could be accessed by Apple or leaked in data breaches?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [storage.js Transaction Assumption] If storage.js assumes queries on the same connection are atomic, but sqlite_pool.js doesn't guarantee transaction boundaries, can interleaved queries from different modules corrupt multi-step operations like unit insertion, causing DAG inconsistencies?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: query()] [validation.js Deadlock] If validation.js performs expensive queries while holding a connection, and another module is waiting in arrQueue for a connection to commit the validated unit, can a circular dependency deadlock occur where validation never completes because the unit can't be committed?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [main_chain.js MC Update Race] If main_chain.js updates MC indices using one connection while validation.js reads MC indices using another connection without proper locking, can validation read stale MC values and accept units with incorrect witness levels, breaking consensus?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [aa_validation.js State Read Race] When AA execution reads state variables across multiple queries, if another AA execution commits state changes between these reads, can the first AA see inconsistent state (phantom reads), causing non-deterministic formula evaluation that breaks consensus?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: close()] [network.js Shutdown Race] If network.js is still receiving and processing units while sqlite_pool.js is closing connections, can units be partially stored with some database writes succeeding and others failing, corrupting the DAG and preventing the node from restarting?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [wallet.js Balance Calculation] If wallet.js calculates balances using snapshot reads without transaction isolation, and composer.js simultaneously spends outputs, can wallet.js see inconsistent balance states and compose transactions that spend non-existent outputs, causing validation failures?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [WAL Checkpoint Starvation] With journal_mode=WAL, write-ahead logs must be periodically checkpointed. If the database experiences high write volume and checkpoints never complete, can the WAL file grow unboundedly until disk space is exhausted, crashing the node?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [WAL Mode Readonly Conflict] When opening in readonly mode (bReadOnly=true), WAL mode may still require write access to the -shm shared memory file. Can readonly nodes fail to open the database or cause conflicts with other processes, preventing light clients from syncing?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [WAL Mode Crash Recovery] If a node crashes while uncommitted transactions are in the WAL, does the next startup correctly recover these transactions, or can partial transactions be lost, causing inconsistencies between database state and the DAG stored on disk?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [WAL Mode Concurrent Writers] SQLite's WAL mode allows one writer and multiple readers. If multiple node processes accidentally open the same database (e.g., during upgrade), can concurrent writers corrupt the WAL file, requiring manual database recovery and causing extended downtime?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.printLongQuery()] [Long Query Detection Threshold] The printLongQuery() method only logs queries running for >60 seconds. Can attackers craft queries that run for 58 seconds repeatedly, staying under the threshold while still causing severe performance degradation that delays transaction confirmation by >1 hour?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [25ms Log Threshold] Queries taking >25ms are logged with full SQL and parameters. Can this logging itself cause performance issues during high transaction volume, where the log I/O becomes a bottleneck that delays subsequent queries and causes cascading slowdowns?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [15 Second Loading Window] The bLoading flag is set to false after 15 seconds. If database initialization actually takes longer (e.g., due to migrations or large initial database), can queries executed during this window face different timeout behavior or missing indexes, causing inconsistent performance?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Sequential PRAGMA Execution] Multiple PRAGMA statements are executed sequentially in nested callbacks. Can this initialization delay cause connections to time out during high load, reducing effective MAX_CONNECTIONS and degrading performance below acceptable thresholds?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: Module Export] [MAX_CONNECTIONS Parameter] The MAX_CONNECTIONS parameter is passed by the caller. If different modules use different MAX_CONNECTIONS values for the same database, can this cause connection pool fragmentation where some pools exhaust connections while others have idle capacity, causing unnecessary delays?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Database Name Validation] The db_name parameter is directly concatenated into file paths without validation. Can an attacker control this parameter (e.g., via configuration injection) to specify absolute paths like '/etc/passwd', causing the node to corrupt system files or leak sensitive data?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [conf.bLight Cache Setting] For light nodes, the cache_size pragma is not set (only full nodes get -200000). Can light nodes with default small cache sizes experience severe performance degradation during catchup, causing sync delays >1 day and preventing timely transaction confirmation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.cquery()] [conf.bFaster Security Mode] The cquery() method bypasses actual queries when conf.bFaster is enabled. If this configuration can be modified at runtime (e.g., via API or message), can an attacker enable it during critical operations to skip validation queries and inject invalid units?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Path Injection via desktop_app] The database path comes from desktop_app.getAppDataDir(). If that module has vulnerabilities allowing path manipulation, can an attacker redirect the database to attacker-controlled locations, enabling database substitution attacks that inject pre-signed malicious units?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Foreign Key Timing Window] PRAGMA foreign_keys=1 is set after database open but before migrations. If migrations create tables with foreign keys referencing not-yet-created tables, do the foreign key checks fail, causing migration failures that leave the database in an inconsistent state?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Foreign Key Cascade Delete] With foreign_keys=1, DELETE operations cascade to dependent rows. Can an attacker trigger deletion of a parent unit that cascades to delete witness records, breaking witness proofs and causing light clients to reject the entire chain as invalid?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Foreign Key Deferred Checking] SQLite foreign key constraints are checked immediately by default. If a transaction needs to temporarily violate foreign keys (e.g., during unit reorg), can the immediate checking cause transaction aborts that leave the database in an inconsistent state?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getNow()] [SQLite Time Manipulation] The getNow() function returns datetime('now') which uses SQLite's built-in time. Can an attacker with OS-level access manipulate the system clock to make SQLite return incorrect timestamps, causing witness level calculations to be wrong and breaking consensus?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getRandom()] [RANDOM() Predictability] The getRandom() function returns SQLite's RANDOM(). Is this cryptographically secure, or can an attacker predict or influence the random values used in queries (e.g., for selecting witnesses or parents), causing deterministic behavior that enables attacks?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getIgnore()] [OR IGNORE Semantic Differences] The function returns 'OR IGNORE' which silently ignores constraint violations. Can this cause critical errors (e.g., duplicate unit insertion) to be silently ignored, allowing an attacker to create duplicate units with different content that break deterministic validation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Parameter Type Confusion] If params array contains non-array objects that have a length property (e.g., strings, buffers), does the function incorrectly treat them as arrays and attempt to expand placeholders, causing parameter count mismatches and query failures?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Callback vs Error Throw] When no callback is provided, errors are thrown synchronously. Can this cause unhandled exceptions in promise chains that crash the entire node process instead of returning rejected promises, causing network-wide outages?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Promise Resolve Race] When using promises, if multiple handlers are queued and onDbReady() fires, do all pending promises get resolved with the same connection, causing race conditions where multiple operations think they have exclusive access?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: close()] [No Callback Handling] The close() function accepts an optional callback but doesn't wait for pending queries to complete before closing. Can this cause in-flight queries to fail mid-execution, corrupting database state if partial writes complete before the close?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getCountUsedConnections()] [Race Condition Visibility] This function iterates arrConnections and counts bInUse flags. Can concurrent modifications to bInUse cause incorrect counts that misrepresent pool health, leading to incorrect resource allocation decisions by monitoring systems?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Arguments Object Mutation] The function modifies the arguments object by pushing new callbacks. Can this cause issues in strict mode or with certain JavaScript engine optimizations, leading to unexpected behavior or performance degradation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Lodash _.flatten Depth] The function uses _.flatten(params) which flattens arrays one level by default. Can attackers pass nested arrays that aren't fully flattened, causing some parameters to be arrays instead of scalars, which SQLite parameter binding may handle incorrectly?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Database File Descriptor Leak] If database opening succeeds but subsequent PRAGMA settings fail, is the database file descriptor properly closed, or does it leak, eventually exhausting file descriptors and preventing any new database connections?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [Symbolic Link Attack] On desktop platforms, can an attacker create a symbolic link at the expected database path pointing to a sensitive system file? When the node attempts to initialize, would it overwrite the system file with the initial database, causing system instability?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Result Object Mutation] The callback receives a result object that may be modified by calling code. If the same result object is reused across multiple queries (e.g., due to caching), can mutations affect subsequent queries and cause data corruption?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Starvation During Migration] If sqlite_migrations.migrateDb() takes a very long time (e.g., reindexing large tables), can requests that arrive during migration queue up indefinitely, causing a backlog that takes hours to clear even after migration completes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Callback Queue Corruption] If handleConnection callback throws an exception, does this corrupt the connection object's state or the arrQueue, causing subsequent connection requests to fail or receive incorrect connection objects?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Time Measurement Wrap Around] The consumed_time is calculated as Date.now() - start_ts. Can long-running queries (>24 days) cause integer overflow in the time calculation, resulting in incorrect performance metrics or missing long query detection?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: escape()] [Array Member Type Coercion] When escaping arrays, the function recursively calls escape() on members. Can non-string members (e.g., numbers, booleans) be coerced to strings in unexpected ways that bypass escaping, allowing SQL injection through numeric array parameters?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Connection Pool Exhaustion DoS] Can an attacker submit queries that hold connections indefinitely without calling connection.release(), exhausting all MAX_CONNECTIONS and preventing legitimate transactions from being processed, causing a network halt lasting >24 hours?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Queue Overflow DoS] Is the arrQueue array unbounded, allowing an attacker to flood the system with millions of pending connection requests that consume all available memory, crashing the node and preventing network transaction confirmation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Long Query DoS] Can an attacker craft SQL queries with extremely expensive operations (e.g., cross joins on large tables, complex subqueries) that consume connection resources beyond the busy_timeout of 30 seconds, causing database locks and preventing other nodes from confirming transactions for >1 hour?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Connection Leak] If sqlite_migrations.migrateDb() fails or hangs during database initialization, does the connection remain marked as bInUse=true permanently, leaking connections until MAX_CONNECTIONS is reached and causing eventual network halt?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.release()] [Race Condition in Release] If two threads simultaneously call connection.release() on the same connection object, can both threads mark bInUse=false and process different handlers from arrQueue, causing one connection to serve two concurrent queries and creating database corruption via non-serialized writes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Connection State Race] When checking !arrConnections[i].bInUse in the loop, if another thread sets bInUse=true between the check and the assignment, can two handlers receive the same connection, leading to interleaved query execution and database inconsistency that breaks double-spend prevention?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Database Lock at Startup] If multiple node instances attempt to open the same SQLite database file simultaneously with PRAGMA journal_mode=WAL, can conflicting WAL file locks cause some nodes to permanently fail initialization, creating a partial network partition?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: query()] [Promise Memory Leak] When queries are called without callbacks, new Promise objects are created but if the connection is never released due to an error in the callback chain, do these promises accumulate in memory, eventually causing OOM crashes and network-wide unavailability?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: escape()] [Null Byte Injection Bypass] The escape function checks for \\\\0 characters and converts to hex, but can an attacker inject UTF-8 sequences that decode to null bytes after SQLite's internal processing, bypassing the check and terminating SQL strings prematurely to inject malicious SQL?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: escape()] [Single Quote Doubling Logic] The escape function replaces ' with '', but if the resulting escaped string is concatenated into a LIKE pattern or other context where '' has special meaning, can an attacker craft inputs that break out of the string literal and inject arbitrary SQL?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Parameter Count Mismatch] If expandArrayPlaceholders() is called with a SQL string containing question marks in SQL comments (e.g., /* ? */), does the placeholder expansion incorrectly count these as parameters, causing params.length mismatch and either throwing an error that reveals database structure or silently corrupting the query?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Empty Array to NULL Conversion] When an array parameter is empty (length 0), the function replaces ? with NULL. Can an attacker use this to bypass NOT NULL constraints or inject NULL into security-critical fields like unit signatures, allowing unsigned transactions to be stored?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Array Flattening Attack] If an attacker passes nested arrays as parameters (e.g., [[value1, value2]]), does _.flatten() recursively flatten them, causing parameter count mismatches that could lead to SQL injection if the flattened array length doesn't match the expanded placeholder count?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: escape()] [Buffer Hex Encoding] When strings contain null bytes and are converted to hex with Buffer.from(str, 'utf8').toString('hex'), can an attacker exploit encoding edge cases where invalid UTF-8 sequences are normalized, causing the hex representation to differ from the original string and bypass validation checks?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [SQL Injection via Object Parameters] If parameters include JavaScript objects that are implicitly converted to strings (e.g., {toString: () =>",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Regex Injection in SQL Split] The function splits SQL on '?' characters without considering escaped question marks or question marks in string literals. Can an attacker craft SQL with strategically placed ? inside string literals to cause incorrect placeholder expansion that results in parameter misalignment and SQL injection?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [TOCTOU Race on Database File] On desktop platforms, the function checks if the database file exists with fs.stat() then creates it. Can two node instances simultaneously pass the stat check and both attempt to copy the initial database, causing file corruption that prevents any node from starting and halting the network?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [Directory Creation Race] When creating parent_dir and path directories with fs.mkdir(), if multiple processes race to create the same directory structure, can EEXIST errors be ignored incorrectly, causing one process to write the database file while another is mid-creation, resulting in a corrupted database that breaks consensus?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [Initial Database File Substitution] On Cordova platforms, the function copies from 'www/' + initial_db_filename without verifying the file's integrity. Can an attacker replace the initial database file in the app bundle with a malicious version containing pre-confirmed fraudulent transactions, causing all new installations to start with corrupted state?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Readonly Flag Bypass] When bReadOnly is true, the database is opened with sqlite3.OPEN_READONLY, but if the database file permissions allow writing or if WAL mode is already enabled, can write operations still succeed, violating the readonly contract and causing unexpected state mutations in supposedly readonly nodes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [Cordova Device Ready Race] The function waits for the 'deviceready' event before accessing the file system. If an attacker can trigger device pairing or unit validation before deviceready fires, do these operations fail silently or throw unhandled exceptions that crash the node, preventing transaction processing?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [File Permission Exploitation] On desktop platforms, directories are created with mode 0700 (owner-only access). If the user's umask is misconfigured or the parent directory has insecure permissions, can other users on the system read the database file and extract private keys, witness lists, or other sensitive data?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Database Path Traversal] The database path is constructed as path + db_name where path comes from desktop_app.getAppDataDir(). Can an attacker manipulate the environment or configuration to make db_name contain '../' sequences, causing the database to be opened/created outside the intended directory and potentially overwriting system files?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Foreign Keys Disabled Window] PRAGMA foreign_keys=1 is set after database open. During the brief window before this pragma is executed, can an attacker insert records that violate foreign key constraints (e.g., units referencing non-existent parent units), causing permanent DAG corruption that breaks consensus?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [WAL Mode Concurrency Issues] PRAGMA journal_mode=WAL enables Write-Ahead Logging. If multiple processes open the same database (e.g., during migration or backup), can conflicting WAL checkpoint operations cause database corruption where some transactions are lost, leading to double-spend vulnerabilities?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Synchronous FULL Performance DoS] PRAGMA synchronous=FULL forces disk sync after every transaction. Can an attacker flood the network with many small transactions that each trigger expensive fsync() calls, causing severe performance degradation where transaction confirmation takes >1 day, meeting the Immunefi medium severity criteria?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Busy Timeout Deadlock] PRAGMA busy_timeout=30000 sets a 30-second timeout for lock acquisition. Can an attacker submit a long-running transaction (e.g., updating MC index for all units) that holds locks for >30 seconds, causing all other connections to timeout and throw errors that crash dependent modules like validation.js?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Cache Size Memory Exhaustion] For full nodes, PRAGMA cache_size=-200000 sets a 200MB page cache. Can an attacker trigger queries that load massive amounts of data into the cache (e.g., scanning all historical units), exhausting system memory and causing OOM kills that halt the network?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Temp Store Memory DoS] PRAGMA temp_store=MEMORY forces temporary tables into RAM. Can an attacker craft queries with large temporary result sets (e.g., complex JOINs or GROUP BY operations on millions of rows) that consume all available memory, crashing the node and preventing transaction confirmation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Migration Failure Recovery] If sqlite_migrations.migrateDb() fails partway through schema changes, does the connection remain in an inconsistent state where some tables have new schemas and others have old schemas, causing validation queries to return incorrect results and breaking double-spend prevention?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [No Explicit Transaction Support] The connection object doesn't expose BEGIN/COMMIT/ROLLBACK methods. Can calling modules like storage.js perform multi-step operations (e.g., inserting a unit + updating balances + marking inputs as spent) without transaction protection, causing partial commits during crashes that create inconsistent database state?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Autocommit Between Queries] SQLite in autocommit mode commits after each query. If a module executes multiple related queries on the same connection (e.g., validating inputs, then inserting outputs), can a crash between queries leave the database in a state where inputs are marked spent but outputs don't exist, permanently locking funds?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Non-Deterministic Query Ordering] If multiple connections execute queries concurrently without proper locking, can the order of operations (e.g., inserting unit A vs unit B) differ across nodes, causing non-deterministic MC index assignment and permanent chain splits?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.release()] [Connection Release Before Commit] If a module calls connection.release() immediately after connection.query() without waiting for the callback, can the connection be reused for a different query before the first query's WAL buffer is flushed to disk, causing commits to be lost during crashes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: query()] [Callback vs Promise Inconsistency] The query() function supports both callbacks and promises. If a module mixes these patterns (e.g., uses promise for one query, callback for another), can error handling differences cause some database errors to be silently swallowed, allowing invalid units to be stored?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [SQL Error Information Disclosure] When a query fails, the error is thrown with the full SQL string and parameters. Can an attacker trigger validation errors that expose database schema, table names, and constraint details, providing reconnaissance information for crafting more sophisticated attacks?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Database Open Error Exposure] If database opening fails, the function throws Error(err) which may contain file system paths, permission details, or disk corruption information. Can an attacker intentionally corrupt the database file to trigger these errors and extract sensitive path information or system configuration?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Parameter Logging Security] When consumed_time > 25ms, the function logs query details including parameters. Can an attacker submit queries that deliberately exceed this threshold to force logging of sensitive data (e.g., private payment amounts, AA state variable keys) to disk, where it can be extracted later?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Unhandled Promise Rejections] When using promises without callbacks, if the query fails, does the promise rejection propagate correctly, or can unhandled promise rejections cause silent failures where critical validation queries fail but the node continues processing, accepting invalid units?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Migration Error Masking] If sqlite_migrations.migrateDb() encounters errors during schema upgrades, does it call the handleConnection callback anyway with a partially migrated database, causing subsequent queries to fail unpredictably and potentially accepting units that should be rejected?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.release()] [Double Release Attack] If connection.release() is called twice on the same connection, can the second call pop a handler from arrQueue and assign the same connection to two different operations, causing query interleaving where results from query A are returned to the callback for query B, corrupting validation logic?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [bInUse Check Bypass] The query() method throws an error if !this.bInUse, but this check isn't atomic. Can an attacker race two threads where one calls release() and another calls query() simultaneously, bypassing the check and executing a query on a released connection that's being used elsewhere?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Queue Starvation] When all connections are busy, new requests are queued in arrQueue. If long-running queries monopolize all connections, can queued requests starve indefinitely, causing transaction confirmation delays >1 hour even though the queue isn't full?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [CurrentQuery Race Condition] The currentQuery field is set before query execution and cleared after. If printLongQuery() reads this field concurrently, can it capture a partially-written array, causing crashes when trying to log undefined elements or exposing memory addresses via toString() coercion?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: close()] [Incomplete Shutdown] The close() function only closes arrConnections[0] and shifts the array. If multiple connections are open, do the remaining connections stay open indefinitely with active queries, preventing clean shutdown and potentially corrupting the database when the process is forcefully terminated?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Ready State Race] If takeConnectionFromPool() is called before onDbReady() fires, it queues the request on the eventEmitter. If the database initialization fails and onDbReady() never fires, do all queued requests leak memory and never execute, causing gradual memory exhaustion?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [SELECT vs Non-SELECT Detection] The code uses regex /^\\\\s*SELECT/i to detect SELECT queries. Can an attacker craft queries that don't match this pattern but still perform reads (e.g., WITH ... SELECT, or /* comment */ SELECT), causing the wrong execution path (db.run vs db.all) and returning incorrect result formats?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Result Transformation Cordova] On Cordova, result.affectedRows is always 1 even for multi-row inserts. Can this cause validation logic that checks affectedRows to incorrectly conclude that only one row was inserted when multiple were, breaking balance calculations and allowing asset inflation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [This Context Binding] The callback uses 'this.changes' and 'this.lastID' which come from sqlite3's db.run() context. Can an attacker manipulate the execution environment to corrupt the 'this' binding, causing affectedRows or insertId to return values from a previous query and breaking unit storage logic?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.cquery()] [conf.bFaster Validation Bypass] When conf.bFaster is true, cquery() skips the actual query and immediately calls the callback. Can an attacker enable this configuration during critical validation queries (e.g., checking if an output is already spent), allowing double-spends to pass validation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: addQuery()] [Async.series Callback Injection] The addQuery() function wraps callbacks for async.series(). If the original callback doesn't call callback() to signal completion, does the async.series chain hang, preventing subsequent queries in the batch from executing and causing transaction confirmation delays?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Undefined Parameter Handling] If parameters array contains undefined values, are they bound as NULL in SQL? Can an attacker exploit this to bypass NOT NULL constraints or cause unexpected NULL equality checks in WHERE clauses, potentially retrieving or modifying unintended records?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: addTime()] [SQL Injection in Time Intervals] The addTime() function constructs SQL like datetime('now', '-8 SECOND') by string concatenation. Can an attacker pass interval values containing SQL injection payloads (e.g., '0 SECOND'); DROP TABLE units; --') that execute arbitrary SQL when the query is run?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getUnixTimestamp()] [Date Parameter Injection] The getUnixTimestamp() function concatenates the date parameter into SQL like strftime('%s', date). Can an attacker pass malicious date values (e.g., datetime('now') || '; DROP TABLE units; --') that inject SQL commands?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getFromUnixTime()] [Timestamp Injection] The getFromUnixTime() function constructs datetime(ts, 'unixepoch') by concatenating ts. Can an attacker provide a string like '0) || (SELECT password FROM users) || (' that extracts sensitive data from the database via SQL injection?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: forceIndex()] [Index Name Injection] The forceIndex() function returns 'INDEXED BY ' + index without escaping. Can an attacker pass index names containing SQL keywords or operators (e.g., 'idx; DROP TABLE units;') that execute arbitrary SQL when the query is built?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: dropTemporaryTable()] [Table Name Injection] The dropTemporaryTable() function constructs 'DROP TABLE IF EXISTS ' + table. Can an attacker pass table names with SQL injection payloads (e.g., 'temp; DROP TABLE units; --') that drop permanent tables instead of temporary ones, corrupting the entire database?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: escape()] [Array Escaping Recursion] The escape() function recursively escapes array members. Can an attacker pass deeply nested arrays that cause stack overflow during recursion, crashing the node and preventing transaction processing?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Large Result Set Memory] When executing SELECT queries with db.all(), all rows are loaded into memory. Can an attacker craft queries that return millions of rows (e.g., SELECT * FROM units), exhausting available memory and crashing the node with OOM errors?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Large Array Parameters] If an attacker passes array parameters with millions of elements, does the placeholder expansion create SQL strings with millions of '?' placeholders, consuming excessive memory during string concatenation and causing crashes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Query History Accumulation] The connection.currentQuery field stores the full query and parameters. If these contain large binary blobs or very long strings, does the memory accumulate over time across all connections, eventually causing memory exhaustion?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Connection Object Leak] Each connection object has a setInterval timer for printLongQuery(). If connections are created but never properly closed, do these timers continue running indefinitely, gradually accumulating timers that consume CPU and prevent garbage collection?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [EventEmitter Memory Leak] When !bReady, listeners are registered on eventEmitter.once('ready'). If onDbReady() fails to fire due to database initialization errors, do these listeners accumulate with each failed connection attempt, causing a memory leak that eventually crashes the node?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Cordova SQLite Plugin Unavailable] The code checks 'window.cordova' to detect Cordova environment but doesn't verify that cordova-sqlite-plugin is actually installed. Can an app launch in Cordova mode without the plugin, causing cordovaSqlite constructor to be undefined and all database operations to fail silently?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Cordova Query Path Differences] On Cordova, queries use self.db.query() while on desktop they use db.all()/db.run(). Can subtle differences in parameter binding or error handling between these implementations cause queries to behave differently, breaking consensus between mobile and desktop nodes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getParentDirPath()] [Platform Detection Bypass] The platform detection uses window.cordova.platformId which can be 'ios', 'android', or default. Can an attacker run on an unsupported platform (e.g., Windows Phone, browser) that defaults to Android paths, causing database operations to fail or write to incorrect locations?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [Cordova File System Permissions] On Android, the database is stored in applicationStorageDirectory/databases/. Can this location be readable by other apps with storage permissions, allowing malicious apps to clone the database and extract private keys or transaction history?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [iOS Library Backup] On iOS, files in Library/ are backed up to iCloud by default. Does this cause the database file (containing private keys) to be uploaded to iCloud, where it could be accessed by Apple or leaked in data breaches?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [storage.js Transaction Assumption] If storage.js assumes queries on the same connection are atomic, but sqlite_pool.js doesn't guarantee transaction boundaries, can interleaved queries from different modules corrupt multi-step operations like unit insertion, causing DAG inconsistencies?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: query()] [validation.js Deadlock] If validation.js performs expensive queries while holding a connection, and another module is waiting in arrQueue for a connection to commit the validated unit, can a circular dependency deadlock occur where validation never completes because the unit can't be committed?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [main_chain.js MC Update Race] If main_chain.js updates MC indices using one connection while validation.js reads MC indices using another connection without proper locking, can validation read stale MC values and accept units with incorrect witness levels, breaking consensus?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [aa_validation.js State Read Race] When AA execution reads state variables across multiple queries, if another AA execution commits state changes between these reads, can the first AA see inconsistent state (phantom reads), causing non-deterministic formula evaluation that breaks consensus?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: close()] [network.js Shutdown Race] If network.js is still receiving and processing units while sqlite_pool.js is closing connections, can units be partially stored with some database writes succeeding and others failing, corrupting the DAG and preventing the node from restarting?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [wallet.js Balance Calculation] If wallet.js calculates balances using snapshot reads without transaction isolation, and composer.js simultaneously spends outputs, can wallet.js see inconsistent balance states and compose transactions that spend non-existent outputs, causing validation failures?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [WAL Checkpoint Starvation] With journal_mode=WAL, write-ahead logs must be periodically checkpointed. If the database experiences high write volume and checkpoints never complete, can the WAL file grow unboundedly until disk space is exhausted, crashing the node?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [WAL Mode Readonly Conflict] When opening in readonly mode (bReadOnly=true), WAL mode may still require write access to the -shm shared memory file. Can readonly nodes fail to open the database or cause conflicts with other processes, preventing light clients from syncing?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [WAL Mode Crash Recovery] If a node crashes while uncommitted transactions are in the WAL, does the next startup correctly recover these transactions, or can partial transactions be lost, causing inconsistencies between database state and the DAG stored on disk?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [WAL Mode Concurrent Writers] SQLite's WAL mode allows one writer and multiple readers. If multiple node processes accidentally open the same database (e.g., during upgrade), can concurrent writers corrupt the WAL file, requiring manual database recovery and causing extended downtime?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.printLongQuery()] [Long Query Detection Threshold] The printLongQuery() method only logs queries running for >60 seconds. Can attackers craft queries that run for 58 seconds repeatedly, staying under the threshold while still causing severe performance degradation that delays transaction confirmation by >1 hour?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [25ms Log Threshold] Queries taking >25ms are logged with full SQL and parameters. Can this logging itself cause performance issues during high transaction volume, where the log I/O becomes a bottleneck that delays subsequent queries and causes cascading slowdowns?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [15 Second Loading Window] The bLoading flag is set to false after 15 seconds. If database initialization actually takes longer (e.g., due to migrations or large initial database), can queries executed during this window face different timeout behavior or missing indexes, causing inconsistent performance?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Sequential PRAGMA Execution] Multiple PRAGMA statements are executed sequentially in nested callbacks. Can this initialization delay cause connections to time out during high load, reducing effective MAX_CONNECTIONS and degrading performance below acceptable thresholds?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: Module Export] [MAX_CONNECTIONS Parameter] The MAX_CONNECTIONS parameter is passed by the caller. If different modules use different MAX_CONNECTIONS values for the same database, can this cause connection pool fragmentation where some pools exhaust connections while others have idle capacity, causing unnecessary delays?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Database Name Validation] The db_name parameter is directly concatenated into file paths without validation. Can an attacker control this parameter (e.g., via configuration injection) to specify absolute paths like '/etc/passwd', causing the node to corrupt system files or leak sensitive data?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [conf.bLight Cache Setting] For light nodes, the cache_size pragma is not set (only full nodes get -200000). Can light nodes with default small cache sizes experience severe performance degradation during catchup, causing sync delays >1 day and preventing timely transaction confirmation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.cquery()] [conf.bFaster Security Mode] The cquery() method bypasses actual queries when conf.bFaster is enabled. If this configuration can be modified at runtime (e.g., via API or message), can an attacker enable it during critical operations to skip validation queries and inject invalid units?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Path Injection via desktop_app] The database path comes from desktop_app.getAppDataDir(). If that module has vulnerabilities allowing path manipulation, can an attacker redirect the database to attacker-controlled locations, enabling database substitution attacks that inject pre-signed malicious units?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Foreign Key Timing Window] PRAGMA foreign_keys=1 is set after database open but before migrations. If migrations create tables with foreign keys referencing not-yet-created tables, do the foreign key checks fail, causing migration failures that leave the database in an inconsistent state?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Foreign Key Cascade Delete] With foreign_keys=1, DELETE operations cascade to dependent rows. Can an attacker trigger deletion of a parent unit that cascades to delete witness records, breaking witness proofs and causing light clients to reject the entire chain as invalid?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Foreign Key Deferred Checking] SQLite foreign key constraints are checked immediately by default. If a transaction needs to temporarily violate foreign keys (e.g., during unit reorg), can the immediate checking cause transaction aborts that leave the database in an inconsistent state?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getNow()] [SQLite Time Manipulation] The getNow() function returns datetime('now') which uses SQLite's built-in time. Can an attacker with OS-level access manipulate the system clock to make SQLite return incorrect timestamps, causing witness level calculations to be wrong and breaking consensus?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getRandom()] [RANDOM() Predictability] The getRandom() function returns SQLite's RANDOM(). Is this cryptographically secure, or can an attacker predict or influence the random values used in queries (e.g., for selecting witnesses or parents), causing deterministic behavior that enables attacks?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getIgnore()] [OR IGNORE Semantic Differences] The function returns 'OR IGNORE' which silently ignores constraint violations. Can this cause critical errors (e.g., duplicate unit insertion) to be silently ignored, allowing an attacker to create duplicate units with different content that break deterministic validation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Parameter Type Confusion] If params array contains non-array objects that have a length property (e.g., strings, buffers), does the function incorrectly treat them as arrays and attempt to expand placeholders, causing parameter count mismatches and query failures?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Callback vs Error Throw] When no callback is provided, errors are thrown synchronously. Can this cause unhandled exceptions in promise chains that crash the entire node process instead of returning rejected promises, causing network-wide outages?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Promise Resolve Race] When using promises, if multiple handlers are queued and onDbReady() fires, do all pending promises get resolved with the same connection, causing race conditions where multiple operations think they have exclusive access?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: close()] [No Callback Handling] The close() function accepts an optional callback but doesn't wait for pending queries to complete before closing. Can this cause in-flight queries to fail mid-execution, corrupting database state if partial writes complete before the close?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: getCountUsedConnections()] [Race Condition Visibility] This function iterates arrConnections and counts bInUse flags. Can concurrent modifications to bInUse cause incorrect counts that misrepresent pool health, leading to incorrect resource allocation decisions by monitoring systems?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Arguments Object Mutation] The function modifies the arguments object by pushing new callbacks. Can this cause issues in strict mode or with certain JavaScript engine optimizations, leading to unexpected behavior or performance degradation?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: expandArrayPlaceholders()] [Lodash _.flatten Depth] The function uses _.flatten(params) which flattens arrays one level by default. Can attackers pass nested arrays that aren't fully flattened, causing some parameters to be arrays instead of scalars, which SQLite parameter binding may handle incorrectly?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: openDb()] [Database File Descriptor Leak] If database opening succeeds but subsequent PRAGMA settings fail, is the database file descriptor properly closed, or does it leak, eventually exhausting file descriptors and preventing any new database connections?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: createDatabaseIfNecessary()] [Symbolic Link Attack] On desktop platforms, can an attacker create a symbolic link at the expected database path pointing to a sensitive system file? When the node attempts to initialize, would it overwrite the system file with the initial database, causing system instability?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Result Object Mutation] The callback receives a result object that may be modified by calling code. If the same result object is reused across multiple queries (e.g., due to caching), can mutations affect subsequent queries and cause data corruption?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: takeConnectionFromPool()] [Starvation During Migration] If sqlite_migrations.migrateDb() takes a very long time (e.g., reindexing large tables), can requests that arrive during migration queue up indefinitely, causing a backlog that takes hours to clear even after migration completes?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connect()] [Callback Queue Corruption] If handleConnection callback throws an exception, does this corrupt the connection object's state or the arrQueue, causing subsequent connection requests to fail or receive incorrect connection objects?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: connection.query()] [Time Measurement Wrap Around] The consumed_time is calculated as Date.now() - start_ts. Can long-running queries (>24 days) cause integer overflow in the time calculation, resulting in incorrect performance metrics or missing long query detection?",
  "[File: byteball/ocore/sqlite_pool.js] [Function: escape()] [Array Member Type Coercion] When escaping arrays, the function recursively calls escape() on members. Can non-string members (e.g., numbers, booleans) be coerced to strings in unexpected ways that bypass escaping, allowing SQL injection through numeric array parameters?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Non-deterministic ordering] In the recursive object key sorting at line 38, if two JavaScript engines produce different sort orders for keys containing non-ASCII Unicode characters (e.g., emoji, CJK characters, or combining diacritics), could this cause different nodes to compute different unit hashes for the same unit content, leading to permanent chain split requiring hard fork?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Null value handling] The function throws an error for null values at line 15, but what happens if an attacker constructs a unit where a critical field (e.g., parent unit hash, witness address) is set to null in a way that bypasses earlier validation? Could this cause some nodes to reject the unit while others process it with default values, causing chain divergence?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Empty array rejection] The function rejects empty arrays at line 31, but does this check apply recursively to nested arrays? Can an attacker submit a unit with structure like `{\\",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Empty object rejection] At line 40, empty objects are rejected, but can an attacker craft a unit definition with an object that becomes empty after prototype pollution or property deletion in transit, causing some nodes to accept it during initial validation but reject it during hash recalculation, freezing fund withdrawals?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Undefined property handling] The function checks for undefined properties at line 42-43, but does this detect properties set to `undefined` via `Object.defineProperty()` with getter functions that return undefined conditionally? Could race conditions cause the same object to produce different hashes on different validation passes?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Number precision] At line 23, numbers are converted to strings using `toString()`. For very large integers near `Number.MAX_SAFE_INTEGER` (2^53-1), can floating-point precision loss cause the same numeric value to be serialized differently on 32-bit vs 64-bit systems, breaking hash determinism?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Infinity/NaN handling] The function rejects non-finite numbers at line 21-22, but what happens if an attacker encodes `Infinity` or `NaN` as a string (e.g., `\\",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Type confusion] At line 16-27, the function handles string, number, and boolean types with specific prefixes ('s', 'n', 'b'). Can an attacker exploit JavaScript type coercion by submitting a unit where a field is a boxed primitive (e.g., `new String(\\",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Array hole handling] At line 33-34, the function iterates over array indices, but does it correctly handle sparse arrays with holes (e.g., `[1, , 3]` where index 1 is empty)? Could this cause different serializations depending on whether holes are skipped or serialized as undefined, breaking consensus?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Symbol property injection] The function uses `Object.keys()` at line 38, which doesn't enumerate Symbol properties. Can an attacker add Symbol-keyed properties to a unit object that get ignored during hash calculation but later affect unit validation or AA execution, causing state divergence?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Prototype pollution impact] If an attacker pollutes `Object.prototype` or `Array.prototype` with additional properties before a unit is hashed, will `Object.keys(variable).sort()` at line 38 include the polluted properties, changing the hash? Could this be exploited to create hash collisions or forge unit signatures?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [STRING_JOIN_CHAR collision] The function joins components with null byte `\\\\x00` at line 55. Can an attacker craft nested object structures where legitimate string values contain `\\\\x00` bytes, causing the join operation to produce ambiguous serializations where `{\\",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Recursive depth attack] The `extractComponents()` function at line 13 is recursive with no depth limit. Can an attacker submit a unit with deeply nested objects (e.g., 10,000+ levels deep) to cause stack overflow, crashing the node and enabling a total network shutdown via DoS?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Circular reference handling] The function does not check for circular references. Can an attacker create a unit object where `obj.child = obj` or similar circular structure, causing infinite recursion at line 34 or 45, crashing all nodes that attempt to hash it and freezing network transactions for >24 hours?",
  "[File: byteball/ocore/string_utils.js] [Function: getSourceString()] [Memory exhaustion] For very large arrays or objects with millions of keys, the `arrComponents` array at line 12 could grow unbounded. Can an attacker submit a unit with massive nested structures to exhaust node memory during hash calculation, causing OOM crashes and network halt?",
  "[File: byteball/ocore/string_utils.js] [Function: encodeMci()] [Integer overflow] The function computes `0xFFFFFFFF - mci` at line 60. If `mci` is negative or exceeds 2^32-1, can this cause integer overflow or underflow, producing colliding encoded values? For example, would `encodeMci(-1)` produce the same result as `encodeMci(0xFFFFFFFF)`, breaking data feed ordering in main_chain.js?",
  "[File: byteball/ocore/string_utils.js] [Function: encodeMci()] [Type coercion] At line 60, if `mci` is passed as a string (e.g., `\\",
  "[File: byteball/ocore/string_utils.js] [Function: encodeMci()] [Hex padding edge case] The function uses `padStart(8, '0')` at line 60 to ensure 8 hex digits. What happens if the result of `(0xFFFFFFFF - mci).toString(16)` is already longer than 8 characters due to overflow? Would `padStart()` leave it unchanged, causing database key collisions?",
  "[File: byteball/ocore/string_utils.js] [Function: getMciFromDataFeedKey()] [Array split vulnerability] At line 64, the function splits the key by newline and takes the last element. Can an attacker inject newlines into earlier parts of the data feed key (e.g., in the `feed_name` or `value` fields) to manipulate which component is treated as the MCI, corrupting the decoded MCI value?",
  "[File: byteball/ocore/string_utils.js] [Function: getMciFromDataFeedKey()] [Hex parse failure] At line 66, `parseInt(strReversedMci, 16)` is called without validating that `strReversedMci` contains valid hex characters. If the last element after split is not a valid hex string (e.g., contains 'g-z' characters), will `parseInt` return `NaN`, and will line 67 produce an invalid MCI that breaks AA data feed lookups?",
  "[File: byteball/ocore/string_utils.js] [Function: getMciFromDataFeedKey()] [Unsigned integer assumption] At line 67, the function computes `0xFFFFFFFF - reversed_mci`. If `reversed_mci` is greater than 0xFFFFFFFF (from overflow or malformed input), can this produce negative MCI values that break main_chain.js's MCI ordering invariants, causing MC index corruption?",
  "[File: byteball/ocore/string_utils.js] [Function: getValueFromDataFeedKey()] [Array length assumption] The function splits the key by newline and checks `if (m.length !== 6)` at line 74. However, if the `value` field itself contains newline characters (e.g., a multi-line string), will this cause the split to produce more than 6 elements, throwing an error and causing AA executions that depend on this data feed to fail, freezing funds?",
  "[File: byteball/ocore/string_utils.js] [Function: getValueFromDataFeedKey()] [Type indicator trust] At line 76-77, the function extracts `type` and `value` from array indices without validation. If an attacker crafts a data feed key where the type indicator at position [3] is something other than 's' or a valid numeric type, will line 78 call `decodeLexicographicToDouble()` on invalid input, potentially returning corrupted numeric values that cause incorrect AA state transitions?",
  "[File: byteball/ocore/string_utils.js] [Function: getValueFromDataFeedKey()] [Ternary operator precedence] At line 78, the ternary operator `(type === 's') ? value : decodeLexicographicToDouble(value)` assumes binary type distinction. What happens if `type` is 'n' but `value` is not a valid hex-encoded double? Will `decodeLexicographicToDouble()` silently corrupt the value, causing AAs to read incorrect oracle data and execute wrong logic?",
  "[File: byteball/ocore/string_utils.js] [Function: toNumber()] [Limited precision mode] The function has two different parsing behaviors based on `bLimitedPrecision` parameter at line 85. If this boolean is set incorrectly due to MCI comparison logic (`bLimitedPrecision = (max_mci < constants.aa2UpgradeMci)`), could nodes before and after the upgrade MCI parse the same numeric string differently, causing AA executions to diverge and creating permanent chain split?",
  "[File: byteball/ocore/string_utils.js] [Function: toNumber()] [Regex bypass] The regex at line 89 matches `^[+-]?(\\\\d+(\\\\.\\\\d+)?)([eE][+-]?(\\\\d+))?$`. Can an attacker submit a value like `\\",
  "[File: byteball/ocore/string_utils.js] [Function: toNumber()] [Scientific notation edge case] At line 97, the function checks `if (f === 0 && mantissa > 0 && abs_exp > 0)` to detect underflow. However, what about a value like `\\",
  "[File: byteball/ocore/string_utils.js] [Function: toNumber()] [Null vs zero ambiguity] The function returns `null` to indicate invalid input at lines 91, 94, 98. Can calling code distinguish between `toNumber()` returning `null` (invalid) and returning `0` (valid zero)? Could an attacker exploit this ambiguity to make AAs treat invalid feed values as zero, bypassing price oracle checks?",
  "[File: byteball/ocore/string_utils.js] [Function: toNumber()] [Type check bypass] At line 88, the function throws an error if the value is not a string and `bLimitedPrecision` is false. But if `bLimitedPrecision` is true, line 86 calls `getNumericFeedValue()` without type validation. Can an attacker pass a non-string non-number value (e.g., object, array) that bypasses the check and corrupts the parsing logic?",
  "[File: byteball/ocore/string_utils.js] [Function: getNumericFeedValue()] [Mantissa length check] At line 124, the function rejects values where `mantissa.length > 15`. However, the comment notes this includes the decimal point, so `\\",
  "[File: byteball/ocore/string_utils.js] [Function: getNumericFeedValue()] [Significant digits mode] When `bBySignificantDigits` is true (line 115), the function counts significant digits after removing leading zeros and trailing zeros. For a value like `\\",
  "[File: byteball/ocore/string_utils.js] [Function: getNumericFeedValue()] [Decimal point handling] At line 117-118, the function removes trailing zeros and the decimal point using `replace(/0+$/, '').replace('.', '')`. If the mantissa is something like `\\",
  "[File: byteball/ocore/string_utils.js] [Function: getNumericFeedValue()] [Precision loss detection] The function returns `null` (line 120, 125) to indicate a value should remain as string rather than be converted to number. If an AA formula performs arithmetic on this string (e.g., `\\",
  "[File: byteball/ocore/string_utils.js] [Function: getNumericFeedValue()] [Mantissa extraction inconsistency] The regex at line 105 captures `mantissa = m[1]`, which includes the decimal point. But at line 116, leading zeros are removed with `replace(/^0+/, '')`. For a value like `\\",
  "[File: byteball/ocore/string_utils.js] [Function: encodeDoubleInLexicograpicOrder()] [Negative zero handling] At line 138-139, the function converts `-0` to `+0` before encoding. However, in JavaScript, `-0 === 0` returns true, so the check `if (float === -0)` will match both -0 and +0. Could this cause legitimate +0 values to be re-assigned, or is this intentional? What happens if an attacker encodes -0 in a data feed, does it get stored identically to +0, potentially breaking oracle data integrity?",
  "[File: byteball/ocore/string_utils.js] [Function: encodeDoubleInLexicograpicOrder()] [Buffer allocation] At line 140, `Buffer.allocUnsafe(8)` is used without initialization. While the next line writes to all 8 bytes, could a race condition or error in `writeDoubleBE()` leave some bytes uninitialized, causing non-deterministic encoding that breaks consensus when different nodes encode the same float?",
  "[File: byteball/ocore/string_utils.js] [Function: encodeDoubleInLexicograpicOrder()] [Sign bit flipping] At line 143, positive numbers have their first byte XORed with 0x80 to flip the sign bit. At line 145-146, negative numbers have all bytes XORed with 0xff. Can an attacker exploit edge cases in IEEE 754 representation (e.g., subnormal numbers, infinity, or specific bit patterns) to create two different floats that encode to the same hex string, breaking data feed key uniqueness?",
  "[File: byteball/ocore/string_utils.js] [Function: encodeDoubleInLexicograpicOrder()] [Endianness assumption] The function uses `writeDoubleBE()` (big-endian) at line 141. If Obyte nodes run on mixed-endianness architectures, or if Node.js version differences handle endianness differently, could this cause the same float to be encoded differently on different systems, breaking consensus?",
  "[File: byteball/ocore/string_utils.js] [Function: encodeDoubleInLexicograpicOrder()] [NaN encoding] The function does not check for NaN input. If a NaN value is passed, `writeDoubleBE()` will encode it, but IEEE 754 has multiple NaN representations with different bit patterns. Could different JavaScript engines produce different encodings for NaN, causing data feed key collisions or ordering inconsistencies in main_chain.js?",
  "[File: byteball/ocore/string_utils.js] [Function: decodeLexicographicToDouble()] [Hex validation] At line 151, `Buffer.from(hex, 'hex')` is called without validating that `hex` is a valid hex string of exactly 16 characters. If the input is shorter, longer, or contains non-hex characters, will this produce a malformed buffer that causes `readDoubleBE()` to return garbage values, corrupting AA data feed reads?",
  "[File: byteball/ocore/string_utils.js] [Function: decodeLexicographicToDouble()] [Bit manipulation symmetry] The decoding at lines 152-156 should be the exact inverse of encoding at lines 142-146. If there's any asymmetry in the XOR operations (e.g., off-by-one in the loop bounds), could this cause decoding to produce values slightly different from the original, breaking oracle data integrity in AAs?",
  "[File: byteball/ocore/string_utils.js] [Function: decodeLexicographicToDouble()] [Negative zero restoration] At line 158-159, the function converts `-0` to `+0` after decoding. Is this consistent with the encoding logic? If an oracle posts a data feed with -0 (e.g., a temperature of -0.0C), will it round-trip correctly, or will the sign be lost, causing AAs to misinterpret the data?",
  "[File: byteball/ocore/string_utils.js] [Function: decodeLexicographicToDouble()] [Buffer underflow] If the input `hex` string is shorter than 16 characters, `Buffer.from()` will create a smaller buffer. When `readDoubleBE(0)` is called at line 157, will this read beyond the buffer bounds, causing a segfault or returning undefined behavior, potentially crashing nodes?",
  "[File: byteball/ocore/string_utils.js] [Function: String.prototype.padStart] [Prototype pollution] The polyfill modifies the global `String.prototype` at line 166. If an attacker can execute code before this module loads (e.g., via another module's constructor), could they override this polyfill with a malicious implementation that subtly changes padding behavior, causing MCI encoding at line 60 to produce non-deterministic results?",
  "[File: byteball/ocore/string_utils.js] [Function: String.prototype.padStart] [Integer truncation] At line 167, `targetLength` is truncated using `>> 0` (unsigned right shift by 0). For negative target lengths or non-integer values, this coercion could produce unexpected results. Can an attacker trigger a code path where `encodeMci()` calls `padStart()` with an attacker-controlled target length, causing the padding to be wrong and breaking data feed key ordering?",
  "[File: byteball/ocore/string_utils.js] [Function: String.prototype.padStart] [Repeat overflow] At line 174, if `targetLength / padString.length` results in a very large value (e.g., target length 2^31), the `repeat()` call could allocate excessive memory, causing OOM and node crash. Can this be exploited via crafted MCI values that trigger pathological padding?",
  "[File: byteball/ocore/string_utils.js] [Function: toWellFormedJsonStringify()] [Surrogate pair handling] At line 187, the function replaces lone surrogates `[\\\\ud800-\\\\udfff]` with escaped Unicode sequences. However, if a unit contains a valid surrogate pair (high surrogate followed by low surrogate), will the regex incorrectly replace them individually, breaking the pair and causing the decoded string to differ from the original?",
  "[File: byteball/ocore/string_utils.js] [Function: toWellFormedJsonStringify()] [Codepoint conversion] The replacement at line 187 uses `chr.codePointAt(0).toString(16)` to get the hex value. For lone surrogates, `codePointAt()` returns the surrogate's code unit (e.g., 0xD800), not a valid Unicode code point. Will this produce a malformed escape sequence that fails to round-trip when parsed, causing unit hash mismatches?",
  "[File: byteball/ocore/string_utils.js] [Function: toWellFormedJsonStringify()] [Comment inconsistency] At line 186, the code contains a commented-out ternary operator that would check `bWellFormedJsonStringify` but always uses the replace logic. If future Node.js versions change their `JSON.stringify()` behavior for surrogates, could this cause nodes on different Node versions to produce different JSON strings, breaking consensus?",
  "[File: byteball/ocore/string_utils.js] [Function: toWellFormedJsonStringify()] [Regex global flag] The regex at line 187 uses the `g` flag for global replacement, but does not anchor the pattern. If the input string contains multiple lone surrogates, are they all replaced correctly, or could some be missed due to how the regex advances through the string?",
  "[File: byteball/ocore/string_utils.js] [Function: getJsonSourceString()] [Empty array/object toggle] The function has a `bAllowEmpty` parameter that, when true, allows empty arrays and objects (lines 204, 210). This is used for AA definitions where `obj[0] === 'autonomous agent'`. If an attacker finds a way to set `bAllowEmpty` to true for non-AA objects (e.g., by manipulating the calling context in object_hash.js), could they create units with empty arrays that produce different hashes than expected, breaking signature validation?",
  "[File: byteball/ocore/string_utils.js] [Function: getJsonSourceString()] [Recursive call without depth limit] The `stringify()` function at line 191 is recursive (called at lines 206, 212) with no depth limit. Similar to `getSourceString()`, can an attacker submit an AA definition with deeply nested structures to cause stack overflow, crashing nodes during AA validation?",
  "[File: byteball/ocore/string_utils.js] [Function: getJsonSourceString()] [Key sorting consistency] At line 209, object keys are sorted using `Object.keys(variable).sort()`. For AA definitions containing Unicode keys, will the sort order be identical across all JavaScript engines and Node.js versions? Could differences in locale-aware sorting cause different canonical strings on different systems?",
  "[File: byteball/ocore/string_utils.js] [Function: getJsonSourceString()] [Comma separator collision] The function joins array elements with commas at line 206 and object key-value pairs with commas at line 212. If an attacker includes commas in string values, could this create ambiguous JSON where `[\\",
  "[File: byteball/ocore/string_utils.js] [Function: getJsonSourceString()] [Boolean toString consistency] At line 201, booleans are converted using `variable.toString()`. In JavaScript, this produces `\\",
  "[File: byteball/ocore/string_utils.js] [Function: getJsonSourceString()] [Missing break statement] At line 214, the switch case for \\",
  "[File: byteball/ocore/string_utils.js] [Cross-function] [getSourceString vs getJsonSourceString] The two functions use different serialization formats (type prefixes + null byte separator vs JSON syntax). In object_hash.js line 11, AA definitions use `getJsonSourceString()` while regular objects use `getSourceString()`. Could an attacker craft an object that hashes identically under both methods, allowing them to create a non-AA unit that is validated as an AA, bypassing AA-specific checks?",
  "[File: byteball/ocore/string_utils.js] [Cross-function] [toNumber vs getNumericFeedValue] Both functions parse numeric strings but with different precision limits. In data_feeds.js lines 58-59, `toNumber()` is called with `bLimitedPrecision`. If the precision mode is inconsistent between validation and execution phases (e.g., due to MCI boundary race conditions), could an AA accept a data feed value during validation but reject it during execution, causing bounce responses and fund loss?",
  "[File: byteball/ocore/string_utils.js] [Cross-function] [encodeMci vs getMciFromDataFeedKey] The encode/decode functions should be perfect inverses. If an attacker finds an MCI value where `getMciFromDataFeedKey(key.split('\\\\n')[5])` after `encodeMci(mci)` produces a different MCI due to integer overflow or hex parsing edge cases, could they manipulate data feed query results in AAs, causing incorrect state transitions?",
  "[File: byteball/ocore/string_utils.js] [Integration: object_hash.js] [Unit hash determinism] Since `getSourceString()` is used to compute unit hashes in object_hash.js lines 11-26, any non-determinism in string_utils.js directly causes hash mismatches. If a unit contains floating-point numbers near the precision limit (e.g., `1.7976931348623157e+308`), will different CPU architectures or JavaScript engines serialize these identically, or could x86 vs ARM or V8 vs SpiderMonkey produce different hashes?",
  "[File: byteball/ocore/string_utils.js] [Integration: object_hash.js] [AA address derivation] AA addresses are derived by hashing `['autonomous agent', definition]` using `getJsonSourceString()` in object_hash.js line 11. If an attacker crafts an AA definition with edge-case JSON structures (e.g., deeply nested, empty arrays with `bAllowEmpty=true`, Unicode surrogates), could they generate hash collisions allowing two different AA definitions to have the same address?",
  "[File: byteball/ocore/string_utils.js] [Integration: data_feeds.js] [Data feed comparison] In data_feeds.js line 58, `toNumber()` is used to convert string data feed values to numbers for comparison. If an attacker submits a price feed like `\\",
  "[File: byteball/ocore/string_utils.js] [Integration: data_feeds.js] [Mixed type comparison] In data_feeds.js lines 53-74, the code compares feed values that may be numbers or strings. The logic at line 58 uses `toNumber(value, bLimitedPrecision)`. If one node is just before the AA2 upgrade MCI and another is just after, will they use different precision modes, causing one to treat a value as numeric and the other as string, breaking AA execution consistency?",
  "[File: byteball/ocore/string_utils.js] [Integration: formula/evaluation.js] [Feed value coercion] AA formulas can access data feeds via `data_feed[[oracles=ADDR, feed_name=NAME]]` syntax. The retrieved value is processed through `getValueFromDataFeedKey()` and `toNumber()` in string_utils.js. If an attacker submits a data feed with a numeric string that's valid pre-AA2 but invalid post-AA2 due to precision limits, could AAs execute differently on nodes at different upgrade stages, causing permanent chain split?",
  "[File: byteball/ocore/string_utils.js] [Integration: main_chain.js] [MCI key ordering] In main_chain.js, data feed keys are constructed using `encodeMci()` to enable efficient range queries by MCI. If the reverse hex encoding at line 60 has any edge cases (e.g., MCI near 0, MCI near 0xFFFFFFFF), could this cause database keys to sort incorrectly, breaking the main chain's ability to retrieve data feeds in chronological order and causing AA executions to read stale oracle data?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Protocol validation bypass] Can an attacker craft a URI with mixed case like 'oBYtE:' or 'BYTEBALL:' that bypasses protocol validation due to case-insensitive regex matching at lines 15-26, potentially allowing malicious URIs to be processed when the application expects only specific protocol formats?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Protocol prefix injection] When process.env.testnet or process.env.devnet are set (lines 11-14), can an attacker exploit environment variable injection to make the protocol matcher accept modified protocols like 'byteball-tn-dn:', potentially causing testnet/mainnet confusion in downstream validation?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Protocol fallback vulnerability] At lines 17-28, the function tries three different protocol formats (byteball, obyte, default obyte). Can an attacker submit URIs that match multiple protocols and exploit timing or state differences in how different protocol variants are processed by downstream modules?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Error message information leakage] When protocol validation fails at line 27, the error message reveals the expected protocol format. Can an attacker use this to fingerprint which network (testnet/devnet/mainnet) a node is running and tailor network-specific attacks?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Pairing pubkey validation bypass] At lines 35-43, pairing URIs are parsed with regex matching a 44-character pubkey. Does the regex properly validate that all 44 characters are valid base64 characters, or can an attacker inject special characters that pass regex but fail in actual cryptographic operations, causing undefined behavior in device.js pairing logic?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Pairing hub injection] The hub address at line 39 is extracted from the URI and assigned without validation beyond the regex pattern. Can an attacker inject a malicious hub address like 'evil.com:443/../../../etc/passwd' that exploits path traversal or SSRF vulnerabilities in subsequent WebSocket connection attempts?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Pairing secret length bypass] Lines 41-42 contain commented-out validation for pairing_secret length >12. Since this check is disabled, can an attacker submit extremely long pairing secrets (e.g., 1MB+) that cause memory exhaustion or buffer overflow when the secret is stored or processed by device.js pairing handlers?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Pairing URL encoding bypass] At line 35, '%23' is replaced with '#' before regex matching. Can an attacker double-encode characters like '%2523' to bypass validation and inject malicious characters into pubkey, hub, or pairing_secret fields that get decoded later in the flow?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Pairing regex catastrophic backtracking] The pairing regex at line 35 uses multiple character classes with '+' quantifiers. Can an attacker craft a near-match URI with thousands of characters that causes catastrophic backtracking in the regex engine, leading to CPU exhaustion and network DoS (1+ hour transaction delay - Medium severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Auth URL validation bypass] At lines 52-54, auth URLs must start with 'https?://' but this only checks the prefix. Can an attacker inject a URL like 'http://trusted.com@evil.com/callback' or 'https://evil.com%00trusted.com' that passes validation but redirects authentication tokens to an attacker-controlled server?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Auth device pubkey length check bypass] At line 66, the pubkey length is checked against constants.PUBKEY_LENGTH (44 characters). If constants.PUBKEY_LENGTH is modified or undefined due to a configuration error, can an attacker submit invalid-length pubkeys that corrupt the device pairing database or cause signature verification failures?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Auth hub address injection] At line 68, the hub address is validated with a blacklist regex '/[^\\\\w\\\\.:-]/'. Can an attacker inject valid-looking but malicious hub addresses like 'evil.com:65535' or '0.0.0.0:80' that bypass the blacklist but cause connection issues or exploit services running on unusual ports?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Auth missing parameter validation] Lines 57-72 check for required params but don't validate that pairing_secret, app, pubkey, and hub contain only expected characters. Can an attacker inject SQL injection payloads, XSS vectors, or control characters into these fields that get unsafely used in database queries or UI rendering?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Auth param precedence attack] At lines 52-72, the code checks 'url' first, then 'device'. If both are present in the query string, can an attacker exploit param precedence to bypass validation (e.g., submit both url and device where url passes but device has malicious content that gets processed later)?",
  "[File: byteball/ocore/uri.js] [Function: parseUri() & handleMnemonic()] [Mnemonic validation bypass] At lines 79-87, mnemonic validation relies on Mnemonic.isValid() but exceptions are caught and return generic error. Can an attacker craft a mnemonic that causes an uncaught exception in a specific edge case (e.g., memory allocation failure), causing the node to crash and potentially leading to 1+ hour network delay (Medium severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Textcoin mnemonic substitution] At line 94, hyphens in the textcoin parameter are replaced with spaces. Can an attacker submit a URI with mixed delimiters like 'word1-word2 word3-word4' that gets inconsistently parsed, causing the mnemonic to validate but derive incorrect private keys, leading to permanent fund loss when user claims the textcoin?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Textcoin word count bypass] At lines 98-101, exactly 12 hyphen-separated words are required. Can an attacker submit URIs with 11 words + empty string (e.g., 'word1-word2-...-word11-') that passes the length check but generates invalid or predictable keys, allowing the attacker to steal funds (Direct loss of funds - Critical severity)?",
  "[File: byteball/ocore/uri.js] [Function: handleMnemonic()] [Mnemonic injection after validation] The mnemonic is assigned to objRequest.mnemonic at line 80 after validation. If downstream code (wallet.js, composer.js) doesn't re-validate the mnemonic format, can an attacker exploit race conditions or state corruption to modify objRequest.mnemonic between validation and usage, stealing textcoin funds?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Textcoin type confusion] At lines 91-102, two different paths set objRequest.type = 'textcoin' - one with explicit 'textcoin?' prefix and one with hyphen-separated words. Can an attacker exploit differences in how these two paths are handled downstream to bypass additional validation or trigger unexpected behavior in wallet claiming logic?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Data app type injection] At lines 118-119, the app type is validated against a hardcoded whitelist. Can an attacker submit app types with trailing/leading whitespace, null bytes, or Unicode homoglyphs that pass the whitelist check but are interpreted differently by downstream AA validation or message storage modules?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Data attestation address bypass] At lines 120-121, attestation addresses are validated with ValidationUtils.isValidAddress(). If there's a discrepancy between uri.js address validation and the validation in definition.js or validation.js, can an attacker submit an address that passes here but fails later, causing inconsistent state or transaction failures?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Data vote unit hash collision] At lines 122-123, poll units are validated with ValidationUtils.isValidBase64() checking constants.HASH_LENGTH (32 bytes). Can an attacker submit a SHA256 collision or second pre-image that passes validation but references a different poll than intended, manipulating vote outcomes?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Data definition SSRF] At lines 124-136, if definition starts with 'https://', the URL is fetched with fetchUrl(). Can an attacker submit a URL pointing to internal network resources (e.g., 'https://localhost:3306/', 'https://169.254.169.254/metadata') to exploit SSRF and exfiltrate sensitive information or interact with internal services?",
  "[File: byteball/ocore/uri.js] [Function: fetchUrl()] [Definition fetch timeout bypass] The fetchUrl() function at lines 251-291 has no timeout configured. Can an attacker provide a URL to a slow-responding server (e.g., slowloris attack) that holds connections open indefinitely, exhausting node resources and causing 1+ day network delay (Medium severity)?",
  "[File: byteball/ocore/uri.js] [Function: fetchUrl()] [Definition fetch size limit bypass] At lines 268-270, response data is accumulated with 'data += chunk' without size limits. Can an attacker provide a URL serving gigabytes of data that causes memory exhaustion, crashing the node and preventing transaction processing for 1+ day (Medium/Critical severity network halt)?",
  "[File: byteball/ocore/uri.js] [Function: fetchUrl()] [Definition fetch redirect exploitation] The https.get() call at line 262 may follow redirects by default. Can an attacker provide a URL that redirects to 'file://', 'ftp://', or other protocols to bypass HTTPS-only validation and exploit protocol confusion vulnerabilities?",
  "[File: byteball/ocore/uri.js] [Function: fetchUrl()] [Definition fetch DNS rebinding] Can an attacker control DNS to initially resolve a URL to a public IP (passing any IP allowlist), then rebind to a private IP (e.g., 127.0.0.1) during the fetch, exploiting SSRF to access internal services?",
  "[File: byteball/ocore/uri.js] [Function: fetchUrl()] [Definition fetch race condition] The bDone flag at line 253 prevents multiple callbacks, but can an attacker exploit race conditions where both resp.on('end') and resp.on('aborted') fire simultaneously, causing cb() to be called twice with different data, leading to inconsistent definition processing?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Definition non-JSON response] After fetchUrl() returns at line 133, assocParams.definition is set to raw response text. If the response isn't valid JSON (required for AA definitions), does downstream validation catch this, or can it cause parser crashes or AA execution failures?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [System vote subject injection] At lines 138-153, system_vote subjects are validated against a whitelist ['op_list', 'threshold_size', etc.]. Can an attacker inject similar-looking subjects with Unicode characters, zero-width spaces, or homoglyphs that bypass the whitelist but corrupt system voting state?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [System vote OP count mismatch] At lines 144-149, op_list must contain exactly COUNT_WITNESSES (12) OPs separated by newlines. Can an attacker submit an op_list with 12 lines but where some lines are empty strings, passing the count check but causing witness validation failures or consensus divergence?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [System vote address validation inconsistency] At line 148, OP addresses are validated with ValidationUtils.isValidAddress() using Array.every(). If one address validation is slow or buggy, can an attacker craft an address list that causes timeout or inconsistent validation across nodes, leading to chain splits?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [System vote numeric overflow] At lines 151-152, non-op_list system vote values must match /^[\\\\d.]+$/. Can an attacker submit extremely large numbers (e.g., '9e99999999999') that pass regex but overflow when parsed to number by downstream code, corrupting system parameters and causing network instability?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Address validation bypass - social accounts] At line 159, addresses matching patterns like 'steem/', 'reddit/', '@username' are allowed without ValidationUtils checks. Can an attacker inject malicious payloads into these social identifiers that exploit downstream attestation or profile services?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Address email validation spoofing] Email addresses are validated with ValidationUtils.isValidEmail() at line 159. Can an attacker exploit RFC-valid but unusual email formats (e.g., 'admin@[127.0.0.1]', 'user+exploit@domain.com') to bypass email verification or exploit downstream email processing?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Address phone number spoofing] Phone numbers matching /^\\\\+\\\\d{9,14}$/ at line 159 are allowed as addresses. Can an attacker use this to spoof caller ID, exploit SMS-based authentication, or send funds to premium-rate numbers controlled by the attacker?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Amount string-to-integer conversion] At lines 167-172, amounts are parsed with parseInt() and validated with string comparison 'amount + '' !== strAmount'. Can an attacker submit amounts like '1.0', '1e10', or '+1' that pass parseInt() but fail string equality, causing validation bypass or amount discrepancies?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Amount integer overflow] At line 167, parseInt(strAmount) is used without bounds checking. Can an attacker submit amounts exceeding Number.MAX_SAFE_INTEGER (9007199254740991) that overflow to incorrect values, potentially allowing creation of unlimited bytes and direct fund theft (Critical severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Amount negative value bypass] ValidationUtils.isPositiveInteger() is called at line 170, but can an attacker exploit integer underflow by submitting very large negative numbers that wrap to positive values in two's complement arithmetic, minting unlimited assets?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Amount zero value attack] If amount is 0, does ValidationUtils.isPositiveInteger() reject it (line 170)? If 0 amounts are allowed, can an attacker flood the network with zero-value payments to exhaust UTXO set or cause DoS (1+ hour delay - Medium severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Asset base64 validation bypass] At line 176, assets are validated with ValidationUtils.isValidBase64(asset, constants.HASH_LENGTH). Can an attacker submit base64 strings with padding errors, invalid characters, or length mismatches that pass validation but reference non-existent assets, locking funds permanently (Critical severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Asset 'base' string injection] The special string 'base' is compared at line 176 for the native asset. Can an attacker submit variations like 'BASE', 'base\\\\x00', or 'base ' (with trailing space) that bypass the comparison but are treated as 'base' downstream, exploiting case sensitivity or whitespace handling differences?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Asset auto-assignment bypass] At lines 180-181, if amount is set but asset is missing, asset defaults to 'base'. Can an attacker exploit race conditions where this auto-assignment happens inconsistently across nodes, causing some nodes to process as base payment and others to reject, leading to chain split (Critical severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseAdditionalAssets()] [Additional asset index injection] At line 218, the loop iterates using 'amount' + i where i starts at 2. Can an attacker submit non-sequential indexes (e.g., amount3, amount5, amount999) that bypass the loop iteration but still exist in assocParams, causing some assets to be processed incorrectly?",
  "[File: byteball/ocore/uri.js] [Function: parseAdditionalAssets()] [Additional asset amount overflow] At line 219, additional_amount is parsed with parseInt() and validated at lines 220-222. Can an attacker submit amounts exceeding 2^53-1 that overflow in different ways across JavaScript implementations, causing balance inconsistencies and fund loss?",
  "[File: byteball/ocore/uri.js] [Function: parseAdditionalAssets()] [Additional asset duplicate detection bypass] At lines 227-228, duplicate assets are detected with indexOf(). Can an attacker submit asset IDs that are bytewise identical but represent different assets due to encoding issues (e.g., UTF-8 vs. Latin1), bypassing duplicate checks and causing double-counting?",
  "[File: byteball/ocore/uri.js] [Function: parseAdditionalAssets()] [Additional asset infinite loop] The loop at line 218 continues while 'amount' + i exists in assocParams. Can an attacker submit URIs with amount2, amount3, ..., amount99999999 that cause extremely long loop iterations, exhausting CPU and causing network DoS (1+ hour delay - Medium severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseAdditionalAssets()] [Additional asset default to base] At line 224, if asset is missing, it defaults to 'base'. Can an attacker intentionally omit asset2, asset3, etc. to create multiple base asset entries, then exploit how composer.js handles multiple base outputs to cause amount miscalculations or double-spends?",
  "[File: byteball/ocore/uri.js] [Function: parseAdditionalAssets()] [Additional asset main_asset bypass] The main_asset parameter is passed but only used for duplicate checking (line 227). Can an attacker submit main_asset = 'X', amount2 for asset 'X', bypassing the duplicate check because main_asset isn't added to the assets array until line 217?",
  "[File: byteball/ocore/uri.js] [Function: parseAdditionalAssets()] [Additional asset return type confusion] The function returns either {error: ...} or {additional_assets: ...} or {}. Can downstream code incorrectly check for errors (e.g., only checking if result is truthy), causing error objects to be treated as valid additional_assets?",
  "[File: byteball/ocore/uri.js] [Function: parseQueryString()] [Query delimiter injection] At lines 236-237, the delimiter defaults to '&' but can be overridden. Can an attacker exploit delimiter confusion by submitting URIs with mixed delimiters (e.g., 'param1=val1&param2=val2;param3=val3') that get parsed inconsistently, bypassing validation?",
  "[File: byteball/ocore/uri.js] [Function: parseQueryString()] [Query parameter name collision] At lines 244-246, if multiple parameters have the same name, later values overwrite earlier ones. Can an attacker exploit this by submitting 'amount=1&amount=999999999' where validation checks the first value but payment uses the last value, stealing funds?",
  "[File: byteball/ocore/uri.js] [Function: parseQueryString()] [Query malformed parameter bypass] At line 242, pairs with !== 2 parts are silently skipped. Can an attacker submit critical parameters in malformed format (e.g., 'amount=') that get ignored during parsing but processed by downstream code expecting all params, causing validation bypass?",
  "[File: byteball/ocore/uri.js] [Function: parseQueryString()] [Query decodeURIComponent error handling] At lines 244-245, decodeURIComponent() is called without try/catch. Can an attacker submit malformed percent-encoded sequences (e.g., '%' without hex digits) that throw URIError exceptions, crashing the node and causing network halt (Critical severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseQueryString()] [Query parameter prototype pollution] Can an attacker submit query parameters like '__proto__=polluted', 'constructor=malicious', or 'prototype.isAdmin=true' that pollute Object.prototype through assocParams[name] assignment at line 246, affecting global application state and potentially allowing privilege escalation?",
  "[File: byteball/ocore/uri.js] [Function: parseQueryString()] [Query parameter length limit] There's no limit on parameter name or value length in parseQueryString(). Can an attacker submit URIs with megabyte-sized parameter values that exhaust memory when stored in assocParams, causing node crash and 1+ day network delay (Medium/Critical severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Device address validation timing] At lines 189-192, device_address is validated with ValidationUtils.isValidDeviceAddress(). Can an attacker exploit timing side channels in this validation to enumerate valid device addresses, then target those devices for spam or exploit attacks?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Base64 data size limit] At lines 194-197, base64data is validated but no size limit is enforced. Can an attacker embed megabytes of base64 data in payment URIs that get decoded and stored, exhausting storage or memory and causing node instability?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [From address validation bypass] At lines 199-202, from_address is validated with isValidAddress(). If wallet.js or composer.js doesn't verify that the user controls this address, can an attacker specify from_address of a victim, causing the victim to unknowingly create and sign transactions when scanning the URI?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Single address flag confusion] At lines 204-210, single_address can be a boolean flag or contain an address (prefixed with 'single'). Can an attacker exploit this dual interpretation to cause parsing inconsistencies where some nodes treat it as flag and others as address, leading to transaction validation failures or chain splits?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Single address backward compatibility bypass] At line 206, 'single' prefix is removed for backward compatibility. Can an attacker submit single_address='singleADDRESS' where 'ADDRESS' is malicious payload that gets accepted as from_address after prefix removal, bypassing address validation?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [ValidationUtils dependency] The file relies heavily on ValidationUtils.* functions. Can an attacker exploit inconsistencies between uri.js validation and validation.js main validation to craft URIs that pass parseUri() but fail validation.js, causing transaction rejection after user has committed to payment?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Constants dependency race] At lines 66, 122, 146, 176, constants.PUBKEY_LENGTH, constants.HASH_LENGTH, and constants.COUNT_WITNESSES are used. Can an attacker exploit race conditions where constants are modified between URI parsing and transaction composition, causing validation mismatches?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Callback double-invocation] Throughout parseUri(), callbacks.ifOk() and callbacks.ifError() are called in multiple branches. Can an attacker craft URIs that trigger multiple callback invocations due to logic errors, causing downstream code to process the same payment multiple times and enabling double-spends?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Async callback race condition] At lines 129-134, fetchUrl() uses async callback for definition fetching. Can an attacker exploit race conditions where multiple URIs are parsed concurrently, causing definition responses to be assigned to wrong objRequest objects, corrupting AA definitions and fund loss?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Error callback information leak] Error messages returned via callbacks.ifError() may contain sensitive info (line 27, 54, 58, etc.). Can an attacker use timing attacks or error message variations to fingerprint node configuration, enabled features, or internal state?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Type field collision] objRequest.type is set to 'pairing', 'auth', 'textcoin', 'data', or 'address' in different branches. Can an attacker craft URIs that match multiple patterns, causing type to be overwritten and downstream code to misinterpret the request type, leading to funds being sent instead of pairing?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Object property injection] Throughout parsing, properties are added directly to objRequest. Can an attacker inject JavaScript property names that conflict with Object.prototype methods (e.g., 'toString', 'valueOf') causing unexpected behavior when objRequest is used downstream?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Missing input sanitization] Many fields (hub, pairing_secret, app, address, etc.) are extracted from URIs and assigned to objRequest without sanitization. Can an attacker inject control characters (\\\\x00, \\\\n, \\\\r) that cause SQL injection, command injection, or log injection when these fields are used in database queries or system commands?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Unicode normalization bypass] None of the validation functions appear to perform Unicode normalization. Can an attacker submit URIs with composed vs. decomposed Unicode characters (e.g., '' vs 'e\\\\u0301') that appear identical but have different hashes, allowing duplicate address registration or attestation bypass?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Null byte injection] JavaScript strings are not null-terminated, but can an attacker inject '\\\\x00' bytes that get truncated differently by C-based modules (if any are called downstream), causing validation bypass where uri.js sees 'address\\\\x00malicious' but C code only processes 'address'?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Regex DoS on pairing] The pairing regex at line 35 has multiple '+' quantifiers. Can an attacker submit URIs with 10,000+ characters that nearly match the pattern, causing exponential backtracking and CPU exhaustion, delaying transaction processing for 1+ hour (Medium severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Query string DoS] At lines 164, 51, 114, query strings are parsed with parseQueryString(). Can an attacker submit URIs with 10,000+ query parameters that exhaust memory during parsing and storage in assocParams object, causing node crash and 1+ day network delay (Medium severity)?",
  "[File: byteball/ocore/uri.js] [Function: parseAdditionalAssets()] [Additional asset count DoS] No limit exists on how many amount2, amount3, ..., amountN parameters can be added. Can an attacker submit URIs with 100,000+ additional assets that overwhelm composer.js when constructing the transaction, causing timeout and transaction rejection?",
  "[File: byteball/ocore/uri.js] [Function: fetchUrl()] [Concurrent fetch DoS] Multiple URIs with remote definitions can be parsed concurrently. Can an attacker submit 1000+ definition URIs simultaneously, causing the node to open 1000+ HTTPS connections and exhausting file descriptors, preventing new connections and causing network partition?",
  "[File: byteball/ocore/uri.js] [Function: fetchUrl()] [Slowloris DoS] Can an attacker provide definition URLs that send response data at 1 byte per second, holding connections open for hours while slowly filling memory, eventually crashing the node and causing 1+ day transaction delay (Medium severity)?",
  "[File: byteball/ocore/uri.js] [Function: handleMnemonic()] [Mnemonic entropy reduction] The Mnemonic.isValid() check at line 79 validates BIP39 format but doesn't check entropy. Can an attacker submit low-entropy mnemonics (e.g., 'word1 word1 word1...') that pass validation but generate predictable keys, allowing attacker to steal textcoin funds before victim claims them?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Pubkey format confusion] At line 66, pubkey length is checked but not the format (base64 alphabet). Can an attacker submit pubkeys with invalid base64 characters that pass length check but fail during actual cryptographic operations, causing authentication bypass or pairing failures?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Hash length verification bypass] At lines 122, 176, hash lengths are validated with constants.HASH_LENGTH. If a different hash algorithm is introduced (e.g., SHA3-256 vs. SHA256), can length-only validation allow attacker to submit hashes from weaker algorithms, enabling collision attacks?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Empty query string handling] At lines 106-109, value.split('?') creates arrParts. If query_string is undefined or empty string, does downstream validation handle this correctly, or can it cause null dereference errors when accessing assocParams properties?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Three question marks bypass] At line 106, validation rejects URIs with >2 question marks. Can an attacker submit URIs with exactly 2 question marks in specific positions (e.g., 'obyte:address??amount=1') that cause query_string parsing to fail silently, allowing malicious parameters to be ignored?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [decodeURIComponent double-decoding] At line 108, decodeURIComponent is called on main_part. If the URI was already decoded by the browser/OS before being passed to parseUri(), can double-decoding cause character corruption or injection attacks?",
  "[File: byteball/ocore/uri.js] [Function: parseQueryString()] [Empty parameter name/value] If a query string contains '=value' or 'name=' (empty name or value), lines 244-246 still create assocParams entries. Can downstream code assume non-empty strings and crash when accessing assocParams[''] or processing empty values?",
  "[File: byteball/ocore/uri.js] [Function: parseAdditionalAssets()] [Zero additional assets] At line 232, empty additional_assets object returns {}. Does composer.js handle the case where additional_assets exists but is empty differently from when it's undefined, potentially causing amount/asset mismatch in transactions?",
  "[File: byteball/ocore/uri.js] [Integration: uri.js  composer.js] If parseUri() allows amounts that pass validation but overflow when combined in composer.js (e.g., amount=MAX_INT and amount2=MAX_INT), can this cause integer overflow in total balance calculations, minting unlimited assets and direct fund theft (Critical severity)?",
  "[File: byteball/ocore/uri.js] [Integration: uri.js  wallet.js] If parseUri() extracts from_address and wallet.js doesn't verify user owns this address before signing, can an attacker create URIs that cause users to sign transactions spending from arbitrary addresses, enabling theft of any user's funds (Critical severity)?",
  "[File: byteball/ocore/uri.js] [Integration: uri.js  device.js] If pairing secrets extracted by parseUri() aren't properly rate-limited in device.js, can an attacker submit millions of pairing URIs with different secrets to brute-force active pairing sessions and hijack device connections?",
  "[File: byteball/ocore/uri.js] [Integration: uri.js  validation.js] If address validation rules differ between ValidationUtils (used by uri.js) and definition.js (used by validation.js), can an attacker craft addresses that pass URI parsing but fail transaction validation after user commits funds?",
  "[File: byteball/ocore/uri.js] [Integration: uri.js  aa_composer.js] If data URIs with 'definition' app type allow arbitrary JSON in fetched definitions, can an attacker inject malicious AA formulas that execute during parsing, exploiting formula evaluation vulnerabilities for fund theft?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Missing maximum URI length] No validation exists for total URI length. Can an attacker submit URIs >1MB that pass parsing but exhaust memory when stored in objRequest or processed by downstream modules, causing node crash?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Missing array length validation] For system_vote op_list (line 145), the array is split on newlines but no validation prevents empty newlines creating empty array elements. Can this cause array length mismatch between lines.length and valid addresses.length, bypassing COUNT_WITNESSES check?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Missing asset existence check] Assets validated at lines 176, 224 check format but not whether asset exists on the DAG. Can an attacker reference non-existent assets that pass validation but cause transaction to be rejected after user signs, wasting user time and fees?",
  "[File: byteball/ocore/uri.js] [Function: parseUri()] [Missing amount feasibility check] Amounts are validated as positive integers but not checked against user's balance or maximum spendable amount. Can attacker create URIs requesting amounts >total_supply that pass validation but fail composition?",
  "[File: byteball/ocore/uri.js] [Function: fetchUrl()] [Missing TLS certificate validation] https.get() at line 262 may not validate TLS certificates by default. Can an attacker perform MITM attacks on definition fetching, injecting malicious AA definitions that steal funds when deployed?",
  "[File: byteball/ocore/uri.js] [Function: fetchUrl()] [Missing Content-Type validation] Fetched definition content isn't validated for Content-Type. Can an attacker serve executable content (e.g., text/html with XSS) that gets interpreted differently by downstream parsers, causing code execution vulnerabilities?",
  "[File: byteball/ocore/validation.js] [Function: validate()] [Race Condition] Can two threads simultaneously validate the same unit before checkDuplicate() runs, both passing the duplicate check and causing the same unit to be stored twice with different validation states, leading to database inconsistency and potential double-spend?",
  "[File: byteball/ocore/validation.js] [Function: validate()] [Hash Collision] If objectHash.getUnitHash() produces a collision (unit hash matches but content differs), can an attacker exploit the hash-first validation to bypass content validation and inject a malicious unit with the same hash as a legitimate one?",
  "[File: byteball/ocore/validation.js] [Function: validate()] [Mutex Deadlock] Can an attacker craft units with circular author address dependencies that cause mutex.lock(arrAuthorAddresses) to deadlock when multiple units are validated concurrently, freezing all validation for those addresses and halting network progress?",
  "[File: byteball/ocore/validation.js] [Function: validate()] [Transaction Rollback] If validation advances the last stable MCI (bAdvancedLastStableMci=true) but then fails later validation steps, can the ROLLBACK at line 242 corrupt the stability point by rolling back only database changes while leaving in-memory caches updated?",
  "[File: byteball/ocore/validation.js] [Function: validate()] [AA Detection Bypass] Can an attacker craft a unit with exactly one author and no authentifiers (triggering 'possible AA' check at line 81) but include valid authentifiers in a race condition, bypassing AA validation requirements and submitting an improperly validated AA response?",
  "[File: byteball/ocore/validation.js] [Function: validate()] [Timestamp Manipulation] Can an attacker set objUnit.timestamp to exactly conf.max_seconds_into_the_future_to_accept seconds in the future (line 158) to delay validation and cause transient errors for all other validators, allowing the attacker to gain timing advantages in double-spend attacks?",
  "[File: byteball/ocore/validation.js] [Function: validate()] [Commission Calculation] If objectLength.getHeadersSize() or objectLength.getTotalPayloadSize() calculations have rounding errors or overflow, can the checks at lines 136-139 be bypassed to submit units with incorrect commission values, allowing underpayment of fees?",
  "[File: byteball/ocore/validation.js] [Function: validate()] [Unit Size Bypass] Can an attacker craft a unit where headers_commission + payload_commission slightly exceeds MAX_UNIT_LENGTH due to integer overflow but passes the check at line 140 because the overflow wraps to a small positive value?",
  "[File: byteball/ocore/validation.js] [Function: validate()] [Genesis Validation] For the genesis unit check at line 73, can an attacker craft a fake genesis unit hash that matches storage.isGenesisUnit() but contains malicious messages, exploiting special genesis validation paths?",
  "[File: byteball/ocore/validation.js] [Function: validate()] [Content Hash Stripping] When content_hash is present (line 106), can an attacker submit a ball with content_hash but mismatched ball hash, exploiting the fact that message validation is skipped for stripped units to inject invalid historical data?",
  "[File: byteball/ocore/validation.js] [Function: checkDuplicate()] [TOCTOU Race] Between the SELECT query at line 372 and the callback at line 373, can another thread insert the same unit, causing both validations to proceed and resulting in duplicate unit storage with conflicting sequences?",
  "[File: byteball/ocore/validation.js] [Function: checkDuplicate()] [Transient Error Abuse] Can an attacker repeatedly submit the same unit to trigger transient errors (line 378), causing validators to waste resources re-validating while the attacker prepares a double-spend attack?",
  "[File: byteball/ocore/validation.js] [Function: validateHashTreeBall()] [Hash Tree Poisoning] If storage.assocHashTreeUnitsByBall is populated from untrusted peers during catchup, can an attacker poison this cache with incorrect ballunit mappings to cause legitimate units to be rejected at line 391?",
  "[File: byteball/ocore/validation.js] [Function: validateHashTreeBall()] [Need Hash Tree DoS] Can an attacker repeatedly send balls with unknown ball hashes to trigger 'need_hash_tree' errors (line 389), forcing nodes into continuous catchup mode and preventing them from accepting new units?",
  "[File: byteball/ocore/validation.js] [Function: validateHashTreeParentsAndSkiplist()] [Ball Hash Mismatch] At line 403, can an attacker exploit timing between ball storage and hash tree updates to submit a unit with correct parent balls in database but incorrect balls in hash tree, causing hash mismatch that gets accepted by some nodes but not others?",
  "[File: byteball/ocore/validation.js] [Function: validateHashTreeParentsAndSkiplist()] [Skiplist Ball Not Found] Can an attacker reference skiplist units that exist in the database but have no ball yet (line 430), exploiting the race condition between stability determination and ball creation to cause validation inconsistencies?",
  "[File: byteball/ocore/validation.js] [Function: validateHashTreeParentsAndSkiplist()] [Ball Array Sorting] If arrParentBalls or arrSkiplistBalls are incorrectly sorted at lines 419-420, can an attacker exploit this to generate colliding ball hashes that validate incorrectly but match the expected ball hash?",
  "[File: byteball/ocore/validation.js] [Function: validateSkiplist()] [MCI Divisibility Bypass] Can an attacker submit a skiplist unit that is stable and on MC but with MCI not divisible by 10 (checked at line 456), exploiting a race condition where the unit becomes stable after this check passes to corrupt the skiplist structure?",
  "[File: byteball/ocore/validation.js] [Function: validateSkiplist()] [Skiplist Ordering] Can an attacker craft skiplist_units where units are ordered by hash but not by MCI, passing the check at line 446 but causing main chain determination errors when the true MCI ordering differs from hash ordering?",
  "[File: byteball/ocore/validation.js] [Function: validateSkiplist()] [Unstable Skiplist] For unstable skiplist units (line 453), can an attacker exploit the lack of MC verification to include units that will never be on MC, causing ball hash mismatches when the unit reaches stability?",
  "[File: byteball/ocore/validation.js] [Function: validateParentsExistAndOrdered()] [Parent Count DoS] Can an attacker submit units with exactly MAX_PARENTS_PER_UNIT parents (line 472) where all parents exist but are known bad, exploiting the query at line 492 to cause excessive database lookups and DoS validation?",
  "[File: byteball/ocore/validation.js] [Function: validateParentsExistAndOrdered()] [Known Bad Parents] Can an attacker reference parent units that are marked as known_bad_joints but exist in storage caches (checked at line 480), bypassing the database check at line 492 and allowing bad units to be built upon?",
  "[File: byteball/ocore/validation.js] [Function: validateParentsExistAndOrdered()] [Parent Ordering Attack] Can an attacker submit parent_units where consecutive parents have equal hashes (violating line 477) but are actually different units due to hash collision, exploiting the ordering check to hide duplicate parent references?",
  "[File: byteball/ocore/validation.js] [Function: validateParents()] [Last Ball MCI Retreat] Can an attacker craft a unit where max_parent_last_ball_mci > last_ball_mci (checked at line 534) by exploiting a race condition during stability advancement, allowing the last ball to retreat and violate monotonicity?",
  "[File: byteball/ocore/validation.js] [Function: validateParents()] [Parent Relation DoS] Can an attacker submit a unit with MAX_PARENTS_PER_UNIT parents that are all unrelated (checked via graph.compareUnitsByProps at line 565), causing O(n) graph traversal operations and exponential validation time?",
  "[File: byteball/ocore/validation.js] [Function: validateParents()] [Last Ball Unit Mismatch] If last_ball_unit is stable but its ball field doesn't match last_ball (checked at lines 596, 652), can an attacker exploit database inconsistency between units and balls tables to submit units with mismatched last ball references?",
  "[File: byteball/ocore/validation.js] [Function: validateParents()] [Timestamp Retreat] Can an attacker craft a unit with timestamp less than parent timestamps (checked at line 556) to violate causality, exploiting units with version=versionWithoutTimestamp to skip this check and cause temporal inconsistencies?",
  "[File: byteball/ocore/validation.js] [Function: validateParents()] [Version Upgrade Attack] Can an attacker submit a unit with version 4.0+ before constants.v4UpgradeMci (checked at line 619), exploiting timing of MCI advancement to cause nodes at different stability points to accept/reject the same unit?",
  "[File: byteball/ocore/validation.js] [Function: validateParents()] [Witness List Removal] For version 4.0+ units, can an attacker exploit the requirement that witnesses/witness_list_unit should not be present (lines 620-623) to cause chain splits if some nodes haven't upgraded their version checking logic?",
  "[File: byteball/ocore/validation.js] [Function: validateParents()] [Oversize Fee Mismatch] Can an attacker craft a unit where the calculated oversize_fee from storage.getOversizeFee() doesn't match objUnit.oversize_fee (line 626), exploiting rounding differences or integer overflow to underpay fees?",
  "[File: byteball/ocore/validation.js] [Function: validateParents()] [Same Address in Parents] Can an attacker submit a unit with two parent units both authored by the same address (checked at line 526), exploiting the nonserial detection to mark their own units as nonserial and avoid validation rules that apply only to serial units?",
  "[File: byteball/ocore/validation.js] [Function: validateParents()] [Stability Advancement Race] When bAdvancedLastStableMci is true (line 666), can an attacker exploit the transient error 'last ball just advanced, try again' to repeatedly force re-validation and delay unit acceptance?",
  "[File: byteball/ocore/validation.js] [Function: validateParents()] [Last Ball Not On MC] Can an attacker reference a last_ball_unit that is not on main chain (checked at line 594), exploiting incorrect MC determination or cached values to build units on invalid MC branches?",
  "[File: byteball/ocore/validation.js] [Function: validateWitnesses()] [Witness List Mutation] Can an attacker exploit storage.determineIfHasWitnessListMutationsAlongMc() at line 747 to submit units that change witness lists in ways that cause permanent chain splits, especially if last_ball_mci < 512000 where mutations aren't enforced?",
  "[File: byteball/ocore/validation.js] [Function: validateWitnesses()] [Witnessed Level Retreat] Can an attacker craft a unit where witnessed_level < max_parent_wl (checked at line 771), exploiting the upgrade MCI thresholds at lines 766-770 to cause some nodes to accept and others to reject, creating a chain split?",
  "[File: byteball/ocore/validation.js] [Function: validateWitnesses()] [Witness Address References] Can an attacker change a witness address definition to include references (checked at line 714), exploiting the fact that this check only runs for stable definitions to cause validation divergence when the definition becomes stable?",
  "[File: byteball/ocore/validation.js] [Function: validateWitnesses()] [Witness List Unit Not Stable] Can an attacker reference a witness_list_unit that is not stable yet (checked at line 802), exploiting timing of stability determination to cause units to be rejected by some nodes but accepted by others?",
  "[File: byteball/ocore/validation.js] [Function: validateWitnesses()] [Witness Order Attack] For inline witnesses, can an attacker submit witnesses that are ordered correctly by hash but some addresses are invalid (checked at line 815), exploiting chash validation weaknesses to include non-addresses in the witness list?",
  "[File: byteball/ocore/validation.js] [Function: validateWitnesses()] [Witness Not Good/Stable] Can an attacker exploit the checkWitnessesKnownAndGood() query at line 730 to include witnesses whose first appearance is not stable yet, causing validation to pass temporarily but fail when other nodes validate?",
  "[File: byteball/ocore/validation.js] [Function: validateWitnesses()] [OP List Migration] For units after v4UpgradeMci using storage.getOpList() at line 781, can an attacker exploit differences between witness lists and OP lists during the migration period to cause consensus divergence?",
  "[File: byteball/ocore/validation.js] [Function: validateAATrigger()] [AA Count Mismatch] Can an attacker send payments to addresses that become AAs after last_ball_mci but before validation, causing count_primary_aa_triggers at line 867 to undercount triggers and result in insufficient tps_fee being charged?",
  "[File: byteball/ocore/validation.js] [Function: validateAATrigger()] [Max AA Responses Field] Can an attacker include max_aa_responses field in non-v4 units (checked at line 841) or omit it when AA triggers exist (line 863), exploiting version checking inconsistencies to bypass AA response limits?",
  "[File: byteball/ocore/validation.js] [Function: validateTpsFee()] [TPS Fee Balance Race] Can an attacker exploit the query at line 914 that reads tps_fees_balance at last_ball_mci to spend from a balance that will be depleted by another unit at the same MCI, causing both units to pass validation but one to overspend?",
  "[File: byteball/ocore/validation.js] [Function: validateTpsFee()] [OP Exemption Abuse] Can an attacker get their addresses included in the OP list (checked via isFromOP at line 910) to bypass minimum acceptable tps_fee checks at line 919, submitting low-fee spam units that validators must accept?",
  "[File: byteball/ocore/validation.js] [Function: validateTpsFee()] [TPS Fee Recipient Manipulation] Can an attacker craft earned_headers_commission_recipients to influence storage.getTpsFeeRecipients() at line 911, directing tps_fees to addresses they control with high balances to bypass fee requirements?",
  "[File: byteball/ocore/validation.js] [Function: validateTpsFee()] [Count Units Manipulation] Can an attacker manipulate storage.getCountUnitsPayingTpsFee() at line 900 by crafting parent_units to reduce count_units and thus reduce min_tps_fee at line 901, underpaying fees?",
  "[File: byteball/ocore/validation.js] [Function: validateTpsFee()] [Ball Catchup Bypass] When objJoint.ball is true, min_acceptable_tps_fee_multiplier is 0 (line 906), can an attacker exploit catchup mode to submit units with zero tps_fee that would be rejected during normal operation?",
  "[File: byteball/ocore/validation.js] [Function: validateHeadersCommissionRecipients()] [Share Sum Overflow] Can an attacker craft earned_headers_commission_recipients where individual shares are valid but total_earned_headers_commission_share overflows before the check at line 950, resulting in sum  100 but passing validation?",
  "[File: byteball/ocore/validation.js] [Function: validateHeadersCommissionRecipients()] [Recipient Sorting] Can an attacker exploit the address sorting check at line 943 to include duplicate addresses if they differ only in checksum case, causing double payment of headers commission to the same address?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthors()] [Author Count DoS] Can an attacker submit a unit with MAX_AUTHORS_PER_UNIT authors (checked at line 959), each requiring expensive signature validation, to DoS validation by making each unit take excessive time to validate?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthors()] [Unit Hash to Sign] Does objectHash.getUnitHashToSign() at line 970 deterministically include all unit fields? Can an attacker craft units where two different units produce the same unit_hash_to_sign, allowing signature reuse across units?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthors()] [Author Sorting Attack] Can an attacker submit authors sorted by address but include duplicate addresses with different authentifiers, exploiting the sorting check at line 965 to include the same address twice?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [Definition Timing Attack] Can an attacker submit a unit referencing an unstable initial definition (found via findUnstableInitialDefinition at line 1043), exploiting the included check at line 1060 to use a definition that will be invalidated later?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [AA Author Bypass] For AA responses (objValidationState.bAA), can an attacker craft objAuthor with fields other than 'address' (checked at line 980) to include authentifiers or definitions that bypass AA validation requirements?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [Conflicting Units Race] Can an attacker exploit findConflictingUnits() at line 1087 by submitting multiple units rapidly, where the query at line 1090 finds no conflicts initially but conflicts emerge before the unit is stored, allowing double-spends?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [Serial Sequence Manipulation] Can an attacker exploit the bAllSerial optimization at line 1110 to skip graph.determineIfIncludedOrEqual checks for earlier units, submitting a nonserial unit that appears serial due to cached results?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [Definition Change Pending] Can an attacker submit a unit while they have an unstable definition_chash change pending (checked at line 1176), exploiting the forked path check at line 1182 to use old and new definitions simultaneously?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [Pending Definition Race] Can an attacker exploit the pending definition check at line 1213 by including a definition in parent units but not in last_ball_mci, causing validation to pass but the definition to be removed later when parents become bad?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [Duplicate Definition] Can an attacker exploit handleDuplicateAddressDefinition() at line 1306 by submitting a nonserial unit with the same definition_chash but different definition content, exploiting the check at line 1311 to accept mismatched definitions?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [Authentifier Length Attack] Can an attacker submit authentifiers longer than MAX_AUTHENTIFIER_LENGTH (checked at line 990) using multibyte characters that count as fewer characters in JavaScript string length but more in storage, causing overflow?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [Content Hash Bypass] When objUnit.content_hash is present, validation sets sequence to 'final-bad' at line 1018 and returns, can an attacker exploit this to submit stripped units without proper signature validation?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [Unstable Initial Definition MCI] At line 1044, can an attacker exploit the unstableInitialDefinitionUpgradeMci threshold to submit definitions that are treated differently by nodes at different MCIs, causing validation divergence?",
  "[File: byteball/ocore/validation.js] [Function: validateAuthor()] [Temp-Bad Sequence Propagation] When objValidationState.sequence is set to 'temp-bad' at line 1153, can an attacker exploit the UPDATE query at line 1164 that affects unstable conflicting units to mark good units as temp-bad?",
  "[File: byteball/ocore/validation.js] [Function: validateMessages()] [Message Count DoS] Can an attacker submit MAX_MESSAGES_PER_UNIT messages (checked at line 133), each requiring full validation, to exponentially slow down validation through nested complexity?",
  "[File: byteball/ocore/validation.js] [Function: validateMessages()] [No Base Payment] Can an attacker submit a unit with only non-payment messages, failing the check at line 1328 but having already consumed validation resources, enabling a DoS attack?",
  "[File: byteball/ocore/validation.js] [Function: validateMessage()] [Spend Proof Reuse] Can an attacker use the same spend_proof across multiple messages in different units, exploiting the check at line 1379 that only prevents reuse within a single unit, allowing cross-unit spend proof reuse?",
  "[File: byteball/ocore/validation.js] [Function: validateMessage()] [Spend Proof Address Mismatch] For multi-authored units, can an attacker include spend_proofs with address field pointing to authors but the actual spend_proof belonging to non-authors, bypassing the check at line 1374?",
  "[File: byteball/ocore/validation.js] [Function: validateMessage()] [Payload Hash Collision] Can an attacker exploit objectHash.getBase64Hash() to find payloads with identical payload_hash but different content, bypassing validation that relies on payload_hash matching?",
  "[File: byteball/ocore/validation.js] [Function: validateMessage()] [Payload URI Length] Can an attacker submit payload_uri longer than 500 chars (checked at line 1404) with encoded characters that expand when decoded, causing buffer overflows in URI handling?",
  "[File: byteball/ocore/validation.js] [Function: validateMessage()] [Private Payment Spend Proof] For private payments with payload_location='none', can an attacker omit spend_proofs (checked at line 1417) by exploiting race conditions in the validation flow?",
  "[File: byteball/ocore/validation.js] [Function: checkForDoublespends()] [Included Doublespend Race] When checking if conflicting unit is included via graph.determineIfIncludedOrEqual at line 1470, can an attacker exploit timing where the unit becomes included after this check but before storage?",
  "[File: byteball/ocore/validation.js] [Function: checkForDoublespends()] [Final-Bad Reuse] Can an attacker reuse outputs from final-bad units (allowed at line 1483) that are marked final-bad due to other addresses being nonserial, spending outputs that shouldn't be spendable?",
  "[File: byteball/ocore/validation.js] [Function: checkForDoublespends()] [Light Client Bypass] For light clients (checked at line 1468), can an attacker resubmit private payments that were already spent, exploiting the lack of graph.determineIfIncludedOrEqual checking to double-spend?",
  "[File: byteball/ocore/validation.js] [Function: checkForDoublespends()] [Ununique Update Race] When executing UPDATE inputs SET is_unique=NULL at line 2044, can another transaction read the same inputs as unique, causing both transactions to accept conflicting spends?",
  "[File: byteball/ocore/validation.js] [Function: checkForDoublespends()] [Private Write Mutex] Can an attacker submit many conflicting private payment units to create lock contention on mutex.lock(['private_write']) at line 2051, causing DoS of private payment validation?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [Definition Chash Mismatch] For 'definition' app, can an attacker submit payload where objectHash.getChash160(payload.definition) doesn't match payload.address due to hash collision, bypassing the check at line 1566?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [AA Definition Validation Race] When calling aa_validation.validateAADefinition at line 1577, can an attacker exploit the async readGetterProps callback to modify state before validation completes?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [Parameterized AA Base Not Found] Can an attacker reference a non-existent base_aa at line 1584, exploiting the check at line 1585 to create parameterized AAs that will fail at runtime but pass validation?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [Poll Choice Count] Can an attacker submit polls with MAX_CHOICES_PER_POLL choices (checked at line 1608), each with MAX_CHOICE_LENGTH characters, to create extremely large poll units that slow down validation?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [Vote Unit Not Serial] Can an attacker submit votes for poll units that are not serial yet (checked at line 1638), exploiting timing of sequence determination to vote on polls that will be invalidated?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [System Vote OP List] For system_vote with subject='op_list', can an attacker include AAs in the OP list that pass checkNotAAs at line 1673 initially but become AAs later, corrupting the OP list?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [System Vote Threshold] Can an attacker vote for threshold_size < 1000 (checked at line 1687) on testnet or before MCI 3543000, exploiting version checking to set dangerous system parameters?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [Data Feed Name Length] Can an attacker submit data_feed with feed names exactly MAX_DATA_FEED_NAME_LENGTH chars (checked at line 1723) containing special characters that expand when processed, causing buffer overflows?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [Fractional Data Feed] Can an attacker submit non-integer numbers in data feeds (checked at line 1735), exploiting floating point precision to cause divergence between nodes with different precision?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [Temp Data Purge Timing] Can an attacker submit temp_data without 'data' field but with timestamp within TEMP_DATA_PURGE_TIMEOUT (checked at line 1779), exploiting transient error to force repeated validation attempts?",
  "[File: byteball/ocore/validation.js] [Function: validateInlinePayload()] [Attestation Self-Attest] Can an attacker attest their own address (allowed at line 1802), creating circular attestation chains that confuse asset attestation requirements?",
  "[File: byteball/ocore/validation.js] [Function: validatePayment()] [Asset Loading Race] Can an attacker exploit storage.loadAssetWithListOfAttestedAuthors at line 1859 to spend an asset before its attestation status changes, bypassing spender_attested requirements?",
  "[File: byteball/ocore/validation.js] [Function: validatePayment()] [Denomination Mismatch] For fixed_denominations assets, can an attacker exploit the denomination check to submit payments where inputs and outputs have different denominations due to integer overflow?",
  "[File: byteball/ocore/validation.js] [Function: validatePayment()] [Privacy Mismatch] Can an attacker exploit the check at line 1872 to mix public and private assets by crafting objValidationState.bPrivate incorrectly?",
  "[File: byteball/ocore/validation.js] [Function: validatePayment()] [Issue Without Definer] For issued_by_definer_only assets, can an attacker issue from a multi-sig address where definer_address is one signer but not the issuer_address (checked at line 1884)?",
  "[File: byteball/ocore/validation.js] [Function: validatePayment()] [Attested Authors Empty] Can an attacker exploit spender_attested assets where arrAttestedAddresses is empty (checked at line 1893), bypassing attestation by submitting during a window when attestations are temporarily removed?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Input Count DoS] Can an attacker submit payments with MAX_INPUTS_PER_PAYMENT_MESSAGE inputs (checked at line 1912), each requiring database queries, to exponentially slow validation through O(n) complexity?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Output Amount Overflow] Can an attacker craft outputs where individual amounts pass isPositiveInteger check at line 1928 but total_output overflows at line 1966, bypassing the MAX_CAP check at line 1967?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Output Sorting Attack] For public payments, can an attacker craft outputs sorted by address but not by amount for the same address (checked at lines 1957-1960), exploiting sort comparison to include duplicate outputs?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Private Asset Open Outputs] For private assets, can an attacker submit exactly 1 open output (checked at line 1970) but make it point to an address they don't control, stealing funds by revealing the recipient?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Blinding Reuse] Can an attacker reuse the same blinding value across multiple private outputs, exploiting the check at line 1941 to link outputs and deanonymize private payments?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Issue Amount Validation] For issue inputs, can an attacker exploit the checks at lines 2083-2086 to issue amounts that overflow MAX_CAP when combined with existing supply?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Serial Number Reuse] Can an attacker reuse serial_numbers for issue inputs (checked via double-spend query), exploiting race conditions to issue the same serial multiple times before database commit?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Capped Issue Not Equal] For capped assets, can an attacker issue amounts not equal to cap (checked at line 2113), exploiting partial issues followed by remainder issues to exceed cap?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Genesis Issue Bypass] Can an attacker craft a non-genesis unit that issues base asset (checked at line 2117), exploiting storage.isGenesisUnit to mint unlimited base currency?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Input Not Found] When querying src output at line 2211, can an attacker reference inputs from units that exist but have no matching output, exploiting null checks at line 2230 to spend non-existent outputs?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Stable Temp-Bad Spend] Can an attacker spend outputs from stable temp-bad units (should throw at line 2226), exploiting cached results to bypass this check?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Final-Bad Stripped Output] Can an attacker spend outputs from final-bad units below min retrievable MCI (checked at line 2231), exploiting archiving to reuse old final-bad outputs?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Asset Mismatch] Can an attacker exploit the asset comparison at line 2238 to spend outputs of one asset as inputs for another asset due to null/undefined confusion?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Spend Unconfirmed Before Upgrade] Before spendUnconfirmedUpgradeMci, can an attacker spend unstable outputs in private payments (allowed at line 2247) but not public, creating validation inconsistency?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Sequence Inheritance] After spendUnconfirmedUpgradeMci, can an attacker exploit sequence inheritance at line 2256 to make a good unit inherit temp-bad or final-bad sequence from parents?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Owner Not Author] Can an attacker spend outputs where owner_address is not among authors (checked at line 2261), exploiting cached author lists to bypass this check?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Denomination Mismatch Transfer] Can an attacker transfer fixed_denominations assets where input denomination doesn't match output denomination (checked at line 2263), exploiting integer division to alter denominations?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Auto-Destroy Bypass] Can an attacker send auto_destroy assets to the definer_address then immediately spend them (checked at lines 2198, 2265), exploiting timing to prevent destruction?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Unstable Input Not In Parents] For unstable inputs, can an attacker reference input units not in parent_units (checked at line 2281), exploiting graph.determineIfIncludedOrEqual race conditions to spend unconfirmed outputs?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Headers Commission Range Overlap] Can an attacker submit headers_commission inputs with overlapping from/to MCI ranges (checked at line 2342), exploiting mc_outputs.readNextSpendableMcIndex race conditions?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Witnessing To MCI Too Large] Can an attacker set witnessing input to_main_chain_index to max_mci (checked at line 2346), exploiting getMaxSpendableMciForLastBallMci calculation errors to claim future earnings?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Zero Commission] Can an attacker submit headers_commission or witnessing inputs that calculate to zero commission (checked at line 2356), wasting validation resources without contributing value?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Input Sum Overflow] Can an attacker craft inputs where total_input overflows MAX_CAP (checked at line 2372) due to headers_commission or witnessing earnings being added last?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Balance Mismatch] Can an attacker exploit rounding or overflow in the balance check at line 2375 to create/destroy assets by making total_input slightly differ from total_output?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Non-Transferrable Loophole] For non-transferrable assets, can an attacker exploit the complex conditions at lines 2378-2389 to transfer by using 2 outputs (one to definer, one to self as change) while actually transferring to a third party?",
  "[File: byteball/ocore/validation.js] [Function: validatePaymentInputsAndOutputs()] [Attested Output Addresses] Can an attacker send spender_attested assets to non-attested output addresses (checked at line 2398), exploiting the filterAttestedAddresses timing to lock funds?",
  "[File: byteball/ocore/validation_utils.js] [Function: hasFieldsExcept()] [Prototype pollution] If an attacker crafts a malicious object with __proto__, constructor, or other prototype chain properties, does hasFieldsExcept() iterate over inherited properties causing false positives in field validation, potentially allowing invalid unit structures to pass validation in validation.js and causing permanent fund freezing?",
  "[File: byteball/ocore/validation_utils.js] [Function: hasFieldsExcept()] [Type confusion] Can hasFieldsExcept() be bypassed by passing non-object primitives (null, undefined, number, string) that lack enumerable properties, causing validation.js to incorrectly accept units with missing required fields and leading to DAG corruption or consensus failure?",
  "[File: byteball/ocore/validation_utils.js] [Function: hasFieldsExcept()] [Non-deterministic iteration] Since JavaScript object property iteration order is implementation-dependent for non-integer keys in older engines, can hasFieldsExcept() produce different results on different nodes when validating units with many fields, causing a permanent chain split requiring hard fork?",
  "[File: byteball/ocore/validation_utils.js] [Function: hasFieldsExcept()] [Array.indexOf performance] If arrFields contains thousands of allowed fields and obj has hundreds of properties, does the O(n*m) complexity of hasFieldsExcept() cause validation.js to spend excessive time checking fields, enabling DoS attacks that delay transaction processing for >1 hour (Medium severity)?",
  "[File: byteball/ocore/validation_utils.js] [Function: isInteger()] [Negative zero handling] Does isInteger(-0) return true, and if so, can an attacker use -0 in unit timestamps, witness_list_unit indices, or parent_units indices to cause non-deterministic behavior in validation.js when comparing values, leading to consensus divergence and permanent chain split?",
  "[File: byteball/ocore/validation_utils.js] [Function: isInteger()] [MAX_SAFE_INTEGER boundary] Can an attacker pass integers larger than Number.MAX_SAFE_INTEGER (2^53-1) to isInteger() that return true but lose precision when stored or compared, causing aa_validation.js to accept invalid AA state variable values that diverge across nodes and break deterministic execution?",
  "[File: byteball/ocore/validation_utils.js] [Function: isInteger()] [Type coercion bypass] If isInteger() receives a numeric string like '42' or boolean true (which typeof returns as 'number' after coercion in some contexts), does it incorrectly validate, allowing formula/evaluation.js to process invalid operands and produce incorrect AA execution results?",
  "[File: byteball/ocore/validation_utils.js] [Function: isInteger()] [NaN and Infinity] While isInteger() checks isFinite(), does it correctly reject all edge cases like -Infinity, +Infinity, and NaN when used in validation.js for unit_props.main_chain_index or last_ball_mci validation, preventing network halt from invalid MCI assignments?",
  "[File: byteball/ocore/validation_utils.js] [Function: isPositiveInteger()] [Zero exclusion validation] Since isPositiveInteger() requires int > 0, if validation.js uses this to validate fee amounts but accidentally allows 0 fees through alternative code paths, can an attacker submit units with zero fees, violating fee sufficiency invariants and enabling spam attacks that delay transaction processing for >24 hours?",
  "[File: byteball/ocore/validation_utils.js] [Function: isPositiveInteger()] [Asset amount validation] If divisible_asset.js uses isPositiveInteger() to validate asset output amounts, can an attacker exploit rounding errors or precision loss with amounts near MAX_SAFE_INTEGER to create outputs that appear positive but become zero or negative after arithmetic, enabling asset inflation or theft?",
  "[File: byteball/ocore/validation_utils.js] [Function: isPositiveInteger()] [Indivisible serial validation] When indivisible_asset.js validates serial numbers with isPositiveInteger(), can an attacker use extremely large serials (>10^15) that lose precision in JavaScript's number type, causing duplicate serials to be issued and violating indivisible serial uniqueness invariant, leading to NFT counterfeiting?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonnegativeInteger()] [Zero acceptance edge case] If aa_composer.js uses isNonnegativeInteger() to validate AA response outputs and allows zero-amount outputs, can an attacker craft AA responses with zero-value outputs that bypass balance checks but still consume output slots, enabling bloat attacks that slow catchup processing for >1 hour?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonnegativeInteger()] [Witness list unit validation] When validation.js validates witness_list_unit field using isNonnegativeInteger(), can an attacker set witness_list_unit to 0 (genesis unit) to bypass witness compatibility checks, causing units to reference incompatible witness lists and triggering permanent chain split?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonnegativeInteger()] [Array index validation] If formula/evaluation.js uses isNonnegativeInteger() to validate array indices in AA state variables but doesn't check upper bounds, can an attacker access out-of-bounds indices causing memory corruption or reading sensitive data from other AAs' state, leading to fund theft?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyString()] [Unicode normalization bypass] Does isNonemptyString() accept Unicode strings with different normalization forms (NFC vs NFD), allowing an attacker to create visually identical addresses or asset names that hash differently in object_hash.js, causing validation.js to treat them as distinct and enabling address spoofing for fund theft?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyString()] [Zero-width character bypass] Can isNonemptyString() be bypassed with strings containing only zero-width Unicode characters (U+200B, U+FEFF) that have str.length > 0 but display as empty, allowing aa_validation.js to accept AA definitions with invisible state variable names that clash with legitimate ones and corrupt state?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyString()] [Whitespace-only bypass] Does isNonemptyString() allow strings containing only whitespace characters (spaces, tabs, newlines), and if so, can wallet.js accept device pairing codes or payment messages that are effectively empty, enabling device impersonation or payment fraud?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyString()] [Null byte injection] If isNonemptyString() accepts strings containing null bytes (\\x00) and validation.js uses these in SQL queries without proper escaping, can an attacker inject null bytes in unit fields to truncate queries or bypass filters, corrupting the database and causing network halt?",
  "[File: byteball/ocore/validation_utils.js] [Function: isStringOfLength()] [Multi-byte character length] Since JavaScript's string.length counts UTF-16 code units not Unicode codepoints, does isStringOfLength() incorrectly measure strings with emoji or surrogate pairs, causing validation.js to accept oversized unit fields that exceed database column limits and crash the node?",
  "[File: byteball/ocore/validation_utils.js] [Function: isStringOfLength()] [False parameter handling] When isStringOfLength() is called without a len parameter or len=0, it returns false for all strings - can this cause validation.js to reject valid units if len is accidentally undefined, creating a network halt where no new transactions can be confirmed?",
  "[File: byteball/ocore/validation_utils.js] [Function: isStringOfLength()] [Negative length] If isStringOfLength() receives a negative len parameter, does it always return false, or can edge cases cause it to incorrectly validate, allowing aa_validation.js to accept AA formulas with malformed string parameters that crash formula evaluation and freeze AA funds?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidChash()] [Chash checksum bypass] Since isValidChash() delegates to chash.isChashValid() which validates checksums, if the checksum validation in chash.js has a collision weakness, can an attacker generate an address with incorrect clean_data but valid checksum, causing validation.js to accept payments to uncontrolled addresses and enabling fund theft?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidChash()] [Length parameter bypass] Does isValidChash() enforce that the decoded chash binary length matches the expected length parameter, or can an attacker pass a 32-character base32 string with len=48 (or vice versa) to bypass address type validation in validation.js, mixing address formats and causing consensus divergence?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidChash()] [Base32 case sensitivity] Since base32 encoding can be case-insensitive, does chash.isChashValid() normalize case before validation, or can an attacker submit mixed-case addresses that produce different hashes in object_hash.js vs chash validation, causing signature verification failures and permanent fund freezing?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidChash()] [Padding validation] If the base32 or base64 encoded chash contains invalid padding characters (= or ==), does isValidChash() reject it, or can padding manipulation cause wallet.js to generate change outputs to malformed addresses that are unspendable, permanently freezing funds?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidAddressAnyCase()] [Case normalization inconsistency] If isValidAddressAnyCase() accepts addresses in any case but validation.js later compares them with case-sensitive string comparison in database queries, can an attacker send payments to lowercased addresses that appear valid but don't match database records, causing double-spend or balance miscalculation leading to fund loss?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidAddressAnyCase()] [Mixed-case collision] Can an attacker exploit isValidAddressAnyCase() to create two units with the same address in different cases (e.g., 'ABC...' and 'abc...') that both pass validation but are treated as different addresses in some contexts and same in others, causing balance inconsistencies and enabling fund theft?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidAddress()] [toUpperCase() non-determinism] Does isValidAddress() use address === address.toUpperCase() check deterministically across all locales and Node.js versions, or can locale-dependent uppercasing (e.g., Turkish i/ conversion) cause validation.js to accept/reject addresses differently on different nodes, triggering permanent chain split?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidAddress()] [Checksum enforcement gap] Since isValidAddress() requires uppercase but delegates checksum validation to isValidChash(), if an attacker finds a collision where a lowercase address has the same checksum as an uppercase one, can they bypass the uppercase requirement to create addresses that pass validation but are unspendable, permanently freezing deposited funds?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidAddress()] [Type check before case check] If the address parameter is not a string (e.g., object with toString()), does isValidAddress() correctly reject it before calling toUpperCase() which might throw an exception, or can this crash validation.js when processing malformed units received from malicious peers, causing node crash and network halt?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidAddress()] [Length validation order] Since isValidAddress() checks case before delegating to isValidChash() which checks length, can an attacker send addresses that are uppercase but wrong length (e.g., 31 or 33 chars) that pass the case check but fail later, causing validation.js to accept units that are partially valid but ultimately rejected, wasting validation resources in DoS attack delaying processing >1 hour?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidDeviceAddress()] [Leading zero requirement] Does isValidDeviceAddress() strictly require address[0] === '0', and if device.js accidentally allows device addresses without leading '0' through alternative validation paths, can an attacker impersonate devices using regular addresses, enabling man-in-the-middle attacks on encrypted pairing sessions that leak private keys and cause fund theft?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidDeviceAddress()] [substr() vs substring() inconsistency] Since isValidDeviceAddress() uses address.substr(1) which is deprecated, can inconsistent behavior across Node.js versions cause device address validation to fail or pass unexpectedly in wallet.js, breaking device pairing and preventing users from receiving payments (temporary fund freezing >1 day)?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidDeviceAddress()] [33-character requirement bypass] If an attacker passes a 34-character string starting with '0' that truncates to valid address, does isValidDeviceAddress() incorrectly validate it, allowing network.js to route messages to wrong devices and enabling payment interception or theft?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyArray()] [Array-like object bypass] Can isNonemptyArray() be bypassed with array-like objects (e.g., {0: 'a', 1: 'b', length: 2}) that pass Array.isArray() check in some JavaScript engines, causing validation.js to process non-array structures as parent_units or witnesses and corrupting DAG topology, leading to consensus failure and chain split?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyArray()] [Sparse array validation] Does isNonemptyArray() accept sparse arrays with undefined holes [1, , 3], and if aa_validation.js processes these as AA response outputs, can an attacker create outputs with undefined amounts that bypass balance checks but are stored in database, enabling asset inflation through duplicate output processing?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyArray()] [Array subclass bypass] If an attacker extends Array class and overrides length getter to return fake values, can isNonemptyArray() be fooled into validating empty arrays as non-empty, causing validation.js to accept units with zero parent_units that violate DAG structure and cause network partition?",
  "[File: byteball/ocore/validation_utils.js] [Function: isArrayOfLength()] [Witness array validation] When validation.js uses isArrayOfLength(witnesses, 12) to validate witness lists, can an attacker exploit prototype pollution to override Array.prototype.length, causing witness lists of wrong size to pass validation and breaking main chain consensus, triggering permanent chain split?",
  "[File: byteball/ocore/validation_utils.js] [Function: isArrayOfLength()] [Length overflow] If len parameter is extremely large (near MAX_SAFE_INTEGER), does isArrayOfLength() comparison work correctly, or can integer overflow cause it to accept arrays of wrong length, allowing aa_composer.js to create AA responses with excessive outputs that exceed database limits and crash nodes?",
  "[File: byteball/ocore/validation_utils.js] [Function: isArrayOfLength()] [Zero-length array acceptance] When isArrayOfLength(arr, 0) is used to validate empty arrays in formula/evaluation.js for AA formula parameters, can an attacker exploit this to pass empty arrays where non-empty ones are required, causing formula evaluation to crash and freeze AA funds permanently?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyObject()] [Array rejection logic] Since isNonemptyObject() explicitly rejects arrays with !Array.isArray(obj), if validation.js accidentally passes array-like structures that aren't true arrays, can this cause inconsistent validation results across nodes running different JavaScript engines, triggering non-deterministic consensus failure and chain split?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyObject()] [Object.keys() performance] If an attacker creates objects with thousands of properties and validation.js calls isNonemptyObject() on each message payload in aa_validation.js, can the O(n) cost of Object.keys() create a DoS vulnerability delaying unit validation and transaction processing for >1 hour?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyObject()] [Null object check order] Does isNonemptyObject() check obj === null before typeof obj, or can the order cause unexpected behavior if obj is a proxy or exotic object that throws on typeof check, crashing validation.js when processing malicious units from peers and causing network halt?",
  "[File: byteball/ocore/validation_utils.js] [Function: isNonemptyObject()] [Inherited properties] Since Object.keys() only returns enumerable own properties, can an attacker create objects with inherited properties that appear non-empty but have Object.keys().length === 0, causing aa_validation.js to reject valid AA definitions with inherited state variables and freezing AA funds?",
  "[File: byteball/ocore/validation_utils.js] [Function: isEmptyObjectOrArray()] [Primitive return values] Does isEmptyObjectOrArray() return false for all primitives (numbers, strings, booleans), and if formula/evaluation.js expects this function to validate empty results, can type confusion cause AA formulas to treat primitives as empty objects, producing incorrect execution results and causing AA state corruption without direct fund loss?",
  "[File: byteball/ocore/validation_utils.js] [Function: isEmptyObjectOrArray()] [Null and undefined distinction] Since isEmptyObjectOrArray(null) returns false, if aa_composer.js uses this to check for empty AA responses but null represents missing response, can this cause AA execution to continue with invalid state, creating bounces that incorrectly refund or withhold funds?",
  "[File: byteball/ocore/validation_utils.js] [Function: isEmptyObjectOrArray()] [Array.length override] If an attacker overrides Array.prototype.length to always return 0, can isEmptyObjectOrArray() be tricked into treating non-empty arrays as empty, causing validation.js to accept units with witness lists or parent_units that appear valid but are actually missing, corrupting DAG and causing consensus failure?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidBase64()] [Buffer round-trip validation] Since isValidBase64() validates by encoding-decoding round-trip (b64 === Buffer.from(b64, 'base64').toString('base64')), can an attacker exploit differences in base64 padding or whitespace handling across Node.js versions to create addresses that validate on some nodes but not others, causing permanent chain split?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidBase64()] [Length parameter enforcement] When validation.js calls isValidBase64(definition_chash, 44) to validate definition changes, does the function enforce exact length matching, or can an attacker pass base64 strings of wrong decoded length that pass validation but corrupt definition storage, enabling unauthorized definition changes that steal funds?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidBase64()] [URL-safe base64 bypass] Does isValidBase64() accept URL-safe base64 encoding (using - and _ instead of + and /) that would decode differently, allowing wallet.js to generate payment URIs that are ambiguous between standard and URL-safe encoding, causing payment misdirection and fund loss?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidBase64()] [Buffer.from() exception handling] If Buffer.from(b64, 'base64') throws an exception on malformed input, does isValidBase64() catch it gracefully, or can uncaught exceptions crash validation.js when processing units with invalid base64 fields, causing node crash and network partition?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidBase64()] [Empty string validation] Does isValidBase64('', 0) return true for empty strings when len=0, and if indivisible_asset.js uses this to validate optional fields that should be omitted, can an attacker include empty string fields that bypass validation but are stored in database, corrupting asset metadata and preventing transfers (permanent fund freezing)?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidHexadecimal()] [Try-catch exception swallowing] Since isValidHexadecimal() wraps validation in try-catch that returns false on any exception, can this hide critical errors in validation.js (e.g., memory exhaustion, stack overflow) that should halt processing, allowing malicious units to continue through validation pipeline and corrupt database?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidHexadecimal()] [Uppercase vs lowercase handling] Does isValidHexadecimal() accept both uppercase and lowercase hex strings, and if validation.js later compares hex values with case-sensitive comparison, can an attacker create signature fields or hashes in mixed case that validate but fail verification, causing units to be permanently rejected after storage and freezing funds?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidHexadecimal()] [Odd-length hex strings] If an attacker passes odd-length hex strings like 'abc' (3 characters), does Buffer.from(hex, 'hex') pad or truncate, and does the round-trip comparison catch this, or can malformed hex cause signature.js to parse signatures incorrectly, enabling signature forgery and fund theft?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidHexadecimal()] [0x prefix handling] Does isValidHexadecimal() accept hex strings with '0x' prefix that are valid JavaScript hex literals, and if aa_validation.js expects unprefixed hex for AA state variables but this function accepts both, can state variable naming collisions occur where '0xabc' and 'abc' are treated as same key, corrupting AA state and causing incorrect fund transfers?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidEmail()] [ReDoS vulnerability] Does the email regex in isValidEmail() contain nested quantifiers or alternations that could cause catastrophic backtracking on crafted input strings, enabling a ReDoS attack where validation.js spends excessive time validating attestation units with malicious email fields, delaying transaction processing for >24 hours (network halt)?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidEmail()] [RFC 5322 compliance] Since the email regex is a simplified pattern, can an attacker use RFC-compliant but unusual email formats (e.g., quoted strings with special chars, IP address domains) that bypass isValidEmail() validation, causing data_feeds.js to accept invalid attestation email addresses that don't match real users, enabling impersonation attacks in attestation services?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidEmail()] [Unicode domain bypass] Does the regex accept internationalized domain names (IDN) with Unicode characters, and if device.js uses this to validate email notifications but email service providers reject Unicode domains, can users miss critical payment notifications leading to payment disputes and fund freezing?",
  "[File: byteball/ocore/validation_utils.js] [Function: isValidEmail()] [Email length limits] Does isValidEmail() enforce maximum length limits for email addresses (254 chars per RFC 5321), and if private_profile.js stores unlimited-length emails validated by this function, can database column overflow cause profile storage to fail, preventing users from receiving attestations and freezing their funds in attestation-gated AAs?",
  "[File: byteball/ocore/validation_utils.js] [Function: hasOwnProperty()] [Object.create(null) bypass] When hasOwnProperty() uses Object.prototype.hasOwnProperty.call(), can it correctly handle objects created with Object.create(null) that lack prototype chain, and if validation.js uses this to check unit properties, can an attacker create prototype-less unit objects that bypass property validation and include malicious fields?",
  "[File: byteball/ocore/validation_utils.js] [Function: hasOwnProperty()] [Proxy object interception] If an attacker creates proxy objects that intercept Object.prototype.hasOwnProperty.call(), can they return fake results causing aa_validation.js to believe required properties exist in AA definitions when they don't, leading to AA execution failures and permanent fund freezing in incompletely defined AAs?",
  "[File: byteball/ocore/validation_utils.js] [Function: hasOwnProperty()] [Symbol properties exclusion] Since hasOwnProperty() only checks string/number properties and excludes Symbol properties, can an attacker include Symbol-keyed properties in units that bypass validation but are processed by formula/evaluation.js, causing non-deterministic AA execution results if Symbol.for() resolves differently across nodes, triggering chain split?",
  "[File: byteball/ocore/validation_utils.js] [Multiple functions] [Validation order dependency] If validation.js calls multiple validation_utils functions on the same value (e.g., isNonemptyString() then isStringOfLength()) but doesn't check the order, can short-circuit evaluation in logic operators cause some checks to be skipped, allowing malformed units to pass validation and corrupt database, causing network halt?",
  "[File: byteball/ocore/validation_utils.js] [Multiple functions] [Type coercion in caller] If aa_composer.js performs type coercion (e.g., +value) before calling isPositiveInteger(), can the coercion convert non-numeric strings to numbers that pass validation but have different semantics than intended, causing AA responses to include incorrect payment amounts and enabling fund theft?",
  "[File: byteball/ocore/validation_utils.js] [Multiple functions] [Inconsistent null handling] Since different functions handle null differently (e.g., isNonemptyObject returns false, isInteger returns false), if wallet.js expects consistent null rejection across all validation functions but some allow null to pass initial checks, can null values propagate into database causing foreign key violations and node crashes?",
  "[File: byteball/ocore/validation_utils.js] [Multiple functions] [Return value interpretation] If formula/evaluation.js interprets all validation function false returns as same error type without checking which validation failed, can this cause incorrect bounce messages in AA execution that don't specify the actual validation error, confusing users and causing them to lose funds by repeatedly submitting invalid triggers?",
  "[File: byteball/ocore/validation_utils.js] [Integration with validation.js] [Address validation bypass] If validation.js uses isValidAddressAnyCase() for certain address fields but isValidAddress() for others without clear specification, can an attacker create units where recipient addresses in payment messages are lowercase but change addresses are uppercase, causing database queries to miss outputs and creating unspendable change (permanent fund freezing)?",
  "[File: byteball/ocore/validation_utils.js] [Integration with aa_validation.js] [Formula string validation] When aa_validation.js validates AA formula strings using isNonemptyString(), if formulas contain only whitespace or comments that parse as empty, can these AAs be deployed but never execute, causing all trigger payments to be lost as AA fails to process them (permanent fund freezing in non-functional AAs)?",
  "[File: byteball/ocore/validation_utils.js] [Integration with formula/evaluation.js] [State variable key validation] If formula/evaluation.js uses isNonemptyString() to validate AA state variable keys but doesn't enforce character restrictions, can an attacker create state keys with SQL wildcard characters (%, _) that corrupt state queries when formula reads 'var[%]', enabling state variable injection that steals funds from other AAs sharing storage?",
  "[File: byteball/ocore/validation_utils.js] [Integration with wallet.js] [Device address validation bypass] When wallet.js validates pairing codes using isValidDeviceAddress(), if the validation is only client-side and network.js doesn't revalidate, can an attacker pair with invalid device addresses, causing encrypted messages to be routed incorrectly and enabling interception of private payment information leading to fund theft?",
  "[File: byteball/ocore/validation_utils.js] [Integration with network.js] [Light client request validation] If network.js uses validation_utils functions to validate light client requests for address history but doesn't rate-limit requests with invalid addresses, can an attacker flood full nodes with malformed address requests that fail isValidAddress() check, causing CPU exhaustion in validation loop and network halt?",
  "[File: byteball/ocore/validation_utils.js] [Integration with indivisible_asset.js] [Serial number validation] When indivisible_asset.js validates NFT serial numbers using isPositiveInteger(), if the function doesn't enforce maximum serial values and serials can be arbitrarily large, can an attacker create NFTs with serials exceeding database integer limits, causing overflows when computing serial ranges and enabling duplicate NFT issuance (breaking serial uniqueness invariant)?",
  "[File: byteball/ocore/validation_utils.js] [Integration with divisible_asset.js] [Asset amount precision] If divisible_asset.js uses isNonnegativeInteger() to validate asset amounts but the caller performs floating-point arithmetic before validation, can rounding errors cause amounts like 0.999999999999999 to round to 1 and pass validation, enabling attackers to steal fractional asset amounts through repeated rounding exploitation?",
  "[File: byteball/ocore/validation_utils.js] [Multiple functions] [JavaScript version differences] Can differences in JavaScript implementation details across Node.js versions (e.g., changes in String.prototype methods, Number precision handling) cause validation_utils functions to return different results for the same inputs on nodes running different versions, triggering consensus divergence and permanent chain split?",
  "[File: byteball/ocore/validation_utils.js] [isValidBase64/isValidHexadecimal] [Buffer encoding differences] If Buffer.from() behavior for base64/hex encoding changed between Node.js versions (e.g., stricter validation in newer versions), can units created with older nodes fail validation on newer nodes, causing network partition where old and new nodes reject each other's units (permanent chain split requiring hard fork)?",
  "[File: byteball/ocore/validation_utils.js] [isValidEmail] [Regex engine differences] Can differences in JavaScript regex engines (V8 vs others) cause the email validation regex to accept/reject emails differently across nodes or platforms, leading to attestation units being valid on some nodes but invalid on others, causing consensus failure in attestation services and freezing funds in attestation-gated AAs?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub()] [Race condition] The mutex lock at line 62 serializes messages from hub, but if two concurrent calls to handleMessageFromHub() occur before the first acquires the lock, could both process the same message type (e.g., 'sign' requests) leading to duplicate signature generation or double-spending attempts?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub()] [Input validation bypass] At lines 71-72, the function checks for subject and body existence but doesn't validate body type deeply - can an attacker send a subject='sign' with body as a string instead of object to bypass subsequent validation and crash the node?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'text' case] [DoS via message flooding] Lines 82-88 increment message_counter without any rate limiting - can a malicious hub or correspondent flood the wallet with 'text' messages to overflow message_counter (JavaScript number limit 2^53-1) causing integer overflow and potential state corruption?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'removed_paired_device' case] [Authorization bypass] Lines 105-117 check determineIfDeviceCanBeRemoved() but if conf.bIgnoreUnpairRequests is true, it only sets is_blackhole=1 without actually removing the device - can a malicious cosigner abuse this to maintain signing access after being 'removed'?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'my_xpubkey' case] [Injection attack] Line 144 checks my_xpubkey length >112 but doesn't validate format - can an attacker inject a crafted xpubkey containing SQL injection payloads that get stored in walletDefinedByKeys.addDeviceXPubKey() and later exploited during wallet operations?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'sign' case] [Signature replay] Lines 227-367 handle signing requests, but the code at lines 241-244 replaces existing signatures with placeholders - if an attacker captures a signing request with legitimate signatures and replays it with modified outputs, can they trick cosigners into signing a different unit than intended?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'sign' case] [Private payload hash collision] Lines 247-270 validate private payload hashes, but at line 264 it only checks payload_hash !== calculated_payload_hash - can an attacker exploit hash collision vulnerabilities (e.g., SHA256 near-collisions) to substitute private payloads and steal funds during indivisible asset transfers?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'sign' case] [Unit validation bypass] Lines 272-288 validate public payload hashes, but if objUnit.messages is manipulated after validation and before network.handleOnlineJoint() at line 334, can an attacker inject malicious messages that bypass signature checks?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'sign' case] [Infinite loop in signing] Lines 295-366 use findAddress() which can recursively call itself for shared addresses - if an attacker crafts a circular address definition where address A delegates to B which delegates back to A, can this cause infinite recursion and crash the node?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'sign' case] [Event listener memory leak] Line 321 uses eventBus.once() for validation, but if validation never completes (e.g., malformed unit), the listener remains attached - can an attacker flood with invalid signing requests to exhaust memory via accumulated event listeners?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'sign' case] [Looping signing proxy] Lines 337-354 forward signing requests to remote devices, but line 339 only checks if device_address === from_address - can an attacker create a signing loop where device A forwards to B, B to C, C back to A, causing infinite message forwarding and network DoS?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'signature' case] [Signature forgery] Lines 369-381 accept signatures without verifying them against the unit hash - can an attacker send arbitrary signatures that get accepted and propagated, potentially causing invalid units to be signed?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'signature' case] [Signature length bypass] Line 373 checks signature length equals constants.SIG_LENGTH OR signature === '[refused]', but doesn't validate signature format - can an attacker send exactly SIG_LENGTH bytes of garbage that passes validation but causes signature verification failures downstream?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'private_payments' case] [Private chain validation] Line 384 calls handlePrivatePaymentChains() which processes chains at lines 770-880, but if the chains array is extremely large, can an attacker cause memory exhaustion or timeout the mutex lock, blocking all other hub messages?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'payment_notification' case] [False payment notification] Lines 387-414 emit payment events for units that may not contain actual payments to the user - can an attacker spam payment_notification messages for random units to confuse wallet UIs or trigger incorrect balance displays?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'payment_notification' case] [Race condition on emitPn] Lines 396-402 use a bEmitted flag and eventBus.once(), but if storage.readJoint() at line 403 completes before eventBus.once() is registered, the event might fire before the listener is attached - can this cause payment notifications to be missed?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'prosaic_contract_offer' case] [Hash collision attack] Line 422 validates contract hash using prosaic_contract.getHash(), but if an attacker finds a hash collision, can they substitute contract terms (title, text) while maintaining the same hash, tricking users into signing different contracts?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'prosaic_contract_offer' case] [Creation date manipulation] Line 427 validates creation_date format with regex but doesn't check if the date is in the future or unreasonably old - can an attacker set creation_date to year 9999 to make contracts never expire (line 498 TTL check)?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'prosaic_contract_response' case] [Signature bypass via authors manipulation] Lines 472-494 allow peer to send authors array and inject address definitions without full validation - can an attacker register fake definitions for victim addresses and later use them to forge signatures?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'prosaic_contract_response' case] [SQL injection in definition update] Line 489 executes UPDATE with JSON.stringify(author.definition) - if author.definition contains SQL escape sequences, can this break out of the JSON string and inject arbitrary SQL?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'prosaic_contract_response' case] [Time-of-check-time-of-use] Lines 495-499 check contract status and TTL separately, but between line 495 (status check) and line 500 (setField), another thread could modify the contract status - can this cause race conditions in contract state transitions?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'prosaic_contract_update' case] [Unauthorized contract modification] Lines 525-552 allow contract status/unit/shared_address updates, but only check if from_address matches peer_device_address - if a shared wallet has multiple cosigners, can non-owner cosigners modify contracts?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'arbiter_contract_offer' case] [Contract hash manipulation after swap] Lines 554-575 swap peer/my fields and validate hash again, but line 574 uses throw Error() instead of returning callbacks.ifError() - can this cause the mutex to remain locked forever, blocking all future messages from hub?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'arbiter_contract_update' case] [Complex authorization logic] Lines 610-664 have intricate status transition rules checking from_cosigner, peer_device_address, and arbstore_device_address - can an attacker exploit edge cases in the state machine (e.g., rapid status changes) to bypass authorization checks?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'arbiter_contract_update' case] [Status transition race] Lines 618-639 check current status and new status compatibility, but the actual update at line 658 happens after the check - can concurrent updates cause invalid state transitions like pending->accepted->revoked simultaneously?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'arbiter_dispute_request' case] [Encrypted contract decryption] Line 671 decrypts contract using device.decryptPackage() without validating the decryption result format - can an attacker send malformed encrypted data that crashes the decryption routine or returns unexpected types?",
  "[File: byteball/ocore/wallet.js] [Function: handleMessageFromHub() - 'arbiter_dispute_request' case] [Light client history poisoning] Lines 674-675 request history for body.unit in light mode - can an attacker reference a fake unit that doesn't exist, causing the light client to request and store invalid history?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentChains()] [Cache key collision] Lines 774-783 use objectHash.getBase64Hash(arrChains) as cache key - if two different chain arrays produce the same hash (collision), can an attacker replay cached chains to double-spend private assets?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentChains()] [Race condition in checkIfAllValidated] Lines 799-819 check assocValidatedByKey without proper locking - if multiple validation events fire simultaneously, can the function execute multiple times leading to duplicate forwarding of private chains?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentChains()] [Validation bypass via denomination mismatch] Lines 825-826 check if payload.denomination presence matches output_index, but uses !== instead of checking type - can an attacker send denomination=0 (falsy) to bypass checks?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentChains()] [Output index overflow] Line 827 sets output_index to -1 for divisible assets, but doesn't validate that objHeadPrivateElement.output_index is within valid range (0 to outputs.length-1) - can negative or huge indices cause array access violations?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentChains()] [Event listener leak] Lines 834-863 create event listeners with eventBus.once() but if cb(error) is called before the event fires, listeners remain attached - can an attacker exhaust memory by sending many invalid private chains?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentChains()] [Error message leakage] Lines 838-843 log errors to console but return generic",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentChains()] [Cache poisoning] Line 873 sets handledChainsCache[cache_key] = true after validation, but if validation partially succeeds then fails, the cache entry blocks future attempts - can an attacker poison the cache to prevent legitimate private payments?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentChains()] [Forwarding flag bypass] Lines 808-817 check !body.forwarded before forwarding chains, but this flag is controlled by the sender - can a malicious forwarding node set forwarded=false to cause infinite forwarding loops?",
  "[File: byteball/ocore/wallet.js] [Function: findAddress()] [Infinite recursion] Lines 1027-1097 recursively call findAddress() for shared addresses at line 1070, but there's no cycle detection - can an attacker create circular shared address definitions causing stack overflow?",
  "[File: byteball/ocore/wallet.js] [Function: findAddress()] [SQL injection via signing_path] Line 1056 uses SUBSTR(?, 1, LENGTH(signing_path)) with user-controlled signing_path - can special characters or SQL keywords in signing_path cause injection?",
  "[File: byteball/ocore/wallet.js] [Function: findAddress()] [Authorization bypass via fallback] Lines 1088-1089 use fallback_remote_device_address if no candidate found - can an attacker set themselves as fallback to gain signing access to addresses they don't control?",
  "[File: byteball/ocore/wallet.js] [Function: findAddress()] [Merkle address leakage] Lines 1065-1066 check for empty string address (merkle) and return bLocal flag - can an attacker enumerate merkle addresses by observing response timing differences?",
  "[File: byteball/ocore/wallet.js] [Function: findAddress()] [Secret address bypass] Lines 1067-1069 check for 'secret' address but don't validate if the secret is actually known - can an attacker reference secret addresses they don't control?",
  "[File: byteball/ocore/wallet.js] [Function: findAddress()] [Multiple results error] Lines 1034-1035 throw Error if rows.length > 1, but this terminates the process - can an attacker create duplicate address entries in database to DoS the wallet?",
  "[File: byteball/ocore/wallet.js] [Function: readBalance()] [Asset proof DoS] Lines 1118-1122 request proofs for all assets in light mode - if a wallet has thousands of different assets, can an attacker cause timeout or memory exhaustion by triggering balance reads?",
  "[File: byteball/ocore/wallet.js] [Function: readBalancesOnAddresses()] [SQL injection via walletId] Line 1134 uses walletId directly in query - if walletId comes from user input without validation, can this enable SQL injection?",
  "[File: byteball/ocore/wallet.js] [Function: readAssetMetadata()] [Metadata expiration bypass] Lines 1149-1152 check if metadata is expired using ASSET_METADATA_EXPIRY_PERIOD, but an attacker controlling registry could repeatedly update metadata to force constant refetching, causing DoS?",
  "[File: byteball/ocore/wallet.js] [Function: readAssetMetadata()] [Registry address validation] Line 1218 checks ValidationUtils.isValidAddress(registry_address) but doesn't verify the registry is trusted - can an attacker register assets with malicious registry addresses that serve fake metadata?",
  "[File: byteball/ocore/wallet.js] [Function: fetchAssetMetadata()] [Metadata unit mismatch] Line 1235 checks if objJoint.unit.authors[0].address !== registry_address but there's a typo 'bjJoint' at line 1236 - does this cause the check to always fail, allowing fake metadata?",
  "[File: byteball/ocore/wallet.js] [Function: fetchAssetMetadata()] [Decimals overflow] Lines 1245-1247 parse decimals as integer but don't check maximum value - can setting decimals to 2^53 cause overflow in balance calculations?",
  "[File: byteball/ocore/wallet.js] [Function: fetchAssetMetadata()] [Race condition on REPLACE] Line 1248 uses REPLACE INTO for updatable registries - if two nodes fetch metadata simultaneously, can they overwrite each other's updates causing inconsistent metadata across network?",
  "[File: byteball/ocore/wallet.js] [Function: readTransactionHistory()] [SQL injection via wallet parameter] Lines 1276-1278 check if wallet is an address but don't sanitize it before use in queries - can attacker inject SQL through wallet parameter?",
  "[File: byteball/ocore/wallet.js] [Function: readTransactionHistory()] [since_mci validation bypass] Line 1287 checks ValidationUtils.isNonnegativeInteger(opts.since_mci) but then directly interpolates it in SQL at line 1287 - can an attacker cause injection by passing since_mci as string '0; DROP TABLE units--'?",
  "[File: byteball/ocore/wallet.js] [Function: readTransactionHistory()] [Unbounded query result] Line 1303 uses LIMIT only if opts.limit is provided - can an attacker omit limit to fetch millions of transactions, causing memory exhaustion?",
  "[File: byteball/ocore/wallet.js] [Function: readTransactionHistory()] [AA detection bypass] Lines 1373-1382 check if payment is from AA by comparing arrPayerAddresses[0] with aa_address, but if there are multiple payers, can an attacker hide AA origin?",
  "[File: byteball/ocore/wallet.js] [Function: readTransactionHistory()] [Asset filter bypass] Line 1408 checks 'has_external_bytes_payment' to filter fee transactions, but if an attacker sends tiny asset amounts with large byte payments, can they hide asset transactions?",
  "[File: byteball/ocore/wallet.js] [Function: readFullSigningPaths()] [Recursive depth limit] Lines 1509-1567 implement recursive goDeeper() without depth limit - can an attacker create deeply nested shared address hierarchies to cause stack overflow?",
  "[File: byteball/ocore/wallet.js] [Function: readFullSigningPaths()] [Signing path accumulation error] Line 1543 concatenates path_prefix + row.signing_path.substr(1), but if row.signing_path doesn't start with 'r', substr(1) returns unexpected results - can this cause incorrect path resolution?",
  "[File: byteball/ocore/wallet.js] [Function: readFullSigningPaths()] [Peer address injection] Lines 1554-1562 parse signing_paths from peer_addresses table without validation - can an attacker inject malformed JSON to crash JSON.parse() or inject unexpected paths?",
  "[File: byteball/ocore/wallet.js] [Function: readFundedAddresses()] [Definition change race] Lines 1604-1607 exclude addresses with pending definition changes, but between the query and actual spending, a definition change could be committed - can this cause transactions to fail or be invalid?",
  "[File: byteball/ocore/wallet.js] [Function: readFundedAddresses()] [Uncapped asset issuer bypass] Lines 1612-1623 allow uncapped assets to be issued from any address if issued_by_definer_only=false, but if an attacker creates multiple addresses, can they issue unlimited amounts?",
  "[File: byteball/ocore/wallet.js] [Function: readFundedAddresses()] [Infinity balance bypass] Line 1616 sets issuer_row.total = Infinity for uncapped assets - can this cause overflow or comparison errors in composer.filterMostFundedAddresses()?",
  "[File: byteball/ocore/wallet.js] [Function: readFundedAddresses()] [Fixed denomination shortcut] Lines 1610-1611 set estimated_amount = 0 for indivisible assets - can this cause all addresses to be selected even when only one is needed?",
  "[File: byteball/ocore/wallet.js] [Function: readAdditionalSigningAddresses()] [Recursive signing address explosion] Lines 1648-1688 recursively call readAdditionalSigningAddresses() - if shared addresses are deeply nested, can this cause exponential address collection and memory exhaustion?",
  "[File: byteball/ocore/wallet.js] [Function: readAdditionalSigningAddresses()] [Definition change query race] Lines 1663-1667 check for definition changes in addresses table, but the subquery uses LEFT JOIN definitions - can this miss addresses with pending definition changes?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Parameter validation bypass] Lines 1932-1949 validate parameter combinations, but line 1951 allows recipient_device_address === device.getMyDeviceAddress() to be nulled - can an attacker exploit self-payments to bypass validation?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [AA address check bypass] Lines 1965-1973 call aa_addresses.checkAAOutputs() and recursively call sendMultiPayment() if checks fail, but opts.aa_addresses_checked flag can be set by attacker - can this skip AA checks?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Funded addresses validation] Lines 1980-1983 check if arrFundedAddresses.length === 0 but don't validate arrBaseFundedAddresses when nonbaseAsset exists - can an attacker create transactions that fail at composition stage wasting resources?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Textcoin mnemonic collision] Lines 2001-2004 generate mnemonics without checking uniqueness - if Mnemonic library has weak entropy, can two textcoins have identical mnemonics allowing double-claims?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Textcoin address reuse] Lines 2010-2012 derive addresses from mnemonics using fixed path m/44'/0'/0'/0/0 - can an attacker precompute target addresses and front-run textcoin creation to steal funds?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Email validation bypass] Line 2006 checks ValidationUtils.isValidEmail() but doesn't prevent sending to attacker-controlled emails - can an attacker receive textcoins meant for others?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [preCommitCb race condition] Lines 2040-2052 iterate over assocMnemonics and execute async inserts, but if ++i reaches length before last insert completes, cb() fires prematurely - can this cause incomplete mnemonic storage?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Private payment forwarding bypass] Lines 2182-2213 forward private chains to recipients and cosigners, but if wallet parameter is null (paying from addresses array), can this skip cosigner forwarding and break shared address private payments?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Textcoin fee calculation race] Lines 2089-2136 calculate fees for textcoins in two phases (estimate then actual), but if network conditions change between phases, can this cause insufficient fees?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [TPS fee estimation] Line 2093 estimates TPS fee using composer.estimateTpsFee() with double the result - if the estimation function is inaccurate, can textcoins have insufficient funds to claim?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Indivisible asset fee dry-run] Lines 2218-2255 perform dry-run composition for indivisible assets to calculate fees, but the dry-run uses tolerance_plus/minus = 0 - can this cause the actual payment to select different inputs?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [AssocPrivatePayloads length check] Lines 2238-2239 check if private payload count differs between dry-run and actual run - if indivisible asset composition is non-deterministic, can this cause transaction to fail after fees were calculated?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Send_all with assets error] Line 2139 throws Error('send_all with asset') - can an attacker trick a wallet into calling sendMultiPayment with both send_all and asset set, crashing the wallet?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Change address handling] Line 2287 adds change_address to outputs with amount: 0, but if change_address equals to_address, can this create duplicate outputs confusing validation?",
  "[File: byteball/ocore/wallet.js] [Function: sendMultiPayment()] [Outputs_by_asset asset mixing] Lines 2162-2175 detect if outputs_by_asset contains multiple non-base assets for private/indivisible assets and rewrites parameters - can an attacker exploit the rewrite logic to bypass restrictions?",
  "[File: byteball/ocore/wallet.js] [Function: getSigner()] [Merkle proof replay] Lines 1767-1768 use opts.merkle_proof without validating uniqueness - can an attacker replay the same merkle proof across multiple transactions to forge signatures?",
  "[File: byteball/ocore/wallet.js] [Function: getSigner()] [Secret path injection] Lines 1770-1772 use opts.secrets[signing_path] without validating signing_path format - can an attacker inject arbitrary paths to retrieve secrets they shouldn't access?",
  "[File: byteball/ocore/wallet.js] [Function: getSigner().readDefinition] [Definition cache poisoning] Lines 1780-1793 read definitions from three tables with UNION, but if an attacker inserts duplicate definitions with different content, which one is returned?",
  "[File: byteball/ocore/wallet.js] [Function: getSigner().sign] [Remote signature timeout] Lines 1809-1820 wait for remote signatures via eventBus.once() without timeout - can an attacker refuse to sign, blocking transactions indefinitely?",
  "[File: byteball/ocore/wallet.js] [Function: getSigner().sign] [Signature cache bypass] Lines 1812-1816 cache signatures by device_address+address+buf_to_sign but use toString(",
  "[File: byteball/ocore/wallet.js] [Function: getSigner().sign] [Refused signature handling] Line 1817 checks if sig === '[refused]' and emits refused_to_sign event, but doesn't fail the transaction - can a malicious cosigner refuse to sign while allowing transaction to proceed with incomplete signatures?",
  "[File: byteball/ocore/wallet.js] [Function: getSigner().sign] [Contract confirmation bypass] Lines 1823-1875 filter contract-related signing requests to show custom confirmation dialogs, but complex async logic with cb(true) may allow bypassing confirmations - can an attacker exploit race conditions?",
  "[File: byteball/ocore/wallet.js] [Function: getSigner().sign] [Merkle proof validation missing] Lines 1877-1882 accept merkle proof without validation if !bLocal - can a remote device send invalid merkle proofs that fail during actual unit validation?",
  "[File: byteball/ocore/wallet.js] [Function: receiveTextCoin()] [Mnemonic injection] Lines 2420-2431 call expandMnemonic() which splits on '-' and spaces, but doesn't sanitize input - can an attacker inject control characters to bypass validation?",
  "[File: byteball/ocore/wallet.js] [Function: receiveTextCoin()] [Double-claim via fee fallback] Lines 2476-2485 retry with addressTo in fee_paying_addresses if textcoin is insufficient, but this allows claiming with external funds - can an attacker partially drain a textcoin then claim remainder with victim's funds?",
  "[File: byteball/ocore/wallet.js] [Function: receiveTextCoin()] [Private asset detection bypass] Line 2534 checks objAsset.is_private but if asset metadata is missing or corrupted, can this default to false allowing private asset recipient addresses to be revealed?",
  "[File: byteball/ocore/wallet.js] [Function: receiveTextCoin()] [Multi-asset textcoin vulnerability] Lines 2528-2547 iterate over multiple assets in rows but only claim the first asset if private - can an attacker create textcoins with mixed private/public assets to steal unclaimed assets?",
  "[File: byteball/ocore/wallet.js] [Function: receiveTextCoin()] [Asset info race condition] Lines 2529-2531 request unknown assets in light mode then recursively call checkStability() - can an attacker cause infinite recursion by repeatedly creating unknown assets?",
  "[File: byteball/ocore/wallet.js] [Function: receiveTextCoin()] [Already claimed check bypass] Line 2491 checks for 'some definition changes' error string but this is fragile - can error messages change in other modules causing this check to fail?",
  "[File: byteball/ocore/wallet.js] [Function: receiveTextCoin()] [Stability check timing] Lines 2519-2565 check stability of textcoin address before claiming, but between check and actual spending, outputs could become spent - can this cause claim failures or race conditions?",
  "[File: byteball/ocore/wallet.js] [Function: receiveTextCoin()] [Send_all for bytes] Line 2559 uses send_all for byte claims, but composer.composeJoint() might include change output - can this cause claiming to fail if exact amounts don't match?",
  "[File: byteball/ocore/wallet.js] [Function: expandMnemonic()] [Mnemonic validation bypass] Lines 2422-2423 check (mnemonic.split(' ').length % 3 !== 0) but this allows 3, 6, 9 words while BIP39 requires 12, 15, 18, 21, 24 - can shorter mnemonics have weak entropy?",
  "[File: byteball/ocore/wallet.js] [Function: claimBackOldTextcoins()] [Days parameter injection] Lines 2595-2616 use days parameter directly in SQL with db.addTime() - if days is negative, can this select future textcoins or cause SQL injection?",
  "[File: byteball/ocore/wallet.js] [Function: claimBackOldTextcoins()] [Claiming error suppression] Lines 2605-2610 only log errors without failing - can an attacker cause all claimBack attempts to silently fail?",
  "[File: byteball/ocore/wallet.js] [Function: storePrivateAssetPayload()] [File path traversal] Line 2639 uses fullPath directly in fs.writeFile() without sanitization - can an attacker specify path like '../../../etc/passwd' to overwrite system files?",
  "[File: byteball/ocore/wallet.js] [Function: storePrivateAssetPayload()] [Cordova path injection] Lines 2642-2655 construct file paths in Cordova without validation - can an attacker inject malicious paths in cordovaPathObj.path to access other apps' data?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentFile()] [ZIP bomb] Lines 2662-2720 decompress ZIP files without checking compressed vs uncompressed size ratio - can an attacker upload a ZIP bomb to exhaust memory/disk?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentFile()] [Malicious ZIP content] Line 2669 calls zip.file(",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentFile()] [Event handling race] Lines 2677-2686 subscribe to event 'all_private_payments_handled-' + first_chain_unit but if the event fires before subscription, it's missed - can this cause payments to be processed but callback never fires?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentFile()] [Textcoin claimed check bypass] Lines 2710-2712 check if textcoin was claimed by comparing action counts, but if mnemonic address has multiple incoming payments, can this incorrectly identify as already claimed?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentFile()] [Light client history manipulation] Lines 2706-2708 request history for mnemonic address if no rows found - can an attacker flood with fake mnemonic addresses causing excessive network requests?",
  "[File: byteball/ocore/wallet.js] [Function: handlePrivatePaymentFile()] [Cordova permission bypass] Lines 2743-2750 request READ_EXTERNAL_STORAGE permission when fileReader.result is null, but doesn't retry if permission denied - can file reading silently fail?",
  "[File: byteball/ocore/wallet.js] [Function: readNonRemovableDevices()] [SQL query without parameters] Lines 2764-2783 build SQL with multiple UNIONs but don't use parameterized queries - if any column names come from user input, can this enable SQL injection?",
  "[File: byteball/ocore/wallet.js] [Function: determineIfDeviceCanBeRemoved()] [Race condition on correspondent read] Lines 2786-2794 read correspondent then check non-removable list, but correspondent could be added to contracts between these steps - can device be removed while still needed?",
  "[File: byteball/ocore/wallet.js] [Function: signMessage()] [Parameter order confusion] Lines 2797-2802 allow swapping message and from_address parameters if types are detected - can this cause signatures to be generated for unintended content?",
  "[File: byteball/ocore/wallet.js] [Function: signMessage()] [Network awareness bypass] Line 2804 accepts bNetworkAware flag without validation - can an attacker force network-aware signatures when they should be offline?",
  "[File: byteball/ocore/wallet.js] [Function: sendTextcoinEmail()] [Amount manipulation] Lines 2382-2391 subtract TEXTCOIN_CLAIM_FEE from amount and display in email - if constants.TEXTCOIN_CLAIM_FEE is updated, can old emails show incorrect claimable amounts?",
  "[File: byteball/ocore/wallet.js] [Function: sendTextcoinEmail()] [Exchange rate injection] Line 2388 uses network.exchangeRates['GBYTE_USD'] without validation - if exchange rate is manipulated, can emails show fraudulent USD values?",
  "[File: byteball/ocore/wallet.js] [Function: replaceInTextcoinTemplate()] [Template injection] Lines 2404-2417 replace template variables with user-controlled values - can an attacker inject HTML/JavaScript in params.amount or params.asset to create phishing emails?",
  "[File: byteball/ocore/wallet.js] [Function: replaceInTextcoinTemplate()] [Unescaped replacement] Line 2410 uses basic regex replacement without HTML escaping - can special characters in mnemonic break email rendering?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendToPeerAllSharedAddressesHavingUnspentOutputs()] [SQL Injection] Can an attacker provide a malicious 'asset' parameter that is not properly escaped in the asset_filter construction at line 53, allowing SQL injection to read arbitrary shared address definitions or private keys from the database?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendToPeerAllSharedAddressesHavingUnspentOutputs()] [Authorization Bypass] Does this function verify that the requesting device_address is actually a legitimate cosigner of the shared addresses before sending their definitions, or can any peer request and receive shared address definitions for addresses they are not authorized to access?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendToPeerAllSharedAddressesHavingUnspentOutputs()] [Information Disclosure] Can an attacker repeatedly call this function to enumerate all shared addresses with unspent outputs by trying different device_address values, thereby learning which addresses hold funds and their balance distribution?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendToPeerAllSharedAddressesHavingUnspentOutputs()] [Race Condition] If outputs are being spent concurrently while this query executes at lines 54-56, can the function send stale shared address information that no longer has unspent outputs, potentially causing confusion or incorrect state at the receiving peer?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendSharedAddressToPeer()] [Authorization Bypass] Does this function validate that the device_address parameter is actually a member/cosigner of the shared_address before sending the definition and signing paths, or can any device request and receive sensitive multi-sig configuration data?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendSharedAddressToPeer()] [Validation Bypass] At line 85, the function checks for 'less than 2 signing paths', but what if exactly 1 signing path exists? Does this allow creation of a degenerate single-signer 'shared' address that bypasses multi-sig security requirements?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendSharedAddressToPeer()] [Data Integrity] If the definition retrieved at line 79 is malformed JSON or contains invalid address definition syntax, does the JSON.parse() throw an uncaught exception that crashes the node or leaves it in an inconsistent state?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendSharedAddressToPeer()] [Information Disclosure] Can an attacker who is not a member of a shared address but knows the shared_address value call this function through a compromised peer connection to exfiltrate the complete multi-sig configuration including all member addresses and device addresses?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Template Injection] Can an attacker craft a malicious arrAddressDefinitionTemplate that when processed by getMemberDeviceAddressesBySigningPaths() causes code execution, infinite loops, or memory exhaustion through deeply nested 'or', 'and', or 'r of set' structures?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Hash Collision] At line 114, the address_definition_template_chash is computed using objectHash.getChash160() - if two different templates produce the same chash160 due to collision, can an attacker replace a legitimate pending shared address with a malicious one by exploiting database primary key constraints?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Race Condition] Between inserting into pending_shared_addresses at line 116 and inserting into pending_shared_address_signing_paths at line 131, if another transaction deletes the pending address or the node crashes, can this leave orphaned signing path records that corrupt the approval workflow?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Authorization Bypass] At line 126, if device_address equals device.getMyDeviceAddress(), the address and approval are auto-filled - can an attacker spoof device.getMyDeviceAddress() through network message manipulation to auto-approve their own malicious address in the template?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Database Integrity] The function inserts into pending_shared_address_signing_paths in a serial loop (lines 119-143) but does not use a database transaction - if insertion fails midway, can this leave partial pending address state that breaks subsequent approval attempts?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Validation Bypass] Does validateAddressDefinitionTemplate() at line 107 check for excessively deep nesting or recursive 'definition template' references that could cause stack overflow when the template is later evaluated for actual address creation?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Race Condition - Double Approval] If two devices send approval for the same definition_template_chash simultaneously and both execute lines 151-154 before either reads the approval status at line 157, can both approvals trigger duplicate address creation, resulting in database integrity violations or inconsistent shared_address records?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Authorization Bypass] Does this function verify that the 'from_address' parameter actually corresponds to a device that was invited to join the shared address template, or can any arbitrary from_address submit approval and hijack the address definition with their own member address?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Parameter Injection] Can an attacker provide malicious assocDeviceAddressesByRelativeSigningPaths JSON that when stringified at line 154 and later parsed at line 188 causes prototype pollution, code execution, or crashes due to circular references or deeply nested objects?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Timing Attack] At lines 163-166, if the query at line 157 returns rows but another device issues rejection simultaneously, can the early return at line 164 leave the approving device in a state where they believe the address was created but it was actually deleted?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Database Atomicity] The function performs multiple database operations (UPDATE at line 152, SELECT at line 157, SELECT at line 172, INSERT at line 181, multiple INSERTs at lines 197-200, DELETE at line 209) without an explicit transaction - can a crash or error between these steps leave the database in an inconsistent state with partial approvals or orphaned records?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Definition Substitution] At line 179, Definition.replaceInTemplate() replaces template variables with actual addresses from params - can an attacker manipulate the 'address' field in their approval to inject a malicious address that doesn't match their actual device, thereby gaining unauthorized control over the resulting shared address?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Path Traversal] At line 192, the full_signing_path is constructed by concatenating row.signing_path + member_signing_path.substring(1) - can an attacker craft a malicious member_signing_path with '../' or special characters that causes path traversal, buffer overflow, or incorrect signing path resolution?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Device Address Confusion] At lines 193-196, the comment notes that row.device_address (not signing_device_address) is stored because signing_device_address might not be a correspondent - can this cause signature requests to be routed to offline or malicious intermediary devices that censor or modify signing requests?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Notification Failure] If sendNewSharedAddress() at line 213 fails to send to some devices due to network issues, do those devices miss the shared address creation entirely, leading to permanent desynchronization where they cannot participate in spending from the address?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Light Client Vulnerability] At lines 216-217, if conf.bLight is true, network.addLightWatchedAddress() is called - can a malicious hub manipulate the light client's watched address list to cause it to miss transactions from the shared address, allowing double-spends or fund theft?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: deletePendingSharedAddress()] [Race Condition] The function deletes from pending_shared_address_signing_paths at line 231 before deleting from pending_shared_addresses at line 232 - if another process is reading this data concurrently or inserting new signing paths, can this cause foreign key violations or orphaned records?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: deletePendingSharedAddress()] [Authorization Bypass] This function has no authorization checks - can any code path call it to delete pending shared addresses that other users are still approving, causing denial of service or forcing them to restart the entire approval process?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [SQL Injection] The function uses db.getIgnore() at lines 242 and 249 which may generate database-specific IGNORE/INSERT OR IGNORE syntax - are there SQL injection vulnerabilities in how the 'address' or 'definition' parameters are incorporated into these dynamically constructed queries?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Race Condition - Duplicate Address] If two peers call addNewSharedAddress() for the same address simultaneously, both using db.getIgnore() to suppress duplicate key errors, can this cause one peer to have incomplete signing path information because their INSERT at line 249 was ignored while the other peer's succeeded?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Definition Mismatch] The function accepts both 'address' and 'arrDefinition' parameters but does not verify that address === objectHash.getChash160(arrDefinition) - can an attacker provide mismatched values to create a shared address record where the stored definition does not match the address chash, breaking signature verification?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Event Bus Vulnerability] At lines 255-256, events 'new_address-'+address and 'new_address' are emitted - can an attacker who controls event listeners exploit these events to trigger reentrancy, cause state corruption, or execute malicious code in response to shared address creation?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Light Client Desync] At lines 258-260, light clients insert the new address into unprocessed_addresses but full nodes do not - can this difference in behavior cause light and full nodes to have different views of which addresses should be watched, leading to missed transactions or inability to spend?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Forwarding Loop] At lines 262-263, if bForwarded is false, the function calls forwardNewSharedAddressToCosignersOfMyMemberAddresses() which may send the address to other devices - can this create an infinite forwarding loop where devices keep re-forwarding the same address to each other if the 'bForwarded' flag is not properly propagated?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Signing Path Validation] The function does not validate that signing paths in assocSignersByPath are well-formed, unique, or consistent with the definition structure - can malformed signing paths cause signature verification failures, inability to sign transactions, or incorrect determination of required signatures?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: includesMyDeviceAddress()] [Logic Bypass] This function iterates through all signing paths at lines 271-276 and returns true if any match device.getMyDeviceAddress() - if device.getMyDeviceAddress() returns different values during the iteration (e.g., due to concurrent device address change), can this cause inconsistent authorization decisions?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: includesMyDeviceAddress()] [Null/Undefined Handling] If assocSignersByPath contains entries where signerInfo.device_address is null, undefined, or empty string, does the comparison at line 273 handle these edge cases correctly, or can they cause false positives/negatives in device membership detection?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [Authorization Bypass - Address Rewriting] At lines 305-310, if bHasMyDeviceAddress is false but some member addresses are mine, the function rewrites signerInfo.device_address to device.getMyDeviceAddress() - can an attacker exploit this rewriting logic by registering their device as controller of a legitimate user's address, causing signatures to be routed to the attacker's device?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [SQL Injection] At lines 294-298, the query uses IN(?) with arrMemberAddresses twice - if arrMemberAddresses is empty or contains maliciously crafted address strings, can this cause SQL syntax errors, injection attacks, or incorrect query results?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [Shared Address Recursion] At line 297, the query checks both my_addresses and shared_addresses tables - if a shared address is itself a member of another shared address, can this create circular dependencies or infinite recursion when trying to determine membership, causing stack overflow or denial of service?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [Race Condition - Address Ownership] Between the membership query at lines 294-298 and the device address rewriting at lines 305-310, if ownership of a member address changes (e.g., via definition_chg), can the rewriting logic incorrectly route signatures to a device that no longer controls the address?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [Type Confusion] At line 303, the function filters rows by row.type === 'my' - if the database returns unexpected types or if an attacker can inject records with manipulated 'type' values, can this cause incorrect address classification and unauthorized device rewriting?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [Empty Address Array] At line 292, if arrMemberAddresses.length === 0, the function returns error 'no member addresses?' - but what if assocSignersByPath contains signers without addresses? Can this scenario occur in legitimate cases (e.g., merkle paths) and cause valid shared addresses to be rejected?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardNewSharedAddressToCosignersOfMyMemberAddresses()] [Authorization Bypass] At lines 327-329, the function queries for device_address WHERE address IN(?) AND device_address!=? but does not verify that the queried device_address values are actually authorized cosigners - can this forward sensitive shared address information to unauthorized devices that happen to be stored in wallet_signing_paths?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardNewSharedAddressToCosignersOfMyMemberAddresses()] [Exception Handling] At line 326, if arrMyMemberAddresses.length === 0, the function throws an Error - is this error caught by calling code, or can it crash the node? Additionally, is it possible for legitimate execution to reach this state (e.g., if the shared address only includes others' addresses as members)?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardNewSharedAddressToCosignersOfMyMemberAddresses()] [Forwarding Loop Prevention] At line 332, the function calls sendNewSharedAddress() with bForwarded=true - but does the receiving device respect this flag and avoid re-forwarding, or can this create a forwarding storm where every cosigner's cosigners keep forwarding the same address indefinitely?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardNewSharedAddressToCosignersOfMyMemberAddresses()] [Information Disclosure] The function forwards the complete arrDefinition and assocSignersByPath to all cosigners at line 332 - can this leak sensitive information about other members' device addresses or signing paths to parties who should only know their own segment of the multi-sig configuration?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Validation Bypass] At line 340, the function checks ValidationUtils.isArrayOfLength(body.definition, 2) - but address definitions can have complex nested structures beyond simple 2-element arrays (e.g., ['or', [['sig', ...], ['and', ...]]] ) - does this validation correctly handle all valid definition formats, or can it reject legitimate shared addresses?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Hash Verification Bypass] At lines 344-345, the function verifies body.address === objectHash.getChash160(body.definition) - but does objectHash.getChash160() deterministically handle all possible definition structures, or can an attacker find colliding inputs that pass this check but produce different addresses when evaluated by other nodes?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Address Injection] At lines 346-350, the function validates signerInfo.address for each signing path, allowing 'secret' as a special value - can an attacker exploit the 'secret' handling or ValidationUtils.isValidAddress() to inject malformed addresses that bypass validation but cause errors during signature verification?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Definition Validation Ordering] At line 354, validateAddressDefinition() is called after determineIfIncludesMeAndRewriteDeviceAddress() at line 351 - can an attacker craft a definition that passes initial checks but fails Definition.validateDefinition(), leaving the device with corrupted assocSignersByPath after device addresses have been rewritten but before validation completes?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Callback Handling] The function uses callbacks.ifError and callbacks.ifOk at multiple points (lines 341, 343, 345, 353, 356, 357) - if the caller provides malicious callback functions, can they exploit the context in which these callbacks are invoked to cause reentrancy, state corruption, or denial of service?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Empty Signers Object] At line 342, the function checks Object.keys(body.signers).length === 0 to reject empty signers - but what if body.signers is not an object at all (e.g., null, array, primitive)? Can this cause typeof check at line 342 to pass but Object.keys() to throw, crashing the handler?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddress()] [Authorization Check] At line 363, the function checks includesMyDeviceAddress(assocSignersByPath) but this only verifies that the device is mentioned somewhere - does it verify that the user actually controls the corresponding signing keys, or can an attacker include my device address without permission to make me unwittingly participate in a malicious multi-sig?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddress()] [Address Reuse] At line 365, the address is computed as objectHash.getChash160(arrDefinition) - if the same definition is used twice to create shared addresses (intentionally or due to race conditions), does this cause database primary key violations, overwrite existing addresses, or create ambiguity about which signing paths are authoritative?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddress()] [Broadcast Failure] At lines 370-378, the function sends the new address to all other device addresses - if some sends fail due to network errors or offline peers, do those peers permanently lose awareness of the shared address, making it impossible to gather enough signatures for spending?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddress()] [Device Address Filtering] At lines 373-374, the function checks signerInfo.device_address !== device.getMyDeviceAddress() to avoid sending to self - but if device.getMyDeviceAddress() changes during iteration or if signerInfo.device_address is spoofed, can this cause missed notifications or duplicate sends?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Infinite Recursion] The evaluate() inner function at lines 385-420 recursively processes 'or', 'and', 'r of set', and 'weighted and' operations - can an attacker craft a deeply nested or cyclically referencing definition template that causes stack overflow, memory exhaustion, or denial of service?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Array Bounds] At lines 393-407, the function iterates over args arrays using for loops with args.length and args.set.length - if these arrays are maliciously large (e.g., millions of elements), can this cause excessive CPU/memory usage or timeouts that freeze the node?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Path Injection] At lines 394, 400, and 406, the path is constructed by string concatenation path + '.' + i - can an attacker inject special characters or control sequences in the path that later cause path traversal, injection attacks, or incorrect signing path resolution?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Type Confusion] At line 408, the function checks for op === 'address' but doesn't validate that args is actually a string before calling args.substr() at lines 411-413 - can an attacker provide a non-string args value that causes TypeError, crashes, or bypasses the device address extraction logic?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Unsupported Operation] At line 417, the function throws an Error for 'definition template' operations - but the throw is inside the evaluate function which is not guaranteed to propagate the error correctly - can this cause silent failures where definition templates are silently skipped instead of causing proper validation errors?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Missing Validation] The function does not validate that args.set exists before accessing args.set.length at lines 397 and 403 - if an attacker provides malformed 'r of set' or 'weighted and' definitions without a 'set' property, can this cause undefined access, TypeError, or incorrect path extraction?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [Fake Address Injection] At lines 439-441, a fake_address is constructed by taking device.getMyDeviceAddress().substr(1) and used to fill template variables - if device addresses can start with characters that are invalid in addresses, can this fake_address bypass validation checks that should catch malformed definitions?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [Device Count Bypass] At lines 428-430, the function requires arrDeviceAddresses.length < 2 to reject templates with too few members - but what if the same device address appears multiple times in different paths? Does this count as multiple devices or is there a uniqueness check that prevents single-device 'multi-sig' addresses?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [Authorization Bypass] At lines 431-434, the function checks that both device.getMyDeviceAddress() and from_address are in the definition - but does it verify that from_address is actually the sender of the current network message, or can an attacker spoof from_address to make it appear they were invited to a template they weren't?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [Template Replacement Vulnerability] At line 444, Definition.replaceInTemplate() is wrapped in try-catch to handle exceptions - but what specific exceptions can occur? If replaceInTemplate throws due to prototype pollution, can an attacker use this to corrupt the global prototype chain and affect other address validations?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [Validation Context Mismatch] At lines 449-451, the fake validation uses objFakeUnit with a simple sig definition and objFakeValidationState with last_ball_mci set to MAX_INT32 - does this artificial context properly test all validation rules that would apply to real addresses, or can malicious definitions pass validation here but fail in production?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [MAX_INT32 Manipulation] At line 450, last_ball_mci is set to MAX_INT32 (2^31 - 1) defined at line 20 - if the protocol ever reaches this MCI value in production, can this cause integer overflow, incorrect validation comparisons, or bypass of MCI-dependent rules in Definition.validateDefinition()?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinition()] [Unresolved Inner Definitions] At line 462, objFakeValidationState.bAllowUnresolvedInnerDefinitions is set to true - does this allow attackers to create shared addresses with inner definitions that reference non-existent or malicious addresses, which only fail validation when actually used for signing, effectively locking funds?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinition()] [Empty Authors Array] At line 461, objFakeUnit.authors is set to an empty array [] - does Definition.validateDefinition() properly handle validation when there are no authors, or can this cause it to skip critical author-dependent validation checks that would catch malicious definitions?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinition()] [Validation Bypass] The function only checks for err at line 464 but does not inspect what specific validation rules were applied - can an attacker craft a definition that passes validation here due to the fake context but fails in real usage, creating addresses where funds can be sent but never spent?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardPrivateChainsToOtherMembersOfAddresses()] [Authorization Bypass] At lines 473-476, the function queries shared_address_signing_paths and forwards private chains to all device_addresses except self - but does it verify that these devices are still active correspondents with valid pairing? Can this forward private payment data to abandoned/compromised devices?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardPrivateChainsToOtherMembersOfAddresses()] [Privacy Leak] The function forwards arrChains to all members of the shared addresses at line 480 - if a member is later removed or the shared address definition changes, do previously forwarded private chains remain accessible to former members who should no longer have access?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardPrivateChainsToOtherMembersOfAddresses()] [SQL Injection] At line 474, the query uses IN(?) with arrAddresses array - if arrAddresses contains maliciously crafted address values or special characters, can this cause SQL injection or return incorrect device addresses that should not receive private chain data?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardPrivateChainsToOtherMembersOfAddresses()] [Connection Parameter] The function accepts optional 'conn' parameter at line 472 and uses conn || db - if a caller provides a malicious conn object that implements a database-like interface, can this cause private chains to be forwarded to attacker-controlled destinations or logged for later exfiltration?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readAllControlAddresses()] [Infinite Recursion] At line 496, the function recursively calls itself with arrControlAddresses - if the shared address dependency graph has cycles (e.g., address A controls B, B controls C, C controls A), can this cause infinite recursion, stack overflow, or denial of service?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readAllControlAddresses()] [SQL Injection] At lines 487-490, the query uses IN(?) twice with arrAddresses - if arrAddresses is manipulated or contains SQL metacharacters, can this cause injection attacks or incorrect results that leak information about unrelated control addresses?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readAllControlAddresses()] [Empty Address Array] At lines 492-493, if rows.length === 0, the function returns empty arrays [] [] - but if arrAddresses was non-empty initially, does this indicate an error condition (no control addresses found) or a legitimate state? Can callers distinguish between these cases?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readAllControlAddresses()] [Correspondent Filter] At line 489, the query filters for have_correspondent IS NOT NULL at line 488 - can this cause the function to miss control device addresses that are actually valid signers but not currently in the correspondent_devices table, potentially preventing signature collection?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readAllControlAddresses()] [Union Correctness] At line 497, the function uses _.union() to merge address/device arrays - if the same address or device appears at different levels of the recursion, can duplicate entries in the result cause incorrect signature counting or redundant signing requests?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressDefinition()] [Exception on Missing Address] At line 524, if rows.length !== 1, the function throws Error - is this error caught by callers, or can a request for a non-existent shared address crash the node or leave it in an inconsistent state?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressDefinition()] [JSON Parsing Vulnerability] At line 525, JSON.parse(rows[0].definition) is called without validation - if the stored definition is malformed JSON, contains circular references, or excessively deep nesting, can this cause parse errors, memory exhaustion, or denial of service?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressDefinition()] [Timestamp Manipulation] At line 520, the query retrieves creation_ts using db.getUnixTimestamp() - if the system clock is manipulated or the database contains incorrect timestamps, can this cause time-based validation logic to fail or allow unauthorized operations?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressCosigners()] [Exception on Missing Cosigners] At line 542, if rows.length === 0, the function throws Error - is it possible for a valid shared address to legitimately have no other cosigners (e.g., if it only includes the current device)? Can this error handling cause crashes for single-device addresses or merkle-based definitions?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressCosigners()] [Information Disclosure] At lines 534-538, the query joins correspondent_devices to get cosigner names - if correspondent_devices.name contains sensitive information or if an attacker can manipulate this table, can this leak information or display misleading cosigner identities to users?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressCosigners()] [Missing Correspondent Handling] The LEFT JOIN at line 537 allows rows with NULL names - if a cosigner device is not in correspondent_devices, what name is returned? Can this cause UI display issues or make it impossible to identify which devices need to sign?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressPeers()] [Authorization Bypass] At lines 557-561, the function queries for addresses WHERE device_address != getMyDeviceAddress() and LEFT JOINs correspondent_devices - but it doesn't verify that these addresses are actually part of the shared address definition - can this return arbitrary addresses that happen to be in shared_address_signing_paths?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressPeers()] [Name Spoofing] At lines 565-568, the function maps addresses to names from correspondent_devices, using 'unknown peer' as fallback - if an attacker can manipulate correspondent_devices.name, can they impersonate legitimate cosigners by using the same name, causing users to send signatures or funds to the wrong party?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressPeers()] [Empty Peers Allowed] The comment at lines 562-564 notes",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getPeerAddressesFromSigners()] [Device Address Spoofing] At lines 574-583, the function extracts addresses where device_address !== getMyDeviceAddress() - if an attacker can temporarily modify what getMyDeviceAddress() returns (e.g., through race conditions or message injection), can this cause the function to misclassify which addresses are peers vs. self-controlled?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendToPeerAllSharedAddressesHavingUnspentOutputs()] [SQL Injection] Can an attacker provide a malicious 'asset' parameter that is not properly escaped in the asset_filter construction at line 53, allowing SQL injection to read arbitrary shared address definitions or private keys from the database?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendToPeerAllSharedAddressesHavingUnspentOutputs()] [Authorization Bypass] Does this function verify that the requesting device_address is actually a legitimate cosigner of the shared addresses before sending their definitions, or can any peer request and receive shared address definitions for addresses they are not authorized to access?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendToPeerAllSharedAddressesHavingUnspentOutputs()] [Information Disclosure] Can an attacker repeatedly call this function to enumerate all shared addresses with unspent outputs by trying different device_address values, thereby learning which addresses hold funds and their balance distribution?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendToPeerAllSharedAddressesHavingUnspentOutputs()] [Race Condition] If outputs are being spent concurrently while this query executes at lines 54-56, can the function send stale shared address information that no longer has unspent outputs, potentially causing confusion or incorrect state at the receiving peer?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendSharedAddressToPeer()] [Authorization Bypass] Does this function validate that the device_address parameter is actually a member/cosigner of the shared_address before sending the definition and signing paths, or can any device request and receive sensitive multi-sig configuration data?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendSharedAddressToPeer()] [Validation Bypass] At line 85, the function checks for 'less than 2 signing paths', but what if exactly 1 signing path exists? Does this allow creation of a degenerate single-signer 'shared' address that bypasses multi-sig security requirements?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendSharedAddressToPeer()] [Data Integrity] If the definition retrieved at line 79 is malformed JSON or contains invalid address definition syntax, does the JSON.parse() throw an uncaught exception that crashes the node or leaves it in an inconsistent state?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: sendSharedAddressToPeer()] [Information Disclosure] Can an attacker who is not a member of a shared address but knows the shared_address value call this function through a compromised peer connection to exfiltrate the complete multi-sig configuration including all member addresses and device addresses?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Template Injection] Can an attacker craft a malicious arrAddressDefinitionTemplate that when processed by getMemberDeviceAddressesBySigningPaths() causes code execution, infinite loops, or memory exhaustion through deeply nested 'or', 'and', or 'r of set' structures?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Hash Collision] At line 114, the address_definition_template_chash is computed using objectHash.getChash160() - if two different templates produce the same chash160 due to collision, can an attacker replace a legitimate pending shared address with a malicious one by exploiting database primary key constraints?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Race Condition] Between inserting into pending_shared_addresses at line 116 and inserting into pending_shared_address_signing_paths at line 131, if another transaction deletes the pending address or the node crashes, can this leave orphaned signing path records that corrupt the approval workflow?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Authorization Bypass] At line 126, if device_address equals device.getMyDeviceAddress(), the address and approval are auto-filled - can an attacker spoof device.getMyDeviceAddress() through network message manipulation to auto-approve their own malicious address in the template?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Database Integrity] The function inserts into pending_shared_address_signing_paths in a serial loop (lines 119-143) but does not use a database transaction - if insertion fails midway, can this leave partial pending address state that breaks subsequent approval attempts?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddressByTemplate()] [Validation Bypass] Does validateAddressDefinitionTemplate() at line 107 check for excessively deep nesting or recursive 'definition template' references that could cause stack overflow when the template is later evaluated for actual address creation?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Race Condition - Double Approval] If two devices send approval for the same definition_template_chash simultaneously and both execute lines 151-154 before either reads the approval status at line 157, can both approvals trigger duplicate address creation, resulting in database integrity violations or inconsistent shared_address records?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Authorization Bypass] Does this function verify that the 'from_address' parameter actually corresponds to a device that was invited to join the shared address template, or can any arbitrary from_address submit approval and hijack the address definition with their own member address?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Parameter Injection] Can an attacker provide malicious assocDeviceAddressesByRelativeSigningPaths JSON that when stringified at line 154 and later parsed at line 188 causes prototype pollution, code execution, or crashes due to circular references or deeply nested objects?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Timing Attack] At lines 163-166, if the query at line 157 returns rows but another device issues rejection simultaneously, can the early return at line 164 leave the approving device in a state where they believe the address was created but it was actually deleted?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Database Atomicity] The function performs multiple database operations (UPDATE at line 152, SELECT at line 157, SELECT at line 172, INSERT at line 181, multiple INSERTs at lines 197-200, DELETE at line 209) without an explicit transaction - can a crash or error between these steps leave the database in an inconsistent state with partial approvals or orphaned records?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Definition Substitution] At line 179, Definition.replaceInTemplate() replaces template variables with actual addresses from params - can an attacker manipulate the 'address' field in their approval to inject a malicious address that doesn't match their actual device, thereby gaining unauthorized control over the resulting shared address?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Path Traversal] At line 192, the full_signing_path is constructed by concatenating row.signing_path + member_signing_path.substring(1) - can an attacker craft a malicious member_signing_path with '../' or special characters that causes path traversal, buffer overflow, or incorrect signing path resolution?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Device Address Confusion] At lines 193-196, the comment notes that row.device_address (not signing_device_address) is stored because signing_device_address might not be a correspondent - can this cause signature requests to be routed to offline or malicious intermediary devices that censor or modify signing requests?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Notification Failure] If sendNewSharedAddress() at line 213 fails to send to some devices due to network issues, do those devices miss the shared address creation entirely, leading to permanent desynchronization where they cannot participate in spending from the address?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: approvePendingSharedAddress()] [Light Client Vulnerability] At lines 216-217, if conf.bLight is true, network.addLightWatchedAddress() is called - can a malicious hub manipulate the light client's watched address list to cause it to miss transactions from the shared address, allowing double-spends or fund theft?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: deletePendingSharedAddress()] [Race Condition] The function deletes from pending_shared_address_signing_paths at line 231 before deleting from pending_shared_addresses at line 232 - if another process is reading this data concurrently or inserting new signing paths, can this cause foreign key violations or orphaned records?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: deletePendingSharedAddress()] [Authorization Bypass] This function has no authorization checks - can any code path call it to delete pending shared addresses that other users are still approving, causing denial of service or forcing them to restart the entire approval process?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [SQL Injection] The function uses db.getIgnore() at lines 242 and 249 which may generate database-specific IGNORE/INSERT OR IGNORE syntax - are there SQL injection vulnerabilities in how the 'address' or 'definition' parameters are incorporated into these dynamically constructed queries?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Race Condition - Duplicate Address] If two peers call addNewSharedAddress() for the same address simultaneously, both using db.getIgnore() to suppress duplicate key errors, can this cause one peer to have incomplete signing path information because their INSERT at line 249 was ignored while the other peer's succeeded?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Definition Mismatch] The function accepts both 'address' and 'arrDefinition' parameters but does not verify that address === objectHash.getChash160(arrDefinition) - can an attacker provide mismatched values to create a shared address record where the stored definition does not match the address chash, breaking signature verification?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Event Bus Vulnerability] At lines 255-256, events 'new_address-'+address and 'new_address' are emitted - can an attacker who controls event listeners exploit these events to trigger reentrancy, cause state corruption, or execute malicious code in response to shared address creation?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Light Client Desync] At lines 258-260, light clients insert the new address into unprocessed_addresses but full nodes do not - can this difference in behavior cause light and full nodes to have different views of which addresses should be watched, leading to missed transactions or inability to spend?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Forwarding Loop] At lines 262-263, if bForwarded is false, the function calls forwardNewSharedAddressToCosignersOfMyMemberAddresses() which may send the address to other devices - can this create an infinite forwarding loop where devices keep re-forwarding the same address to each other if the 'bForwarded' flag is not properly propagated?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: addNewSharedAddress()] [Signing Path Validation] The function does not validate that signing paths in assocSignersByPath are well-formed, unique, or consistent with the definition structure - can malformed signing paths cause signature verification failures, inability to sign transactions, or incorrect determination of required signatures?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: includesMyDeviceAddress()] [Logic Bypass] This function iterates through all signing paths at lines 271-276 and returns true if any match device.getMyDeviceAddress() - if device.getMyDeviceAddress() returns different values during the iteration (e.g., due to concurrent device address change), can this cause inconsistent authorization decisions?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: includesMyDeviceAddress()] [Null/Undefined Handling] If assocSignersByPath contains entries where signerInfo.device_address is null, undefined, or empty string, does the comparison at line 273 handle these edge cases correctly, or can they cause false positives/negatives in device membership detection?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [Authorization Bypass - Address Rewriting] At lines 305-310, if bHasMyDeviceAddress is false but some member addresses are mine, the function rewrites signerInfo.device_address to device.getMyDeviceAddress() - can an attacker exploit this rewriting logic by registering their device as controller of a legitimate user's address, causing signatures to be routed to the attacker's device?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [SQL Injection] At lines 294-298, the query uses IN(?) with arrMemberAddresses twice - if arrMemberAddresses is empty or contains maliciously crafted address strings, can this cause SQL syntax errors, injection attacks, or incorrect query results?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [Shared Address Recursion] At line 297, the query checks both my_addresses and shared_addresses tables - if a shared address is itself a member of another shared address, can this create circular dependencies or infinite recursion when trying to determine membership, causing stack overflow or denial of service?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [Race Condition - Address Ownership] Between the membership query at lines 294-298 and the device address rewriting at lines 305-310, if ownership of a member address changes (e.g., via definition_chg), can the rewriting logic incorrectly route signatures to a device that no longer controls the address?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [Type Confusion] At line 303, the function filters rows by row.type === 'my' - if the database returns unexpected types or if an attacker can inject records with manipulated 'type' values, can this cause incorrect address classification and unauthorized device rewriting?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: determineIfIncludesMeAndRewriteDeviceAddress()] [Empty Address Array] At line 292, if arrMemberAddresses.length === 0, the function returns error 'no member addresses?' - but what if assocSignersByPath contains signers without addresses? Can this scenario occur in legitimate cases (e.g., merkle paths) and cause valid shared addresses to be rejected?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardNewSharedAddressToCosignersOfMyMemberAddresses()] [Authorization Bypass] At lines 327-329, the function queries for device_address WHERE address IN(?) AND device_address!=? but does not verify that the queried device_address values are actually authorized cosigners - can this forward sensitive shared address information to unauthorized devices that happen to be stored in wallet_signing_paths?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardNewSharedAddressToCosignersOfMyMemberAddresses()] [Exception Handling] At line 326, if arrMyMemberAddresses.length === 0, the function throws an Error - is this error caught by calling code, or can it crash the node? Additionally, is it possible for legitimate execution to reach this state (e.g., if the shared address only includes others' addresses as members)?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardNewSharedAddressToCosignersOfMyMemberAddresses()] [Forwarding Loop Prevention] At line 332, the function calls sendNewSharedAddress() with bForwarded=true - but does the receiving device respect this flag and avoid re-forwarding, or can this create a forwarding storm where every cosigner's cosigners keep forwarding the same address indefinitely?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardNewSharedAddressToCosignersOfMyMemberAddresses()] [Information Disclosure] The function forwards the complete arrDefinition and assocSignersByPath to all cosigners at line 332 - can this leak sensitive information about other members' device addresses or signing paths to parties who should only know their own segment of the multi-sig configuration?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Validation Bypass] At line 340, the function checks ValidationUtils.isArrayOfLength(body.definition, 2) - but address definitions can have complex nested structures beyond simple 2-element arrays (e.g., ['or', [['sig', ...], ['and', ...]]] ) - does this validation correctly handle all valid definition formats, or can it reject legitimate shared addresses?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Hash Verification Bypass] At lines 344-345, the function verifies body.address === objectHash.getChash160(body.definition) - but does objectHash.getChash160() deterministically handle all possible definition structures, or can an attacker find colliding inputs that pass this check but produce different addresses when evaluated by other nodes?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Address Injection] At lines 346-350, the function validates signerInfo.address for each signing path, allowing 'secret' as a special value - can an attacker exploit the 'secret' handling or ValidationUtils.isValidAddress() to inject malformed addresses that bypass validation but cause errors during signature verification?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Definition Validation Ordering] At line 354, validateAddressDefinition() is called after determineIfIncludesMeAndRewriteDeviceAddress() at line 351 - can an attacker craft a definition that passes initial checks but fails Definition.validateDefinition(), leaving the device with corrupted assocSignersByPath after device addresses have been rewritten but before validation completes?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Callback Handling] The function uses callbacks.ifError and callbacks.ifOk at multiple points (lines 341, 343, 345, 353, 356, 357) - if the caller provides malicious callback functions, can they exploit the context in which these callbacks are invoked to cause reentrancy, state corruption, or denial of service?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: handleNewSharedAddress()] [Empty Signers Object] At line 342, the function checks Object.keys(body.signers).length === 0 to reject empty signers - but what if body.signers is not an object at all (e.g., null, array, primitive)? Can this cause typeof check at line 342 to pass but Object.keys() to throw, crashing the handler?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddress()] [Authorization Check] At line 363, the function checks includesMyDeviceAddress(assocSignersByPath) but this only verifies that the device is mentioned somewhere - does it verify that the user actually controls the corresponding signing keys, or can an attacker include my device address without permission to make me unwittingly participate in a malicious multi-sig?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddress()] [Address Reuse] At line 365, the address is computed as objectHash.getChash160(arrDefinition) - if the same definition is used twice to create shared addresses (intentionally or due to race conditions), does this cause database primary key violations, overwrite existing addresses, or create ambiguity about which signing paths are authoritative?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddress()] [Broadcast Failure] At lines 370-378, the function sends the new address to all other device addresses - if some sends fail due to network errors or offline peers, do those peers permanently lose awareness of the shared address, making it impossible to gather enough signatures for spending?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: createNewSharedAddress()] [Device Address Filtering] At lines 373-374, the function checks signerInfo.device_address !== device.getMyDeviceAddress() to avoid sending to self - but if device.getMyDeviceAddress() changes during iteration or if signerInfo.device_address is spoofed, can this cause missed notifications or duplicate sends?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Infinite Recursion] The evaluate() inner function at lines 385-420 recursively processes 'or', 'and', 'r of set', and 'weighted and' operations - can an attacker craft a deeply nested or cyclically referencing definition template that causes stack overflow, memory exhaustion, or denial of service?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Array Bounds] At lines 393-407, the function iterates over args arrays using for loops with args.length and args.set.length - if these arrays are maliciously large (e.g., millions of elements), can this cause excessive CPU/memory usage or timeouts that freeze the node?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Path Injection] At lines 394, 400, and 406, the path is constructed by string concatenation path + '.' + i - can an attacker inject special characters or control sequences in the path that later cause path traversal, injection attacks, or incorrect signing path resolution?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Type Confusion] At line 408, the function checks for op === 'address' but doesn't validate that args is actually a string before calling args.substr() at lines 411-413 - can an attacker provide a non-string args value that causes TypeError, crashes, or bypasses the device address extraction logic?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Unsupported Operation] At line 417, the function throws an Error for 'definition template' operations - but the throw is inside the evaluate function which is not guaranteed to propagate the error correctly - can this cause silent failures where definition templates are silently skipped instead of causing proper validation errors?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getMemberDeviceAddressesBySigningPaths()] [Missing Validation] The function does not validate that args.set exists before accessing args.set.length at lines 397 and 403 - if an attacker provides malformed 'r of set' or 'weighted and' definitions without a 'set' property, can this cause undefined access, TypeError, or incorrect path extraction?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [Fake Address Injection] At lines 439-441, a fake_address is constructed by taking device.getMyDeviceAddress().substr(1) and used to fill template variables - if device addresses can start with characters that are invalid in addresses, can this fake_address bypass validation checks that should catch malformed definitions?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [Device Count Bypass] At lines 428-430, the function requires arrDeviceAddresses.length < 2 to reject templates with too few members - but what if the same device address appears multiple times in different paths? Does this count as multiple devices or is there a uniqueness check that prevents single-device 'multi-sig' addresses?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [Authorization Bypass] At lines 431-434, the function checks that both device.getMyDeviceAddress() and from_address are in the definition - but does it verify that from_address is actually the sender of the current network message, or can an attacker spoof from_address to make it appear they were invited to a template they weren't?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [Template Replacement Vulnerability] At line 444, Definition.replaceInTemplate() is wrapped in try-catch to handle exceptions - but what specific exceptions can occur? If replaceInTemplate throws due to prototype pollution, can an attacker use this to corrupt the global prototype chain and affect other address validations?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [Validation Context Mismatch] At lines 449-451, the fake validation uses objFakeUnit with a simple sig definition and objFakeValidationState with last_ball_mci set to MAX_INT32 - does this artificial context properly test all validation rules that would apply to real addresses, or can malicious definitions pass validation here but fail in production?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinitionTemplate()] [MAX_INT32 Manipulation] At line 450, last_ball_mci is set to MAX_INT32 (2^31 - 1) defined at line 20 - if the protocol ever reaches this MCI value in production, can this cause integer overflow, incorrect validation comparisons, or bypass of MCI-dependent rules in Definition.validateDefinition()?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinition()] [Unresolved Inner Definitions] At line 462, objFakeValidationState.bAllowUnresolvedInnerDefinitions is set to true - does this allow attackers to create shared addresses with inner definitions that reference non-existent or malicious addresses, which only fail validation when actually used for signing, effectively locking funds?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinition()] [Empty Authors Array] At line 461, objFakeUnit.authors is set to an empty array [] - does Definition.validateDefinition() properly handle validation when there are no authors, or can this cause it to skip critical author-dependent validation checks that would catch malicious definitions?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: validateAddressDefinition()] [Validation Bypass] The function only checks for err at line 464 but does not inspect what specific validation rules were applied - can an attacker craft a definition that passes validation here due to the fake context but fails in real usage, creating addresses where funds can be sent but never spent?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardPrivateChainsToOtherMembersOfAddresses()] [Authorization Bypass] At lines 473-476, the function queries shared_address_signing_paths and forwards private chains to all device_addresses except self - but does it verify that these devices are still active correspondents with valid pairing? Can this forward private payment data to abandoned/compromised devices?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardPrivateChainsToOtherMembersOfAddresses()] [Privacy Leak] The function forwards arrChains to all members of the shared addresses at line 480 - if a member is later removed or the shared address definition changes, do previously forwarded private chains remain accessible to former members who should no longer have access?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardPrivateChainsToOtherMembersOfAddresses()] [SQL Injection] At line 474, the query uses IN(?) with arrAddresses array - if arrAddresses contains maliciously crafted address values or special characters, can this cause SQL injection or return incorrect device addresses that should not receive private chain data?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: forwardPrivateChainsToOtherMembersOfAddresses()] [Connection Parameter] The function accepts optional 'conn' parameter at line 472 and uses conn || db - if a caller provides a malicious conn object that implements a database-like interface, can this cause private chains to be forwarded to attacker-controlled destinations or logged for later exfiltration?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readAllControlAddresses()] [Infinite Recursion] At line 496, the function recursively calls itself with arrControlAddresses - if the shared address dependency graph has cycles (e.g., address A controls B, B controls C, C controls A), can this cause infinite recursion, stack overflow, or denial of service?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readAllControlAddresses()] [SQL Injection] At lines 487-490, the query uses IN(?) twice with arrAddresses - if arrAddresses is manipulated or contains SQL metacharacters, can this cause injection attacks or incorrect results that leak information about unrelated control addresses?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readAllControlAddresses()] [Empty Address Array] At lines 492-493, if rows.length === 0, the function returns empty arrays [] [] - but if arrAddresses was non-empty initially, does this indicate an error condition (no control addresses found) or a legitimate state? Can callers distinguish between these cases?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readAllControlAddresses()] [Correspondent Filter] At line 489, the query filters for have_correspondent IS NOT NULL at line 488 - can this cause the function to miss control device addresses that are actually valid signers but not currently in the correspondent_devices table, potentially preventing signature collection?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readAllControlAddresses()] [Union Correctness] At line 497, the function uses _.union() to merge address/device arrays - if the same address or device appears at different levels of the recursion, can duplicate entries in the result cause incorrect signature counting or redundant signing requests?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressDefinition()] [Exception on Missing Address] At line 524, if rows.length !== 1, the function throws Error - is this error caught by callers, or can a request for a non-existent shared address crash the node or leave it in an inconsistent state?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressDefinition()] [JSON Parsing Vulnerability] At line 525, JSON.parse(rows[0].definition) is called without validation - if the stored definition is malformed JSON, contains circular references, or excessively deep nesting, can this cause parse errors, memory exhaustion, or denial of service?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressDefinition()] [Timestamp Manipulation] At line 520, the query retrieves creation_ts using db.getUnixTimestamp() - if the system clock is manipulated or the database contains incorrect timestamps, can this cause time-based validation logic to fail or allow unauthorized operations?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressCosigners()] [Exception on Missing Cosigners] At line 542, if rows.length === 0, the function throws Error - is it possible for a valid shared address to legitimately have no other cosigners (e.g., if it only includes the current device)? Can this error handling cause crashes for single-device addresses or merkle-based definitions?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressCosigners()] [Information Disclosure] At lines 534-538, the query joins correspondent_devices to get cosigner names - if correspondent_devices.name contains sensitive information or if an attacker can manipulate this table, can this leak information or display misleading cosigner identities to users?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressCosigners()] [Missing Correspondent Handling] The LEFT JOIN at line 537 allows rows with NULL names - if a cosigner device is not in correspondent_devices, what name is returned? Can this cause UI display issues or make it impossible to identify which devices need to sign?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressPeers()] [Authorization Bypass] At lines 557-561, the function queries for addresses WHERE device_address != getMyDeviceAddress() and LEFT JOINs correspondent_devices - but it doesn't verify that these addresses are actually part of the shared address definition - can this return arbitrary addresses that happen to be in shared_address_signing_paths?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressPeers()] [Name Spoofing] At lines 565-568, the function maps addresses to names from correspondent_devices, using 'unknown peer' as fallback - if an attacker can manipulate correspondent_devices.name, can they impersonate legitimate cosigners by using the same name, causing users to send signatures or funds to the wrong party?",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: readSharedAddressPeers()] [Empty Peers Allowed] The comment at lines 562-564 notes",
  "[File: byteball/ocore/wallet_defined_by_addresses.js] [Function: getPeerAddressesFromSigners()] [Device Address Spoofing] At lines 574-583, the function extracts addresses where device_address !== getMyDeviceAddress() - if an attacker can temporarily modify what getMyDeviceAddress() returns (e.g., through race conditions or message injection), can this cause the function to misclassify which addresses are peers vs. self-controlled?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: createWallet()] [Wallet ID collision] Can an attacker who controls xPubKey input craft a collision in the SHA256 hash used to generate the wallet ID (line 233), allowing them to hijack an existing wallet's state in the database and potentially gain unauthorized access to funds?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: createWallet()] [Race condition] If createWallet() is called concurrently with the same xPubKey from multiple threads or devices, can both executions pass the initial checks and insert duplicate wallet records (line 236), leading to database inconsistencies or wallet state corruption?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: createWallet()] [Device address validation bypass] In the arrOtherCosigners array construction (lines 244-246), if device.readCorrespondentsByDeviceAddresses() returns manipulated data with incorrect device addresses, can an attacker inject unauthorized cosigners into the wallet definition?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: createMultisigWallet()] [Signature threshold bypass] If count_required_signatures is set to 0 or negative value (line 259), does the function properly validate this before creating the 'r of set' definition (line 262), or can an attacker create a wallet with no signature requirements?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: createMultisigWallet()] [Integer overflow] If count_required_signatures is set to a value greater than arrDeviceAddresses.length (checked at line 259-260), but what if arrDeviceAddresses.length itself is manipulated to be MAX_INT32, can this cause integer overflow when computing the 'required' field in the definition template?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: createSinglesigWallet()] [Device address spoofing] The function uses device.getMyDeviceAddress() directly in the definition template (line 268) - if the device module returns a corrupted or attacker-controlled device address due to state manipulation, can funds be locked or stolen?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: createSinglesigWalletWithExternalPrivateKey()] [Authorization bypass] This function accepts a device_address parameter (line 272) without validation - can an attacker specify an arbitrary device address to create a wallet controlled by someone else's keys, potentially enabling front-running or fund theft?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: createWalletByDevices()] [Empty cosigner array handling] When arrOtherDeviceAddresses.length === 0 (line 280), the function creates a singlesig wallet - but what if the array is manipulated to be undefined or null rather than empty, causing the wrong wallet type to be created?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: checkAndFinalizeWallet()] [Race condition in finalization] If multiple devices call checkAndFinalizeWallet() simultaneously for the same wallet (line 121), can the check at line 128 pass for multiple executions before the UPDATE at line 130 completes, causing ready_date to be set multiple times and potentially triggering duplicate wallet_completed events?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: checkAndFinalizeWallet()] [SQL injection via wallet ID] The wallet parameter is directly interpolated into SQL queries (line 122) - if the wallet ID generation at line 233 can be manipulated to include SQL metacharacters, can this lead to SQL injection despite using parameterized queries?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: checkAndFullyApproveWallet()] [Approval date race condition] Between checking approval_date at line 142 and updating full_approval_date at line 144, can an attacker send a cancellation message that deletes extended_pubkeys records, causing the UPDATE to succeed even though the wallet should be cancelled?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: checkAndFullyApproveWallet()] [Device address validation] The function uses device.getMyDeviceAddress() in multiple queries (lines 147, 151) - if this value changes between calls due to device state manipulation, can wallet membership records become inconsistent?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: checkAndFullyApproveWallet()] [Notification spam DoS] The function sends notifications to all other members (lines 154-156) without rate limiting - can an attacker repeatedly trigger wallet approval to flood other devices with messages, causing network congestion or device crashes?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: approveWallet()] [XPubKey validation] The function accepts xPubKey from network messages (line 288) and stores it in the database (line 291) - is the xPubKey validated to be a valid BIP32 extended public key before storage, or can malformed keys cause crashes during later address derivation?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: approveWallet()] [Indirect correspondent injection] The addIndirectCorrespondents call (line 290) processes arrOtherCosigners - can an attacker include malicious correspondent data that exploits vulnerabilities in the device pairing system?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: validateWalletDefinitionTemplate()] [Recursive definition attack] The function calls Definition.replaceInTemplate() at line 495 - if the template contains nested 'definition template' operators (which throw Error at line 473), can an attacker craft a template that passes initial validation but causes stack overflow during actual address derivation?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: validateWalletDefinitionTemplate()] [Fake validation state] The function creates objFakeValidationState with last_ball_mci set to MAX_INT32 (line 501) - can this allow definition templates that would be invalid at current MCI to pass validation, enabling future consensus issues when the template is actually used?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: validateWalletDefinitionTemplate()] [Device address membership bypass] The function checks that my device address and sender's device address are in arrDeviceAddresses (lines 484-487) - but what if arrDeviceAddresses is empty due to a malformed template, can the checks be bypassed?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: validateWalletDefinitionTemplate()] [Same pubkey for all devices] The validation assigns the same public key to all devices (line 492) - can this mask errors where two devices actually have conflicting signing paths in the real definition, causing wallet creation to succeed but address derivation to fail later?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: getDeviceAddressesBySigningPaths()] [Path traversal via signing path] The evaluate() function builds path strings like 'r.0.1' (lines 457, 463, 469) - can an attacker craft a template where these paths contain '../' or other directory traversal sequences that corrupt the assocDeviceAddressesBySigningPaths object?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: getDeviceAddressesBySigningPaths()] [Infinite recursion] The evaluate() function recursively processes 'or', 'and', 'r of set', and 'weighted and' operators (lines 454-470) - is there a depth limit to prevent stack overflow if a malicious template contains deeply nested operators?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: getDeviceAddressesBySigningPaths()] [Prototype pollution] The function assigns values to assocDeviceAddressesBySigningPaths using computed keys (lines 446, 452) - can an attacker craft a template where the path evaluates to '__proto__' or 'constructor', causing prototype pollution?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: getDeviceAddressesBySigningPaths()] [Hash operator device extraction] The function extracts device addresses from hash.hash fields (lines 449-452) just like sig.pubkey - but hash operators require preimage revelation, not signatures. Can this allow creation of wallets with unrevealed device addresses that cannot actually be used?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: handleOfferToCreateNewWallet()] [Wallet name XSS] The function sanitizes wallet_name by removing '<>' characters (line 74) - but is this sufficient to prevent XSS in UI contexts, or can attackers use other HTML entities, Unicode confusables, or JavaScript protocol URIs?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: handleOfferToCreateNewWallet()] [Wallet ID length validation bypass] The function checks wallet.length > constants.HASH_LENGTH (line 70) - but what if constants.HASH_LENGTH is misconfigured or an attacker sends a wallet ID with embedded null bytes that appear shorter than they are?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: handleOfferToCreateNewWallet()] [Definition template type confusion] The function checks ValidationUtils.isArrayOfLength(body.wallet_definition_template, 2) at line 75 - but does this prevent passing an array-like object (with length property) that isn't actually an array, potentially causing type errors in downstream processing?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: handleOfferToCreateNewWallet()] [Cosigner array length manipulation] The function checks other_cosigners.length === arrDeviceAddresses.length - 1 (line 84) - can an attacker exploit integer overflow if arrDeviceAddresses.length is 0, making the comparison 'otherLength === -1' which might match a very large array due to underflow?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: handleOfferToCreateNewWallet()] [Device address verification bypass] The function verifies cosigner.device_address === objectHash.getDeviceAddress(cosigner.pubkey) at line 94 - but what if objectHash.getDeviceAddress() is deterministic and an attacker can find a pubkey that hashes to a target device address (pre-image attack)?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: handleOfferToCreateNewWallet()] [Cosigner name length exhaustion] The function checks cosigner.name.length > 100 (line 98) - but with 100 characters per cosigner and potentially many cosigners, can an attacker cause memory exhaustion by sending hundreds of cosigners with maximum-length names?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: handleOfferToCreateNewWallet()] [Hub URL validation] The function checks cosigner.hub.length but doesn't validate the URL format (line 103) - can attackers specify 'javascript:', 'file:', or other dangerous protocols that get executed in contexts expecting HTTPS URLs?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: handleOfferToCreateNewWallet()] [Event bus injection] The function emits 'create_new_wallet' event with attacker-controlled body fields (line 106) - if event handlers don't sanitize this data, can this lead to code injection or privilege escalation?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: addDeviceXPubKey()] [XPubKey replacement attack] The function updates extended_pubkey without checking if one already exists (line 365) - can an attacker repeatedly send my_xpubkey messages to replace a legitimate cosigner's xPubKey with their own, effectively stealing control of the wallet?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: addDeviceXPubKey()] [Approval date manipulation] The function sets approval_date to db.getNow() (line 365) - if the database time is manipulated or significantly skewed from real time, can this allow bypassing time-based restrictions in wallet approval logic?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: handleNotificationThatWalletFullyApproved()] [Premature wallet finalization] The function sets member_ready_date without checking if the wallet was actually fully approved by the notifying device (line 383) - can an attacker send fake notifications to prematurely finalize wallets before all members have approved?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: addNewAddress()] [Address derivation mismatch] The function compares derived address with provided address (line 420-421) - but what if the comparison is case-sensitive and the provided address uses different case, causing legitimate addresses to be rejected?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: addNewAddress()] [Wallet existence TOCTOU] The function checks wallet existence at line 417, but the wallet could be deleted before deriveAddress() is called - can this lead to deriving addresses for non-existent wallets that later cause orphaned records?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: addWallet()] [Single-sig timestamp injection] For single-sig wallets, the function uses db.getNow() for full_approval_date and ready_date (line 176) - if db.getNow() is exploitable (SQL injection, time manipulation), can attacker create backdated or future-dated wallets?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: addWallet()] [Definition template serialization] The function serializes arrWalletDefinitionTemplate with JSON.stringify() (line 178) - can circular references, large nested objects, or prototype pollution in the template cause JSON serialization to fail or produce corrupted data?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: addWallet()] [Device address insertion race] The function inserts device addresses using INSERT IGNORE (line 200) - if multiple wallets are being created simultaneously with overlapping device sets, can race conditions cause device records to be associated with wrong wallets?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: addWallet()] [Signing path insertion without validation] The function inserts signing paths without validating their format (line 215) - can an attacker who controls the wallet definition template inject arbitrary signing_path values that corrupt the database or cause errors during signature verification?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: addWallet()] [Parallel execution callback timing] The function calls onDone() at line 227 regardless of whether single-sig or multi-sig path is taken - but the multi-sig path calls checkAndFullyApproveWallet() which is asynchronous. Can this cause race conditions where onDone() is called before wallet approval completes?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readNextAccount()] [Account number overflow] The function computes account as max_account + 1 (line 115) - if max_account is close to MAX_INT32, can this overflow and wrap to negative numbers, causing account numbering to restart and potentially collide with existing wallets?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readNextAccount()] [Empty result handling] When rows.length === 0, the function returns account = 0 (line 115) - but what if the query fails due to database errors, returning empty rows unintentionally? Can this cause duplicate account 0 assignments?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: cancelWallet()] [Initiator identification logic] The function computes initiator as the device NOT in arrOtherCosigners (lines 311-315) - can an attacker manipulate arrOtherCosigners to incorrectly identify the initiator, sending cancellation to the wrong device?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: cancelWallet()] [Hub message security] The function uses device.sendMessageToHub() directly with attacker-influenced cosigner.hub and cosigner.pubkey (line 321) - can this enable message injection or routing attacks if the hub field contains malicious URLs?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: cancelWallet()] [Cascading delete without transaction] The function deletes from extended_pubkeys and wallet_signing_paths in separate queries (lines 323-325) - if a failure occurs between deletions, can this leave orphaned records that corrupt wallet state?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: deleteWallet()] [Authorization check bypass] The function checks if rejector_device_address approved the wallet (line 334-335) - but what if the rejector approved the wallet, then the approval_date field is corrupted or deleted, allowing them to reject it anyway?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: deleteWallet()] [Indirect correspondent deletion timing] The function deletes unused indirect correspondents (lines 343-349) - but what if those correspondents are being added to another wallet concurrently? Can the EXISTS subquery miss the concurrent insertion, incorrectly deleting correspondents that are still needed?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: deleteWallet()] [Event emission before commit] The function emits 'wallet_declined' event (line 351) inside the async.series callback - but are all deletions guaranteed to be committed before the event is emitted, or can listeners observe inconsistent state?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: derivePubkey()] [Bitcore exception handling] The function creates Bitcore.HDPublicKey and calls derive() (lines 532-533) without try-catch - can invalid xPubKey or path cause uncaught exceptions that crash the node?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: derivePubkey()] [Path injection] The path parameter is passed directly to hdPubKey.derive() (line 533) - can attackers inject malicious paths like 'm/../../' or paths with large numbers that cause Bitcore to derive weak keys or crash?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: derivePubkey()] [Key format conversion] The function converts to base64 using .toString('base64') (line 533) - can this conversion fail for certain key values, produce non-canonical encodings, or truncate data?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: deriveAddress()] [Wallet not found timing] The function throws Error if wallet not found (line 539) - but this is after database query completes. Can an attacker delete the wallet between query and error check, causing the error to leak information about wallet existence?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: deriveAddress()] [Full approval check bypass] The function checks full_approval_date (line 540-541) - but what if the wallet's full_approval_date is set to a future time, or the database timestamp is manipulated? Can addresses be derived before wallet is actually ready?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: deriveAddress()] [Extended pubkey missing check] The function throws Error if no extended_pubkey (line 553) - but this check is inside the forEach loop. Can a wallet with some devices having xPubKeys and others missing proceed with partial derivation?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: deriveAddress()] [Path construction] The path is constructed as 'm/'+is_change+'/'+address_index (line 549) - can non-numeric is_change or address_index values cause malformed paths that Bitcore misinterprets or crashes on?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: deriveAddress()] [Definition template replacement] The function calls Definition.replaceInTemplate() (line 557) - if the params object has unexpected keys due to device_address manipulation, can this cause the wrong pubkeys to be inserted or template corruption?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: deriveAddress()] [Address hash collision] The function computes address using objectHash.getChash160() (line 558) - is there any collision detection to prevent two different definitions from generating the same address, which could enable fund theft?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: recordAddress()] [String index for change address] The function throws Error if address_index is string AND is_change is true (line 566-567) - but what if is_change is a truthy non-boolean value like 1 or '1'? Can this bypass the check?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: recordAddress()] [Column name injection] The address_index_column_name is set based on typeof check (line 568) - can an attacker craft address_index to be an object with numeric toString() to bypass type check and inject 'app' column when it should be 'address_index'?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: recordAddress()] [Light client unprocessed address] For light clients, unprocessed_addresses is inserted before my_addresses (line 570) - can race conditions between these insertions cause addresses to be added to my_addresses without corresponding unprocessed_addresses records?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: recordAddress()] [Definition serialization] The definition is JSON.stringify'd (line 577) - can large or deeply nested definitions cause serialization failures, memory exhaustion, or exceed database column limits?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: recordAddress()] [Event emission timing] The function emits 'new_address-'+address and 'new_address' events (lines 579-580) - if event handlers throw exceptions, can this prevent onDone() from being called and leave the address in inconsistent state?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueAddress()] [Gap check bypass] The function issues address without checking if address_index exceeds MAX_BIP44_GAP (line 599) - unlike issueOrSelectNextAddress(), can this allow unlimited gap creation when called directly by other modules?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueAddress()] [Device notification failure] The function sends address to other devices in forEach loop (lines 602-605) - if sendNewWalletAddress() fails for some devices, the address is still returned. Can this cause address synchronization to break across multi-sig wallet members?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueAddress()] [Timestamp overflow] The function uses Date.now()/1000 (line 606) - in year 2038, will this overflow when converted to int32 timestamp, causing addresses to have incorrect creation_ts?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueAddress()] [Asynchronous checkAddress timing] The function calls checkAddress() after 5 second timeout (lines 609-611) - if the issueAddress() call fails after scheduling this timeout, can the checkAddress() run on non-existent addresses causing errors?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueNextAddress()] [Mutex deadlock] The function locks 'issueNextAddress' mutex (line 640) but doesn't specify timeout - can concurrent address issuance cause permanent mutex deadlock if unlock() is never called due to exceptions?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueNextAddress()] [Next index race condition] Between reading next_index (line 641) and issuing address (line 642), can another process issue the same index, causing both to attempt inserting the same address with INSERT IGNORE silently failing for one?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueOrSelectNextAddress()] [MAX_BIP44_GAP boundary] When next_index exactly equals MAX_BIP44_GAP (20), the function issues new address (line 654) - but should the limit be inclusive or exclusive? Can this create exactly 21 consecutive unused addresses?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueOrSelectNextAddress()] [Last used index null handling] When last_used_index is null, the function compares next_index - null >= MAX_BIP44_GAP (line 656) - does JavaScript treat this correctly, or can NaN comparisons cause unexpected behavior?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueOrSelectNextAddress()] [Random address selection bias] The function uses selectRandomAddress() which orders by db.getRandom() (line 631) - if the database's random function is predictable or has low entropy, can attackers predict which addresses will be reused?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueOrSelectNextChangeAddress()] [First unused vs next index mismatch] The function computes first_unused_index as last_used_index + 1 (line 667) but compares it to next_index - if first_unused < next_index, it tries to read address at first_unused. Can malicious database corruption make first_unused > next_index, causing Error 'unused > next' to be thrown?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueOrSelectNextChangeAddress()] [Ternary operator ambiguity] The function uses ternary addressInfo ? handleAddress(addressInfo) : issueAddress() (line 672) - if addressInfo is truthy but invalid (e.g., empty object), can this cause handleAddress to be called with bad data instead of issuing new address?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readNextAddressIndex()] [Null vs 0 ambiguity] The function returns 0 when last_used_index is null (line 515) - but 0 is also a valid address index. Can this cause confusion where 'no addresses ever used' is indistinguishable from 'address 0 was last used'?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readLastUsedAddressIndex()] [Join with outputs table] The function joins my_addresses with outputs table (line 522) - can this be exploited by creating fake outputs in the database that point to non-existent addresses, causing incorrect last_used_index calculations?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: scanForGaps()] [Multisig wallet detection] The function identifies multisig wallets by COUNT(*) > 1 in wallet_signing_paths (line 684) - can single-sig wallets with duplicate signing path entries (database corruption) be incorrectly treated as multisig?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: scanForGaps()] [Gap detection algorithm] The function identifies gaps by checking if address_index !== prev_address_index + 1 (line 698) - but what if addresses are inserted out of order in the database? Can this cause false positives where no actual gaps exist?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: scanForGaps()] [Missing address array memory] The function builds arrMissingAddressInfos array (lines 699-700, 703-704) which could contain thousands of entries if massive gaps exist - can attackers create wallets with address indices 0 and 1000000, causing memory exhaustion when scanForGaps tries to fill all intermediate indices?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: scanForGaps()] [Sequential address issuance DoS] The function issues all missing addresses sequentially with async.eachSeries (line 716) - can this take hours or days for wallets with large gaps, effectively DoS'ing the node during gap filling?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: scanForGaps()] [Event emission timing] The function emits 'maybe_new_transactions' after gap filling (line 719) - but are all addresses guaranteed to be committed to database, or can event handlers query for addresses that aren't yet visible?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueOrSelectAddressForApp()] [App name SQL injection] The app_name parameter is used in WHERE clause (line 729) - if app_name contains SQL metacharacters, can this cause SQL injection despite parameterized queries?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueOrSelectAddressForApp()] [Multiple address error] The function throws Error if rows.length > 1 (line 731) - but this is after database query completes. Can race conditions cause multiple app addresses to be inserted concurrently, with only one execution detecting the error?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: issueOrSelectAddressForApp()] [App name as address index] The function passes app_name directly as address_index to issueAddress() (line 734) - can special app names like '__proto__', 'constructor', or '0' cause property pollution or type confusion?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readAddresses()] [SQL injection via opts] The function constructs SQL by concatenating opts.is_change, opts.reverse, opts.limit (lines 769-775) - if these fields come from user input, can attackers inject SQL commands?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readAddresses()] [Limit parameter overflow] If opts.limit is set to MAX_INT32 or larger (line 775), can this cause database memory exhaustion or integer overflow in query processing?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readAllAddresses()] [Memory exhaustion] The function selects ALL addresses for a wallet with no limit (line 806) - can wallets with millions of addresses cause memory exhaustion when this function loads them all into an array?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: checkAddress()] [Single wallet assumption] The function expects exactly 1 row from query (line 742) but only checks for === 0 or > 1 - what if account is used across multiple wallets? Does the function silently skip verification in this case?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: checkAddress()] [Pubkey extraction from definition] The function extracts pubkey using JSON.parse(definition)[1].pubkey (line 755) - can malformed definitions with different structure cause array access errors or extract wrong pubkey?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: checkAddress()] [Mismatch error handling] The function throws Error on pubkey or address mismatch (lines 757, 759) - are these errors caught by calling code, or do they crash the node? Can attackers trigger these errors to cause DoS?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: checkAddress()] [Silent verification success] The function only logs 'addresses match' via breadcrumbs (line 760) - if addresses don't match, no breadcrumb is added. Can this make debugging address corruption difficult?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readCosigners()] [Self-identification logic] The function checks if device_address === device.getMyDeviceAddress() to identify self (line 400) - if device module state is corrupted, can the node fail to identify itself, or incorrectly identify another device as self?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readCosigners()] [Missing correspondent detection] The function throws Error if cosigner not found in correspondents (line 406) - but this check is AFTER setting row.me flag. Can race conditions cause the error to reference wrong device address?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readCosigners()] [Left join null handling] The function uses LEFT JOIN with correspondents (line 396) - if correspondent records are deleted concurrently, can row.name be null for non-self devices, causing incorrect error messages?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: forwardPrivateChainsToOtherMembersOfWallets()] [Wallet array validation] The function passes arrWallets directly to SQL IN clause (line 824) - if arrWallets contains non-string elements or is empty, can this cause SQL syntax errors?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: forwardPrivateChainsToOtherMembersOfWallets()] [Self-exclusion bypass] The function excludes device.getMyDeviceAddress() from recipients (line 825) - but what if device address changes during query execution? Can the node forward chains to itself, causing infinite loops?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: forwardPrivateChainsToOtherMembersOfWallets()] [Connection parameter injection] The function accepts optional conn parameter (line 822) - if attacker can inject a malicious connection object, can this redirect private chains to attacker's database?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readDeviceAddressesControllingPaymentAddresses()] [Empty address array handling] The function returns early if arrAddresses.length === 0 (line 835) - but what if arrAddresses is undefined or null? Can this cause the query to execute with undefined parameter?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: readDeviceAddressesControllingPaymentAddresses()] [Address ownership ambiguity] The function queries my_addresses joined with extended_pubkeys - can addresses controlled by multiple wallets (shouldn't happen, but possible with bugs) return duplicate device addresses, causing chains to be forwarded multiple times?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Function: forwardPrivateChainsToOtherMembersOfAddresses()] [bForwarded parameter missing] This function calls forwardPrivateChainsToDevices with bForwarded=true hardcoded (line 851) - but forwardPrivateChainsToOtherMembersOfWallets() accepts bForwarded as parameter. Can this inconsistency cause chains to be marked as forwarded when they shouldn't be?",
  "[File: byteball/ocore/wallet_defined_by_keys.js] [Cross-function race: createWallet + deleteWallet] If createWallet() and deleteWallet() execute concurrently for the same wallet ID, can the delete remove extended_pubkeys records after createWallet's addWallet() inserts them but before full_approval_date is set, leaving orphaned wallet in limbo state?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Type confusion] If last_stable_mci is passed as a numeric string like '1000' instead of integer 1000, does the typeof check at line 16 incorrectly throw an error while the SQL query at line 27 still executes with string interpolation, potentially causing SQL injection or incorrect MCI comparisons?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Input validation bypass] Can an attacker pass arrWitnesses containing strings that pass ValidationUtils.isValidAddress() but are not actual witness addresses (e.g., valid base32 strings that don't correspond to real units), causing the function to build invalid proofs that nodes accept as valid?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Array mutation] Since arrWitnesses is not cloned before use, can an attacker mutate the array from calling context during async execution between lines 18-156, causing witness list to change mid-flight and producing inconsistent proof that references different witness sets?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Integer bounds] If last_stable_mci is MAX_SAFE_INTEGER or exceeds database integer limits, does the comparison at line 102 (last_stable_mci >= last_ball_mci) produce incorrect boolean result due to integer overflow, causing proof generation to skip current state when it should update?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [SQL injection] At line 25, the and_end_mci variable directly concatenates end_mci into SQL query string without parameterization - if end_mci is passed as malicious string from a compromised caller, can attacker inject SQL to extract private data, modify database state, or cause denial of service?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [SQL injection via witness addresses] At lines 107-136, the arrWitnesses array is directly interpolated into three SQL UNION queries - if ValidationUtils.isValidAddress() has a bypass allowing malicious strings, can attacker inject SQL to return arbitrary units as witness definition changes, tricking light clients into accepting fake proofs?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [SQL injection in ORDER BY] At line 82, the query uses conf.storage to dynamically select ORDER BY column (rowid vs creation_date) - if conf.storage is somehow corrupted or injected with malicious value, can this cause SQL injection or incorrect ordering that breaks witness proof consistency?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Race condition on ball deletion] At line 32, the code deletes objJoint.ball after reading it with 'the unit might get stabilized while we were reading other units' - if multiple concurrent prepareWitnessProof() calls race on the same units during stabilization, can this cause some proofs to include balls while others don't, creating non-deterministic proofs that split light clients?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Race condition on arrUnstableMcJoints] At lines 66-72, arrUnstableMcJoints is conditionally assigned based on _arrLastBallUnits.length > 0, but if units stabilize between this check and final proof assembly at line 155, can the proof contain stale unstable units that are actually stable, causing light clients to reject the proof?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [TOCTOU on last_stable_mci] The last_stable_mci parameter is validated at line 16 but used throughout async operations until line 155 - if the actual last_stable_mci in the database advances during execution, can the proof contain units with MCI <= last_stable_mci that should be excluded, breaking light client validation?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Concurrent definition updates] At lines 258-260, assocDefinitionChashes[address] is updated within validateUnit() which is called in async.eachSeries - if two units contain definition_chg for the same address, can out-of-order execution cause the wrong definition to be cached, allowing later signatures to validate against incorrect definition?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Race on assocDefinitions cache] At lines 220-221, assocDefinitions and assocDefinitionChashes are shared mutable state across all validateUnit() calls - if multiple proofs are processed concurrently (no mutex protection visible), can cache poisoning cause one proof's definitions to bleed into another, validating signatures against wrong definitions?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Duplicate witness counting] At lines 36-37, witnesses are added to arrFoundWitnesses only if not already present, but at line 34-38 the check iterates through ALL authors in objJoint.unit.authors - if a single unit has the same witness address listed multiple times as authors (malicious unit), does this bypass the deduplication and incorrectly inflate witness count toward MAJORITY_OF_WITNESSES?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Off-by-one in majority check] At line 41, the condition is arrFoundWitnesses.length >= constants.MAJORITY_OF_WITNESSES - if MAJORITY_OF_WITNESSES is defined as 7 (for 12 witnesses) but the actual threshold should be >7 (strictly greater), does this off-by-one allow proofs to be constructed with exactly 7 witnesses when 8 are needed, breaking light client consensus?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Witness counting inconsistency] At lines 180-186, witnesses are counted in arrFoundWitnesses and joints added to arrWitnessJoints - if a unit has multiple authors that are witnesses, does bAddedJoint flag prevent adding the joint multiple times but arrFoundWitnesses still counts all witness authors, creating mismatch between witness count and actual witness-authored joints?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Insufficient witness validation] At line 194-195, the code returns error if arrFoundWitnesses.length < MAJORITY_OF_WITNESSES, but does it verify that the witnesses found actually match the arrWitnesses parameter passed in? Can attacker send proof with correct number of witnesses but from a completely different witness list, bypassing the 1 shared witness requirement?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Last ball unit deduplication bug] At line 41-42, last_ball_unit is added to arrLastBallUnits only if not already present via indexOf() check, but if the same last_ball_unit appears in multiple unstable MC units with different last_ball hashes, does this silently drop valid last balls, causing proof to reference incomplete ball chain?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Parent chain break] At lines 175-176, the code checks if arrParentUnits && arrParentUnits.indexOf(objUnit.unit) === -1, returning 'not in parents' error - but arrParentUnits is initialized to null at line 163 and only set at line 188, so the first unit in arrUnstableMcJoints is never validated against parents. Can attacker inject arbitrary first unit that doesn't connect to DAG?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Parent verification incomplete] The parent chain validation at lines 175-176 only checks if current unit is in previous unit's parent_units, but doesn't verify that ALL parents exist or that the chain forms valid DAG without cycles - can attacker craft proof where units reference non-existent or future units as parents, breaking DAG invariants?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Missing parent transitivity check] At line 188, arrParentUnits is updated to objUnit.parent_units for each iteration, but there's no verification that these parents are actually in the arrUnstableMcJoints set or known to the node - can attacker send proof with gaps where intermediate parent units are missing, causing light client to accept incomplete DAG fragment?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Main chain order assumption] At line 27, units are selected with ORDER BY main_chain_index DESC and iterated in reverse chronological order, but at line 188 parent_units are used directly without verifying they have lower MCI - can database reorg or malicious hub send units out of order, breaking parentchild MCI monotonicity assumption?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Insufficient hash validation] At lines 173-174 and 208-209, validation.hasValidHashes(objJoint) is called but the return value true/false is checked - does this function also verify unit hash matches content, or just that hash fields exist? Can attacker send proof with valid-looking hashes that don't actually match unit content, bypassing cryptographic integrity?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Hash validation before content check] Hash validation at line 173 occurs before parent chain check at line 175 and witness authorship check at line 180 - if hasValidHashes() is expensive, can attacker DoS the node by flooding with proofs that have invalid parents/witnesses but valid hashes, forcing CPU-intensive hash verification before cheap structural checks?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Ball hash not validated] At lines 189-192, objUnit.last_ball is stored in assocLastBallByLastBallUnit keyed by last_ball_unit, but there's no verification that last_ball hash actually corresponds to the last_ball_unit - can attacker provide mismatched last ball hash/unit pair, breaking last ball chain integrity for light clients?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Ball existence for unstable units] At lines 171-172, the code returns error if objJoint.ball exists for unstable MC units, with comment 'unstable mc but has ball' - but what if a unit was just stabilized and now has ball? Does this cause legitimate proofs to be rejected during stabilization window, potentially freezing light client sync for hours?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Ball requirement for definition changes] At lines 206-207, witness definition change joints MUST have ball ('joint without ball' error), but this conflicts with the unstable joint check at line 171-172 - if a witness changes definition in an unstable unit, which rule wins? Can this create inconsistency where proofs are impossible to construct during certain DAG states?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Ball deletion timing] At line 32, balls are deleted from joints with comment about stabilization race, but at lines 189-192 processWitnessProof expects last_ball to exist in unstable units - does prepareWitnessProof delete last_ball field too, or only ball field? Can this cause processWitnessProof to fail on proofs generated by prepareWitnessProof?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Stable unit inclusion] At lines 107-136, the query selects units with is_stable=1 for witness definition changes, but the main unstable joints query at line 27 doesn't explicitly filter for is_stable=0 - can stable units leak into arrUnstableMcJoints, causing processWitnessProof to reject proof due to unexpected balls at line 171?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Definition chash mismatch] At lines 239-240, if author.definition exists, it's hashed and compared to definition_chash, returning error if mismatch - but if objectHash.getChash160() throws exception (line 242-243), the try-catch returns generic error message. Can attacker craft malformed definition that causes hash function to crash node or leak stack traces with sensitive info?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Definition cache poisoning] At line 245, assocDefinitions[definition_chash] = author.definition updates global cache with author-provided definition - if the definition hasn't been validated yet (only hash checked at line 239), can attacker poison cache with malicious definition that's used to validate subsequent signatures, bypassing actual stored definitions?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Definition not found exception] At lines 273-275, if storage.readDefinition() fails to find definition, it throws Error instead of calling callback with error - this breaks async error handling flow. Does the thrown Error crash the entire proof validation, causing denial of service where any missing definition prevents all light clients from syncing?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Signature validation bypass] At line 251, validateAuthorSignaturesWithoutReferences() is called but the function name suggests it skips reference validation - can attacker craft signatures that embed references to definitions not in assocDefinitions, bypassing the definition tracking and allowing unauthorized signatures to pass?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Definition chash initialization] At lines 291-295, if !bFromCurrent, all witnesses get address as definition_chash (assocDefinitionChashes[address] = address), but this assumes witness addresses haven't changed definitions - can attacker replay old proof with original address as definition when witness has since changed, allowing old signatures to validate against new witness state?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Definition change message validation] At lines 256-260, definition_chg messages are processed if payload.address matches author.address OR unit has single author - the OR condition allows single-author units to change ANY address's definition. Can attacker create single-author unit that changes victim witness's definition without authorization, bricking the witness or stealing funds?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Missing definition for non-witness] At lines 232-234, non-witness authors are skipped if definition_chash not in assocDefinitionChashes, but line 235-236 throws Error if witness has no definition_chash - can attacker exploit this by crafting units where witness authors have no definition_chash, causing unexpected Error to crash validation?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Last ball unit selection race] At lines 99-102, the newest last_ball_unit is selected from arrLastBallUnits by MAX main_chain_index, but if two units have same MCI (shouldn't happen but DB corruption could cause it), LIMIT 1 returns arbitrary unit - can this non-determinism cause different nodes to generate different proofs for same parameters, splitting light clients?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Already current bypass] At line 102, if last_stable_mci >= last_ball_mci, the function returns 'already_current' error, but what if last_stable_mci == last_ball_mci exactly? This edge case means the last ball unit is at the stable point - should proof still be generated to confirm stability, or does 'already_current' incorrectly reject valid proof requests?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Genesis last_ball_unit handling] At lines 40-42, the code checks objJoint.unit.last_ball_unit exists with comment '(genesis lacks last_ball_unit)' - if genesis IS in the unstable set (edge case during initial sync), does missing last_ball_unit cause arrLastBallUnits to remain empty, failing proof generation with 'too few witness authored units' at line 98?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Last ball units empty check] At lines 198-199, the code throws Error if arrLastBallUnits.length === 0, but this is throw not callback error - does this crash propagate to caller breaking all proof validation, or is it caught somewhere? Can attacker trigger this by sending proof with insufficient witnesses to DoS light client sync?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Multiple last ball units] At lines 55-56 and 66-72, arrLastBallUnits can contain multiple different last_ball_unit values from different unstable MC units, but at lines 99-103 only ONE is selected as THE last_ball_unit for the proof - does this mean proofs are non-deterministic if multiple valid last ball units exist at same time?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Database query order dependence] At line 82, the ORDER BY clause uses different columns for sqlite (rowid) vs mysql (creation_date) - if these don't produce same ordering, can nodes using different databases generate different witness proofs for identical chain state, causing light client consensus split?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Index hint bypass] At line 121, db.forceIndex('byDefinitionChash') forces specific index usage, but if this index is corrupt, missing, or has different definition in sqlite vs mysql schema, does the query fail silently returning empty results, causing witness definition changes to be invisible and signatures to fail validation?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Database check during validation] At lines 323-327, when bFromCurrent=true, the code queries DB to check if unit is already stable before validating - can this DB roundtrip be exploited for timing attacks where attacker sends many proofs causing DB query flooding, or does DB state change between check and validation causing race condition?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [UNION query result ordering] At lines 120-135, three SELECT queries are UNIONed and ordered by level, but SQL UNION may eliminate duplicates - if the same unit appears in multiple SELECTs (e.g., witness initially defines address AND later changes it), does deduplication cause definition change ordering to be wrong, validating signatures out of sequence?",
  "[File: byteball/ocore/witness_proof.js] [Function: storage.findWitnessListUnit()] [Witness list unit lookup] At line 79, storage.findWitnessListUnit() is called with 2^31-1 as parameter (MAX_INT), but if this function doesn't exist in storage.js or has different signature, does this cause undefined function error that crashes proof generation?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Early return in series] At lines 75-76 and 77-78, the async.series step returns cb() early if conditions are met, but at line 106-107, after_last_stable_mci_cond is constructed using last_stable_mci - if cb() was called early at line 76, does execution skip to final handler at line 152 leaving arrWitnessChangeAndDefinitionJoints uninitialized, causing processWitnessProof to fail?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Error string consistency] At lines 62, 78, 81, 84, 98, error messages are returned as strings like 'some witnesses have references in their addresses' - are these exact error strings checked by callers in network.js or light.js? If yes, any typo or rewording breaks error handling. If no, can attacker distinguish between real errors and attack-induced errors?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Async.eachSeries error propagation] At lines 226-285, validateUnit() uses nested async.eachSeries for authors (line 226) with callback cb3, but if one author fails validation, does cb3 error propagate correctly to cb2 (line 278-283), or can partial validation succeed leaving some authors unvalidated?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [ifNotFound callback] At lines 140-142, storage.readJoint() has ifNotFound callback that throws Error - this synchronous throw inside async callback breaks error handling. Does this crash the process, or is there a try-catch somewhere catching it? Can attacker cause missing joints to DoS node?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Callback vs throw inconsistency] At line 199, arrLastBallUnits.length === 0 causes throw Error, but at line 194-195, arrFoundWitnesses.length < MAJORITY_OF_WITNESSES causes handleResult() callback with error string - why different error handling patterns? Can caller handle both, or does throw bypass handleResult causing uncaught exception?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Definition reference check bypass] At lines 61-63, storage.determineIfWitnessAddressDefinitionsHaveReferences() is called and errors if witnesses have references in definitions - but what if this check is performed at time T1, then during async execution until line 155, a witness changes their definition to one WITH references? Does stale check result allow invalid proof to be created?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Reference check incomplete] The reference check at line 61-63 only checks current witness definitions, but definition change units collected at lines 105-151 may contain new definitions WITH references - are these new definitions also checked for references, or can witness upgrade to definition-with-references bypass the reference prohibition?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [No reference check in validation] In processWitnessProof(), there's no equivalent call to determineIfWitnessAddressDefinitionsHaveReferences() - if attacker sends proof with witnesses that have references in definitions, does validation accept it since check is missing, allowing light clients to accept proofs that full nodes would reject?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Witness list off-chain validation] At line 79, if no last balls found in current unstable range, code looks for witness_list_unit matching arrWitnesses - but if attacker provides arrWitnesses that no units on MC use (completely custom witness list), does this cause 'witness list might be too much off' errors at lines 78, 81, 84, 98, permanently preventing proof generation?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Witness list not persisted] The arrWitnesses parameter is used throughout validation but never checked against any stored witness list for the receiving node - can attacker send proof with completely different witness set than node expects, causing validation to pass but node to be unable to use the proof for chain advancement due to witness incompatibility?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Witness list compatibility] The code finds witness-authored units but never verifies that the witness list arrWitnesses is compatible with witness lists in the DAG - can two nodes using incompatible witness lists (sharing <1 witness) generate and validate proofs that reference different stability points, causing permanent network partition?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Memory exhaustion on large witness change history] At lines 138-148, ALL witness definition change units since last_stable_mci are loaded into arrWitnessChangeAndDefinitionJoints via async.eachSeries with no limit - if a witness has changed definitions thousands of times (malicious or legitimate), can this exhaust memory or take hours to process, causing DoS where proof generation never completes?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Memory exhaustion on deep unstable chain] At lines 26-48, ALL unstable MC units are loaded into arrUnstableMcJoints - if last stable MCI is very old (e.g., 1 million units ago due to witness inactivity), can this load gigabytes of units into memory, causing OOM crash and preventing any proofs from being generated?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Joint array mutation] At line 334, arrWitnessJoints.reverse() mutates the input array in-place - if caller reuses arrWitnessJoints after processWitnessProof() returns, will it be in reversed order causing bugs? Should this be arrWitnessJoints.slice().reverse() to avoid mutating caller's data?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [MCI boundary cases] At line 86, start_mci is calculated as findLastBallMciOfMci(findLastBallMciOfMci(main_chain_index)) - double nesting of findLastBallMciOfMci - what if main_chain_index is 0 or 1? Does findLastBallMciOfMci return -1 or null for genesis, causing SQL query with negative start_mci to return wrong results?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Empty arrWitnesses] If arrWitnesses is empty array [], does ValidationUtils.isValidAddress check at line 18 pass (empty.every() returns true in JavaScript), and subsequent witness counting at line 36-37 always fail to reach MAJORITY_OF_WITNESSES, causing all proof generation to fail with 'too few witness authored units'?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Empty proof arrays] If arrUnstableMcJoints is empty array [], does the for loop at lines 168-193 skip entirely, leaving arrFoundWitnesses empty and failing at line 194-195? But if arrWitnessChangeAndDefinitionJoints is also empty, should this be considered valid proof of no changes, or invalid proof?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Single author edge case] At lines 256-260, the condition (message.payload.address === address || objUnit.authors.length === 1 && objUnit.authors[0].address === address) has potential bug - if objUnit.authors.length === 1, does objUnit.authors[0].address === address always equal the message.payload.address check, making the OR redundant? Or can single-author unit have message.payload.address different from author address, allowing unauthorized definition changes?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Zero start_mci] If start_mci is 0 (genesis), does the SQL query 'main_chain_index>?' correctly select genesis unit with MCI=0, or does > operator exclude it requiring >= operator instead? Can this cause proofs starting from genesis to be invalid?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [storage.getMinRetrievableMci() trust] At line 66, storage.getMinRetrievableMci() is called to determine oldest units to scan - if this function returns incorrect value (too new due to aggressive archiving), can proof generation miss old witness definition changes, causing signatures to validate against wrong definitions for light clients?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [validation.hasValidHashes() assumptions] At lines 173-174 and 208-209, validation.hasValidHashes() is assumed to return boolean - if this function actually returns string error message or undefined on invalid hashes, does the if (!validation.hasValidHashes()) check incorrectly pass validation, accepting units with invalid hashes?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [validation.validateAuthorSignaturesWithoutReferences() contract] At line 251, this validation function is called - does 'WithoutReferences' mean it skips validating definition references entirely, or just skips loading referenced definitions? If former, can attacker craft definitions with malicious references that bypass security checks?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [storage.readJointWithBall() vs readJoint()] At line 31, storage.readJointWithBall() is used for unstable units, but at line 139, storage.readJoint() is used for definition changes - do these functions have compatible error handling and return formats? Can mismatch cause validation to fail unpredictably?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [storage.readDefinition() vs readDefinitionByAddress()] At lines 268-276 vs 300-311, two different storage functions are used to read definitions - do they have identical behavior and error callbacks? If readDefinitionByAddress() returns different results than readDefinition() for same address, can cached definitions mismatch between bFromCurrent=true and false cases?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Non-deterministic UNION ordering] At lines 120-135, three UNION queries are ordered by level, but if multiple units have identical level, SQL ORDER BY doesn't specify secondary sort column - can database return units in different order on different executions, causing prepareWitnessProof() to generate different arrWitnessChangeAndDefinitionJoints for same chain state on different nodes?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Timestamp-based ordering ambiguity] At line 82, MySQL uses ORDER BY creation_date for witness list unit lookup - if multiple witness list units have identical creation_date timestamp (same second), can LIMIT 1 return arbitrary unit, causing different nodes to use different witness list units as reference point?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Definition lookup race] At lines 268-276, if definition is not in cache, it's read from DB with storage.readDefinition() - if two nodes have different database states (one has definition, other doesn't due to archiving), can validation succeed on one node but fail on other, causing network split?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [async.eachSeries ordering guarantee] At lines 138-148, async.eachSeries is used to read joints in order from SQL result - does this guarantee that arrWitnessChangeAndDefinitionJoints has same ordering as SQL ORDER BY level? If async operations can complete out-of-order due to caching, can joint order be wrong?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [MCI arithmetic overflow] At lines 85-86, start_mci is calculated via nested findLastBallMciOfMci() calls - if main_chain_index is near MAX_SAFE_INTEGER, can intermediate calculations overflow JavaScript number limits, producing negative or invalid start_mci that breaks SQL query?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [2^31 - 1 magic number] At line 79, findWitnessListUnit is called with 2^31 - 1 as max_mci parameter - this is INT_MAX for 32-bit signed integers. If database uses 64-bit integers for MCI, does this artificially limit search space, potentially missing witness list units at higher MCIs?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Array length limits] At lines 23-24, arrUnstableMcJoints and arrLastBallUnits are standard JavaScript arrays - if unstable chain has more than MAX_SAFE_INTEGER units (unlikely but theoretically possible), can array operations silently fail or corrupt data?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [bRequireDefinitionOrChange flag] At line 224, validateUnit() takes bRequireDefinitionOrChange parameter, set to true for definition changes (line 322, 326) and false for witness joints (line 336) - if attacker sends witness joint that contains definition_chg message, does bFound flag at line 246, 259 incorrectly succeed without the requirement, bypassing definition change validation?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Definition change double application] At line 258, if address_definition_change message matches current author, assocDefinitionChashes[address] is updated - if same unit contains multiple definition_chg messages for same address, are they all processed in sequence (lines 254-261 in loop), potentially applying multiple definition changes in single unit?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Definition timeline consistency] At lines 316-330, definition changes are processed in order from arrWitnessChangeAndDefinitionJoints, but these units were selected from database with arbitrary level ordering - if witness changes definition in unit A (level 100) then again in unit B (level 99), does reverse level order cause definition changes to apply in wrong sequence?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Last ball chain verification] At lines 189-192, last_ball values are stored in assocLastBallByLastBallUnit keyed by last_ball_unit, but there's no verification that these form valid chain (each last_ball_unit's ball hash should match previous unit's last_ball) - can attacker send proof with broken last ball chain, tricking light clients about stability point?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Last ball MCI consistency] At lines 99-102, last_ball_unit and last_ball_mci are selected, but there's no check that last_ball_mci <= last_stable_mci parameter - can caller pass inconsistent last_stable_mci forcing proof to reference future stability point that doesn't exist yet?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Type confusion] If last_stable_mci is passed as a numeric string like '1000' instead of integer 1000, does the typeof check at line 16 incorrectly throw an error while the SQL query at line 27 still executes with string interpolation, potentially causing SQL injection or incorrect MCI comparisons?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Input validation bypass] Can an attacker pass arrWitnesses containing strings that pass ValidationUtils.isValidAddress() but are not actual witness addresses (e.g., valid base32 strings that don't correspond to real units), causing the function to build invalid proofs that nodes accept as valid?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Array mutation] Since arrWitnesses is not cloned before use, can an attacker mutate the array from calling context during async execution between lines 18-156, causing witness list to change mid-flight and producing inconsistent proof that references different witness sets?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Integer bounds] If last_stable_mci is MAX_SAFE_INTEGER or exceeds database integer limits, does the comparison at line 102 (last_stable_mci >= last_ball_mci) produce incorrect boolean result due to integer overflow, causing proof generation to skip current state when it should update?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [SQL injection] At line 25, the and_end_mci variable directly concatenates end_mci into SQL query string without parameterization - if end_mci is passed as malicious string from a compromised caller, can attacker inject SQL to extract private data, modify database state, or cause denial of service?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [SQL injection via witness addresses] At lines 107-136, the arrWitnesses array is directly interpolated into three SQL UNION queries - if ValidationUtils.isValidAddress() has a bypass allowing malicious strings, can attacker inject SQL to return arbitrary units as witness definition changes, tricking light clients into accepting fake proofs?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [SQL injection in ORDER BY] At line 82, the query uses conf.storage to dynamically select ORDER BY column (rowid vs creation_date) - if conf.storage is somehow corrupted or injected with malicious value, can this cause SQL injection or incorrect ordering that breaks witness proof consistency?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Race condition on ball deletion] At line 32, the code deletes objJoint.ball after reading it with 'the unit might get stabilized while we were reading other units' - if multiple concurrent prepareWitnessProof() calls race on the same units during stabilization, can this cause some proofs to include balls while others don't, creating non-deterministic proofs that split light clients?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Race condition on arrUnstableMcJoints] At lines 66-72, arrUnstableMcJoints is conditionally assigned based on _arrLastBallUnits.length > 0, but if units stabilize between this check and final proof assembly at line 155, can the proof contain stale unstable units that are actually stable, causing light clients to reject the proof?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [TOCTOU on last_stable_mci] The last_stable_mci parameter is validated at line 16 but used throughout async operations until line 155 - if the actual last_stable_mci in the database advances during execution, can the proof contain units with MCI <= last_stable_mci that should be excluded, breaking light client validation?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Concurrent definition updates] At lines 258-260, assocDefinitionChashes[address] is updated within validateUnit() which is called in async.eachSeries - if two units contain definition_chg for the same address, can out-of-order execution cause the wrong definition to be cached, allowing later signatures to validate against incorrect definition?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Race on assocDefinitions cache] At lines 220-221, assocDefinitions and assocDefinitionChashes are shared mutable state across all validateUnit() calls - if multiple proofs are processed concurrently (no mutex protection visible), can cache poisoning cause one proof's definitions to bleed into another, validating signatures against wrong definitions?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Duplicate witness counting] At lines 36-37, witnesses are added to arrFoundWitnesses only if not already present, but at line 34-38 the check iterates through ALL authors in objJoint.unit.authors - if a single unit has the same witness address listed multiple times as authors (malicious unit), does this bypass the deduplication and incorrectly inflate witness count toward MAJORITY_OF_WITNESSES?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Off-by-one in majority check] At line 41, the condition is arrFoundWitnesses.length >= constants.MAJORITY_OF_WITNESSES - if MAJORITY_OF_WITNESSES is defined as 7 (for 12 witnesses) but the actual threshold should be >7 (strictly greater), does this off-by-one allow proofs to be constructed with exactly 7 witnesses when 8 are needed, breaking light client consensus?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Witness counting inconsistency] At lines 180-186, witnesses are counted in arrFoundWitnesses and joints added to arrWitnessJoints - if a unit has multiple authors that are witnesses, does bAddedJoint flag prevent adding the joint multiple times but arrFoundWitnesses still counts all witness authors, creating mismatch between witness count and actual witness-authored joints?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Insufficient witness validation] At line 194-195, the code returns error if arrFoundWitnesses.length < MAJORITY_OF_WITNESSES, but does it verify that the witnesses found actually match the arrWitnesses parameter passed in? Can attacker send proof with correct number of witnesses but from a completely different witness list, bypassing the 1 shared witness requirement?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Last ball unit deduplication bug] At line 41-42, last_ball_unit is added to arrLastBallUnits only if not already present via indexOf() check, but if the same last_ball_unit appears in multiple unstable MC units with different last_ball hashes, does this silently drop valid last balls, causing proof to reference incomplete ball chain?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Parent chain break] At lines 175-176, the code checks if arrParentUnits && arrParentUnits.indexOf(objUnit.unit) === -1, returning 'not in parents' error - but arrParentUnits is initialized to null at line 163 and only set at line 188, so the first unit in arrUnstableMcJoints is never validated against parents. Can attacker inject arbitrary first unit that doesn't connect to DAG?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Parent verification incomplete] The parent chain validation at lines 175-176 only checks if current unit is in previous unit's parent_units, but doesn't verify that ALL parents exist or that the chain forms valid DAG without cycles - can attacker craft proof where units reference non-existent or future units as parents, breaking DAG invariants?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Missing parent transitivity check] At line 188, arrParentUnits is updated to objUnit.parent_units for each iteration, but there's no verification that these parents are actually in the arrUnstableMcJoints set or known to the node - can attacker send proof with gaps where intermediate parent units are missing, causing light client to accept incomplete DAG fragment?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Main chain order assumption] At line 27, units are selected with ORDER BY main_chain_index DESC and iterated in reverse chronological order, but at line 188 parent_units are used directly without verifying they have lower MCI - can database reorg or malicious hub send units out of order, breaking parentchild MCI monotonicity assumption?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Insufficient hash validation] At lines 173-174 and 208-209, validation.hasValidHashes(objJoint) is called but the return value true/false is checked - does this function also verify unit hash matches content, or just that hash fields exist? Can attacker send proof with valid-looking hashes that don't actually match unit content, bypassing cryptographic integrity?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Hash validation before content check] Hash validation at line 173 occurs before parent chain check at line 175 and witness authorship check at line 180 - if hasValidHashes() is expensive, can attacker DoS the node by flooding with proofs that have invalid parents/witnesses but valid hashes, forcing CPU-intensive hash verification before cheap structural checks?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Ball hash not validated] At lines 189-192, objUnit.last_ball is stored in assocLastBallByLastBallUnit keyed by last_ball_unit, but there's no verification that last_ball hash actually corresponds to the last_ball_unit - can attacker provide mismatched last ball hash/unit pair, breaking last ball chain integrity for light clients?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Ball existence for unstable units] At lines 171-172, the code returns error if objJoint.ball exists for unstable MC units, with comment 'unstable mc but has ball' - but what if a unit was just stabilized and now has ball? Does this cause legitimate proofs to be rejected during stabilization window, potentially freezing light client sync for hours?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Ball requirement for definition changes] At lines 206-207, witness definition change joints MUST have ball ('joint without ball' error), but this conflicts with the unstable joint check at line 171-172 - if a witness changes definition in an unstable unit, which rule wins? Can this create inconsistency where proofs are impossible to construct during certain DAG states?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Ball deletion timing] At line 32, balls are deleted from joints with comment about stabilization race, but at lines 189-192 processWitnessProof expects last_ball to exist in unstable units - does prepareWitnessProof delete last_ball field too, or only ball field? Can this cause processWitnessProof to fail on proofs generated by prepareWitnessProof?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Stable unit inclusion] At lines 107-136, the query selects units with is_stable=1 for witness definition changes, but the main unstable joints query at line 27 doesn't explicitly filter for is_stable=0 - can stable units leak into arrUnstableMcJoints, causing processWitnessProof to reject proof due to unexpected balls at line 171?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Definition chash mismatch] At lines 239-240, if author.definition exists, it's hashed and compared to definition_chash, returning error if mismatch - but if objectHash.getChash160() throws exception (line 242-243), the try-catch returns generic error message. Can attacker craft malformed definition that causes hash function to crash node or leak stack traces with sensitive info?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Definition cache poisoning] At line 245, assocDefinitions[definition_chash] = author.definition updates global cache with author-provided definition - if the definition hasn't been validated yet (only hash checked at line 239), can attacker poison cache with malicious definition that's used to validate subsequent signatures, bypassing actual stored definitions?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Definition not found exception] At lines 273-275, if storage.readDefinition() fails to find definition, it throws Error instead of calling callback with error - this breaks async error handling flow. Does the thrown Error crash the entire proof validation, causing denial of service where any missing definition prevents all light clients from syncing?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Signature validation bypass] At line 251, validateAuthorSignaturesWithoutReferences() is called but the function name suggests it skips reference validation - can attacker craft signatures that embed references to definitions not in assocDefinitions, bypassing the definition tracking and allowing unauthorized signatures to pass?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Definition chash initialization] At lines 291-295, if !bFromCurrent, all witnesses get address as definition_chash (assocDefinitionChashes[address] = address), but this assumes witness addresses haven't changed definitions - can attacker replay old proof with original address as definition when witness has since changed, allowing old signatures to validate against new witness state?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Definition change message validation] At lines 256-260, definition_chg messages are processed if payload.address matches author.address OR unit has single author - the OR condition allows single-author units to change ANY address's definition. Can attacker create single-author unit that changes victim witness's definition without authorization, bricking the witness or stealing funds?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Missing definition for non-witness] At lines 232-234, non-witness authors are skipped if definition_chash not in assocDefinitionChashes, but line 235-236 throws Error if witness has no definition_chash - can attacker exploit this by crafting units where witness authors have no definition_chash, causing unexpected Error to crash validation?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Last ball unit selection race] At lines 99-102, the newest last_ball_unit is selected from arrLastBallUnits by MAX main_chain_index, but if two units have same MCI (shouldn't happen but DB corruption could cause it), LIMIT 1 returns arbitrary unit - can this non-determinism cause different nodes to generate different proofs for same parameters, splitting light clients?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Already current bypass] At line 102, if last_stable_mci >= last_ball_mci, the function returns 'already_current' error, but what if last_stable_mci == last_ball_mci exactly? This edge case means the last ball unit is at the stable point - should proof still be generated to confirm stability, or does 'already_current' incorrectly reject valid proof requests?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Genesis last_ball_unit handling] At lines 40-42, the code checks objJoint.unit.last_ball_unit exists with comment '(genesis lacks last_ball_unit)' - if genesis IS in the unstable set (edge case during initial sync), does missing last_ball_unit cause arrLastBallUnits to remain empty, failing proof generation with 'too few witness authored units' at line 98?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Last ball units empty check] At lines 198-199, the code throws Error if arrLastBallUnits.length === 0, but this is throw not callback error - does this crash propagate to caller breaking all proof validation, or is it caught somewhere? Can attacker trigger this by sending proof with insufficient witnesses to DoS light client sync?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Multiple last ball units] At lines 55-56 and 66-72, arrLastBallUnits can contain multiple different last_ball_unit values from different unstable MC units, but at lines 99-103 only ONE is selected as THE last_ball_unit for the proof - does this mean proofs are non-deterministic if multiple valid last ball units exist at same time?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Database query order dependence] At line 82, the ORDER BY clause uses different columns for sqlite (rowid) vs mysql (creation_date) - if these don't produce same ordering, can nodes using different databases generate different witness proofs for identical chain state, causing light client consensus split?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Index hint bypass] At line 121, db.forceIndex('byDefinitionChash') forces specific index usage, but if this index is corrupt, missing, or has different definition in sqlite vs mysql schema, does the query fail silently returning empty results, causing witness definition changes to be invisible and signatures to fail validation?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Database check during validation] At lines 323-327, when bFromCurrent=true, the code queries DB to check if unit is already stable before validating - can this DB roundtrip be exploited for timing attacks where attacker sends many proofs causing DB query flooding, or does DB state change between check and validation causing race condition?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [UNION query result ordering] At lines 120-135, three SELECT queries are UNIONed and ordered by level, but SQL UNION may eliminate duplicates - if the same unit appears in multiple SELECTs (e.g., witness initially defines address AND later changes it), does deduplication cause definition change ordering to be wrong, validating signatures out of sequence?",
  "[File: byteball/ocore/witness_proof.js] [Function: storage.findWitnessListUnit()] [Witness list unit lookup] At line 79, storage.findWitnessListUnit() is called with 2^31-1 as parameter (MAX_INT), but if this function doesn't exist in storage.js or has different signature, does this cause undefined function error that crashes proof generation?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Early return in series] At lines 75-76 and 77-78, the async.series step returns cb() early if conditions are met, but at line 106-107, after_last_stable_mci_cond is constructed using last_stable_mci - if cb() was called early at line 76, does execution skip to final handler at line 152 leaving arrWitnessChangeAndDefinitionJoints uninitialized, causing processWitnessProof to fail?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Error string consistency] At lines 62, 78, 81, 84, 98, error messages are returned as strings like 'some witnesses have references in their addresses' - are these exact error strings checked by callers in network.js or light.js? If yes, any typo or rewording breaks error handling. If no, can attacker distinguish between real errors and attack-induced errors?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Async.eachSeries error propagation] At lines 226-285, validateUnit() uses nested async.eachSeries for authors (line 226) with callback cb3, but if one author fails validation, does cb3 error propagate correctly to cb2 (line 278-283), or can partial validation succeed leaving some authors unvalidated?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [ifNotFound callback] At lines 140-142, storage.readJoint() has ifNotFound callback that throws Error - this synchronous throw inside async callback breaks error handling. Does this crash the process, or is there a try-catch somewhere catching it? Can attacker cause missing joints to DoS node?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Callback vs throw inconsistency] At line 199, arrLastBallUnits.length === 0 causes throw Error, but at line 194-195, arrFoundWitnesses.length < MAJORITY_OF_WITNESSES causes handleResult() callback with error string - why different error handling patterns? Can caller handle both, or does throw bypass handleResult causing uncaught exception?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Definition reference check bypass] At lines 61-63, storage.determineIfWitnessAddressDefinitionsHaveReferences() is called and errors if witnesses have references in definitions - but what if this check is performed at time T1, then during async execution until line 155, a witness changes their definition to one WITH references? Does stale check result allow invalid proof to be created?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Reference check incomplete] The reference check at line 61-63 only checks current witness definitions, but definition change units collected at lines 105-151 may contain new definitions WITH references - are these new definitions also checked for references, or can witness upgrade to definition-with-references bypass the reference prohibition?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [No reference check in validation] In processWitnessProof(), there's no equivalent call to determineIfWitnessAddressDefinitionsHaveReferences() - if attacker sends proof with witnesses that have references in definitions, does validation accept it since check is missing, allowing light clients to accept proofs that full nodes would reject?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Witness list off-chain validation] At line 79, if no last balls found in current unstable range, code looks for witness_list_unit matching arrWitnesses - but if attacker provides arrWitnesses that no units on MC use (completely custom witness list), does this cause 'witness list might be too much off' errors at lines 78, 81, 84, 98, permanently preventing proof generation?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Witness list not persisted] The arrWitnesses parameter is used throughout validation but never checked against any stored witness list for the receiving node - can attacker send proof with completely different witness set than node expects, causing validation to pass but node to be unable to use the proof for chain advancement due to witness incompatibility?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Witness list compatibility] The code finds witness-authored units but never verifies that the witness list arrWitnesses is compatible with witness lists in the DAG - can two nodes using incompatible witness lists (sharing <1 witness) generate and validate proofs that reference different stability points, causing permanent network partition?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Memory exhaustion on large witness change history] At lines 138-148, ALL witness definition change units since last_stable_mci are loaded into arrWitnessChangeAndDefinitionJoints via async.eachSeries with no limit - if a witness has changed definitions thousands of times (malicious or legitimate), can this exhaust memory or take hours to process, causing DoS where proof generation never completes?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Memory exhaustion on deep unstable chain] At lines 26-48, ALL unstable MC units are loaded into arrUnstableMcJoints - if last stable MCI is very old (e.g., 1 million units ago due to witness inactivity), can this load gigabytes of units into memory, causing OOM crash and preventing any proofs from being generated?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Joint array mutation] At line 334, arrWitnessJoints.reverse() mutates the input array in-place - if caller reuses arrWitnessJoints after processWitnessProof() returns, will it be in reversed order causing bugs? Should this be arrWitnessJoints.slice().reverse() to avoid mutating caller's data?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [MCI boundary cases] At line 86, start_mci is calculated as findLastBallMciOfMci(findLastBallMciOfMci(main_chain_index)) - double nesting of findLastBallMciOfMci - what if main_chain_index is 0 or 1? Does findLastBallMciOfMci return -1 or null for genesis, causing SQL query with negative start_mci to return wrong results?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Empty arrWitnesses] If arrWitnesses is empty array [], does ValidationUtils.isValidAddress check at line 18 pass (empty.every() returns true in JavaScript), and subsequent witness counting at line 36-37 always fail to reach MAJORITY_OF_WITNESSES, causing all proof generation to fail with 'too few witness authored units'?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Empty proof arrays] If arrUnstableMcJoints is empty array [], does the for loop at lines 168-193 skip entirely, leaving arrFoundWitnesses empty and failing at line 194-195? But if arrWitnessChangeAndDefinitionJoints is also empty, should this be considered valid proof of no changes, or invalid proof?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Single author edge case] At lines 256-260, the condition (message.payload.address === address || objUnit.authors.length === 1 && objUnit.authors[0].address === address) has potential bug - if objUnit.authors.length === 1, does objUnit.authors[0].address === address always equal the message.payload.address check, making the OR redundant? Or can single-author unit have message.payload.address different from author address, allowing unauthorized definition changes?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Zero start_mci] If start_mci is 0 (genesis), does the SQL query 'main_chain_index>?' correctly select genesis unit with MCI=0, or does > operator exclude it requiring >= operator instead? Can this cause proofs starting from genesis to be invalid?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [storage.getMinRetrievableMci() trust] At line 66, storage.getMinRetrievableMci() is called to determine oldest units to scan - if this function returns incorrect value (too new due to aggressive archiving), can proof generation miss old witness definition changes, causing signatures to validate against wrong definitions for light clients?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [validation.hasValidHashes() assumptions] At lines 173-174 and 208-209, validation.hasValidHashes() is assumed to return boolean - if this function actually returns string error message or undefined on invalid hashes, does the if (!validation.hasValidHashes()) check incorrectly pass validation, accepting units with invalid hashes?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [validation.validateAuthorSignaturesWithoutReferences() contract] At line 251, this validation function is called - does 'WithoutReferences' mean it skips validating definition references entirely, or just skips loading referenced definitions? If former, can attacker craft definitions with malicious references that bypass security checks?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [storage.readJointWithBall() vs readJoint()] At line 31, storage.readJointWithBall() is used for unstable units, but at line 139, storage.readJoint() is used for definition changes - do these functions have compatible error handling and return formats? Can mismatch cause validation to fail unpredictably?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [storage.readDefinition() vs readDefinitionByAddress()] At lines 268-276 vs 300-311, two different storage functions are used to read definitions - do they have identical behavior and error callbacks? If readDefinitionByAddress() returns different results than readDefinition() for same address, can cached definitions mismatch between bFromCurrent=true and false cases?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Non-deterministic UNION ordering] At lines 120-135, three UNION queries are ordered by level, but if multiple units have identical level, SQL ORDER BY doesn't specify secondary sort column - can database return units in different order on different executions, causing prepareWitnessProof() to generate different arrWitnessChangeAndDefinitionJoints for same chain state on different nodes?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Timestamp-based ordering ambiguity] At line 82, MySQL uses ORDER BY creation_date for witness list unit lookup - if multiple witness list units have identical creation_date timestamp (same second), can LIMIT 1 return arbitrary unit, causing different nodes to use different witness list units as reference point?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Definition lookup race] At lines 268-276, if definition is not in cache, it's read from DB with storage.readDefinition() - if two nodes have different database states (one has definition, other doesn't due to archiving), can validation succeed on one node but fail on other, causing network split?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [async.eachSeries ordering guarantee] At lines 138-148, async.eachSeries is used to read joints in order from SQL result - does this guarantee that arrWitnessChangeAndDefinitionJoints has same ordering as SQL ORDER BY level? If async operations can complete out-of-order due to caching, can joint order be wrong?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [MCI arithmetic overflow] At lines 85-86, start_mci is calculated via nested findLastBallMciOfMci() calls - if main_chain_index is near MAX_SAFE_INTEGER, can intermediate calculations overflow JavaScript number limits, producing negative or invalid start_mci that breaks SQL query?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [2^31 - 1 magic number] At line 79, findWitnessListUnit is called with 2^31 - 1 as max_mci parameter - this is INT_MAX for 32-bit signed integers. If database uses 64-bit integers for MCI, does this artificially limit search space, potentially missing witness list units at higher MCIs?",
  "[File: byteball/ocore/witness_proof.js] [Function: findUnstableJointsAndLastBallUnits()] [Array length limits] At lines 23-24, arrUnstableMcJoints and arrLastBallUnits are standard JavaScript arrays - if unstable chain has more than MAX_SAFE_INTEGER units (unlikely but theoretically possible), can array operations silently fail or corrupt data?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [bRequireDefinitionOrChange flag] At line 224, validateUnit() takes bRequireDefinitionOrChange parameter, set to true for definition changes (line 322, 326) and false for witness joints (line 336) - if attacker sends witness joint that contains definition_chg message, does bFound flag at line 246, 259 incorrectly succeed without the requirement, bypassing definition change validation?",
  "[File: byteball/ocore/witness_proof.js] [Function: validateUnit()] [Definition change double application] At line 258, if address_definition_change message matches current author, assocDefinitionChashes[address] is updated - if same unit contains multiple definition_chg messages for same address, are they all processed in sequence (lines 254-261 in loop), potentially applying multiple definition changes in single unit?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Definition timeline consistency] At lines 316-330, definition changes are processed in order from arrWitnessChangeAndDefinitionJoints, but these units were selected from database with arbitrary level ordering - if witness changes definition in unit A (level 100) then again in unit B (level 99), does reverse level order cause definition changes to apply in wrong sequence?",
  "[File: byteball/ocore/witness_proof.js] [Function: processWitnessProof()] [Last ball chain verification] At lines 189-192, last_ball values are stored in assocLastBallByLastBallUnit keyed by last_ball_unit, but there's no verification that these form valid chain (each last_ball_unit's ball hash should match previous unit's last_ball) - can attacker send proof with broken last ball chain, tricking light clients about stability point?",
  "[File: byteball/ocore/witness_proof.js] [Function: prepareWitnessProof()] [Last ball MCI consistency] At lines 99-102, last_ball_unit and last_ball_mci are selected, but there's no check that last_ball_mci <= last_stable_mci parameter - can caller pass inconsistent last_stable_mci forcing proof to reference future stability point that doesn't exist yet?",
  "[File: byteball/ocore/formula/common.js] [Decimal Configuration Lines 11-18] [Non-deterministic execution] The Decimal.js library is configured with precision=15 and ROUND_HALF_EVEN rounding mode. If different nodes have different versions of Decimal.js or if floating-point edge cases produce slightly different rounding results near the precision boundary, can this cause non-deterministic AA formula evaluation across nodes, leading to permanent chain splits?",
  "[File: byteball/ocore/formula/common.js] [Decimal Configuration Lines 14] [Overflow exploitation] The maxE is set to 308, which is stated to be 'slightly wider' than IEEE754 double to handle overflowing datafeeds. Can an attacker craft a datafeed value exactly at 1.7e308 that gets saved as a string in datafeeds but is parsed as Decimal in formulas, causing different nodes to handle the value inconsistently (some as string, some as number) and diverge in AA execution?",
  "[File: byteball/ocore/formula/common.js] [Function: isFiniteDecimal() Lines 34-36] [Type confusion] The function checks if val.isFinite() AND isFinite(val.toNumber()). If a malicious formula constructs a Decimal value where val.isFinite() returns true but val.toNumber() returns Infinity (e.g., due to overflow during conversion), can this bypass validation and allow infinite values to enter AA state variables, causing arithmetic errors in subsequent operations?",
  "[File: byteball/ocore/formula/common.js] [Function: toDoubleRange() Lines 38-41] [Underflow silencing] This function converts underflowed decimals (values that round to zero when converted to double) to exactly Decimal(0). Can an attacker exploit this by creating formulas that rely on very small non-zero values (e.g., 1e-325) which get silently converted to zero, causing incorrect balance calculations or division-by-zero errors that weren't intended in the original formula logic?",
  "[File: byteball/ocore/formula/common.js] [Function: createDecimal() Lines 43-45] [Precision loss attack] The function calls new Decimal(val).times(1) to reduce precision. If an attacker passes a high-precision string (e.g., '0.123456789012345678901234567890') as input to an AA, does this function truncate it to 15 digits in a way that could allow precision-based attacks where the attacker exploits the difference between their local calculation (full precision) and the on-chain calculation (truncated)?",
  "[File: byteball/ocore/formula/common.js] [Function: toOscriptPrecision() Lines 48-50] [Rounding inconsistency] This function is meant to 'calculate the same result as Oscript would calculate' by converting to string representation. If there's a version mismatch between the Oscript interpreter and this JavaScript implementation, or if edge cases in string conversion differ across platforms/Node.js versions, can this create consensus failure where different nodes compute different string representations of the same numeric value?",
  "[File: byteball/ocore/formula/common.js] [Decimal Configuration Lines 12-13] [Rounding mode vulnerability] ROUND_HALF_EVEN is used (banker's rounding). In financial calculations where an AA divides fees or rewards, if an attacker can manipulate inputs to consistently fall on the .5 boundary (e.g., always 2.5, 4.5, etc.), can they exploit the even-rounding bias to systematically steal fractional amounts across many transactions that accumulate to significant value?",
  "[File: byteball/ocore/formula/common.js] [Decimal Configuration Lines 16-17] [Exponential notation bypass] The toExpNeg=-7 and toExpPos=21 settings control when numbers are displayed in exponential notation. Can an attacker craft formula inputs that exploit the boundary between standard and exponential notation (e.g., 9999999999999999999 vs 1e19) to cause string comparison mismatches or parsing errors when the value is later retrieved from state as a string?",
  "[File: byteball/ocore/formula/common.js] [Cache Variables Lines 5-7] [Cache poisoning] The cache, formulasInCache, and cacheLimit are exported as mutable objects. If an attacker can somehow execute code in the same Node.js process (e.g., via a compromised dependency or eval vulnerability elsewhere), can they directly modify the cache object to replace parsed formula ASTs with malicious ones, causing all nodes using the cached formula to execute attacker-controlled code?",
  "[File: byteball/ocore/formula/common.js] [Cache Limit Lines 5-7, 94-99] [Memory exhaustion via cache] The cacheLimit is set to 100 formulas. If an attacker deploys 101 different AAs (or triggers 101 unique formulas through data variations), the cache will thrash as it continuously evicts and re-parses formulas. Can this cause a DoS by making formula evaluation extremely slow, delaying transaction processing for more than 1 hour (Medium severity per Immunefi)?",
  "[File: byteball/ocore/formula/common.js] [Cache Implementation Lines 88-99 in evaluation.js] [Race condition in cache access] The cache check 'if(cache[formula])' followed by cache write 'cache[formula] = parser.results' is not atomic. In a multi-threaded or concurrent scenario (if Node.js event loop timing allows), can two simultaneous AA triggers with the same formula both miss the cache, parse twice, and cause one parsed result to overwrite the other, potentially leading to a corrupted cache entry if parsing is non-deterministic?",
  "[File: byteball/ocore/formula/common.js] [Cache Array Lines 6, 94-98] [Cache eviction order vulnerability] The formulasInCache array uses FIFO eviction (shift() removes oldest). If the 100 most recently used formulas include both benign and malicious AAs, and a critical frequently-used AA's formula gets evicted, can an attacker deliberately trigger cache thrashing by alternating between 101 different formulas to ensure the victim AA always requires reparsing, causing targeted DoS?",
  "[File: byteball/ocore/formula/common.js] [Function: fixFormula() Lines 94-99] [Hardcoded address whitelist bypass] This function contains 9 hardcoded testnet addresses that receive special formula fixing (replacing 'elsevar' with 'else var', etc.). If an attacker discovers that one of these addresses has a vulnerable formula with syntax that was accidentally 'fixed' to work, but the fix itself introduced a security bug, can they exploit the fact that only these specific addresses get the fix while new AAs cannot use the same pattern?",
  "[File: byteball/ocore/formula/common.js] [Function: fixFormula() Lines 95-96] [Mainnet vs testnet divergence] The fix only applies 'if (constants.bTestnet && [...addresses...].indexOf(address) >= 0)'. If there's a configuration error where a node accidentally runs in testnet mode while connected to mainnet peers (or vice versa), will this cause formulas to be parsed differently (with/without the fixes), leading to a permanent chain split between nodes with different bTestnet values?",
  "[File: byteball/ocore/formula/common.js] [Function: fixFormula() Lines 96] [Incomplete syntax fix] The function replaces 'elsevar' with 'else var', 'elseresponse' with 'else response', and 'elsebounce' with 'else bounce'. Are there other malformed syntax patterns (e.g., 'elseif', 'elsereturn', 'else{') that could exist in deployed AAs but aren't covered by this fix? Can an attacker deploy an AA using these patterns before this function is updated, causing the formula to be parsed incorrectly?",
  "[File: byteball/ocore/formula/common.js] [Function: fixFormula() Lines 94-99] [Address collision attack] If an attacker can generate a new address that matches one of the 9 hardcoded addresses through hash collision (extremely unlikely but theoretically possible with SHA256 weaknesses), can they deploy malicious AA code that gets 'fixed' in an unintended way, bypassing normal formula validation?",
  "[File: byteball/ocore/formula/common.js] [Function: fixFormula() Lines 96] [Regex injection via replace()] The .replace() calls use simple string replacement, not regex. However, if formula content includes patterns like 'elsevarelse var', does replace('elsevar', 'else var') create 'else varelse var', and can this be chained with subsequent formula parsing to inject unexpected tokens or break parsing in a way that causes formula execution to diverge from validation?",
  "[File: byteball/ocore/formula/common.js] [objBaseAssetInfo Lines 20-32] [Base asset property tampering] The objBaseAssetInfo is exported as a mutable object containing critical properties for the base 'bytes' asset (cap: TOTAL_WHITEBYTES, is_transferrable: true, etc.). If any code elsewhere in the codebase accidentally modifies this object (e.g., objBaseAssetInfo.cap = 0), will all subsequent AA executions use the corrupted asset info, potentially allowing AAs to believe the base asset is non-transferrable or has zero cap, causing logic errors?",
  "[File: byteball/ocore/formula/common.js] [objBaseAssetInfo Lines 21] [Total supply manipulation] The cap is set to constants.TOTAL_WHITEBYTES (presumably 1e15 bytes). If an AA formula queries asset info for the base asset and receives this hardcoded value, but the actual circulating supply differs (due to lost keys, burns, or bugs), can an attacker exploit this discrepancy to make incorrect assumptions about available supply and manipulate DeFi protocols that rely on accurate supply data?",
  "[File: byteball/ocore/formula/common.js] [objBaseAssetInfo Lines 31] [Definer address hardcoded] The definer_address is hardcoded as 'MZ4GUQC7WUKZKKLGAS3H3FSDKLHI7HFO'. If this address is compromised or if there's a protocol upgrade that changes the genesis address, will AAs still reference this stale hardcoded address, causing asset_info lookups to return incorrect definer information?",
  "[File: byteball/ocore/formula/common.js] [objBaseAssetInfo Lines 22-28] [Boolean property type confusion] Properties like is_private, is_transferrable, auto_destroy are hardcoded as false/true. If formula evaluation code elsewhere expects these to be numbers (0/1) instead of booleans, can this cause type coercion bugs where 'false == 0' evaluates differently than 'false === 0', leading to incorrect conditional logic in AA execution?",
  "[File: byteball/ocore/formula/common.js] [Function: clearObject() Lines 52-56] [Prototype pollution via clearObject] The function deletes all own properties of an object using Object.keys(obj). If obj has a malicious setter on __proto__ or constructor, and an AA formula triggers clearObject on a tainted object, can this lead to prototype pollution that affects all subsequent formula evaluations in the same process?",
  "[File: byteball/ocore/formula/common.js] [Function: assignObject() Lines 59-62] [Object reference confusion] This function clears target and assigns source properties while 'preserving the target object reference'. If AA code holds multiple references to the target object before assignObject is called, will all those references now point to the mutated object? Can this cause unexpected side effects where an AA's internal state gets overwritten by a later assignObject call meant for a different purpose?",
  "[File: byteball/ocore/formula/common.js] [Function: assignField() Lines 64-71] [Property descriptor override] The function uses Object.defineProperty with writable:true, configurable:true, enumerable:true. If the object already has a field with the same name but different descriptors (e.g., writable:false, configurable:false), will this override fail silently in strict mode, or can an attacker exploit this to freeze certain properties and prevent AA state updates?",
  "[File: byteball/ocore/formula/common.js] [Function: clearObject() Lines 53-55] [Delete side effects] Using 'delete obj[key]' can trigger setters or getters if they exist on the prototype chain. If an AA's state object inherits from a prototype with malicious setters, can calling clearObject inadvertently execute attacker-controlled code?",
  "[File: byteball/ocore/formula/common.js] [Function: assignObject() Lines 60-61] [Cyclic reference vulnerability] If source contains a cyclic reference to target (directly or through nested objects), will Object.assign create an infinite loop or throw an error, causing AA execution to fail and potentially freeze user funds if this occurs during a critical withdrawal operation?",
  "[File: byteball/ocore/formula/common.js] [Function: isValidValue() Lines 73-75] [Type whitelist bypass] The function only allows string, boolean, or finite Decimal values. Can an attacker pass null, undefined, NaN, Infinity, or object types that slip through this check and later cause type coercion bugs when the 'invalid' value is used in arithmetic operations or comparisons within AA formulas?",
  "[File: byteball/ocore/formula/common.js] [Function: isValidValue() Lines 74] [Decimal vs Number confusion] The check is 'typeof val === 'string' || typeof val === 'boolean' || isFiniteDecimal(val)'. If val is a regular JavaScript Number (not a Decimal object), will it fail this check even if it's a valid finite number? Can this cause valid numeric datafeed values to be rejected if they're not properly converted to Decimal before validation?",
  "[File: byteball/ocore/formula/common.js] [Function: isValidValue() Lines 73-75] [Empty string bypass] The function allows any string, including empty string ''. Can an AA exploit this by setting state variables to '' and later causing string-to-number coercion bugs where '' coerces to 0 in arithmetic but remains '' in string operations, leading to inconsistent behavior?",
  "[File: byteball/ocore/formula/common.js] [Function: isValidValue() Lines 74] [Boolean coercion attack] The function explicitly allows booleans. In JavaScript, booleans coerce to 0/1 in arithmetic. Can an attacker set AA state variables to boolean values and then exploit formulas that expect numbers, causing 'true + 10' to evaluate to 11 instead of throwing an error, potentially bypassing validation logic?",
  "[File: byteball/ocore/formula/common.js] [Function: getFormula() Lines 77-88] [Brace stripping vulnerability] The function checks if formula is enclosed in braces {} and strips them. If a malicious formula contains nested braces like '{{malicious code}}', will this function only strip the outer braces, leaving '{malicious code}' which might bypass subsequent validation that expects no braces?",
  "[File: byteball/ocore/formula/common.js] [Function: getFormula() Lines 78-79] [Exception vs null inconsistency] If bOptionalBraces is true, the function throws an Error. If false but formula lacks braces, it returns null. Can this inconsistency cause calling code to not properly handle the error case (expecting null but getting an exception), leading to unhandled promise rejections or process crashes?",
  "[File: byteball/ocore/formula/common.js] [Function: getFormula() Lines 80-87] [Empty formula bypass] If formula is exactly '{}', this function returns an empty string ''. Can an AA be deployed with an empty formula that passes validation but does nothing, potentially locking funds forever because there's no logic to release them?",
  "[File: byteball/ocore/formula/common.js] [Function: getFormula() Lines 82] [Unicode brace confusion] The function checks for ASCII braces '{' and '}'. Can an attacker use Unicode lookalike characters (e.g., U+FF5B '' or U+FF5D '') that appear as braces visually but aren't detected by this check, causing the formula to be incorrectly parsed or not stripped of its braces?",
  "[File: byteball/ocore/formula/common.js] [Function: getFormula() Lines 84-85] [Dead code branch] Lines 84-85 check 'else if (bOptionalBraces)' but line 78-79 already throw an error if bOptionalBraces is true, making this branch unreachable. Does this indicate a logic error where bOptionalBraces was intended to work but is currently disabled, and could re-enabling it introduce a security bug?",
  "[File: byteball/ocore/formula/common.js] [Function: hasCases() Lines 90-92] [Cases array validation bypass] The function checks if value is an object with exactly one key 'cases' that is a non-empty array. If an attacker passes {cases: []}, does ValidationUtils.isNonemptyArray correctly reject it, or can an empty cases array pass through and cause issues when the formula engine expects at least one case?",
  "[File: byteball/ocore/formula/common.js] [Function: hasCases() Lines 91] [Object prototype pollution] The check 'typeof value === 'object'' will also match null (since typeof null === 'object' in JavaScript). If value is null, will Object.keys(null) throw an error, causing AA validation to crash? Or does the check fail gracefully, potentially allowing null to be treated as a valid cases structure?",
  "[File: byteball/ocore/formula/common.js] [Function: hasCases() Lines 91] [Key count verification weakness] The function checks 'Object.keys(value).length === 1'. Can an attacker pass an object with inherited properties that aren't counted by Object.keys but still affect formula evaluation (e.g., {cases: [...], __proto__: {malicious: true}})?",
  "[File: byteball/ocore/formula/common.js] [Function: hasCases() Lines 91-92] [Cases array content validation] The function only checks that value.cases is a non-empty array but doesn't validate the content of each case. Can an attacker include malicious objects within the cases array (e.g., [null, undefined, {}]) that later cause formula evaluation to fail or behave incorrectly?",
  "[File: byteball/ocore/formula/common.js] [Exports Lines 101-119] [Module state sharing vulnerability] The cache, formulasInCache, cacheLimit, and objBaseAssetInfo are all exported as live references (not deep copies). If multiple AAs executing concurrently in the same Node.js process modify these shared objects (e.g., one AA corrupts the cache while another is reading it), can this cause race conditions leading to non-deterministic formula evaluation?",
  "[File: byteball/ocore/formula/common.js] [Decimal Export Line 105] [Decimal library version mismatch] The Decimal object is exported for use by other modules. If different parts of the codebase use different versions of Decimal.js (e.g., due to nested node_modules), will they have incompatible configurations (precision, rounding), causing formulas evaluated in one module to produce different results than formulas evaluated in another?",
  "[File: byteball/ocore/formula/common.js] [Function Exports Lines 108-119] [Function identity assumption] Functions like isFiniteDecimal, toDoubleRange, createDecimal are exported by reference. If malicious code elsewhere monkey-patches these functions (e.g., global.require.cache manipulation), can all AA formula evaluations be compromised without any visible changes to the common.js file itself?",
  "[File: byteball/ocore/formula/common.js] [Decimal Configuration Lines 11-18] [Global Decimal mutation] The Decimal.set() call modifies the global Decimal configuration. If any other code in the process also calls Decimal.set() with different settings (e.g., precision: 20), will this affect AA formula evaluation mid-execution, causing non-deterministic results depending on timing?",
  "[File: byteball/ocore/formula/common.js] [Function: toDoubleRange() Lines 38-41] [Zero comparison vulnerability] The function checks 'val.toNumber() === 0' to detect underflow. In JavaScript, -0 === +0 is true, but they're different values in IEEE754. Can an attacker exploit signed zero (-0) to cause subtle bugs in division operations (1/-0 === -Infinity vs 1/+0 === +Infinity)?",
  "[File: byteball/ocore/formula/common.js] [Function: createDecimal() Lines 43-45] [String input injection] The function calls 'new Decimal(val)' without validating that val is a safe input. Can an attacker pass a maliciously crafted string like '1e+99999999' that causes Decimal.js to hang or consume excessive memory during parsing?",
  "[File: byteball/ocore/formula/common.js] [Function: isFiniteDecimal() Lines 34-36] [NaN handling] The function checks isFinite(val.toNumber()), which returns false for NaN. However, if val is a Decimal representing NaN (created via invalid operations), can it pass val.isFinite() but fail isFinite(val.toNumber()), or vice versa, causing inconsistent validation?",
  "[File: byteball/ocore/formula/common.js] [Function: toOscriptPrecision() Lines 48-50] [Precision reduction side effects] The function calls 'new Decimal(num).times(1).toString()'. If num is already a Decimal with attached metadata or custom properties, does times(1) strip those properties, and can this cause issues if the formula engine expects metadata to be preserved?",
  "[File: byteball/ocore/formula/common.js] [objBaseAssetInfo Lines 20-32] [Immutability assumption] The object is defined with literal syntax but not frozen via Object.freeze(). The comment says properties are for the base asset, implying they should be immutable. If an AA formula accidentally or deliberately modifies these properties (e.g., objBaseAssetInfo.is_transferrable = false), will all subsequent AAs in the same process see the corrupted value?",
  "[File: byteball/ocore/formula/common.js] [Decimal Configuration Lines 11-18] [Rounding mode consensus] The ROUND_HALF_EVEN mode is banker's rounding, which behaves differently than ROUND_HALF_UP used in many financial systems. If an AA author assumes ROUND_HALF_UP behavior (because that's common in their local testing environment), but production uses ROUND_HALF_EVEN, can this cause the AA to behave unexpectedly, potentially transferring funds to unintended recipients?",
  "[File: byteball/ocore/formula/common.js] [Function: toDoubleRange() Lines 38-41] [Underflow determinism] When val.toNumber() === 0 due to underflow, the function returns new Decimal(0). If two nodes evaluate this at slightly different times or with slightly different CPU states, could they disagree on whether underflow occurred (due to timing-dependent floating-point operations), causing one node to use the original underflowed value while another uses exactly 0?",
  "[File: byteball/ocore/formula/common.js] [Cache Lines 5-7, 88-99] [Cache timing non-determinism] If two nodes process the same AA trigger at slightly different times, and one has the formula cached while the other doesn't (due to cache eviction timing), could the parsing step introduce non-deterministic behavior if the parser depends on external factors like system locale, timezone, or random number generation?",
  "[File: byteball/ocore/formula/common.js] [Function: fixFormula() Lines 94-99] [testnet flag race condition] If constants.bTestnet is read from a config file that can be modified while the node is running, can a testnet-to-mainnet transition mid-block cause some AAs in the same block to receive formula fixes while others don't, creating divergent state?",
  "[File: byteball/ocore/formula/common.js] [Cache Lines 5-7] [Cache size limit bypass] The cacheLimit is 100, but there's no enforcement on the total memory size of cached parser results. If an attacker deploys AAs with extremely large formulas (near the maximum allowed size), can 100 large formulas consume gigabytes of RAM, causing the node to OOM and crash?",
  "[File: byteball/ocore/formula/common.js] [Function: clearObject() Lines 52-56] [Deletion performance attack] The function iterates over all keys and deletes them individually. If an AA's state object has thousands of keys, will this operation take excessive time (O(n) deletions), causing transaction processing to slow down below 1 hour per block (Medium severity)?",
  "[File: byteball/ocore/formula/common.js] [Function: assignObject() Lines 59-62] [Object.assign performance] If source has a deeply nested structure with thousands of properties, will Object.assign perform a deep copy or shallow copy? If shallow, can an attacker exploit shared references between AAs? If deep, can it cause performance degradation during AA response composition?",
  "[File: byteball/ocore/formula/common.js] [Function: getFormula() Lines 82] [String slicing performance] The function uses str.slice(1, -1) to remove braces. For extremely large formulas (near max allowed size), is slice() O(n) complexity? If called repeatedly during validation, could this cause validation to take excessive time?",
  "[File: byteball/ocore/formula/common.js] [fixFormula Usage in evaluation.js Line 60] [Formula preprocessing order] In formula/evaluation.js, fixFormula is called before parsing. If an attacker can influence the order of formula preprocessing (e.g., by nesting multiple layers of formula definitions), can they cause fixFormula to be applied multiple times, potentially creating 'else else var' or other malformed syntax that crashes the parser?",
  "[File: byteball/ocore/formula/common.js] [Cache Usage in evaluation.js Lines 88-99] [Cache invalidation vulnerability] When a formula is added to cache, there's no mechanism to invalidate it if the formula is later found to be malicious or buggy. If an AA is deployed, cached, and then discovered to have a critical vulnerability, will all nodes continue executing the cached (vulnerable) version until they restart, allowing the attacker to exploit it before patches are applied?",
  "[File: byteball/ocore/formula/common.js] [Decimal Usage in evaluation.js] [Precision propagation] When evaluation.js uses createDecimal() to convert user inputs, and those Decimals are then used in complex arithmetic formulas, can accumulated rounding errors cause significant divergence from the expected result? For example, if an AA computes a 10-step calculation with 15-digit precision at each step, could the final result differ from what a user calculated with full precision?",
  "[File: byteball/ocore/formula/common.js] [isValidValue Usage in validation.js] [Validation escape] If formula/validation.js uses isValidValue to check formula outputs before writing to state, but formula/evaluation.js doesn't use it consistently, can an AA exploit the gap by producing outputs during evaluation that wouldn't pass validation, but get written to state anyway because evaluation doesn't validate?",
  "[File: byteball/ocore/formula/common.js] [toDoubleRange Usage in validation.js Lines 32, 92] [Validation-execution mismatch] During formula validation, toDoubleRange is used to convert Decimal values to double range before comparison. If a formula is validated with certain input values that fall within double range, but executed later with slightly different inputs that underflow, will the execution result differ from what validation predicted, potentially allowing bounces to occur unexpectedly?",
  "[File: byteball/ocore/formula/common.js] [isFiniteDecimal Usage in validation.js Lines 30, 90] [Finite validation bypass] If validation.js checks isFiniteDecimal on formula parameters but evaluation.js doesn't recheck it during execution, can an attacker exploit a timing attack where they pass finite values during validation but somehow inject infinite values during execution (e.g., via datafeed manipulation)?",
  "[File: byteball/ocore/formula/common.js] [Function: getFormula() Lines 80-81] [String type coercion] The function checks 'typeof str !== 'string''. In JavaScript, this means str could be a String object (new String('...')). Will the indexing operations str[0] and str[str.length-1] work correctly on String objects, or could this cause subtle bugs if an AA passes a String object instead of a string primitive?",
  "[File: byteball/ocore/formula/common.js] [Function: fixFormula() Lines 96] [Unicode normalization] The replace() operations look for exact ASCII strings 'elsevar', 'elseresponse', 'elsebounce'. If an attacker uses Unicode equivalents or combining characters that visually appear the same but differ in byte representation, can they bypass the fix and deploy broken formulas on testnet addresses?",
  "[File: byteball/ocore/formula/common.js] [Function: toOscriptPrecision() Lines 49] [toString() locale dependency] The .toString() method on Decimal might respect system locale in some configurations (e.g., comma vs period as decimal separator). If two nodes have different locales, could Decimal.toString() produce '1,5' on one node and '1.5' on another, causing consensus failure?",
  "[File: byteball/ocore/formula/common.js] [Decimal Configuration Lines 16-17] [Exponential notation ambiguity] The toExpNeg and toExpPos settings determine when toString() uses exponential notation. If an AA writes a state variable with value 1e-7 (right at the boundary), will it be stored as '0.0000001' or '1e-7'? If different nodes make different choices due to implementation differences, can this cause state divergence?",
  "[File: byteball/ocore/formula/common.js] [objBaseAssetInfo Lines 27] [issued_by_definer_only flag] This is set to true for the base asset, meaning only the definer can issue more. But the base asset's total supply is fixed at genesis. Does this flag create confusion where code checks this flag and incorrectly believes the definer can mint new base bytes, potentially creating logic errors in DeFi protocols?",
  "[File: byteball/ocore/formula/common.js] [Function: assignField() Lines 64-71] [Enumerable property attack] By forcing enumerable:true, can an attacker exploit this to make properties visible to Object.keys() or for...in loops that should be hidden? For example, if AA state variables are supposed to be non-enumerable to prevent iteration attacks, but assignField makes them enumerable, can this expose internal state?",
  "[File: byteball/ocore/formula/common.js] [Function: clearObject() Lines 52-56] [Getter/setter triggers] If obj has getters/setters defined via Object.defineProperty, will deleting those properties trigger the setter one last time with undefined? Can an attacker define malicious setters that execute code during clearObject, potentially causing reentrancy-like issues where AA state is accessed mid-clear?",
  "[File: byteball/ocore/formula/common.js] [Lines 2-3] [Dependency imports] The file imports ../constants and ../validation_utils. If either of these modules is compromised or contains bugs, can it affect all AA formula evaluations? For example, if constants.TOTAL_WHITEBYTES is incorrect, will objBaseAssetInfo.cap be wrong, and can AAs exploit this?",
  "[File: byteball/ocore/formula/common.js] [Line 1] [Decimal.js library vulnerability] The entire formula engine depends on the Decimal.js library. If a security vulnerability is discovered in Decimal.js (e.g., in parsing, arithmetic, or conversion functions), can it be exploited through AA formulas to cause incorrect calculations or consensus failure?",
  "[File: byteball/ocore/formula/common.js] [Cache Limit Line 5] [Hardcoded cache limit] The cacheLimit is hardcoded to 100. If the network grows to have thousands of active AAs, will this limit become a bottleneck? Can an attacker exploit the low limit by deploying 101 frequently-used AAs, ensuring that the most popular community AAs (like DeFi protocols) constantly miss cache, causing network-wide slowdowns?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() arithmetic ops] [Precision Loss] Can an attacker craft a formula with deeply nested decimal operations that accumulates rounding errors through toDoubleRange() calls at lines 179, 202, 218, causing state variable values to diverge across nodes and leading to permanent chain split?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() pow operation] [Overflow] At lines 183-204, when computing fractional powers using ln().times(res).exp(), can an attacker provide extreme base and exponent values that cause intermediate ln() results to overflow Double.MAX_VALUE, bypassing the finite check and corrupting state calculations?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() pow operation] [DoS] At line 189, the check res.abs().gte(Number.MAX_SAFE_INTEGER) only applies to integer exponents - can an attacker use a fractional exponent like 0.5 with extremely large magnitude to cause exponentially expensive exp() computation that freezes the node for hours?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() division] [Division by Zero] When division operation (op='/') is evaluated at lines 154-156, if the divisor evaluates to exactly zero after toDoubleRange(), does the Decimal.div() throw an error that gets caught and causes bounce, or does it produce Infinity that passes through the isFiniteDecimal() check at line 216?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() modulo] [Negative Modulo] At line 158 (op='%'), can an attacker exploit non-deterministic modulo behavior when operands are negative, where different JavaScript engines might produce different results for (-5) % 3, causing nodes to diverge on state variable updates?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() sqrt/ln] [Negative Input] At lines 240-241, sqrt and ln operations check res.isNegative() and return error - but if res is exactly -0 (negative zero), does isNegative() return false, allowing sqrt(-0) to proceed and potentially produce NaN that bypasses finite checks?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() round/ceil/floor] [Decimal Places Overflow] At lines 267-268, the dp (decimal places) parameter is validated to be 15, but can an attacker pass a Decimal that equals exactly 15.9999999 which gets converted to 15.toNumber() but internally stores fractional part, causing non-deterministic rounding behavior?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() hypot] [Catastrophic Cancellation] At line 333, Decimal.hypot() computes sqrt(a+b+...) - for very large numbers close in magnitude, can precision loss from squaring cause incorrect results that differ across nodes running different Decimal.js versions?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() arithmetic] [Non-deterministic Conversion] At lines 173-177, strings are converted to numbers only after testnetStringToNumberInArithmeticUpgradeMci - can an attacker exploit the bLimitedPrecision parameter in string_utils.toNumber() to cause different nodes (with different precision settings) to parse '1.23e100' differently, causing state divergence?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() comparison] [Type Coercion Race] At lines 473-477, when comparing string with Decimal, strings are toString()-ed - if val2 is a Decimal like 1.000000000000000001, does toString() produce different string representations on different platforms, causing comparison operators to yield non-deterministic results?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() and/or] [Early Abort Logic] At lines 366-367 and 394-395, 'and' and 'or' operators use early abort with cb('done') - can an attacker craft a formula where the early abort prevents necessary side effects (like state variable updates in later operands) from executing, causing state inconsistency?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluate() comparison] [Object Equality] At lines 424-426, objects are compared using _.isEqual() - can an attacker craft two wrappedObjects with properties in different orders that _.isEqual() considers equal, but JSON.stringify() would serialize differently, causing non-determinism when these objects are stored as state variables?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: getDataFeed()] [Oracle Address Injection] At lines 547-549, oracle addresses are split by ':' delimiter without sanitization - can an attacker inject a malformed address containing ':' characters to bypass the isValidAddress() check and query data from unintended oracles?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: getDataFeed()] [Race Condition] At line 588, dataFeeds.readDataFeedValue() is called asynchronously - if the same AA is triggered by two units simultaneously reading the same data feed 'last' value, can they see different values if a new oracle post arrives between the two reads, causing non-deterministic execution?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: getDataFeed()] [Min MCI Bypass] At lines 562-566, min_mci is validated as nonnegative integer - but if attacker passes a Decimal like 0.9 that gets parsed as '0' string and then parseInt() to 0, can they bypass intended min_mci restrictions to access older/invalid oracle data?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: getDataFeed()] [Type Confusion] At lines 596-598, data feed values are returned as strings or Decimals depending on 'type' parameter - if an attacker switches from type='auto' to type='string' for the same feed between triggers, can this cause state variables to store different types for the same semantic value, breaking comparisons?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: getDataFeed()] [ifseveral Abort Inconsistency] At lines 569-572 and 591-592, ifseveral='abort' returns error if multiple values found - but this check happens after reading from database, so timing-dependent oracle posts could cause one node to see 1 value (proceeds) while another sees 2 values (aborts), causing permanent divergence?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: in_data_feed()] [Relation Operator Bypass] At line 676, the relation parameter from feed_value.operator is passed to dataFeedExists() without validation - can an attacker inject operators like '>=' or '<=' that aren't properly handled, causing incorrect boolean results?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: findOutputOrInputAndReturnName()] [Ambiguity Handling] At lines 745-747, when multiple matching inputs/outputs are found, an empty string '' is returned - but this is indistinguishable from 'not found' case at line 751, so can an attacker craft a unit with 2 matching outputs to make the formula return false instead of error, bypassing intended validation?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: findOutputOrInputAndReturnName()] [Asset Comparison] At lines 704-708, asset filtering uses operator='=' or '!=' - if payload_asset is 'base' and filter asset is null/undefined, does the comparison asset === 'base' incorrectly include/exclude base asset outputs?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: findOutputOrInputAndReturnName()] [Amount Operator Injection] At lines 727-741, amount comparison operators are checked in switch statement - but if objParams.amount.operator contains an unexpected value like '===' or 'IN', does it throw Error (line 741) that gets caught improperly, or does it silently proceed with undefined behavior?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: attestation case] [SQL Injection] At line 886, the field parameter is directly inserted into SQL with conn.escape(field) - but if field contains SQL escape sequences or Unicode characters that conn.escape() doesn't handle properly, can an attacker inject SQL to read arbitrary attested_fields values?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: attestation case] [Race Condition] At lines 904-942, attestations are queried first from unstable units (MCI>mci or NULL), then stable units (MCImci) - can an attacker exploit the time gap between these two queries to cause non-determinism if an unstable unit becomes stable mid-query?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: attestation case] [Count Overflow] At line 889 (count_rows), if the attacker triggers the same attestation query simultaneously from multiple formulas in the same unit, can count_rows be incremented incorrectly, causing 'several attestations found' error when there's actually only one?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: attestation case] [ifnone Type Preservation] At line 937, params.ifnone.value is returned 'even if no field' - if field was false (lines 867-879) indicating 'just fact of attestation', returning ifnone value breaks the boolean semantics and can cause type confusion in subsequent operations?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: attestation case] [Attestor Address Bypass] At lines 843-847, arrAttestorAddresses is split by ':' and validated - but can an attacker provide a single valid address, and then later in the same AA execution, modify the attestors parameter to add more addresses via state variable manipulation?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: concat case] [Length Bypass] At lines 971-974, concat returns error if result.length > MAX_AA_STRING_LENGTH (line 972), but the check happens AFTER concatenation - can an attacker concatenate two strings each of length MAX_AA_STRING_LENGTH/2 + 1 to temporarily create an oversized string in memory that causes OOM before the check triggers?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: concat case] [Object Type Confusion] At lines 2584-2593, concat handles wrappedObject+wrappedObject by checking Array vs Object - but if obj0 has Array.prototype but is actually an object with numeric keys {'0':'a', '1':'b'}, does Array.isArray() return false causing incorrect 'trying to concat object and array' error?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: substring] [Negative Index] At lines 1910-1929, start and length parameters are validated as integers but not checked for negativity - does substr() with negative start behave consistently across JavaScript engines, or can it cause non-deterministic string extraction?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: replace] [Replacement Length] At lines 1980-1984, after replace operation, new_str length is checked - but if search_str is empty string '', does split('') create an array of length str.length+1 that, when joined with long replacement, causes exponential memory usage before the length check?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: has_only] [Regex Injection] At lines 1884-1887, the sub parameter is sanitized by replacing ']' with '\\\\]' and checking for '\\\\]' at end - but can an attacker inject other regex metacharacters like '^', '$', '*', '+' that cause RegExp to behave unexpectedly or hang in catastrophic backtracking?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: split] [Limit Bypass] At lines 2015-2027, limit parameter is validated as nonnegative integer - but if limit=0, does res.split(separator, 0) return [] or [res]? Non-determinism here could cause nodes to store different array lengths in state variables?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: join] [Non-Scalar Elements] At lines 2033-2035, join checks that all elements are scalars (string, number, boolean) - but if an element is a Decimal that's not finite, it passes the typeof check but toString() might return 'Infinity', causing the joined string to contain non-reproducible values?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: local_var_assignment] [Reassignment Race] At lines 1154-1156, reassignment is forbidden unless selectors are present - but if two assignments to the same var happen in parallel async operations (via nested function calls), can both pass the hasOwnProperty() check before either completes, allowing double assignment?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: local_var_assignment] [Frozen Variable Bypass] At lines 1159-1160, frozen variables cannot be mutated - but if the frozen flag is stored on the wrappedObject instance, can an attacker create a new wrappedObject with same obj content but unfrozen flag, and assign it to bypass the freeze check?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: local_var_assignment] [Shadow Variable] At lines 1172-1173, function args that shadow local vars are rejected - but if a function is declared inside another function, can inner function args shadow outer function args, creating scoping confusion that causes wrong variable values to be used?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: local_var_assignment] [Selector Key Injection] At lines 1193-1203, evaluateSelectorKeys() converts keys to strings/numbers - if an attacker passes a Decimal key like 0.0 vs 0.00, do they both become key '0', or do they create separate keys '0.0' and '0.00', causing inconsistent object mutation?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: state_var_assignment] [Name Length Bypass] At line 1252, state var name length is checked AFTER evaluation - can an attacker use a formula that dynamically constructs a long var name to bypass validation-time checks and only fail at assignment time, after side effects have occurred?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: state_var_assignment] [Object Serialization] At lines 1241-1248, wrappedObjects are serialized to JSON and length-checked - but if the object contains circular references (even though they should be impossible), does getJsonSourceString() throw an error that's not properly caught, causing the entire AA execution to abort instead of bounce?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: state_var_assignment] [Operator Race] At lines 1259-1305, different assignment operators (=, +=, -=, *=, /=, %=, ||=) read old value then update - if the same state variable is updated twice in the same formula (via separate statements), does the second update see the first update's value, or the original value from stateVars cache?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: state_var_assignment] [old_value Initialization] At lines 1284-1285, old_value is set to dec0 for += and -= operators if it was undefined - but this happens AFTER the value has been used in arithmetic, so is the old_value stored in stateVars[address][var_name] reflecting the actual value or the defaulted dec0?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: response_var_assignment] [Infinite Loop] At lines 1326-1330, Decimal values are converted to JS numbers - if the Decimal is extremely close to Number.MAX_VALUE, can toNumber() produce Infinity that passes isFinite() check initially but becomes non-finite during storage, causing inconsistent response vars?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: readVar()] [Cache Poisoning] At lines 2610-2612, stateVars cache is checked first before database - if an attacker can trigger multiple AA executions in parallel that read the same var before any writes are committed, can they all get false from cache while database contains actual value, causing all AAs to initialize var incorrectly?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: readVar()] [Type Ambiguity] At lines 2620-2631, database values are converted - numbers become Decimals, objects become wrappedObjects - but if database contains string '123' vs number 123, does bLimitedPrecision cause one to be parsed as Decimal and other to remain string, causing type confusion?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: readVar()] [Old Value Tracking] At line 2632, old_value and original_old_value are both set to the read value - but if this var is updated multiple times in the same AA, does old_value get overwritten, causing += operator to accumulate incorrectly on subsequent updates?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: readBalance()] [Asset Validation Timing] At lines 1409-1410, asset is validated as 'base' or valid hash - but if the asset hash is valid but the asset doesn't exist yet, does the query at lines 1417-1424 return balance=0, which might differ from the 'asset not found' error that should be returned?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: readBalance()] [Balance Cache Race] At lines 1412-1416, balance is first checked in objValidationState.assocBalances cache - if two AA executions in the same trigger cascade both read the same balance, then the first one sends payment reducing the balance, does the second AA see the old cached balance or updated balance?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: asset case] [Field Injection] At line 1438, field is validated using objBaseAssetInfo.hasOwnProperty(field) - but if objBaseAssetInfo is a prototype-polluted object where attacker has added a field like '__proto__', can they read unintended asset properties?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: asset case] [Sequence Check] At line 1451, objAsset.sequence must be 'good' - but if asset was defined in an unstable unit that later becomes bad, does this check prevent access to the asset info, potentially breaking AAs that rely on the asset's existence?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: readAssetInfoPossiblyDefinedByAA()] [Timing Attack] At lines 2943-2944, if objAsset.main_chain_index > mci, it checks if defined by AA - can an attacker time their AA trigger to arrive exactly when an asset is being defined, causing different nodes to have different views of whether the asset is visible?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: unit case] [Response Unit Leakage] At lines 1478-1480, if objResponseUnit matches the queried unit, it's returned immediately - but objResponseUnit contains the full unit object including private data - can an attacker query their own response unit to access sensitive information that shouldn't be visible?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: unit case] [Previous Response Iteration] At lines 1482-1486, arrPreviousAAResponses is iterated without bounds check - can an attacker cause a very long cascade of AA responses to make this loop expensive, causing DoS during unit query evaluation?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: unit case] [Temp Data Deletion] At lines 1505-1507, temp_data is deleted from unit messages - but this modifies the objUnit object that's retrieved from storage - can this mutation affect other concurrent queries to the same unit, causing non-deterministic results?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: unit case] [Timestamp Injection] At line 1500, units without timestamp get timestamp=0 - can an attacker query such units and use timestamp=0 in time-based logic to bypass timestamp validation, allowing them to execute actions that should only work at genesis?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: definition case] [MCI Race] At lines 1527-1530, definition_unit's MCI is checked - if the unit is in the process of being stabilized (MCI transitioning from null to a value), can different nodes see different MCI values, causing one node to return the definition while another returns false?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: definition case] [Non-AA Definition Timing] At lines 1534-1541, ifFound callback is called for non-AA definitions - but if the address changes its definition via definition_chg message between query and callback, can the callback return a stale definition that no longer matches the address?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: is_valid_signed_package] [Version Bypass] At lines 1562-1568, version is checked with maxVersion=4 - but this is a hardcoded constant, so when the protocol upgrades to version 5, will existing AAs break, or will they accept version 5 packages incorrectly?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: is_valid_signed_package] [Last Ball Race] At line 1573, last_ball_mci is checked - if last_ball_mci is null (unit not stable yet), the check 'last_ball_mci > mci' is false, allowing unstable signed packages to be considered valid, which could be front-run or reorged?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: is_valid_sig] [Signature Length] At line 1595, signature is checked to be 1024 bytes - but very long signatures could contain padding that, when verified, causes the signature library to allocate excessive memory or take long time, causing DoS?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: is_valid_sig] [PEM Key Validation] At lines 1602-1605, PEM key is validated with signature.validateAndFormatPemPubKey() - if this function has a parser vulnerability that accepts malformed keys, can attacker inject a key that causes verifyMessageWithPemPubKey() to crash or hang?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: vrf_verify] [Algorithm Restriction] At line 1634, vrf_verify only accepts RSA keys - but VRF (Verifiable Random Function) typically uses elliptic curve crypto, not RSA - is this implementation using a non-standard VRF algorithm that might have weaker security properties?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: is_valid_merkle_proof] [Proof Deserialization] At lines 1662-1664, if proof is a string, it's deserialized with merkle.deserializeMerkleProof() - can an attacker provide a maliciously crafted proof string that causes deserialization to produce a valid-looking but incorrect proof object that verifyMerkleProof() accepts?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: sha256] [Object Serialization Non-Determinism] At lines 1679-1683, wrappedObjects are serialized with getJsonSourceString() before hashing - if the object contains Decimals or special values, does serialization produce identical strings across all nodes, or can JavaScript implementation differences cause different sha256 hashes?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: sha256] [Format Confusion] At lines 1691-1701, format parameter can be 'base64', 'hex', or 'base32' - if an attacker requests 'base32' format and then later requests 'hex' format for the same input, can they exploit the different encoding lengths to cause collision attacks or length extension attacks?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: chash160] [Object vs String Hash] At lines 1710-1717, objects use objectHash.getChash160() while strings use chash.getChash160() - can an attacker create a string that, when hashed with chash, collides with the chash160 of an object, allowing them to forge object identities?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: number_from_seed] [Seed Collision] At lines 1749-1752, seed is hashed with SHA256 and first 16 hex chars are used - can an attacker brute-force seeds to create collisions in the 64-bit space, allowing them to predict random numbers generated by other AAs?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: number_from_seed] [Min/Max Validation] At lines 1766-1769, min and max must be integers and max>min - but if min and max are both very large (near Number.MAX_SAFE_INTEGER), does the arithmetic at lines 1770-1771 overflow, causing incorrect random number generation?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: json_parse] [Prototype Pollution] At line 1790, JSON.parse() is called on user input - if the parsed JSON contains '__proto__' or 'constructor' keys, can this pollute the object prototype and allow attacker to inject properties into all objects?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: json_parse] [Number Precision Loss] At lines 1798-1799, parsed numbers are converted to Decimals - but JSON.parse() first parses them as JavaScript numbers, potentially losing precision for large integers - can this cause 123456789012345678 to become 123456789012345680, creating inconsistencies?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: json_stringify] [Circular Reference] At line 1821, getJsonSourceString() is called - if the object somehow contains circular references (perhaps through cloneDeep bugs), will this throw an error that's properly caught and bounced, or will it cause a stack overflow?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: json_stringify] [Empty Object Handling] At line 1820, bAllowEmpty flag depends on MCI - before aa2UpgradeMci, empty objects/arrays might be stringify-ed differently - can this cause AAs to behave differently depending on when they were triggered, breaking determinism?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: array case] [Decimal Conversion] At lines 1080-1082, Decimals in arrays are converted to JavaScript numbers - if the Decimal is a very precise fractional value like 0.1234567890123456789, does toNumber() lose precision, and will this cause state variables to store different values than what the formula computed?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: dictionary case] [Key Collision] At lines 1101-1113, keys are strings but evaluated values can be Decimals that get converted to numbers - if two keys '1' and '1.0' both exist, do they map to the same field, causing the second assignment to overwrite the first?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: is_array vs is_assoc] [Type Confusion] At lines 2088-2091, is_array returns true for arrays, is_assoc for objects - but if attacker creates an object with only numeric keys like {0:'a', 1:'b', 2:'c'}, does Array.isArray() correctly return false, or can this confuse code that expects arrays?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: keys] [Key Ordering] At line 2118, Object.keys() is sorted - but if keys contain Unicode characters, does sort() produce deterministic ordering across locales, or can different node locale settings cause different key orders, breaking determinism?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: reverse] [Deep Copy] At line 2123, array is reverse()-ed after cloneDeep() - but if the array contains wrappedObjects with circular references, can cloneDeep() fail to copy properly, causing reverse() to mutate the original array stored elsewhere?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: freeze] [Shallow Freeze] At line 2138, only the wrappedObject is marked frozen, not its contents - can an attacker access a nested object inside the frozen var and mutate it, bypassing the freeze protection?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: delete] [Array Splice Side Effects] At line 2177, splice() is used to delete array elements - if the array is also referenced by another variable in the same formula, does splice() mutate both references, causing unexpected side effects?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: foreach/map/filter/reduce] [Count Validation Bypass] At lines 2214-2215, count parameter limits iterations - but if attacker provides count=MAX_SAFE_INTEGER and the array has fewer elements, the check 'arrElements.length > count' is false - can they still cause DoS by having a very expensive function called many times?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: foreach/map/filter/reduce] [Accumulator Type Change] At lines 2226-2242 (reduce), accumulator starts as initial_value but gets reassigned - if the function returns different types (number, then string, then boolean) across iterations, can this cause type confusion when accumulator is finally returned?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: foreach/map/filter/reduce] [Remote Function DoS] At lines 2252-2260, remote function can be called in loops - if the remote AA's getter has high complexity, and count=1000, can attacker cause the calling AA to execute 1000 expensive remote calls, exceeding gas limits?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: map] [Return Value Conversion] At line 2266, map result is converted with toJsType() - if the function returns a Decimal, it becomes a JavaScript number - can this precision loss cause the mapped array to contain incorrect values when stored in state?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: filter] [Deep Clone Cost] At lines 2276-2278, filtered elements are cloneDeep()-ed - if the array contains very large objects, can repeated cloneDeep() calls exhaust memory before the filter completes, causing OOM crash?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: selectSubobject()] [Search Criteria Injection] At lines 2710-2830, search_param_list allows complex filtering with comparison operators - can an attacker inject malicious comparison expressions that cause the filter function to hang or produce non-deterministic results?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: selectSubobject()] [Type Coercion in Filter] At lines 2808-2811, if val is string and search_value is number, string is converted to number - but if conversion fails (f===null), it's not converted - can this cause some nodes to match the search criteria while others don't, depending on whether they parse the string successfully?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: selectSubobject()] [Empty Array After Filter] At lines 2826-2828, empty filtered arrays return error 'empty array after filtering' - but this happens AFTER expensive filtering operation - can attacker craft filters that always produce empty results to waste computation?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: assignByPath()] [Key Type Confusion] At lines 2674-2694, keys can be numbers or strings - if key is number 1 vs string '1', do they create separate properties in object, or do they refer to the same property, causing assignment conflicts?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: assignByPath()] [Array Gap Creation] At lines 2680-2681, if pointer[key-1] is undefined/null, error is thrown - but can attacker set key-2 to undefined to bypass this check and create array gaps like [,,,value] that cause iteration issues?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: evaluateSelectorKeys()] [Null Key Handling] At lines 2642-2644, null keys are pushed directly without evaluation - but later in assignByPath() at line 2674-2677, null means 'next array element' - can this special meaning be exploited to inject elements at unintended positions?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: unwrapOneElementArrays()] [Recursive Unwrapping] At line 2957, single-element arrays are recursively unwrapped - if attacker creates deeply nested single-element arrays [[[[...]]]]], can this cause stack overflow during unwrapping?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: callFunction()] [Scope Variable Shadowing] At lines 2838-2840, func_locals is populated with scopeVarNames - if a variable was deleted from locals after function declaration, can accessing it in func_locals return undefined instead of false, breaking function logic?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: callFunction()] [Argument Default Value] At lines 2845-2846, missing arguments default to false - but if the function expects a number or string, false behaves differently than 0 or '', potentially causing type errors inside the function?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: callFunction()] [Early Return Persistence] At lines 2855-2859, early_return is used and then set to undefined - if an exception occurs after setting early_return but before restoring locals, does early_return persist to the next function call, causing incorrect return value?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: callGetter()] [Storage Size Manipulation] At line 3053, objValidationState.storage_size is rewritten with the remote AA's storage size - if the remote AA has very large storage, can this cause the calling AA's formula to incorrectly believe it has large storage, bypassing storage limits?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: callGetter()] [Params Confusion] At line 3059, params from remote AA are passed - if remote AA's params object has been tampered with (contains __proto__ keys), can this pollute the calling AA's state?",
  "[File: byteball/ocore/formula/evaluation.js] [Function: callGetter()] [Infinite Recursion] At lines 3038-3109, callGetter can call another getter which calls another getter - is there a recursion depth limit? Can attacker create circular getter calls (AA1.getter1 calls AA2.getter2 which calls AA1.getter1) to cause stack overflow?",
  "[File: byteball/ocore/formula/validation.js] [Function: validateDataFeed()] [Oracle address validation] Can an attacker bypass the oracle address validation by crafting oracle addresses with leading/trailing whitespace that pass ValidationUtils.isValidAddress() but resolve to different addresses during execution, allowing unauthorized data feed access?",
  "[File: byteball/ocore/formula/validation.js] [Function: validateDataFeed()] [Oracle list parsing] When parsing the oracles parameter using split(':'), can an attacker inject empty strings or malformed addresses between colons (e.g., 'ADDRESS1::ADDRESS2') that bypass the validation but cause evaluation errors, leading to AA execution failures and temporary fund freezing?",
  "[File: byteball/ocore/formula/validation.js] [Function: validateDataFeed()] [Complexity tracking bypass] The complexity increment is commented out for oracle address counting. Can an attacker exploit this by creating data feeds with thousands of oracle addresses, bypassing complexity limits and causing network-wide validation slowdown leading to transaction delays exceeding 1 day?",
  "[File: byteball/ocore/formula/validation.js] [Function: validateDataFeed()] [min_mci validation] Can an attacker submit a min_mci value that passes regex validation (/^\\d+$/) but causes integer overflow when parsed with parseInt(), leading to incorrect MCI filtering and accepting stale or future oracle data?",
  "[File: byteball/ocore/formula/validation.js] [Function: validateDataFeed()] [ifseveral parameter bypass] Can an attacker submit an 'ifseveral' value that is neither 'last' nor 'abort' but passes validation due to type coercion or encoding issues, causing non-deterministic behavior where different nodes handle multiple oracle values differently?",
  "[File: byteball/ocore/formula/validation.js] [Function: validateDataFeed()] [ifnone validation missing] The 'ifnone' parameter has no validation constraints. Can an attacker inject arbitrary expressions that execute during evaluation, potentially accessing unauthorized state or causing execution errors that brick the AA?",
  "[File: byteball/ocore/formula/validation.js] [Function: validateDataFeed()] [feed_name injection] Can an attacker craft a feed_name with special characters or encoding that passes the empty check but causes SQL injection or query errors in data_feeds.js during execution?",
  "[File: byteball/ocore/formula/validation.js] [Function: validateDataFeed()] [Decimal value conversion] When a Decimal value is converted to string using toDoubleRange().toString(), can precision loss or rounding differences cause non-deterministic validation across nodes with different Decimal library versions, leading to chain splits?",
  "[File: byteball/ocore/formula/validation.js] [Function: validateDataFeedExists()] [Operator bypass with ==] While operator '==' is explicitly rejected, can an attacker use Unicode lookalikes or other encoding tricks to bypass this check while still causing evaluation issues?",
  "[File: byteball/ocore/formula/validation.js] [Function: validateDataFeedExists()] [feed_value operator mismatch] The feed_value parameter allows any operator except '==', but is this validated consistently during evaluation? Can mismatched operators cause type coercion errors leading to AA bounces?",
  "[File: byteball/ocore/formula/validation.js] [Function: getAttestationError()] [Attestor list exhaustion] Can an attacker submit an attestation query with hundreds of attestor addresses (all valid individually) that pass validation but cause the evaluation phase to exceed complexity limits or timeout, freezing the AA?",
  "[File: byteball/ocore/formula/validation.js] [Function: getAttestationError()] [Address parameter injection] When the 'address' parameter is validated using ValidationUtils.isValidAddress(), can an attacker submit an expression that evaluates to a valid address during validation but resolves differently during execution due to state changes?",
  "[File: byteball/ocore/formula/validation.js] [Function: getAttestationError()] [Type coercion in ifseveral] Can an attacker exploit the 'ifseveral' validation by submitting values that pass string equality checks but behave differently when coerced to other types during evaluation?",
  "[File: byteball/ocore/formula/validation.js] [Function: getAttestationError()] [Field expression evaluation] For attestation queries, the field can be an expression. Can an attacker craft a field expression that is valid during validation but throws errors or accesses unauthorized data during execution?",
  "[File: byteball/ocore/formula/validation.js] [Function: getInputOrOutputError()] [Empty params bypass] The function rejects empty params objects, but can an attacker submit params with only prototype-inherited properties that appear non-empty but cause evaluation failures?",
  "[File: byteball/ocore/formula/validation.js] [Function: getInputOrOutputError()] [Operator confusion] While '==' is rejected, operators like '=' and '!=' are allowed for address/asset. Can an attacker exploit operator precedence or associativity issues in complex nested expressions to bypass intended validation logic?",
  "[File: byteball/ocore/formula/validation.js] [Function: getInputOrOutputError()] [Asset base64 validation] When validating asset IDs using ValidationUtils.isValidBase64(), can an attacker submit assets with valid base64 encoding but incorrect length that pass validation but cause database lookup failures?",
  "[File: byteball/ocore/formula/validation.js] [Function: getInputOrOutputError()] [Amount integer overflow] The amount validation checks for positive integers using regex and isPositiveInteger(), but can extremely large values that fit in strings cause overflow when converted to numbers during execution?",
  "[File: byteball/ocore/formula/validation.js] [Function: getInputOrOutputError()] [Nested expression depth] When params contain nested expressions (typeof value !== 'string'), is there a depth limit? Can an attacker create deeply nested expressions that pass validation but cause stack overflow during evaluation?",
  "[File: byteball/ocore/formula/validation.js] [Function: finalizeLocals()] [Race condition in state transition] When locals are finalized and 'maybe assigned' becomes 'assigned', can concurrent validation of multiple formulas sharing locals cause race conditions leading to non-deterministic validation results?",
  "[File: byteball/ocore/formula/validation.js] [Function: finalizeLocals()] [Prototype pollution] Can an attacker inject properties into locals through prototype pollution that bypass the hasOwnProperty checks and cause unexpected behavior in variable state tracking?",
  "[File: byteball/ocore/formula/validation.js] [Function: validate()] [Parser cache poisoning] The parser caches results in the global 'cache' object. Can an attacker submit malicious formulas that pollute the cache with invalid parse trees, causing subsequent valid formulas to fail validation and bricking all AAs?",
  "[File: byteball/ocore/formula/validation.js] [Function: validate()] [Cache limit bypass] The cache has a limit (cacheLimit) controlled by common.js. Can an attacker flood the system with unique formulas that thrash the cache, causing excessive memory usage and validation slowdown leading to network-wide delays?",
  "[File: byteball/ocore/formula/validation.js] [Function: validate()] [Ambiguous grammar exploitation] When parser.results.length > 1, the code reports 'ambiguous grammar'. Can an attacker craft formulas that deliberately produce ambiguous parses to cause denial of service or non-deterministic validation?",
  "[File: byteball/ocore/formula/validation.js] [Function: validate()] [setImmediate vs setTimeout] The evaluate() function uses setImmediate when available, else setTimeout. Can differences in these implementations across Node.js versions cause non-deterministic evaluation order, leading to chain splits?",
  "[File: byteball/ocore/formula/validation.js] [Function: validate()] [Locals initialization check] The function throws if !locals, but can an attacker pass an empty object {} that passes this check but causes errors when accessing expected properties?",
  "[File: byteball/ocore/formula/validation.js] [Function: validate()] [readGetterProps callback injection] If the readGetterProps callback is maliciously implemented by an attacker who compromises the calling code, can it return false getter data that passes validation but causes execution failures?",
  "[File: byteball/ocore/formula/validation.js] [Function: validate()] [bStateVarAssignmentAllowed bypass] Can an attacker craft formulas where state variable assignments are hidden in nested contexts that bypass the bStateVarAssignmentAllowed check during initial validation but execute during runtime?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [Arithmetic string injection] For arithmetic operations (+, -, *, /, %), string parameters are rejected, but can an attacker submit expressions that evaluate to strings only after passing validation, causing type coercion errors during execution?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [Division by zero] The division operator (/) has no explicit check for division by zero. Can an attacker craft expressions where the divisor becomes zero during execution, causing errors that aren't caught during validation?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [Modulo negative numbers] The modulo operator (%) behavior with negative numbers varies across implementations. Can this cause non-deterministic results across nodes with different JavaScript engines?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [Exponentiation overflow] The exponentiation operator (^) increments complexity by only 1, but can extremely large exponents (e.g., 2^1000000) cause computation that far exceeds the complexity estimate, leading to DoS?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [Decimal precision loss] When Decimal operations are performed during validation, can precision loss cause results to differ from execution-time calculations, leading to validation/execution mismatches?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [sqrt of negative] The sqrt operation doesn't validate that the argument is non-negative. Can passing negative values cause NaN results that propagate through calculations, causing non-deterministic behavior?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [ln of zero or negative] The ln (natural log) function doesn't validate the domain. Can ln(0) or ln(negative) produce -Infinity or NaN, causing validation to pass but execution to fail?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [Rounding with excessive precision] For ceil/floor/round, the second parameter can be an expression. Can attackers submit extremely large precision values that cause computation slowdown despite passing complexity checks?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [min/max with empty arrays] The min/max functions reject empty arrays, but can an attacker submit arrays that become empty only after expression evaluation, bypassing this check?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [hypot complexity underestimate] The hypot function increments complexity by 1, but for large arrays it performs O(n) operations. Can attackers bypass complexity limits by using hypot with many arguments?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [Comparison operator = rejection] The code explicitly rejects '=' in comparisons, but can Unicode homoglyphs or other encoding tricks bypass this check?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [Comparison type coercion] When comparing values of different types (number vs string), can implicit type coercion cause non-deterministic results across different JavaScript engine versions?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [Short-circuit evaluation bypass] For 'and'/'or' operations, are all branches validated even if short-circuit evaluation would skip them during execution? Can this cause validation/execution mismatches?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [Ternary operator complexity] The ternary operator validates all three parts, but during execution only one branch executes. Can attackers craft formulas where the unexecuted branch contains complexity violations that aren't caught?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [data_feed param evaluation order] When evaluating data_feed parameters, are they processed in a deterministic order? Can different iteration orders of Object.keys() across environments cause non-deterministic validation?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [in_data_feed complexity tracking] Does in_data_feed properly account for the complexity of querying the database? Can attackers use this to perform expensive queries that bypass complexity limits?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [trigger.outputs pre-aa3] The trigger.outputs field is rejected for mci < aa3UpgradeMci, but can attackers craft AAs that activate at the upgrade boundary and exploit race conditions in the mci check?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [trigger.initial_unit timing] The trigger.initial_unit field was added in aa3. Can AAs created before aa3 but executed after aa3 access this field in unexpected ways?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [trigger.output asset validation] For trigger.output, asset can be an expression. Can attackers craft expressions that resolve to invalid assets during execution but pass validation?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [params in non-AA context] The 'params' keyword is only allowed in AAs, but can definition-based addresses that aren't full AAs access params through nested formulas?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [mc_unit in getters] The mc_unit field is rejected in getters, but can remote getter calls bypass this restriction by accessing mc_unit indirectly?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [storage_size complexity] The storage_size operation checks if bAA is true but doesn't increment complexity. Can attackers use storage_size queries extensively to perform expensive database operations that bypass complexity tracking?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [var/balance non-AA context] The var and balance operations are rejected in non-AA contexts, but can attackers craft address definitions that execute AA-like code without being recognized as AAs?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [var address validation bypass] For two-parameter var[address][name] access, address validation checks ValidationUtils.isValidAddress(), but can attackers submit expressions that evaluate to non-addresses during execution?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [balance asset validation incomplete] For balance queries, asset validation uses isValidBase64() but only for string literals. Can expression-based assets resolve to invalid values during execution?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [State variable time inconsistency] The comment notes that var values are taken at 'last_ball_unit' time in non-AAs. Can this temporal mismatch cause validation to pass but execution to see different state values?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [asset field validation] For asset[x] queries, the field must be in objBaseAssetInfo, but this is only checked for string literals. Can expression-based fields access unauthorized asset properties?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [asset complexity undercount] Asset queries increment complexity by 1, but accessing asset metadata may require database lookups. Can attackers perform many asset queries to exceed real computational cost?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [unit query complexity] Unit queries increment complexity by 1, but loading and validating a full unit may be expensive. Can attackers query many units to cause DoS?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [definition query recursion] Definition queries may recursively load nested definitions. Is there a depth limit to prevent infinite recursion attacks?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [is_valid_signed_package complexity] Signature verification is computationally expensive but only increments complexity by 1. Can attackers perform many signature checks to cause validation slowdown?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [is_valid_sig parameter types] The function doesn't validate parameter types during validation. Can passing non-string values cause execution errors that aren't caught?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [vrf_verify complexity underestimate] VRF verification is cryptographically expensive but complexity is only 1. Can this be exploited for DoS?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [is_valid_merkle_proof depth attack] Merkle proof verification complexity depends on proof depth, but validation assigns constant complexity. Can deeply nested proofs cause excessive computation?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [sha256 format validation] The sha256 function accepts format as 'hex', 'base64', or 'base32', but validation for expression-based formats is incomplete. Can invalid formats cause execution errors?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [sha256 input size] There's no limit on sha256 input size. Can attackers hash extremely large strings to cause memory exhaustion?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [number_from_seed randomness] The number_from_seed function generates pseudorandom numbers. Can attackers predict or manipulate these values if the seed is predictable?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [chash160 pre-aa2 timing] The chash160 function is rejected for mci < aa2UpgradeMci. Can AAs created before aa2 but executed after access chash160 unexpectedly?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [substring negative indices] The substring function accepts start and length parameters but doesn't validate they're non-negative. Can negative values cause unexpected behavior?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [substring length overflow] Can extremely large length values in substring cause memory allocation issues?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [replace regex injection] The replace function accepts search_str and replacement. Can attackers inject regex patterns or replacement specials to cause DoS or unexpected behavior?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [split limit bypass] The split function accepts an optional limit parameter. Can attackers bypass this by using expressions that evaluate to different values during execution?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [join separator injection] Can attackers inject separators in join operations that cause the output to be misparsed by consuming code?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [timestamp_to_string format validation] Format validation for timestamp_to_string only checks string literals. Can expression-based formats cause execution errors?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [array pre-aa2 timing] Arrays are rejected for mci < aa2UpgradeMci. Can AAs that span the upgrade boundary exploit timing issues?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [array size limit] Is there a limit on array size during validation? Can extremely large arrays cause memory exhaustion?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [dictionary key collision] The dictionary validation checks for duplicate keys using hasOwnProperty, but can prototype properties or Symbol keys bypass this check?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [dictionary key type enforcement] Dictionary keys must be strings, but can attackers craft expressions that evaluate to non-strings during execution?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [local_var uninitialized access] For mci >= aa2UpgradeMci, accessing uninitialized vars is rejected, but can attackers exploit the conditional check (!locals['']) to access uninitialized vars in certain contexts?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [local_var function access without call] The code rejects accessing functions without calling them, but can attackers use indirect references to bypass this check?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [local_var leading underscore] Leading underscores in var names are rejected pre-aa2, but can attackers use Unicode underscore lookalikes to bypass this?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [local_var array key evaluation] When accessing vars with array keys (var[key1][key2]), are keys evaluated in deterministic order? Can evaluation order differences cause non-determinism?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [local_var_assignment empty name] Empty literal local var names are rejected for mci >= aa2UpgradeMci, but can zero-width characters bypass this check?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [local_var_assignment frozen var] Frozen vars cannot be reassigned, but can attackers unfreeze them through indirect means or prototype manipulation?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [local_var_assignment conditional tracking] Conditional assignments set state to 'maybe assigned', but can attackers exploit the bInIf flag to cause inconsistent state tracking?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [local_var_assignment selector mutation] Selectors allow mutating nested values, but can attackers mutate non-existent vars by exploiting the validation logic?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [local_var_assignment function collision] Can attackers declare vars with the same name as functions in different scopes to cause shadowing issues?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [state_var_assignment context bypass] State var assignments are only allowed when bStateVarAssignmentAllowed is true and !bGetters. Can nested function calls bypass these checks?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [state_var_assignment operator validation] Assignment operators must be in [=, +=, -=, *=, /=, %=, ||=], but can Unicode variants or other encodings bypass this check?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [state_var_assignment complexity] State var assignments increment complexity by 1, but database writes may be expensive. Can many state var updates cause DoS?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [response_var_assignment in getters] Response var assignments are rejected in getters, but can indirect assignment through function calls bypass this?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [response_var_assignment naming collision] Can response var names collide with trigger data or other reserved names to cause confusion?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [block statement validation order] In block statements, are all statements validated even if early statements would throw errors? Can validation order affect the result?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [ifelse bInIf flag manipulation] The bInIf flag tracks whether code is inside conditional blocks. Can nested if-else statements cause the flag to be set incorrectly?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [ifelse else_block null handling] When else_block is null, the code restores bInIf. Can this cause issues if the if_block modified bInIf?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [ifelse complexity undercount] Both if and else blocks are validated, but only one executes. Can attackers create expensive branches that only execute in rare cases?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [foreach count limit] The count is limited to 100, but can attackers nest multiple foreach loops to create O(100^n) complexity?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [foreach callback complexity] Callback complexity is multiplied by count, but can the complexity calculation overflow for large counts?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [map/filter callback arguments] Callbacks must have 1 or 2 arguments, but can attackers use rest parameters or default arguments to bypass this check?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [reduce callback arguments] Reduce callbacks must have 2 or 3 arguments, but the validation allows null count_args. Can this lead to runtime errors?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [reduce initial_value type] Is the initial_value in reduce validated for type compatibility with the accumulator?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [has_only complexity] The has_only operation increments complexity by 1, but pattern matching may be expensive for long strings. Can this be exploited?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [starts_with/ends_with case sensitivity] Are these operations case-sensitive? Can case differences cause non-deterministic behavior across locales?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [contains performance] For very long strings and patterns, contains operations may be O(n*m). Can this be used for DoS?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [index_of negative return] The index_of operation returns -1 when not found. Can code that doesn't check for -1 cause array access errors?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [is_integer precision] Can very large numbers that appear as integers in strings fail the is_integer check due to floating point precision issues?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [is_valid_amount negative check] Does is_valid_amount properly reject negative amounts and zero?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [is_valid_address checksum] Does is_valid_address verify checksums, or only format? Can invalid checksums pass validation but fail execution?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [is_aa false positives] Can regular addresses that happen to have AA-like properties pass is_aa checks?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [keys on non-objects] What happens when keys() is called on non-object types? Is this validated?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [reverse mutability] Does reverse() mutate the original array or return a new one? Can mutation cause unexpected side effects?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [exists undefined vs null] Does exists() distinguish between undefined and null values? Can this cause confusion?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [is_array vs is_assoc] Can objects that are both array-like and associative cause confusion in type checks?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [array_length on non-arrays] What happens when array_length is called on non-arrays? Is this an error or does it return undefined?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [freeze non-existent var] When freezing a variable that doesn't exist and locals[''] is falsy, an error is returned. But can attackers exploit the locals[''] flag to freeze non-existent vars conditionally?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [freeze function rejection] Functions cannot be frozen, but can attackers rename functions to data vars and then freeze them?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [freeze conditional bypass] When bInIf is true, freeze doesn't actually set state to 'frozen'. Can this be exploited to bypass freeze protection?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [delete frozen var] Delete rejects frozen vars, but can the freeze state be manipulated to allow deletion?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [delete function rejection] Functions cannot be deleted, but can function pointers stored in data vars be deleted?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [delete selector validation] Delete requires selectors to be an array, but can empty arrays or arrays with invalid keys cause issues?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [func_call undefined function] The code checks hasOwnProperty(locals, func_name), but can prototype-defined functions bypass this check?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [func_call argument count] Excessive arguments are rejected, but can missing arguments cause the function to behave unexpectedly?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [func_call complexity accumulation] Function complexity is added to the total, but can recursive function calls cause the complexity to grow unboundedly?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [remote_func_call AA address timing] If the remote AA address changes between validation and execution, can this cause execution failures?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [remote_func_call max_remote_complexity bypass] When max_remote_complexity is not provided, can attackers call expensive getters that bypass complexity limits?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [remote_func_call getter properties validation] The code expects getter objects to have complexity, count_ops, and count_args properties of specific types. Can malformed getter objects cause validation errors?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [remote_func_call base AA inference] When max_remote_complexity is a string (base AA), is the base AA's existence validated? Can non-existent base AAs cause errors?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [log pre-aa3 timing] The log operation is rejected for mci < aa3UpgradeMci. Can AAs that span this upgrade boundary exploit timing issues?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [log argument limit] There's no limit on the number of log arguments. Can excessive logging cause storage or performance issues?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [bounce in getters restriction] Bounce is not allowed at top level in getters, but can it be called from within functions in getters?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [bounce message validation] The bounce message is evaluated but not validated for type. Can non-string messages cause execution errors?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [require pre-aa3 timing] The require operation is rejected for mci < aa3UpgradeMci. Can upgrade boundary exploits occur?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [require vs bounce difference] How do require and bounce differ in behavior? Can attackers use one when they should use the other to cause unexpected behavior?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [return in statements-only mode] Return with a value is rejected in statements-only mode unless inside a function. Can nested contexts bypass this check?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [return without value] Return without a value (return;) is only allowed in statements-only mode or functions. Can this be exploited to cause early exits in expressions?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [return flag tracking] The bHadReturn flag tracks whether a return was encountered. Can this flag be manipulated to bypass validation checks?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [main statements vs expression] The main operation validates both statements array and final expression. Can inconsistencies between them cause validation/execution mismatches?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [main non-array statements] The code checks if statements is an array but then iterates assuming it's valid. Can non-array values that pass the check cause errors?",
  "[File: byteball/ocore/formula/validation.js] [Function: evaluate()] [main top-level flag] The bTopLevel parameter controls validation of statements-only vs expression mode. Can nested main calls manipulate this flag?",
  "[File: byteball/ocore/formula/validation.js] [Function: parseFunctionDeclaration()] [Argument shadowing] The function checks for argument/local var name collisions using intersection, but can case-insensitive name collisions bypass this check?",
  "[File: byteball/ocore/formula/validation.js] [Function: parseFunctionDeclaration()] [Duplicate arguments] Duplicate arguments are rejected, but can Unicode variants or zero-width characters create duplicates that pass uniq() checks?",
  "[File: byteball/ocore/formula/validation.js] [Function: parseFunctionDeclaration()] [Complexity reset] Complexity is reset to 0 when parsing function body, then restored. Can this reset be exploited to bypass global complexity limits?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Parser ambiguity - Network halt] If the Nearley parser produces multiple valid parse trees (parserResults.length > 1) for a crafted OJSON input at line 67, can different nodes select different parse results due to non-deterministic array ordering, causing them to compute different AA definition hashes and reject each other's units, leading to a permanent chain split?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Parser ambiguity - Determinism] At line 37-38, if parserResults.length !== 1 triggers an error in validateFormula(), but the same input passes in parse() at line 67-68, can an attacker craft an OJSON string that validates differently across calls, breaking deterministic AA execution and causing state divergence?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parseOjsonGrammar()] [Grammar ambiguity] If the ojsonGrammar at line 45 has ambiguous production rules allowing multiple parse trees for the same input, and different nodes' Nearley parsers resolve ambiguity differently due to JavaScript engine variations, can this cause nodes to parse identical OJSON text into different AA definitions, leading to consensus failure?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Type check bypass] At line 64, if parser.results is a non-array object with a numeric 'length' property (e.g., {length: 1, 0: validResult}), does _.isArray() fail to detect this, allowing a malformed parser result to proceed and potentially crash processTree() at line 72?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: validateFormula()] [Ambiguity validation gap] At line 37-38, if parserResults.length !== 1 for a formula but the outer OJSON parse at line 67 succeeds with length === 1, can an attacker embed an ambiguously-parsed formula within a valid OJSON structure, causing the formula validation to pass but later formula evaluation to fail non-deterministically?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: validateFormula() -> searchNewlineRecursive()] [Newline bypass - AA behavior] At line 30-32, the newline check uses st.includes('\\\\n'), but can an attacker inject formulas containing Unicode line separators (U+2028, U+2029) or carriage returns (\\\\r) without \\\\n, bypassing the validation and causing formulas to span multiple lines, potentially breaking formula evaluation or allowing code injection?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: searchNewlineRecursive()] [Recursive depth - DoS] At lines 20-33, if an attacker crafts a deeply nested OJSON structure with 10,000+ levels of nested arrays/objects, can the recursive searchNewlineRecursive() exhaust the call stack, causing validator nodes to crash during AA definition parsing and preventing new AAs from being deployed (network delay 1 day)?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: validateFormula()] [Error context manipulation] At line 31, if an attacker crafts an OJSON input where context.line or context.col are negative, Infinity, or NaN, can the error message 'Error parsing formula starting at line ${context.line} col ${context.col}' leak internal state or cause string concatenation issues that crash the parser?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: searchNewlineRecursive()] [Object prototype pollution detection] At line 25-29, if st is an object with malicious prototype properties (e.g., Object.prototype.maliciousKey = '\\\\n'), will Object.keys(st) iterate over inherited properties, triggering false newline errors for legitimate OJSON, or worse, will checking st[keys[i]] access the prototype pollution?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: validateFormula()] [Newline in object keys] The searchNewlineRecursive() at line 30 checks string values, but does it validate object keys? Can an attacker create OJSON with keys containing newlines (e.g., {'key\\\\nwith\\\\nnewline': 'value'}), bypassing validation since only values are checked, and potentially breaking formula evaluation that assumes single-line keys?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parseOscriptGrammar()] [Formula grammar injection] At line 51-53, when parsing the extracted formula with oscriptGrammar, if the formula contains unescaped grammar meta-characters or specially crafted tokens, can it trigger parser vulnerabilities in the Nearley oscript grammar, causing validator nodes to hang or crash during AA validation?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Formula boundary confusion] At line 94, the formula is wrapped as '{' + formula + '}' and returned. If the original formula was extracted from quotes and already contains balanced braces, can this create formulas like '{{nested}}' that evaluate differently than intended, potentially allowing attackers to escape formula sandboxing or inject malicious code?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: validateFormula()] [Array vs Object type confusion] At line 21-24, searchNewlineRecursive() checks _.isArray(st) before checking _.isPlainObject(st). If an attacker creates an array-like object (e.g., {0: 'a', 1: 'b', length: 2}) that passes _.isArray() but has string properties containing newlines, can it bypass the newline check on line 30?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [Recursive depth - Network halt] At lines 78-119, processTree() recursively processes nested OJSON structures. If an attacker submits an AA definition with 100,000 nested arrays/objects (e.g., [[[[...]]...]]), can the unbounded recursion exhaust the JavaScript call stack on all validator nodes simultaneously, causing them to crash and preventing network consensus for >24 hours?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsArray()] [Stack exhaustion via arrays] At line 135-143, processAsArray() calls processTree() for each array element. If an attacker creates a 10,000-element array where each element is itself a deeply nested structure, can the combined recursive depth (array iteration * element depth) exceed stack limits and crash nodes during AA deployment?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Stack exhaustion via objects] At line 121-134, processAsObject() iterates over object key-value pairs and recursively processes each. If an attacker crafts an object with 10,000 keys, each with deeply nested values, can the cumulative recursion (object size * value depth) cause stack overflow on nodes with smaller stack limits, creating network partition?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [Circular reference in tree] If the Nearley parser produces a tree structure with circular references (e.g., tree.value[0] === tree), and processTree() at line 78 doesn't detect cycles, can the recursive processing enter an infinite loop, hanging validator nodes and preventing them from validating any new units (network halt)?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [Mixed recursion depth attack] At lines 79-118, if an attacker alternates between ARRAY and OBJECT types in nested structures (e.g., array of objects of arrays of objects...) with each level containing FORMULA types that trigger parseOscriptGrammar(), can the combined recursion depth (tree processing + formula parsing) exceed limits not caught by individual depth checks?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Duplicate key bypass - Prototype] At line 128, duplicate keys are detected using ValidationUtils.hasOwnProperty(obj, key). If an attacker uses '__proto__', 'constructor', or 'prototype' as keys, can they bypass the duplicate check since these are inherited properties, allowing them to inject multiple values for the same key and potentially override critical AA definition fields?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Case sensitivity in duplicate detection] At line 128-130, if the OJSON input contains keys that differ only in case (e.g., 'messages' and 'Messages'), does the duplicate detection catch this? Can an attacker exploit case-insensitive downstream processing to inject multiple conflicting values for what downstream code treats as the same field?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Unicode normalization bypass] At line 126-130, if an attacker uses Unicode equivalent representations of the same key (e.g., 'caf' in NFC vs NFD normalization), does the duplicate key check at line 128 detect them as different strings? Can this allow duplicate semantic keys that later cause AA execution to read conflicting values non-deterministically?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Symbol keys bypass] If the Nearley parser allows Symbol-type keys in the tree (though unlikely), would the duplicate check at line 128 work correctly? Can an attacker inject duplicate Symbol('sameDescription') keys that are technically different Symbols but represent the same semantic field?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Whitespace-only key variations] At line 126, if keys are '  field  ' and 'field' (with/without spaces), does processTree(st.key) trim whitespace? If not, can an attacker bypass duplicate detection using whitespace variations, creating multiple entries for semantically identical fields?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Empty string keys] If an attacker includes multiple key-value pairs with empty string keys (''), does the duplicate check at line 128-130 catch all but the first one? Or can multiple empty-key entries exist in the final AA definition, causing undefined behavior when downstream code accesses obj['']?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Numeric string keys] At line 126, if keys are numeric strings ('0', '1', '2'), does processTree() preserve them as strings or convert to numbers? If conversion happens, can an attacker exploit this to bypass duplicate detection (string '1' vs number 1) or inject array-like properties into the AA definition object?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [Unknown type crash] At line 117, if tree.type is an unknown value (not in TYPES enum), the function throws 'Unknown ojson node type'. If an attacker crafts a malicious Nearley grammar or exploits a grammar bug to produce a tree node with type 'MALICIOUS', can this error crash all validator nodes simultaneously during AA parsing (network halt)?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [Type enum poisoning] At lines 8-17, if an attacker can inject additional TYPES constants (e.g., by polluting the imported module), can they create OJSON trees with custom types that processTree() mishandles, either by falling through to line 117's error or by triggering unintended code paths?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [DECIMAL precision loss] At line 87-88, tree.value for TYPES.DECIMAL is returned directly. If the Nearley parser produces DECIMAL values as JavaScript numbers that lose precision (e.g., 0.1 + 0.2 !== 0.3), can this cause non-deterministic AA behavior when different nodes' parsers compute slightly different decimal values?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [Boolean representation inconsistency] At lines 83-86, TRUE and FALSE types return tree.value directly. If the parser sets tree.value to the strings 'true'/'false' instead of booleans, can downstream AA code misinterpret these, causing unintended smart contract logic (e.g., if ('false') evaluates to true in JavaScript)?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.PAIR] [Key type validation missing] At line 115, processTree(tree.key) is used as an object key via computed property [{...}]. If processTree(tree.key) returns a non-string type (object, array, etc.), JavaScript will convert it to '[object Object]' or similar. Can this cause multiple different complex keys to collide as the same string key in the AA definition?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [Null/undefined handling] If tree.type is null or undefined due to a parser bug, the switch-like structure at lines 79-118 doesn't explicitly handle these. Will the function fall through to line 117's error, or will it silently return undefined, creating an AA definition with undefined fields that crash during evaluation?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [Mixed type array elements] At line 135-143, processAsArray() allows any mix of types in array elements. If an AA definition has arrays mixing formulas, objects, strings, and booleans, can downstream evaluation code that expects homogeneous arrays fail or behave non-deterministically?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Prototype pollution - Fund theft] At line 131, assignField(obj, key, value) is called. If key is '__proto__', 'constructor', or 'prototype', can this pollute Object.prototype globally across the node process? If so, can an attacker deploy an AA with such keys, polluting the prototype on all validator nodes and causing all subsequent AA evaluations to read attacker-controlled values, potentially stealing funds?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Prototype pollution - Network halt] At line 131, if assignField() uses Object.defineProperty() without safeguards, and key is '__proto__', can this modify the prototype chain? If multiple AAs attempt prototype pollution with conflicting values, can this cause non-deterministic prototype state across nodes, leading to divergent AA execution and permanent chain split?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Constructor.prototype pollution] If key at line 131 is 'constructor' and value is an object with a 'prototype' property, can assignField() inadvertently set obj.constructor.prototype, polluting the constructor's prototype? Can this affect all instances created from that constructor across the node process?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Prototype pollution persistence] If an attacker successfully pollutes Object.prototype via line 131, does the pollution persist across multiple AA deployments? Can a single malicious AA deployment affect all subsequent AA executions on all nodes, causing a chain reaction of fund theft or incorrect AA behavior?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Prototype chain manipulation] At line 131, if value is itself an object with polluted prototypes, and assignField() assigns it without cloning, can the attacker inject a poisoned prototype chain into the AA definition that later gets accessed during AA evaluation, causing malicious code execution?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Error message injection] At line 61, if the Nearley parser error message contains user-controlled content from the OJSON input, can an attacker inject newlines or format strings into the error ('ojson parsing failed: ' + e), potentially breaking log parsers or leaking sensitive information if the error is displayed to users?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Regex DoS in error parsing] At line 97, the error message is matched against regex /invalid syntax at line ([\\\\d]+) col ([\\\\d]+):([\\\\s\\\\S]+)/m. If the error message is crafted to have thousands of digits or repeated patterns, can this regex exhibit catastrophic backtracking (ReDoS), causing validator nodes to hang during error processing and delaying network consensus for 1 hour?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Error context arithmetic overflow] At lines 99-104, line and col numbers are extracted and used in arithmetic (line + tree.context.line, col + tree.context.col). If an attacker crafts context values or error line numbers that cause integer overflow (e.g., Number.MAX_SAFE_INTEGER + 1), can the error message report incorrect line/col positions, hindering debugging or causing nodes to reject valid AAs?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Error propagation chain] At lines 95-110, if formula parsing fails, errors are re-thrown with modified messages. If this error handling is called recursively for deeply nested formulas, can the error message grow unboundedly with each recursion level, causing memory exhaustion or network bandwidth issues when errors are broadcast?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Exception object manipulation] At line 75, exceptions are caught and e.message is used in callback. If the Nearley parser throws a non-Error object (e.g., throw {toString: () => 'malicious'}), can accessing e.message return undefined, causing the callback to receive undefined error, which downstream code might interpret as success?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Error message startsWith() bypass] At line 106, the code checks if msg.startsWith('Error parsing formula starting at line'). If an attacker crafts an error message starting with a similar but not identical string (e.g., 'Error parsing formula  starting at line' with double space), can this bypass the check and fall through to line 109, losing context information?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: validateFormula()] [Context object injection] At lines 31, 36, the code accesses context.line and context.col. If the Nearley parser produces a context object with getter methods that execute malicious code, can accessing context.line trigger arbitrary code execution during error generation?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Formula escaping bypass] At line 94, the formula is wrapped as '{' + formula + '}'. If the original formula contains the sequence '}{', can this create multiple apparent formulas (e.g., '{a}{b}' becomes '{{a}{b}}'), causing formula evaluation to interpret this differently than intended and potentially executing unintended code?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Formula comment injection] If the formula at line 90 contains comment syntax (e.g., '// comment' or '/* comment */'), and the wrapping at line 94 doesn't account for this, can an attacker use comments to hide malicious code that only becomes active after wrapping, bypassing formula validation?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parseOscriptGrammar()] [Formula parser state pollution] At line 51-53, a new Nearley parser is created for each formula. If parseOscriptGrammar() is called concurrently for multiple formulas (e.g., during AA deployment spam), can shared state in the Nearley library cause parser confusion, leading to non-deterministic formula validation results?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Formula validation TOCTOU] At lines 91-94, the formula is first validated via parseOscriptGrammar(), then wrapped and returned. If there's any processing between validation and wrapping where the formula variable could be modified (though unlikely in this synchronous code), can an attacker exploit a TOCTOU race to inject an unvalidated formula?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: validateFormula()] [Formula parser vs OJSON parser inconsistency] At line 93, validateFormula() is called with parser.results from parseOscriptGrammar(). If the oscript grammar and ojson grammar have inconsistent rules for formula parsing (e.g., different whitespace handling), can an attacker create formulas that validate successfully but parse differently during evaluation?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Context tracking error] At line 129, the error message uses st.context.line and st.context.col. If the Nearley parser produces incorrect context information (e.g., all nodes have context.line = 1), can error messages point to the wrong source location, preventing auditors from identifying malicious AA code and allowing attackers to hide backdoors?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Context offset miscalculation] At lines 99-104, context.line and context.col are adjusted based on error line numbers. If the formula contains multi-byte UTF-8 characters, can the column calculation be off (counting bytes vs characters), causing error messages to point to incorrect positions and hindering security analysis?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: validateFormula()] [Context in nested structures] At line 31, context.line and context.col are used in error messages. If the OJSON contains formulas nested within deeply nested objects/arrays, does the context accurately reflect the nesting depth, or can it overflow/wraparound for very deep structures, making errors untraceable?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Multi-line formula context] At lines 101-104, if line === 0, col is adjusted; otherwise line is adjusted. If a formula spans multiple lines (which should be caught by newline validation), but newline validation is bypassed, can the context adjustment logic produce nonsensical line/col values?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parseOjsonGrammar()] [Grammar definition tampering] At line 45, ojsonGrammar is imported from './grammars/ojson.js'. If an attacker gains write access to the grammar file (e.g., via dependency confusion or supply chain attack), can they inject grammar rules that accept malicious OJSON, causing all nodes to accept backdoored AA definitions?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parseOscriptGrammar()] [Oscript grammar vs validation mismatch] At line 51, oscriptGrammar is used for formula validation. If there's a mismatch between how oscriptGrammar parses formulas and how formula/evaluation.js evaluates them, can an attacker create formulas that pass validation but execute malicious logic during evaluation?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parseOjsonGrammar()] [Nearley parser version incompatibility] At line 45-46, if different nodes run different versions of the Nearley library with incompatible grammar behavior, can the same OJSON input parse differently on different nodes, causing them to compute different AA definition hashes and reject each other's units (permanent chain split)?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parseOjsonGrammar()] [Grammar ambiguity from whitespace] If ojsonGrammar has ambiguous whitespace handling rules (e.g., treating tabs vs spaces differently), can an attacker craft OJSON that parses differently based on whitespace normalization, causing nodes with different whitespace handling to diverge in their AA definitions?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parseOscriptGrammar()] [Formula grammar injection via Unicode] If oscriptGrammar doesn't properly handle Unicode categories (e.g., treating Unicode whitespace as syntax), can an attacker inject Unicode characters that are parsed as operators or keywords, bypassing formula validation and injecting malicious logic?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsArray()] [Array length manipulation] At line 136-142, the function iterates using tree.value.length. If tree.value is an array-like object with a manipulated length property (e.g., length: 1000000 but only 2 actual elements), can the iteration access undefined elements, causing errors or non-deterministic behavior?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsArray()] [Array hole handling] At line 139, arr.push(res) adds elements sequentially. If tree.value has sparse array holes (e.g., [1, , , 4]), does processTree() handle undefined elements correctly? Can attackers exploit holes to create AA definitions with unexpected undefined values that crash during evaluation?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsArray()] [Array prototype pollution] If tree.value has polluted Array.prototype (e.g., Array.prototype[0] = 'malicious'), does the iteration at line 137-141 iterate over prototype properties? Can this inject attacker-controlled values into the AA definition array?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsArray()] [Array mutation during iteration] If processTree() at line 139 somehow mutates tree.value (e.g., via shared references), can the iteration see inconsistent array state, causing elements to be skipped or processed twice, leading to non-deterministic AA definitions?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsArray()] [Array vs tuple semantics] If the AA definition expects fixed-length tuples but processAsArray() allows arbitrary-length arrays, can an attacker submit arrays with too many or too few elements, causing downstream validation to fail only after the expensive parsing step (DoS via computational waste)?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Object key ordering non-determinism] At line 123-132, object keys are processed in iteration order. If JavaScript engines iterate Object.keys() in different orders for the same object on different nodes (e.g., due to JIT optimization differences), can the final AA definition have different key ordering, causing different object hashes and consensus failure?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Getter/setter in object] At line 127, _.values(res)[0] extracts the value. If res is an object with a getter that executes code, can this trigger arbitrary code execution during AA parsing? Though unlikely from Nearley output, can grammar exploits create such objects?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Object with numeric keys] At line 126, Object.keys(res)[0] gets the key. If the key is numeric (e.g., 123), Object.keys() returns it as a string ('123'). If downstream code expects numeric keys, can this type mismatch cause AA execution errors?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Symbol keys ignored] At line 126, Object.keys() doesn't return Symbol keys. If the parser somehow produces objects with Symbol keys, are they silently ignored, causing incomplete AA definitions that fail during evaluation with confusing errors?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Non-enumerable properties] If tree.value contains objects with non-enumerable properties, Object.keys() at line 126 won't see them. Can an attacker exploit this to hide malicious properties in AA definitions that are later accessed via Object.getOwnPropertyNames() or Reflect?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Memory exhaustion via large OJSON] If an attacker submits a 100MB OJSON string with deeply nested structures, does the Nearley parser at line 46 consume unbounded memory to build the parse tree? Can this cause validator nodes to run out of memory during AA deployment, crashing them (network delay 1 day)?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsArray()] [Quadratic array concatenation] At line 140, arr.push() is used. If tree.value has 1,000,000 elements, is the array allocation efficient, or does it cause repeated reallocations with quadratic time complexity, delaying AA validation for 1 hour?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Quadratic object building] At line 131, assignField() is called for each key. If the object has 100,000 keys, and assignField() uses Object.defineProperty() without optimization, can the cumulative cost cause O(n) performance, delaying AA deployment?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: searchNewlineRecursive()] [Memory leak via closures] If searchNewlineRecursive() at line 20 creates closures that capture large objects, and these closures are not garbage collected (due to exception handling at line 31), can repeated AA parsing leak memory, eventually crashing nodes?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Parser state accumulation] At line 46, nearleyParser.feed(text) is called. If the parser maintains internal state that grows with input size, and garbage collection doesn't reclaim it, can repeatedly parsing large OJSON strings accumulate memory until nodes crash?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [assignField interaction with evaluation.js] At line 131, assignField() from common.js is used. If formula/evaluation.js expects fields to be plain properties but assignField() creates non-writable or non-configurable properties via Object.defineProperty(), can this cause AA evaluation to fail when trying to modify state, permanently freezing funds?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Callback error handling] At line 73, the callback is invoked with ['autonomous agent', result]. If aa_validation.js expects errors to be Error objects but parse() passes strings (line 61, 65, 75), can this cause exception handling to fail, allowing invalid AAs to pass validation?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.FORMULA] [Formula format expectation mismatch] At line 94, formulas are returned as '{formula}'. If formula/evaluation.js expects formulas without braces (using getFormula() to extract), but somewhere the format expectation changes, can this cause formulas to be evaluated as literal strings instead of code, breaking AA logic?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Definition array format] At line 73, the result is ['autonomous agent', result]. If aa_validation.js expects index [0] to be exactly 'autonomous agent' (case-sensitive), but the parser produces 'Autonomous Agent' or ' autonomous agent ' (with whitespace), can this cause all AAs to be rejected, freezing network?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [Type conversion inconsistency with validation] If processTree() returns numeric strings for DECIMAL types but aa_validation.js expects numbers, or vice versa, can this cause validation to pass but evaluation to fail (or opposite), allowing broken AAs to be deployed?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parseOjsonGrammar()] [UTF-8 BOM handling] At line 46, if the input text starts with a UTF-8 BOM (\\\\uFEFF), does the Nearley parser handle it correctly? Can a BOM cause parsing to fail for otherwise valid OJSON, or worse, can it cause different parsing results on nodes with different UTF-8 handling?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.STR] [Unicode normalization inconsistency] At line 82, string values are returned as-is. If strings contain Unicode characters in different normalization forms (NFC vs NFD), can this cause the same semantic AA definition to hash differently on nodes with different Unicode handling, leading to consensus failure?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: validateFormula()] [Zero-width characters in formulas] At line 30, newline detection checks for '\\\\n', but what about zero-width spaces (U+200B) or other invisible Unicode characters? Can attackers inject hidden characters into formulas that change their meaning without being visible in error messages?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processAsObject()] [Homoglyph attack in keys] At line 126, if object keys contain homoglyphs (e.g., Cyrillic '' vs Latin 'a'), does duplicate key detection catch them? Can an attacker create two visually identical keys that are treated as different, confusing auditors and hiding malicious AA logic?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parseOjsonGrammar()] [Surrogate pair handling] If the OJSON input contains unpaired UTF-16 surrogates, does the Nearley parser handle them correctly? Can malformed surrogates cause parsing errors that crash nodes or produce different results on nodes with different JavaScript engines?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: validateFormula()] [Validation called conditionally] At line 93, validateFormula() is called only for FORMULA types during processTree(). If the outer OJSON parse succeeds but contains formulas that were never processed (e.g., unreachable branches), can these unvalidated formulas be activated later during AA execution, bypassing security checks?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Success without processTree] If parser.results[0] at line 72 is somehow null or a primitive type, processTree() might return it immediately (lines 82-88). Can an attacker craft OJSON that parses to a primitive, bypassing all the object/array processing logic and creating a trivial AA definition that downstream code mishandles?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree() -> TYPES.PAIR] [Single-property object assumption] At line 115, the code assumes the result of processing a PAIR is a single-property object and extracts Object.keys(res)[0] at line 126. If processTree() returns an empty object or multi-property object, can this cause undefined key/value to be assigned to the parent object?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: parse()] [Empty OJSON handling] If the input text is empty or whitespace-only, does parseOjsonGrammar() return a valid parse tree with an empty object/array? Can an attacker deploy an empty AA definition that passes all validation but fails at evaluation time, wasting network resources?",
  "[File: byteball/ocore/formula/parse_ojson.js] [Function: processTree()] [Null tree handling] If tree is null at line 78, does the function immediately crash with 'Cannot read property type of null', or does it fall through to line 117? Can an attacker exploit null trees to cause non-deterministic error handling?",
  "[File: byteball/ocore/formula/index.js] [Module Loading] [Race Condition] If multiple threads/processes attempt to require() this module simultaneously during node startup, can the require() statements on lines 1-2 create race conditions where validation.js is loaded but evaluation.js is not yet available, causing some callers to receive an incomplete formulaParser object with only the validate export but undefined evaluate function?",
  "[File: byteball/ocore/formula/index.js] [Module Loading] [Initialization Order] Since this file exports functions from validation.js and evaluation.js without any initialization checks, if either underlying module fails to load or throws an error during require(), will this module export undefined functions that crash the system when definition.js attempts to call formulaParser.validate() during address definition processing?",
  "[File: byteball/ocore/formula/index.js] [Module Caching] [Cache Poisoning] Given Node.js's require() cache mechanism, if an attacker can manipulate the module cache before this file is first loaded, can they inject malicious validate() or evaluate() implementations that would be used throughout the application's lifetime, allowing them to bypass all formula validation and execute arbitrary AA code?",
  "[File: byteball/ocore/formula/index.js] [Export Interface] [Function Binding] Since the exports on lines 4-5 directly assign function references without binding context, if validation.js or evaluation.js rely on 'this' context in their validate()/evaluate() implementations, will calls through this facade fail or produce non-deterministic results when the functions are invoked from different calling contexts in definition.js versus aa_composer.js?",
  "[File: byteball/ocore/formula/index.js] [Module Loading] [Circular Dependency] If validation.js or evaluation.js attempt to require('./index.js') creating a circular dependency, can this cause the exports on lines 4-5 to be undefined at the time they're needed by the underlying modules, potentially causing a network-wide crash when nodes attempt to validate any unit containing formula definitions?",
  "[File: byteball/ocore/formula/index.js] [Import Inconsistency] [Divergent Behavior] Given that definition.js imports from formula/index.js while aa_composer.js imports directly from formula/evaluation.js, if there are any transformations, wrappers, or state initialization in index.js that evaluation.js depends on, can this inconsistency cause definition.js and aa_composer.js to execute formulas with different behaviors, leading to nodes disagreeing on whether address definitions or AA executions are valid?",
  "[File: byteball/ocore/formula/index.js] [Import Inconsistency] [Non-Determinism] Since some modules use this facade while others bypass it and import directly from validation.js/evaluation.js, if the underlying modules maintain any module-level state or caching, can the two different import paths result in separate instances of state, causing formula validation results to differ depending on which import path was used, leading to permanent chain splits?",
  "[File: byteball/ocore/formula/index.js] [API Surface] [Missing Validation] This module exports validate() and evaluate() without any wrapper logic, error handling, or parameter validation - if a caller passes malformed arguments (e.g., null, undefined, or objects with prototype pollution) directly to these functions, can this bypass security checks that should exist at the API boundary, allowing attackers to crash nodes or trigger undefined behavior in formula processing?",
  "[File: byteball/ocore/formula/index.js] [Function References] [Monkey Patching] Since the exports are direct function references, can an attacker who gains code execution in the same process (e.g., through a separate vulnerability) replace exports.validate or exports.evaluate with malicious implementations, allowing them to approve invalid formulas in address definitions or manipulate AA execution results without detection?",
  "[File: byteball/ocore/formula/index.js] [Module Isolation] [Shared State] If validation.js and evaluation.js share any module-level state (e.g., caches, configuration, or complexity counters), and this index.js imports both into the same scope, can concurrent calls to validate() and evaluate() from different parts of the codebase create race conditions on shared state that cause non-deterministic validation results, leading to nodes accepting different sets of units?",
  "[File: byteball/ocore/formula/index.js] [Error Handling] [Unhandled Exceptions] Since this module performs no try-catch wrapping around the exports from validation.js and evaluation.js, if either validate() or evaluate() throws an exception instead of returning an error through the callback, will this cause the calling code in definition.js to crash the entire node when processing a maliciously crafted formula, enabling a DoS attack that prevents transaction confirmation network-wide?",
  "[File: byteball/ocore/formula/index.js] [Error Propagation] [Callback Inconsistency] If validation.js and evaluation.js use different error callback conventions (e.g., one uses (err, result) while the other uses (result) with result.error), and this facade doesn't normalize the interface, can callers like definition.js misinterpret error conditions, potentially accepting invalid formulas as valid or vice versa, causing consensus failures?",
  "[File: byteball/ocore/formula/index.js] [Error Handling] [Silent Failures] If the require() statements on lines 1-2 fail to load the underlying modules (e.g., due to file system errors or syntax errors in validation.js/evaluation.js), but Node.js's require() doesn't throw immediately, can this result in exports.validate and exports.evaluate being undefined, causing silent failures when definition.js attempts to validate formula definitions, potentially allowing units with invalid formulas to be accepted?",
  "[File: byteball/ocore/formula/index.js] [Determinism] [Version Skew] If different nodes have different versions of validation.js or evaluation.js installed, but all use the same version of this index.js facade, can the exported validate() and evaluate() functions behave differently across nodes (e.g., due to bug fixes or changes in formula complexity calculations), causing permanent chain splits when nodes disagree on whether specific formulas are valid?",
  "[File: byteball/ocore/formula/index.js] [Determinism] [Platform Dependencies] If validation.js or evaluation.js contain any platform-specific code (e.g., using platform-specific regex features, number precision, or timing functions), and this index.js exports them without platform normalization, can nodes running on different operating systems or Node.js versions produce different validation/evaluation results, causing consensus failures?",
  "[File: byteball/ocore/formula/index.js] [Module Loading] [Load Order Non-Determinism] Since Node.js module loading can be affected by filesystem ordering, if validation.js and evaluation.js have initialization side effects that depend on load order, can the order in which they're required on lines 1-2 affect their behavior, potentially causing some nodes to initialize the formula system differently and reject units that other nodes accept?",
  "[File: byteball/ocore/formula/index.js] [Concurrency] [Reentrant Calls] If validation.js or evaluation.js maintain any module-level mutable state, and concurrent calls to the exported validate()/evaluate() functions can occur from multiple async contexts in definition.js and aa_composer.js, can reentrant calls corrupt shared state, causing formula validation to produce incorrect results and potentially approving formulas that should fail, leading to unauthorized fund transfers?",
  "[File: byteball/ocore/formula/index.js] [State Management] [Module Singleton] Since Node.js caches required modules as singletons, any state in validation.js or evaluation.js is shared across all callers of exports.validate and exports.evaluate - if this shared state includes complexity counters, caches, or execution contexts, can one caller's formula validation affect another concurrent validation, causing non-deterministic results that break consensus?",
  "[File: byteball/ocore/formula/index.js] [Concurrency] [Callback Race] If multiple callers invoke exports.validate or exports.evaluate concurrently with different complexity limits or validation contexts, and the underlying implementations don't properly isolate per-call state, can callbacks from one validation be delivered to a different caller, causing definition.js to incorrectly accept or reject formula definitions based on another formula's validation result?",
  "[File: byteball/ocore/formula/index.js] [API Boundary] [Missing Sanitization] Since this facade directly exports validate() and evaluate() without any input sanitization layer, if callers like definition.js pass user-controlled data (formula strings, complexity limits, or context objects) directly through, can attackers craft inputs that exploit vulnerabilities in the underlying validation.js or evaluation.js implementations, such as regex DoS, prototype pollution, or code injection?",
  "[File: byteball/ocore/formula/index.js] [Access Control] [Privilege Escalation] If validation.js and evaluation.js are designed to be called only from trusted contexts with specific preconditions, but this index.js exports them as a public API without enforcing those preconditions, can untrusted code or malicious callers invoke these functions directly to bypass security checks, potentially validating and executing malicious formulas that would normally be rejected?",
  "[File: byteball/ocore/formula/index.js] [API Versioning] [Breaking Changes] If the validate() or evaluate() function signatures in validation.js or evaluation.js change (e.g., adding new required parameters, changing callback conventions, or modifying return values), but this index.js continues to export them without version checks or adapter logic, can existing callers like definition.js invoke these functions with incorrect arguments, causing crashes or security vulnerabilities when processing formulas?",
  "[File: byteball/ocore/formula/index.js] [Memory Management] [Closure Leaks] If the exported validate() and evaluate() functions create closures over large objects in validation.js or evaluation.js, and these closures are long-lived due to module caching, can repeated calls to formula validation/evaluation from definition.js and aa_composer.js cause memory leaks by accumulating unreleased formula contexts, eventually exhausting node memory and causing network-wide outages?",
  "[File: byteball/ocore/formula/index.js] [Resource Management] [Missing Cleanup] Since this module exports functions without any cleanup or disposal mechanism, if validation.js or evaluation.js allocate resources (e.g., worker threads, timers, or file handles) during formula processing, can these resources leak when formulas are validated/evaluated through this interface, eventually causing resource exhaustion and preventing nodes from processing new units?",
  "[File: byteball/ocore/formula/index.js] [Test Coverage] [Interface Mismatch] If test files import formulaParser from this index.js but production code like aa_composer.js imports directly from evaluation.js, can tests pass while production code fails because the test coverage doesn't exercise the actual import paths used in production, potentially missing bugs that only manifest when evaluation.js is used directly?",
  "[File: byteball/ocore/formula/index.js] [Mock Injection] [Test Isolation] If tests mock the exports of this module to test definition.js behavior, but production code uses multiple import paths (both index.js and direct imports from validation.js/evaluation.js), can the mocks fail to override all code paths, causing tests to provide false confidence while production code still uses the real, potentially vulnerable implementations?",
  "[File: byteball/ocore/formula/index.js] [Upgrade Safety] [Backward Compatibility] If a protocol upgrade modifies the behavior of validate() or evaluate() in validation.js/evaluation.js (e.g., to add new formula opcodes or change complexity calculations), but this index.js continues to export them without version gating based on MCI, can nodes at different upgrade states produce different validation results for the same formulas, causing permanent chain splits during the upgrade transition period?",
  "[File: byteball/ocore/formula/index.js] [Upgrade Safety] [Hard Fork Risk] If the formula system requires a hard fork to fix a critical vulnerability in validation or evaluation logic, but this facade provides no mechanism to switch between old and new implementations based on MCI, can the upgrade fail to be atomic across the network, leaving some nodes using old formula validation while others use new logic, causing permanent network partition?",
  "[File: byteball/ocore/formula/index.js] [Module Pattern] [Export Mutation] Since JavaScript allows mutation of exported objects, if any code in the system (including third-party dependencies or malicious code) modifies exports.validate or exports.evaluate after this module loads, can subsequent callers receive the modified implementations, allowing attackers to compromise all formula validation/evaluation throughout the node's lifetime without triggering any security alerts?",
  "[File: byteball/ocore/formula/index.js] [Import Resolution] [Path Traversal] If an attacker can manipulate the module resolution path or create malicious validation.js/evaluation.js files in the formula directory before this index.js is first loaded, can the require() statements on lines 1-2 load attacker-controlled code instead of the legitimate modules, allowing complete compromise of formula validation and enabling theft of all funds secured by formula-based address definitions?",
  "[File: byteball/ocore/formula/index.js] [Function Identity] [Type Confusion] Since this module exports bare function references without type validation, if validation.js or evaluation.js accidentally export non-function values (e.g., due to refactoring errors), will definition.js and aa_composer.js attempt to invoke these non-functions as functions, causing type errors that crash nodes when processing units with formula definitions?",
  "[File: byteball/ocore/formula/index.js] [Module Scope] [Global Pollution] If validation.js or evaluation.js pollute the global scope during their initialization (e.g., by setting global variables, modifying built-in prototypes, or registering global event handlers), and this index.js loads them without isolation, can this global pollution affect other parts of the codebase, potentially causing non-deterministic behavior in unrelated validation logic that leads to consensus failures?",
  "[File: byteball/ocore/formula/index.js] [Async Behavior] [Event Loop Starvation] If the exported validate() and evaluate() functions perform synchronous operations that block the event loop (e.g., complex validation without yielding), and callers like definition.js invoke them during unit validation, can an attacker submit units with maximally complex formulas that cause event loop starvation, preventing the node from processing other units and effectively DoSing the network for extended periods?",
  "[File: byteball/ocore/formula/index.js] [Callback Semantics] [Double Callback] If validation.js or evaluation.js contain bugs that cause their callbacks to be invoked multiple times for a single formula validation/evaluation, and this facade doesn't prevent double-callbacks, can definition.js process the same formula validation result multiple times, potentially storing duplicate or conflicting results in the database and causing state corruption?",
  "[File: byteball/ocore/formula/index.js] [Module Loading] [Dependency Injection] Since this module hard-codes the dependencies on ./validation.js and ./evaluation.js without any dependency injection mechanism, if a critical security vulnerability is discovered in either module requiring an emergency patch, can nodes apply the patch without restarting or clearing caches, or will the module cache prevent the fix from taking effect until all nodes restart, creating a window for widespread exploitation?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 6-8] [Command Injection] Can an attacker execute arbitrary system commands by injecting shell metacharacters into process.argv arguments (e.g., `earlier_unit` containing '; rm -rf /' or backtick commands), potentially compromising the node host system and causing total network shutdown for that operator?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 7] [Input Validation] Does the script validate that `args[0]` (earlier_unit) matches the expected base64 unit hash format before passing it to main_chain.determineIfStableInLaterUnits(), or can arbitrary strings cause SQL injection, database corruption, or incorrect stability determinations leading to chain split?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Array Parsing] If `args[1]` is undefined or null (when running with fewer than 2 arguments), will the `.split(',')` operation throw an uncaught exception that crashes the process, potentially causing temporary network disruption if this script is used in production automation?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Input Validation] Can an attacker provide malformed comma-separated values in `args[1]` (e.g., empty strings after split like 'unit1,,unit3') resulting in arrLaterUnits containing invalid empty string elements that cause determineIfStableInLaterUnits() to return incorrect stability results or crash?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [DOS Attack] If an attacker provides an extremely long comma-separated list in `args[1]` (e.g., millions of unit hashes), will the split() operation consume excessive memory, causing the Node.js process to crash with OOM error and resulting in temporary network disruption?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 7-8] [Type Confusion] Does the script validate that args[0] and args[1] are strings before calling .split(), or can non-string types (if somehow injected) cause unexpected behavior, crashes, or incorrect results when passed to main_chain functions?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Special Characters] Can an attacker inject special characters in the comma-separated list (e.g., unit hashes containing commas, quotes, or SQL metacharacters) that bypass split() parsing and cause SQL injection in the downstream main_chain.determineIfStableInLaterUnits() function?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 6-8] [Argument Count] If the script is executed with zero arguments, does it handle the case where args[0] and args[1] are both undefined, or will it pass undefined values to main_chain.determineIfStableInLaterUnits() causing incorrect stability results or database errors?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 1-14] [Error Handling] The script contains no try-catch blocks or error handling for exceptions from main_chain.determineIfStableInLaterUnits() - if the function throws due to database errors, invalid units, or internal bugs, will the process crash without logging useful diagnostics, hindering incident response?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Callback Error Handling] The callback function (line 12-14) receives only `bStable` parameter with no error parameter - if determineIfStableInLaterUnits() encounters errors (database failures, invalid units, timeout), how are these errors communicated, and can silent failures lead to incorrect stability assumptions?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 1-14] [Uncaught Exceptions] If the db.js module fails to initialize (database file locked, corrupted, or inaccessible), will the script crash on line 3 with an uncaught exception before any validation occurs, potentially masking critical database integrity issues?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Async Error Propagation] If determineIfStableInLaterUnits() encounters an error deep in its execution (e.g., during graph traversal in main_chain.js lines 803-1000), but doesn't properly propagate it to the callback, can the script return incorrect stability results (bStable = undefined or false when it should error), leading to incorrect consensus decisions if this tool is used in automation?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 3] [Database Connection] The script passes the global `db` object to determineIfStableInLaterUnits() without explicitly opening or closing database connections - if the database is not properly initialized or is in an inconsistent state, can this lead to corrupt stability determinations that might be cached or propagated to other nodes?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 12-14] [Resource Cleanup] After the callback executes and logs the result, the script does not explicitly call process.exit() or close database connections - if the script hangs waiting for pending database operations or event loop tasks, can this cause resource exhaustion when run repeatedly in automated scripts?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 3] [Database Locking] If multiple instances of check_stability.js are executed concurrently on the same database (SQLite), can database locking conflicts cause determineIfStableInLaterUnits() to timeout, return incorrect results, or corrupt the database file leading to permanent data loss?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 3] [Connection Pool Exhaustion] If the db.js module uses connection pooling and this script is called repeatedly without proper cleanup, can it exhaust the connection pool, preventing other critical operations (unit validation, storage) from accessing the database and causing network-wide transaction delays?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Stability Determination Logic] If earlier_unit and arrLaterUnits form a circular dependency (where earlier_unit is actually a descendant of units in arrLaterUnits), will determineIfStableInLaterUnits() detect this impossibility and return false/error, or can it enter infinite recursion causing stack overflow and process crash?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Non-existent Units] If earlier_unit or any element in arrLaterUnits does not exist in the database, will determineIfStableInLaterUnits() handle this gracefully, or can it cause SQL errors, null pointer dereferences, or incorrect stability results that might lead to incorrect consensus decisions?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Malformed Unit Hashes] If earlier_unit or arrLaterUnits contain syntactically invalid base64 strings (wrong length, invalid characters), will determineIfStableInLaterUnits() reject them before database queries, or can malformed hashes cause SQL injection, database corruption, or crashes?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Hardcoded Exception Bypass] The main_chain.determineIfStableInLaterUnits() function contains hardcoded unit hash exceptions (lines 762-768 in main_chain.js) that bypass normal stability logic - if an attacker discovers the specific hash combinations in these hardcoded checks, can they craft inputs to check_stability.js that return incorrect stability results, potentially enabling double-spend attacks or chain splits?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Genesis Unit Edge Case] If earlier_unit is the genesis unit, determineIfStableInLaterUnits() returns true immediately (main_chain.js line 759-760) - but if the genesis unit constant is misconfigured or database is corrupted, can this early return bypass critical stability checks and cause all units to be incorrectly marked stable, leading to permanent chain split?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Free Unit Handling] According to main_chain.js line 774, units with is_free=1 return false - if an attacker can manipulate the is_free flag in the database (via direct DB access or corruption), can they force legitimate units to appear unstable indefinitely, causing permanent fund freezing?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Main Chain Index Null] If earlier_unit has main_chain_index=null (main_chain.js line 774), stability returns false - but if database corruption causes valid units to have null MCI, can this cause widespread incorrect stability determinations leading to chain split when different nodes have different corruption states?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Max Later LIMCI Comparison] The determineIfStableInLaterUnits() logic compares max_later_limci with objEarlierUnitProps.main_chain_index (main_chain.js lines 776-779) - if integer overflow occurs in max_later_limci calculation (when summing very large MCI values), can this cause incorrect stability determinations where earlier units appear stable when they're not, enabling double-spend attacks?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Witness Coverage Bypass] The stability determination requires collecting 7+ unique witnesses (constants.MAJORITY_OF_WITNESSES in main_chain.js lines 818-823) - if an attacker can craft a scenario where check_stability.js tests units that reference a corrupted witness list with duplicate witnesses counted twice (as noted in the bug comment at main_chain.js line 860), can this return incorrect stable=true results, allowing unstable units to be treated as confirmed?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Alternative Branch Detection] The determineIfStableInLaterUnits() checks for alternative branches (main_chain.js lines 886-901) - if an attacker can construct a DAG where alternative branches are not properly detected due to timing windows or race conditions, can this cause incorrect stability=true results for units that should remain unstable, enabling double-spend attacks?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Best Children Traversal DOS] The createListOfBestChildrenIncludedByLaterUnits() function (main_chain.js lines 904-1055) recursively traverses the DAG - if an attacker crafts a unit with an extremely deep or wide best children tree, can calling check_stability.js trigger stack overflow or timeout in this traversal, causing process crash or hanging indefinitely?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 3-12] [TOCTOU Race] Between reading earlier_unit properties (storage.readPropsOfUnits in main_chain.js line 771) and determining stability, if another process modifies unit properties (is_on_main_chain, main_chain_index, is_free) in the database, can this cause time-of-check-time-of-use race conditions leading to incorrect stability results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Concurrent Modification] If check_stability.js is executed while the node is actively processing new units and updating main chain assignments, can concurrent database writes cause non-deterministic results where the same earlier_unit/arrLaterUnits combination returns different stability values on successive runs?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 3-12] [Database Transaction Isolation] Does the determineIfStableInLaterUnits() function execute within a database transaction with appropriate isolation level, or can dirty reads of partially committed unit data cause incorrect stability calculations that diverge from other nodes' results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Async Callback Ordering] If multiple calls to check_stability.js are executed in rapid succession with overlapping database queries, can callback execution order become non-deterministic, causing console.log output to interleave incorrectly and confuse automated log parsing or monitoring systems?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 13] [Boolean Type Assumption] The script assumes bStable is a boolean, but if determineIfStableInLaterUnits() returns undefined, null, or non-boolean type due to errors, will console.log output misleading results that appear as valid stability determinations?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 13] [Output Parsing] If this script's console output is parsed by automated systems (monitoring, CI/CD), can malicious input cause injection of fake success/failure messages (e.g., earlier_unit containing '\\\\n--- stable? true' to forge results), leading to incorrect operational decisions?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 10] [Logging Injection] The console.log statement directly interpolates earlier_unit and arrLaterUnits from untrusted command-line input - if these contain ANSI escape codes, can they manipulate terminal output to hide errors, forge log messages, or execute terminal commands on operators' machines?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 10, 13] [Information Disclosure] Does logging the full earlier_unit hash and arrLaterUnits expose sensitive information about node state, pending units, or stability determination logic that could assist attackers in timing attacks or identifying vulnerable units?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Empty Array] If args[1] is an empty string '', the split(',') produces arrLaterUnits=[''] (array with one empty string element) - will determineIfStableInLaterUnits() handle this as an error or attempt to query for a unit with empty hash, causing SQL errors or incorrect results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Single Element Array] If args[1] contains a single unit hash with no commas, arrLaterUnits will have one element - does determineIfStableInLaterUnits() correctly handle the case where only one later unit is provided, or does it assume multiple units for statistical consensus?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Duplicate Later Units] If args[1] contains duplicate unit hashes (e.g., 'unit1,unit2,unit1'), will determineIfStableInLaterUnits() deduplicate them or process duplicates, potentially causing incorrect witness coverage calculations or performance degradation?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Case Sensitivity] If unit hashes in args[0] or args[1] have incorrect case (though base64 is case-sensitive), will determineIfStableInLaterUnits() fail to find matching units in the database, silently returning false stability when the correct-case units would return true?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 7-8] [Unicode/Encoding Issues] If command-line arguments contain non-ASCII characters or different Unicode encodings, can string comparison in determineIfStableInLaterUnits() fail to match database unit hashes, causing incorrect stability results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Whitespace Handling] If args[1] contains spaces around commas (e.g., 'unit1 , unit2'), will split(',') produce array elements with leading/trailing whitespace that don't match database hashes, causing false negative stability results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Testnet Hardcoded Exceptions] The determineIfStableInLaterUnits() function has testnet-specific hardcoded hash checks (constants.bTestnet conditions in main_chain.js lines 765-773) - if check_stability.js is used on mainnet with testnet configuration or vice versa, can this cause incorrect stability results leading to chain split between testnet and mainnet nodes?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 3] [Configuration Mismatch] If the db.js module is initialized with testnet configuration but check_stability.js is used to verify mainnet units, can this cause cross-chain stability checks that return incorrect results, potentially enabling cross-chain replay attacks?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Slow Query Attack] If an attacker provides earlier_unit and arrLaterUnits that trigger expensive graph traversal in determineIfStableInLaterUnits() (deep DAG, many alternative branches), can repeated execution of check_stability.js consume CPU and database resources, causing temporary network transaction delays 1 hour?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 7-8] [Memory Exhaustion] If an attacker provides args[1] with millions of comma-separated unit hashes (multi-MB command-line argument), will the split() operation and subsequent array processing exhaust Node.js heap memory, causing OOM crash and process termination?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Query Timeout Bypass] Does determineIfStableInLaterUnits() implement query timeouts to prevent indefinite hanging - if not, can an attacker craft inputs that cause infinite loops in graph traversal (main_chain.js lines 912-977) hanging the script and consuming resources indefinitely?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 4] [main_chain.js Dependency] The script directly requires main_chain.js without version checking or integrity validation - if main_chain.js is compromised (backdoor, modification), can malicious code execute when check_stability.js runs, potentially stealing keys, corrupting database, or manipulating stability results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 3] [db.js Initialization] The script assumes db.js is already initialized when required - if db.js requires explicit initialization (connecting to database, running migrations), can check_stability.js operate on uninitialized or partially-initialized database state, causing incorrect results or corruption?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 3-4] [Module Loading Order] If main_chain.js or db.js have circular dependencies or initialization order requirements, can requiring them in check_stability.js cause module loading errors, undefined references, or incorrect behavior that's hard to diagnose?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 6-8] [Command Injection] Can an attacker execute arbitrary system commands by injecting shell metacharacters into process.argv arguments (e.g., `earlier_unit` containing '; rm -rf /' or backtick commands), potentially compromising the node host system and causing total network shutdown for that operator?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 7] [Input Validation] Does the script validate that `args[0]` (earlier_unit) matches the expected base64 unit hash format before passing it to main_chain.determineIfStableInLaterUnits(), or can arbitrary strings cause SQL injection, database corruption, or incorrect stability determinations leading to chain split?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Array Parsing] If `args[1]` is undefined or null (when running with fewer than 2 arguments), will the `.split(',')` operation throw an uncaught exception that crashes the process, potentially causing temporary network disruption if this script is used in production automation?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Input Validation] Can an attacker provide malformed comma-separated values in `args[1]` (e.g., empty strings after split like 'unit1,,unit3') resulting in arrLaterUnits containing invalid empty string elements that cause determineIfStableInLaterUnits() to return incorrect stability results or crash?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [DOS Attack] If an attacker provides an extremely long comma-separated list in `args[1]` (e.g., millions of unit hashes), will the split() operation consume excessive memory, causing the Node.js process to crash with OOM error and resulting in temporary network disruption?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 7-8] [Type Confusion] Does the script validate that args[0] and args[1] are strings before calling .split(), or can non-string types (if somehow injected) cause unexpected behavior, crashes, or incorrect results when passed to main_chain functions?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Special Characters] Can an attacker inject special characters in the comma-separated list (e.g., unit hashes containing commas, quotes, or SQL metacharacters) that bypass split() parsing and cause SQL injection in the downstream main_chain.determineIfStableInLaterUnits() function?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 6-8] [Argument Count] If the script is executed with zero arguments, does it handle the case where args[0] and args[1] are both undefined, or will it pass undefined values to main_chain.determineIfStableInLaterUnits() causing incorrect stability results or database errors?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 1-14] [Error Handling] The script contains no try-catch blocks or error handling for exceptions from main_chain.determineIfStableInLaterUnits() - if the function throws due to database errors, invalid units, or internal bugs, will the process crash without logging useful diagnostics, hindering incident response?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Callback Error Handling] The callback function (line 12-14) receives only `bStable` parameter with no error parameter - if determineIfStableInLaterUnits() encounters errors (database failures, invalid units, timeout), how are these errors communicated, and can silent failures lead to incorrect stability assumptions?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 1-14] [Uncaught Exceptions] If the db.js module fails to initialize (database file locked, corrupted, or inaccessible), will the script crash on line 3 with an uncaught exception before any validation occurs, potentially masking critical database integrity issues?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Async Error Propagation] If determineIfStableInLaterUnits() encounters an error deep in its execution (e.g., during graph traversal in main_chain.js lines 803-1000), but doesn't properly propagate it to the callback, can the script return incorrect stability results (bStable = undefined or false when it should error), leading to incorrect consensus decisions if this tool is used in automation?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 3] [Database Connection] The script passes the global `db` object to determineIfStableInLaterUnits() without explicitly opening or closing database connections - if the database is not properly initialized or is in an inconsistent state, can this lead to corrupt stability determinations that might be cached or propagated to other nodes?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 12-14] [Resource Cleanup] After the callback executes and logs the result, the script does not explicitly call process.exit() or close database connections - if the script hangs waiting for pending database operations or event loop tasks, can this cause resource exhaustion when run repeatedly in automated scripts?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 3] [Database Locking] If multiple instances of check_stability.js are executed concurrently on the same database (SQLite), can database locking conflicts cause determineIfStableInLaterUnits() to timeout, return incorrect results, or corrupt the database file leading to permanent data loss?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 3] [Connection Pool Exhaustion] If the db.js module uses connection pooling and this script is called repeatedly without proper cleanup, can it exhaust the connection pool, preventing other critical operations (unit validation, storage) from accessing the database and causing network-wide transaction delays?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Stability Determination Logic] If earlier_unit and arrLaterUnits form a circular dependency (where earlier_unit is actually a descendant of units in arrLaterUnits), will determineIfStableInLaterUnits() detect this impossibility and return false/error, or can it enter infinite recursion causing stack overflow and process crash?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Non-existent Units] If earlier_unit or any element in arrLaterUnits does not exist in the database, will determineIfStableInLaterUnits() handle this gracefully, or can it cause SQL errors, null pointer dereferences, or incorrect stability results that might lead to incorrect consensus decisions?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Malformed Unit Hashes] If earlier_unit or arrLaterUnits contain syntactically invalid base64 strings (wrong length, invalid characters), will determineIfStableInLaterUnits() reject them before database queries, or can malformed hashes cause SQL injection, database corruption, or crashes?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Hardcoded Exception Bypass] The main_chain.determineIfStableInLaterUnits() function contains hardcoded unit hash exceptions (lines 762-768 in main_chain.js) that bypass normal stability logic - if an attacker discovers the specific hash combinations in these hardcoded checks, can they craft inputs to check_stability.js that return incorrect stability results, potentially enabling double-spend attacks or chain splits?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Genesis Unit Edge Case] If earlier_unit is the genesis unit, determineIfStableInLaterUnits() returns true immediately (main_chain.js line 759-760) - but if the genesis unit constant is misconfigured or database is corrupted, can this early return bypass critical stability checks and cause all units to be incorrectly marked stable, leading to permanent chain split?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Free Unit Handling] According to main_chain.js line 774, units with is_free=1 return false - if an attacker can manipulate the is_free flag in the database (via direct DB access or corruption), can they force legitimate units to appear unstable indefinitely, causing permanent fund freezing?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Main Chain Index Null] If earlier_unit has main_chain_index=null (main_chain.js line 774), stability returns false - but if database corruption causes valid units to have null MCI, can this cause widespread incorrect stability determinations leading to chain split when different nodes have different corruption states?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Max Later LIMCI Comparison] The determineIfStableInLaterUnits() logic compares max_later_limci with objEarlierUnitProps.main_chain_index (main_chain.js lines 776-779) - if integer overflow occurs in max_later_limci calculation (when summing very large MCI values), can this cause incorrect stability determinations where earlier units appear stable when they're not, enabling double-spend attacks?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Witness Coverage Bypass] The stability determination requires collecting 7+ unique witnesses (constants.MAJORITY_OF_WITNESSES in main_chain.js lines 818-823) - if an attacker can craft a scenario where check_stability.js tests units that reference a corrupted witness list with duplicate witnesses counted twice (as noted in the bug comment at main_chain.js line 860), can this return incorrect stable=true results, allowing unstable units to be treated as confirmed?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Alternative Branch Detection] The determineIfStableInLaterUnits() checks for alternative branches (main_chain.js lines 886-901) - if an attacker can construct a DAG where alternative branches are not properly detected due to timing windows or race conditions, can this cause incorrect stability=true results for units that should remain unstable, enabling double-spend attacks?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Best Children Traversal DOS] The createListOfBestChildrenIncludedByLaterUnits() function (main_chain.js lines 904-1055) recursively traverses the DAG - if an attacker crafts a unit with an extremely deep or wide best children tree, can calling check_stability.js trigger stack overflow or timeout in this traversal, causing process crash or hanging indefinitely?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 3-12] [TOCTOU Race] Between reading earlier_unit properties (storage.readPropsOfUnits in main_chain.js line 771) and determining stability, if another process modifies unit properties (is_on_main_chain, main_chain_index, is_free) in the database, can this cause time-of-check-time-of-use race conditions leading to incorrect stability results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Concurrent Modification] If check_stability.js is executed while the node is actively processing new units and updating main chain assignments, can concurrent database writes cause non-deterministic results where the same earlier_unit/arrLaterUnits combination returns different stability values on successive runs?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 3-12] [Database Transaction Isolation] Does the determineIfStableInLaterUnits() function execute within a database transaction with appropriate isolation level, or can dirty reads of partially committed unit data cause incorrect stability calculations that diverge from other nodes' results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Async Callback Ordering] If multiple calls to check_stability.js are executed in rapid succession with overlapping database queries, can callback execution order become non-deterministic, causing console.log output to interleave incorrectly and confuse automated log parsing or monitoring systems?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 13] [Boolean Type Assumption] The script assumes bStable is a boolean, but if determineIfStableInLaterUnits() returns undefined, null, or non-boolean type due to errors, will console.log output misleading results that appear as valid stability determinations?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 13] [Output Parsing] If this script's console output is parsed by automated systems (monitoring, CI/CD), can malicious input cause injection of fake success/failure messages (e.g., earlier_unit containing '\\\\n--- stable? true' to forge results), leading to incorrect operational decisions?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 10] [Logging Injection] The console.log statement directly interpolates earlier_unit and arrLaterUnits from untrusted command-line input - if these contain ANSI escape codes, can they manipulate terminal output to hide errors, forge log messages, or execute terminal commands on operators' machines?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 10, 13] [Information Disclosure] Does logging the full earlier_unit hash and arrLaterUnits expose sensitive information about node state, pending units, or stability determination logic that could assist attackers in timing attacks or identifying vulnerable units?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Empty Array] If args[1] is an empty string '', the split(',') produces arrLaterUnits=[''] (array with one empty string element) - will determineIfStableInLaterUnits() handle this as an error or attempt to query for a unit with empty hash, causing SQL errors or incorrect results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Single Element Array] If args[1] contains a single unit hash with no commas, arrLaterUnits will have one element - does determineIfStableInLaterUnits() correctly handle the case where only one later unit is provided, or does it assume multiple units for statistical consensus?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Duplicate Later Units] If args[1] contains duplicate unit hashes (e.g., 'unit1,unit2,unit1'), will determineIfStableInLaterUnits() deduplicate them or process duplicates, potentially causing incorrect witness coverage calculations or performance degradation?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Case Sensitivity] If unit hashes in args[0] or args[1] have incorrect case (though base64 is case-sensitive), will determineIfStableInLaterUnits() fail to find matching units in the database, silently returning false stability when the correct-case units would return true?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 7-8] [Unicode/Encoding Issues] If command-line arguments contain non-ASCII characters or different Unicode encodings, can string comparison in determineIfStableInLaterUnits() fail to match database unit hashes, causing incorrect stability results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 8] [Whitespace Handling] If args[1] contains spaces around commas (e.g., 'unit1 , unit2'), will split(',') produce array elements with leading/trailing whitespace that don't match database hashes, causing false negative stability results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Testnet Hardcoded Exceptions] The determineIfStableInLaterUnits() function has testnet-specific hardcoded hash checks (constants.bTestnet conditions in main_chain.js lines 765-773) - if check_stability.js is used on mainnet with testnet configuration or vice versa, can this cause incorrect stability results leading to chain split between testnet and mainnet nodes?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 3] [Configuration Mismatch] If the db.js module is initialized with testnet configuration but check_stability.js is used to verify mainnet units, can this cause cross-chain stability checks that return incorrect results, potentially enabling cross-chain replay attacks?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Slow Query Attack] If an attacker provides earlier_unit and arrLaterUnits that trigger expensive graph traversal in determineIfStableInLaterUnits() (deep DAG, many alternative branches), can repeated execution of check_stability.js consume CPU and database resources, causing temporary network transaction delays 1 hour?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 7-8] [Memory Exhaustion] If an attacker provides args[1] with millions of comma-separated unit hashes (multi-MB command-line argument), will the split() operation and subsequent array processing exhaust Node.js heap memory, causing OOM crash and process termination?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 12] [Query Timeout Bypass] Does determineIfStableInLaterUnits() implement query timeouts to prevent indefinite hanging - if not, can an attacker craft inputs that cause infinite loops in graph traversal (main_chain.js lines 912-977) hanging the script and consuming resources indefinitely?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 4] [main_chain.js Dependency] The script directly requires main_chain.js without version checking or integrity validation - if main_chain.js is compromised (backdoor, modification), can malicious code execute when check_stability.js runs, potentially stealing keys, corrupting database, or manipulating stability results?",
  "[File: byteball/ocore/tools/check_stability.js] [Line 3] [db.js Initialization] The script assumes db.js is already initialized when required - if db.js requires explicit initialization (connecting to database, running migrations), can check_stability.js operate on uninitialized or partially-initialized database state, causing incorrect results or corruption?",
  "[File: byteball/ocore/tools/check_stability.js] [Lines 3-4] [Module Loading Order] If main_chain.js or db.js have circular dependencies or initialization order requirements, can requiring them in check_stability.js cause module loading errors, undefined references, or incorrect behavior that's hard to diagnose?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [SQL Injection] Although the UPDATE query uses parameterized queries at line 25, could a malicious actor who gains write access to the order_providers array inject SQL through the replacement.new or replacement.old values if they contain special characters that bypass parameter sanitization?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [SQL Injection] Does the db.query() implementation at line 25 properly handle edge cases where replacement.new or replacement.old contain null bytes, Unicode control characters, or other special sequences that could break out of parameter binding?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Address Validation] The order_providers array hardcodes 7 address pairs without any validation - could typos in these addresses (e.g., invalid checksums, wrong length, invalid characters) cause the script to insert invalid witnesses into my_witnesses table, breaking witness consensus and causing a permanent network split?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Address Validation] The script does not call ValidationUtils.isValidAddress() to verify replacement.new before insertion at line 25 - could this allow insertion of invalid addresses into my_witnesses table, causing node crashes when the main chain logic tries to process witnesses?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Address Validation] Does the script verify that replacement.new addresses are valid Obyte addresses with proper chash160 format and checksums before updating my_witnesses, or could invalid addresses cause validation.js to reject all new units?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Address Validation] Could an attacker who modifies the source code insert their own address as replacement.new, effectively replacing trusted order provider witnesses with attacker-controlled addresses and compromising consensus?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Atomicity] The script executes 7 separate UPDATE queries (lines 23-28) without wrapping them in a database transaction (BEGIN/COMMIT) - if the script crashes after updating only some witnesses, could this leave my_witnesses in an inconsistent state with mixed old/new addresses, violating the 12-witness requirement?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Atomicity] Since asyncForEach processes replacements sequentially without a transaction wrapper, if UPDATE #4 fails but #1-3 succeed, can the resulting partial witness list (e.g., 9 old + 3 new) cause witness compatibility violations with existing units on the DAG?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Atomicity] Does the lack of transaction atomicity mean that if the node crashes mid-execution, the my_witnesses table could end up with fewer than constants.COUNT_WITNESSES (12) entries, causing readMyWitnesses() to throw 'wrong number of my witnesses' error and halting all unit composition?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 29-32] [Atomicity] The db.close() call at line 29 closes the database connection before verifying all UPDATEs succeeded - could database connection termination during async UPDATE operations cause some updates to be lost, resulting in incomplete witness replacement?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Race Condition] If this script runs concurrently with the main node process that's composing new units via composer.js (which reads my_witnesses), could a race condition cause the composer to read a partially-updated witness list and create units with invalid witness compatibility?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Race Condition] Since the script does not acquire a mutex or lock before modifying my_witnesses, could concurrent execution of this script (accidentally run twice) result in duplicate UPDATE operations causing database deadlocks or inconsistent state?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Race Condition] If witness_proof.js is generating proofs while this script updates my_witnesses at line 25, could the witness proof generator use a mix of old and new witnesses in a single proof, creating invalid proofs that light clients reject?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Race Condition] Can concurrent reads from readMyWitnesses() in my_witnesses.js during the UPDATE operations return an empty array or incomplete witness list, causing the node to crash with 'wrong number of my witnesses' error?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Consensus Violation] If any of the 7 replacement.new addresses are not actively posting units or have never posted stable units, does this break the witness stability requirements and prevent the main chain from advancing past the replacement MCI?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Consensus Violation] After replacing witnesses at line 25, does the script verify that existing stable units on the main chain are still compatible with the new witness list (share 1 witness), or could this create a witness compatibility fork?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Consensus Violation] Could malicious replacement addresses in order_providers array cause nodes that run this script to diverge from nodes that don't, creating a permanent network partition where the two subsets have incompatible witness lists?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Consensus Violation] Does the script check whether the new witness addresses have address definitions that could change in the future (violating witness stability requirements), potentially causing main chain calculation failures when storage.determineIfWitnessAddressDefinitionsHaveReferences() runs?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Consensus Violation] If the replacement witness addresses have lower activity levels than the old witnesses, could this slow down main chain advancement and cause network transaction delays exceeding 1 day (Medium severity per Immunefi)?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Error Handling] The script does not check the return value or catch errors from db.query() at line 25 - if an UPDATE fails due to database constraint violations or disk full errors, does the script continue silently without alerting operators?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: asyncForEach()] [Error Handling] The asyncForEach helper at lines 16-20 does not wrap the callback in try/catch - if the callback throws an exception during UPDATE operations, could this cause the script to exit before db.close() is called, leaving database connections open?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 29-32] [Error Handling] The db.close() callback at line 29 does not handle potential errors during connection closure - could failed database closure leave locks or transactions in inconsistent states?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 24-27] [Error Handling] The conditional check at line 24 verifies replacement.old and replacement.new exist but does not validate they are non-empty strings - could empty string values pass this check and cause UPDATE queries to corrupt my_witnesses data?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Error Handling] If the UPDATE query at line 25 fails to match any rows (replacement.old not found in my_witnesses), does the script detect this and abort, or does it silently continue and potentially leave the witness list incomplete?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 6-14] [Environment Bypass] The testnet check at line 6 only examines process.env.testnet - could an attacker manipulate environment variables to make the script run on testnet with mainnet witness addresses, or vice versa, causing incompatible witness lists?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 6-14] [Environment Bypass] Does the environment check properly handle edge cases where process.env.testnet is set to string 'false' or '0' (truthy in JavaScript), potentially causing mainnet witness replacements to not execute?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 6-14] [Environment Bypass] If constants.bTestnet and process.env.testnet fall out of sync due to configuration errors, could the script update witnesses for the wrong network, causing witness incompatibility?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Duplicate Detection] The order_providers array does not check for duplicate old addresses - if the same old address appears twice with different new addresses, could both UPDATEs execute and cause the final witness list to have duplicates of the second new address?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Duplicate Detection] Does the script verify that replacement.new addresses are not already present in my_witnesses before UPDATE (like my_witnesses.js replaceWitness() does), or could this create duplicate witness entries violating the unique constraint?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Duplicate Detection] If two different old addresses map to the same new address in order_providers, would both UPDATE queries try to insert the same new address, potentially reducing the witness count below 12?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Witness Count] After all UPDATE operations complete, does the script verify that my_witnesses still contains exactly constants.COUNT_WITNESSES (12) entries, or could failed/skipped updates leave an invalid count causing node crashes?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Witness Count] If not all 7 old addresses exist in my_witnesses before replacement (e.g., user has custom witness list), could the UPDATEs that match zero rows cause the final witness count to be less than 12?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Witness Count] Does the script account for the possibility that users may have manually modified my_witnesses to include witnesses not in the order_providers list, and could this cause witness count inconsistencies after replacement?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Database Corruption] If the my_witnesses table lacks a PRIMARY KEY constraint on address field, could the UPDATE at line 25 create duplicate entries for the same witness address, breaking witness validation logic?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Database Corruption] Does the script verify that the database is not in read-only mode before attempting UPDATEs at line 25, or could this cause silent failures leaving witness replacements incomplete?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 29-32] [Database Corruption] The immediate process.exit() at line 31 after db.close() does not wait for all pending write operations to flush to disk - could this cause database corruption on systems with delayed write caching?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Rollback Capability] The script provides no mechanism to rollback witness changes if replacement addresses turn out to be inactive or malicious - does this mean a bad replacement requires manual database surgery or data restoration from backups?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Rollback Capability] Since the script does not create a backup of my_witnesses before modification, if the replacement causes consensus failures, how can operators restore the original witness list without full database restoration?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Rollback Capability] Does the lack of transaction wrapping mean that partial execution cannot be rolled back atomically, requiring manual identification and reversal of which UPDATEs succeeded?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 1-34] [Concurrent Execution] The script lacks any mutex, lock file, or singleton enforcement mechanism - could accidental concurrent execution (e.g., cron job overlap) cause database deadlocks or apply witness replacements multiple times?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Concurrent Execution] If two instances of this script run simultaneously with different order_providers arrays, could interleaved UPDATE operations create an inconsistent final witness list that doesn't match either intended replacement set?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Light Client] After witness replacement at line 25, do light clients using the old witness list receive witness proofs that are incompatible with their local witness configuration, causing them to reject all new stable units?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Light Client] Does witness_proof.js detect that local my_witnesses has changed and invalidate cached proofs, or could stale proofs referencing old witnesses cause light client sync failures?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Hardcoded Secrets] The order_providers array contains hardcoded addresses visible in source code - could attackers targeting these specific witnesses (via DDoS, compromise, etc.) gain leverage knowing they are critical to network consensus?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 7-13] [Hardcoded Secrets] Does the public visibility of exact witness addresses in GitHub allow attackers to precompute attacks or social engineering campaigns against the 7 order provider operators?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 29-32] [Process Lifecycle] The process.exit() at line 31 terminates the entire process - if this script is imported as a module by another process (despite being a standalone tool), could it crash the parent process?",
  "[File: byteball/ocore/tools/replace_ops.js] [Function: replace_OPs()] [Process Lifecycle] Does the script handle SIGINT/SIGTERM signals gracefully during UPDATE operations, or could Ctrl+C mid-execution leave database transactions uncommitted or connections leaked?",
  "[File: byteball/ocore/tools/replace_ops.js] [Lines: 34] [Process Lifecycle] The immediate execution at line 34 (replace_OPs() called at module load) prevents any pre-execution validation or confirmation prompts - could accidental execution (e.g., require() in wrong context) trigger unwanted witness replacement?",
  "[File: byteball/ocore/tools/supply.js] [Hardcoded addresses] If the hardcoded not_circulating addresses (MZ4GUQC7WUKZKKLGAS3H3FSDKLHI7HFO, BZUAVP5O4ND6N3PVEUZJOATXFPIKHPDC, TUOMEGAZPYLZQBJKLEM2BGKYR2Q5SEYS, FCXZXQR353XI4FIPQL6U4G2EQJL4CCU2) are compromised and their private keys leaked, can attackers spend funds from these addresses causing incorrect circulating supply calculations and potentially market manipulation through false scarcity metrics?",
  "[File: byteball/ocore/tools/supply.js] [Configuration vulnerability] Does the testnet check using process.env.testnet have any validation to ensure the environment variable hasn't been tampered with, potentially causing mainnet nodes to use testnet addresses or vice versa, leading to completely incorrect supply calculations that could affect economic decisions?",
  "[File: byteball/ocore/tools/supply.js] [Address list integrity] If one of the hardcoded not_circulating addresses (lines 8-15) is incorrectly copied or contains a typo, would this silently include those funds in the circulating supply calculation, potentially inflating the reported circulating supply and misleading market participants about actual token scarcity?",
  "[File: byteball/ocore/tools/supply.js] [Missing address validation] Are the hardcoded addresses validated to ensure they are valid Obyte addresses with correct checksums, or could an address typo go undetected until funds are actually moved, causing a sudden unexpected change in circulating supply metrics?",
  "[File: byteball/ocore/tools/supply.js] [Address completeness] Is there any mechanism to verify that all non-circulating addresses are actually included in the not_circulating array, or could forgotten addresses (e.g., additional foundation wallets, locked contracts, or burned addresses) cause the circulating supply to be overreported?",
  "[File: byteball/ocore/tools/supply.js] [Race condition - nested callbacks] Between the three nested async callbacks (readLastMainChainIndex  readLastStableMcIndex  readAllUnspentOutputs), if new units are added to the main chain after reading last_mci but before calculating balances, will the supply calculation reflect an inconsistent state where last_mci is stale but unspent outputs are fresh, potentially causing supply discrepancies?",
  "[File: byteball/ocore/tools/supply.js] [Database transaction isolation] Since the script doesn't use database transactions to atomically read last_mci, last_stable_mci, and unspent outputs, can concurrent unit additions during the three separate queries cause the script to report supply values from different database snapshots, leading to inconsistent or impossible supply states?",
  "[File: byteball/ocore/tools/supply.js] [Main chain advancement race] If the main chain advances (new units become stable) between reading last_stable_mci and reading unspent outputs, could this cause the script to include outputs from units that haven't reached stability yet, violating the invariant that circulating supply should only count stable confirmed funds?",
  "[File: byteball/ocore/tools/supply.js] [Concurrent execution] If multiple instances of this script are run simultaneously on the same database, could they interfere with each other's reads or cause database lock contention that delays or corrupts the supply calculation results?",
  "[File: byteball/ocore/tools/supply.js] [Callback execution order] Is there any guarantee that the nested callbacks execute in the expected order without interleaving, or could event loop scheduling cause unexpected execution sequences that produce incorrect supply calculations under high load?",
  "[File: byteball/ocore/tools/supply.js] [Missing error handling] The script has no error handling for any of the three async operations (storage.readLastMainChainIndex, storage.readLastStableMcIndex, balances.readAllUnspentOutputs) - if any of these operations fail (database unavailable, corrupted data, network timeout), will the script hang indefinitely without reporting the error, potentially causing monitoring systems to miss supply calculation failures?",
  "[File: byteball/ocore/tools/supply.js] [Uncaught exceptions] If balances.readAllUnspentOutputs throws an exception (e.g., database query error, memory exhaustion from large result sets), is the exception caught and handled, or will the process crash without cleanup, potentially leaving database connections open or locks held?",
  "[File: byteball/ocore/tools/supply.js] [Process exit timing] The script calls process.exit() immediately after logging results (line 22) - does this allow sufficient time for console.error output to be flushed to stderr, or could the process terminate before error messages are fully written, causing monitoring systems to miss critical supply calculation data?",
  "[File: byteball/ocore/tools/supply.js] [Database connection cleanup] Before calling process.exit(), does the script properly close database connections and release any held resources (locks, cursors, connection pool entries), or could abrupt termination leave zombie connections that eventually exhaust the connection pool and cause database deadlocks?",
  "[File: byteball/ocore/tools/supply.js] [Exit code handling] The script always calls process.exit() without specifying an exit code - in case of errors or invalid supply calculations, should it exit with non-zero status to signal failure to orchestration systems, or does silent success with incorrect data pose operational risks?",
  "[File: byteball/ocore/tools/supply.js] [Integer overflow in supply calculation] Within balances.readAllUnspentOutputs, when summing amounts across all unspent outputs (total_amount, circulating_amount), could integer overflow occur if total supply exceeds JavaScript's MAX_SAFE_INTEGER (2^53-1), causing reported supply to wrap around and show impossibly low values?",
  "[File: byteball/ocore/tools/supply.js] [Spent output detection] Does balances.readAllUnspentOutputs correctly filter for is_spent=0 in its database query, or could a race condition between marking outputs as spent and reading them cause spent outputs to be incorrectly counted in circulating supply?",
  "[File: byteball/ocore/tools/supply.js] [Asset filtering] The script passes not_circulating addresses to readAllUnspentOutputs but doesn't specify asset filtering - does this correctly calculate supply for the base asset (bytes) only, or could it incorrectly include custom assets held by those addresses, inflating the reported supply?",
  "[File: byteball/ocore/tools/supply.js] [Witness and commission outputs] Does balances.readAllUnspentOutputs include witnessing_outputs and headers_commission_outputs in the total supply calculation, and if so, are these outputs correctly attributed to circulating vs non-circulating supply based on who controls the witness addresses?",
  "[File: byteball/ocore/tools/supply.js] [Double-counting prevention] If the same output appears in multiple categories within balances.readAllUnspentOutputs (e.g., both in regular outputs and commission outputs due to database inconsistency), could it be counted twice in total_amount, artificially inflating the reported supply?",
  "[File: byteball/ocore/tools/supply.js] [SQL injection via address list] If the not_circulating address array were somehow modified (e.g., via environment variable injection in testnet mode), could malformed addresses cause SQL injection in balances.readAllUnspentOutputs when constructing the WHERE address IN(...) clause?",
  "[File: byteball/ocore/tools/supply.js] [Database connection state] Does storage.readLastMainChainIndex establish a fresh database connection or reuse an existing one, and if the connection is in a failed state from a previous operation, will the script detect this and fail gracefully rather than returning stale cached data?",
  "[File: byteball/ocore/tools/supply.js] [Query performance under load] If the unspent outputs table contains millions of rows, could the balances.readAllUnspentOutputs query (which groups by address and sums amounts) cause excessive memory usage or CPU load that delays or crashes the script, effectively creating a DoS vector for supply monitoring?",
  "[File: byteball/ocore/tools/supply.js] [Index utilization] Does the database query in readAllUnspentOutputs properly utilize indexes on (is_spent, address, asset) columns, or could missing indexes cause full table scans that exponentially slow down as the DAG grows, eventually making supply calculations take hours instead of milliseconds?",
  "[File: byteball/ocore/tools/supply.js] [Database transaction visibility] Since the script doesn't explicitly start a transaction, it relies on the database's default isolation level - if this is READ COMMITTED rather than REPEATABLE READ, could concurrent transactions cause the three queries to see different committed states, producing inconsistent supply snapshots?",
  "[File: byteball/ocore/tools/supply.js] [MCI consistency check] The script reads both last_mci and last_stable_mci but doesn't validate that last_stable_mci  last_mci - if database corruption or a bug in main chain advancement causes last_stable_mci > last_mci (impossible state), will the script detect this invariant violation or silently report invalid supply data?",
  "[File: byteball/ocore/tools/supply.js] [Stability point regression] If last_stable_mci decreases between two consecutive runs of the script (which should never happen after units become stable), does any monitoring or alerting detect this consensus-breaking event, or would the supply calculation silently accept the impossible state?",
  "[File: byteball/ocore/tools/supply.js] [Genesis unit handling] Does storage.readLastMainChainIndex handle the special case of an empty database (genesis unit not yet added) by returning 0, and does balances.readAllUnspentOutputs correctly handle this case, or could a newly initialized node crash when running this script before syncing any units?",
  "[File: byteball/ocore/tools/supply.js] [Unstable unit outputs] When calculating circulating supply, does the script include outputs from units that are on the main chain (have MCI assigned) but are not yet stable (MCI > last_stable_mci), potentially counting funds that could theoretically be reorganized out during stability determination?",
  "[File: byteball/ocore/tools/supply.js] [Light node compatibility] If this script is run on a light node that only stores stable units and doesn't have full DAG history, will storage.readLastMainChainIndex and readLastStableMcIndex return correct values, or could missing historical data cause the script to report incorrectly low supply?",
  "[File: byteball/ocore/tools/supply.js] [Environment variable spoofing] The testnet check relies on process.env.testnet (line 8) - if an attacker can set environment variables for the node process (e.g., through container orchestration misconfiguration), could they force a mainnet node to use testnet addresses, causing all foundation funds to be incorrectly counted as circulating and reporting inflated supply?",
  "[File: byteball/ocore/tools/supply.js] [Testnet address validity] Is the single testnet not_circulating address (5ZPGXCOGRGUUXIUU72JIENHXU6XU77BD) actually the testnet equivalent of the mainnet foundation addresses, or was this address arbitrarily chosen without corresponding to real non-circulating testnet funds?",
  "[File: byteball/ocore/tools/supply.js] [Cross-network pollution] If a node switches between testnet and mainnet (e.g., by changing process.env.testnet and restarting without clearing database), could residual testnet data in the database cause supply calculations to mix testnet and mainnet outputs, producing nonsensical results?",
  "[File: byteball/ocore/tools/supply.js] [Testnet-specific units] Does the testnet have different genesis parameters (initial supply, distribution addresses) compared to mainnet, and if so, does using only one not_circulating address for testnet correctly account for all non-circulating testnet funds?",
  "[File: byteball/ocore/tools/supply.js] [Supply object tampering] The supply object returned by balances.readAllUnspentOutputs contains addresses, txouts, total_amount, circulating_txouts, circulating_amount, headers_commission_amount, payload_commission_amount - could any of these fields be NaN, undefined, or negative due to database corruption, causing the logged output to be unparseable by monitoring systems?",
  "[File: byteball/ocore/tools/supply.js] [Precision loss in large numbers] When logging supply.total_amount and supply.circulating_amount using console.error (line 21), if these values exceed JavaScript's safe integer range, could they lose precision during string conversion, causing monitoring systems to see supply values that differ from actual database values by several decimal places?",
  "[File: byteball/ocore/tools/supply.js] [Object.assign side effects] The script uses Object.assign to merge {last_mci, last_stable_mci} with the supply object before logging - if the supply object already has properties named last_mci or last_stable_mci, would the merge silently overwrite critical supply data, causing confusion in supply reports?",
  "[File: byteball/ocore/tools/supply.js] [Execution time accuracy] The script calculates execution time using Date.now() at the start and end (lines 7, 20) - if the system clock is adjusted (NTP sync, timezone change) during execution, could the reported execution time be negative or impossibly large, triggering false alerts in monitoring systems?",
  "[File: byteball/ocore/tools/supply.js] [Stderr buffer limits] The script logs potentially large JSON objects to stderr using console.error (line 21) - if the supply object is extremely large (millions of addresses with unspent outputs), could this exceed stderr buffer limits and cause truncation or blocking that prevents the process from exiting cleanly?",
  "[File: byteball/ocore/tools/supply.js] [Unit addition during calculation] If new units are being actively added to the DAG while this script runs (normal network operation), the three separate database queries could see different states - for example, a new payment from a not_circulating address could be read by readAllUnspentOutputs but the corresponding input spending hasn't been processed yet, causing temporary double-counting of those funds?",
  "[File: byteball/ocore/tools/supply.js] [Archiving interference] If the archiving process (archiving.js) is running concurrently and strips old unit content while this script reads unspent outputs, could archived outputs be excluded from the count even though they're still unspent, causing sudden drops in reported supply?",
  "[File: byteball/ocore/tools/supply.js] [Database backup during execution] If a database backup or maintenance operation locks tables while this script is running, could the script timeout waiting for locks, hang indefinitely, or receive partial results that produce incorrect supply calculations?",
  "[File: byteball/ocore/tools/supply.js] [Catchup state interference] If a node is actively catching up (syncing historical units) while this script runs, could the rapidly changing database state cause the three queries to produce incoherent results (e.g., last_stable_mci from before catchup but unspent outputs from after), reporting impossible supply transitions?",
  "[File: byteball/ocore/tools/supply.js] [No supply bounds validation] The script doesn't validate that total_amount is within expected bounds (e.g., equal to or less than the theoretical maximum supply defined in protocol constants) - if database corruption or a balance calculation bug causes reported supply to exceed the maximum possible supply, will this go unnoticed or trigger alerts?",
  "[File: byteball/ocore/tools/supply.js] [Negative supply detection] If a bug in balances.readAllUnspentOutputs causes negative amounts to be summed (e.g., due to integer underflow or corrupted database rows with negative amounts), could circulating_amount become negative, which is an impossible state that should trigger immediate alerts but instead might silently propagate to monitoring dashboards?",
  "[File: byteball/ocore/tools/supply.js] [Circulating > Total invariant] The script doesn't validate that circulating_amount  total_amount (since circulating excludes non-circulating addresses) - if this invariant is violated due to database corruption or accounting errors, will monitoring detect this impossible state?",
  "[File: byteball/ocore/tools/supply.js] [Missing address ownership verification] The hardcoded not_circulating addresses are assumed to be controlled by trusted entities (Obyte foundation, distribution fund) - is there any mechanism to verify these addresses haven't changed owners via definition_chg messages, potentially causing funds to be incorrectly excluded from circulating supply even though they're now controlled by untrusted parties?",
  "[File: byteball/ocore/tools/supply.js] [Commission output accounting] The script includes headers_commission_amount and payload_commission_amount in total supply - does this correctly account for unclaimed witness rewards that haven't been withdrawn yet, or could there be a discrepancy between reported supply and actual spendable supply due to locked commission outputs?",
  "[File: byteball/ocore/tools/supply.js] [Memory exhaustion from large result sets] If balances.readAllUnspentOutputs loads all unspent outputs into memory before processing (rather than streaming), and there are millions of unspent outputs, could the script exhaust available memory and crash with OOM error, causing supply calculation monitoring to fail silently?",
  "[File: byteball/ocore/tools/supply.js] [Execution timeout] The script has no timeout mechanism - if the database queries hang due to deadlocks or extremely slow queries, will the script run indefinitely consuming resources, or is there external process supervision that would kill it after a reasonable timeout?",
  "[File: byteball/ocore/tools/supply.js] [Database connection pool exhaustion] If this script is scheduled to run frequently (e.g., every minute for monitoring) and previous executions haven't properly closed database connections, could connection pool exhaustion prevent new runs from starting, causing monitoring gaps?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 8: earlier_unit = args[0]] [Input Validation] Does the script validate that args[0] is a valid base64-encoded unit hash before passing it to determineIfStableInLaterUnitsAndUpdateStableMcFlag, or can an attacker provide a malformed string causing SQL injection or database corruption?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 9: arrLaterUnits = args[1].split(',')] [Input Validation] If args[1] is undefined or not a string, will the .split() call crash the script, and if so, does this leave the database in an inconsistent state since storage.initCaches() was already called?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 9: arrLaterUnits = args[1].split(',')] [Array Manipulation] Can an attacker provide an empty string or whitespace-only values in the comma-separated list, resulting in arrLaterUnits containing empty strings that bypass validation in determineIfStableInLaterUnits and cause incorrect stability determination?",
  "[File: byteball/ocore/tools/update_stability.js] [Lines 7-9: process.argv] [Input Validation] Does the script validate that exactly 2 command-line arguments are provided, or can providing 0, 1, or >2 arguments cause undefined behavior or incorrect stability updates?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 8: earlier_unit] [Hash Format Validation] Can an attacker provide a unit hash that exists in the database but points to an already-stable unit, causing the script to attempt re-stabilization and potentially corrupting the last_stable_mci or ball chain?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 9: arrLaterUnits] [Duplicate Detection] If arrLaterUnits contains duplicate unit hashes (e.g., 'unit1,unit1,unit2'), will determineIfStableInLaterUnits handle this correctly, or could it cause double-counting of witnessed levels leading to incorrect stability determination?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 9: arrLaterUnits] [Order Dependency] Does the order of units in the comma-separated arrLaterUnits list affect the stability calculation, and if so, can an attacker manipulate the ordering to cause earlier_unit to be incorrectly marked as stable or unstable?",
  "[File: byteball/ocore/tools/update_stability.js] [Lines 8-9: args parsing] [Injection Attack] Can an attacker inject special characters or SQL/JavaScript payloads in the unit hash arguments that get passed unsanitized to database queries in main_chain.js, causing SQL injection or code execution?",
  "[File: byteball/ocore/tools/update_stability.js] [Script Execution] [Authorization] Is there any access control mechanism preventing unauthorized users from running this script, or can any user with command-line access to the node manually advance the stability point, causing consensus divergence from other nodes in the network?",
  "[File: byteball/ocore/tools/update_stability.js] [Script Purpose] [Privilege Escalation] Since this tool directly modifies the stability point (a consensus-critical property), can a malicious node operator use it to falsely mark units as stable before the network consensus agrees, creating a permanent chain split when other nodes reject subsequent units referencing different stability points?",
  "[File: byteball/ocore/tools/update_stability.js] [Database Access] [Permission Model] Does the script require elevated database privileges (e.g., ability to UPDATE units table and acquire write locks), and if so, is there auditing or logging of when and by whom the script is executed to detect malicious stability manipulation?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 13: storage.initCaches()] [Race Condition] If the main network process is simultaneously running and also calling storage.initCaches() or modifying assocUnstableUnits/assocStableUnits caches, can the script's cache initialization create inconsistent in-memory state that causes subsequent validation to accept/reject units incorrectly?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 15: db.executeInTransaction] [Concurrent Transactions] If the main network process is simultaneously advancing the stability point in its own transaction (via main_chain.updateStableMcFlag), can both transactions attempt to mark overlapping MCIs as stable, causing database deadlock or one transaction overwriting the other's stability updates?",
  "[File: byteball/ocore/tools/update_stability.js] [Lines 15-19: Transaction] [Lock Acquisition] The determineIfStableInLaterUnitsAndUpdateStableMcFlag function acquires a write lock (line 1163 of main_chain.js), but does db.executeInTransaction() also hold a database connection lock, potentially causing deadlock if the network process is waiting for either lock?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: determineIfStableInLaterUnitsAndUpdateStableMcFlag] [Callback Timing] The callback at line 17 logs 'stable? bStable' but determineIfStableInLaterUnitsAndUpdateStableMcFlag may return early (line 1159) before actually updating the database - can this cause the script to exit with cb() before stability updates are committed, leaving partial updates?",
  "[File: byteball/ocore/tools/update_stability.js] [Lines 15-19: Transaction Scope] [Atomicity Violation] If determineIfStableInLaterUnitsAndUpdateStableMcFlag acquires its own database connection (line 1166 of main_chain.js) after the callback returns, does this violate the transaction boundary established by db.executeInTransaction, causing the stability updates to occur outside the transaction and potentially fail to commit or rollback correctly?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: determineIfStableInLaterUnitsAndUpdateStableMcFlag] [Non-Deterministic Execution] If the network receives new units between when this script determines stability and when it updates the database, can the stability determination become stale, causing the script to mark a unit as stable that should no longer be considered stable given newer network state?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 15: db.executeInTransaction] [Transaction Rollback] If determineIfStableInLaterUnitsAndUpdateStableMcFlag throws an error after partially marking some MCIs as stable (e.g., fails during markMcIndexStable iteration), does db.executeInTransaction properly rollback all changes, or can partial stability updates persist causing last_stable_mci to be inconsistent with is_stable flags?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: earlier_unit parameter] [Non-Existent Unit] If earlier_unit does not exist in the units table, will determineIfStableInLaterUnitsAndUpdateStableMcFlag throw an error causing the transaction to rollback, or can it silently fail leaving the script in an unknown state?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: arrLaterUnits parameter] [Invalid Later Units] If one or more units in arrLaterUnits do not exist in the database or are not actually 'later' than earlier_unit (lower MCI), will the stability determination return false correctly, or can it incorrectly mark earlier_unit as stable causing consensus divergence?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: false parameter] [bStableInDb Flag] The script always passes false for the bStableInDb parameter - if earlier_unit is already marked as stable in the database (is_stable=1), will determineIfStableInLaterUnitsAndUpdateStableMcFlag detect this and skip redundant updates, or can it cause duplicate ball creation or corruption of the stability chain?",
  "[File: byteball/ocore/tools/update_stability.js] [Lines 15-19: Transaction] [Connection Pooling] Does db.executeInTransaction acquire and release a database connection properly, or can running this script multiple times in parallel exhaust the connection pool causing the main network process to be unable to acquire connections for processing new units (network halt)?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: determineIfStableInLaterUnitsAndUpdateStableMcFlag] [MCI Validation] If earlier_unit has main_chain_index=NULL (is not on main chain), will the function correctly return false and prevent stability updates, or can it attempt to mark off-chain units as stable causing database constraint violations?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 13: storage.initCaches()] [Cache Initialization] Does initCaches() load ALL unstable and stable units into memory, or only a subset, and if the latter, can the script's stability determination be based on incomplete cache data causing incorrect results?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 13: storage.initCaches()] [Cache Staleness] If the main network process modifies assocUnstableUnits or assocStableUnits AFTER this script calls initCaches() but BEFORE determineIfStableInLaterUnitsAndUpdateStableMcFlag reads from these caches, can the stale cache cause incorrect stability determination?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 13: storage.initCaches()] [Memory Exhaustion] If the database contains a very large number of unstable units (e.g., during a spam attack or network partition), will initCaches() attempt to load all of them into memory causing OOM and crashing the script before stability updates can complete?",
  "[File: byteball/ocore/tools/update_stability.js] [Lines 13-16: Cache Usage] [Write-Through Consistency] After determineIfStableInLaterUnitsAndUpdateStableMcFlag updates the database to mark units as stable, does it also update the in-memory caches (assocUnstableUnits  assocStableUnits), or can the caches become inconsistent with the database causing subsequent validations to fail?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: earlier_unit stability] [Premature Stabilization] If an administrator runs this script with an earlier_unit that is NOT yet stable according to normal network consensus rules (min_mc_wl < first_unstable_mc_level), but provides carefully chosen arrLaterUnits that artificially satisfy the stability check, can this cause the node to diverge from the network by prematurely advancing its stability point?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: stability advancement] [Chain Split] If this script marks earlier_unit and all preceding MCIs as stable, but other nodes in the network have not yet reached consensus on this stability point, will subsequent units from this node reference a last_ball that other nodes consider invalid, causing permanent rejection and chain split?",
  "[File: byteball/ocore/tools/update_stability.js] [Script Purpose] [Consensus Override] Since this tool allows manual stability advancement bypassing the normal updateStableMcFlag automatic process, can a malicious operator use it to 'fast-forward' stability past units that should have been marked as final-bad due to double-spends, allowing invalid transactions to become immutable?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: determineIfStableInLaterUnitsAndUpdateStableMcFlag] [Witness Counting] The stability determination relies on collecting MAJORITY_OF_WITNESSES (7 of 12) witness signatures - if the provided arrLaterUnits contains units with incompatible witness lists, can the function incorrectly count witnesses across incompatible sets causing false positive stability?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: bStableInDb=false] [Re-execution Safety] If this script is run multiple times with the same earlier_unit (e.g., administrator retries after error), will subsequent runs correctly detect that earlier_unit is already stable and skip updates, or can repeated execution cause corruption of balls, last_stable_mci, or content hashes?",
  "[File: byteball/ocore/tools/update_stability.js] [Lines 15-19: Transaction callback] [Error Propagation] If determineIfStableInLaterUnitsAndUpdateStableMcFlag throws an error (e.g., 'new last stable mci expected to be higher than existing' at main_chain.js line 1174), does db.executeInTransaction catch and rollback properly, or can the error crash the script leaving the database connection open and locked?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 18: callback] [Incomplete Logging] The callback only logs 'stable? bStable' without indicating whether database updates were actually performed - if an administrator relies on this output to verify success, can silent failures (e.g., thrown errors after callback returns) go undetected?",
  "[File: byteball/ocore/tools/update_stability.js] [Script Exit] [Graceful Shutdown] After the callback at line 18 executes and logs the result, does the script properly wait for the database transaction to commit and all async operations to complete before exiting, or can it terminate prematurely leaving uncommitted changes or orphaned connections?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 13: storage.initCaches()] [Initialization Failure] If initCaches() fails (e.g., database connection error, corrupt data), does it throw an error that prevents the script from continuing to stability updates, or can it silently fail with partial cache initialization causing incorrect stability determination?",
  "[File: byteball/ocore/tools/update_stability.js] [Lines 7-9: args parsing] [Missing Arguments] If the script is run with no arguments (process.argv.length < 4), accessing args[0] and args[1] will return undefined - does this cause a crash with clear error message, or does it pass undefined values to determineIfStableInLaterUnitsAndUpdateStableMcFlag causing obscure database errors?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: determineIfStableInLaterUnitsAndUpdateStableMcFlag] [Hardcoded Exceptions] The determineIfStableInLaterUnits function in main_chain.js has hardcoded exceptions for specific unit hashes (lines 762-768) - if an administrator unknowingly provides one of these as earlier_unit, will the script always return true regardless of actual stability, potentially marking non-stable units as stable?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: determineIfStableInLaterUnitsAndUpdateStableMcFlag] [Genesis Unit Handling] If earlier_unit is the genesis unit, determineIfStableInLaterUnits immediately returns true (line 760 of main_chain.js) - can this cause the script to attempt re-stabilizing the genesis unit causing unnecessary database writes or errors?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: determineIfStableInLaterUnitsAndUpdateStableMcFlag] [Free Unit Check] If earlier_unit is a free unit (is_free=1), determineIfStableInLaterUnits returns false (line 774-775 of main_chain.js) - but does the script provide any indication of WHY stability failed, or does it silently report 'stable? false' without explaining that free units cannot be stabilized?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: determineIfStableInLaterUnitsAndUpdateStableMcFlag] [v4 Upgrade Check] The function throws 'not stable in db but stable in later units in v4' error if last_stable_mci >= constants.v4UpgradeMci (line 1169-1170 of main_chain.js) - is this script intended for use ONLY pre-v4, and if so, does using it post-v4 cause protocol violations?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: determineIfStableInLaterUnitsAndUpdateStableMcFlag] [Write Lock Duration] The function holds a write lock from line 1163 to line 1189 of main_chain.js while performing multiple database queries and batch writes - during this time, can the main network process be blocked from creating new units or processing incoming units causing temporary network halt?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: MCI Advancement] [Gap Creation] If the provided earlier_unit has an MCI that is significantly higher than the current last_stable_mci (e.g., jumped ahead by 1000 MCIs), will determineIfStableInLaterUnitsAndUpdateStableMcFlag attempt to mark ALL intermediate MCIs as stable in sequence, and if any of those MCIs have no units, can this cause errors or incomplete stability advancement?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: stability update] [Ball Chain Consistency] After marking multiple MCIs as stable, does the function ensure that the ball chain (last_ball references) is properly constructed for all newly stabilized units, or can interruption during the batch write cause some units to be marked stable without balls leading to broken last_ball chain?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: determineIfStableInLaterUnitsAndUpdateStableMcFlag] [Final-Bad Propagation] The stability update process checks for temp-bad units and converts them to final-bad or good - if the script is interrupted during propagateFinalBad (line 1279-1333 of main_chain.js), can some spending units remain marked as temp-bad when they should be final-bad, allowing future double-spends to be accepted?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: markMcIndexStable] [Content Hash Setting] For final-bad units, markMcIndexStable calls setContentHash (line 1286-1299 of main_chain.js) - if this fails due to unit not found or hash collision, does the entire stability update rollback, or can it proceed leaving some final-bad units without content_hash causing validation errors?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 16: stability advancement] [MinRetrievableMci Update] After advancing stability, the system should update min_retrievable_mci to allow archiving of old units - does this script trigger updateMinRetrievableMciAfterStabilizingMci, or can repeated manual stability updates cause min_retrievable_mci to lag behind causing unbounded database growth?",
  "[File: byteball/ocore/tools/update_stability.js] [Script Documentation] [Misuse Risk] Is there documentation clearly stating when and why this script should be used (e.g., only for recovering from database corruption or for testing), or can administrators misuse it during normal operation causing consensus divergence?",
  "[File: byteball/ocore/tools/update_stability.js] [Script Availability] [Attack Surface] Should this script be removed or restricted in production deployments to prevent accidental or malicious misuse, or is it a necessary administrative tool that must remain available despite the risk of consensus manipulation?",
  "[File: byteball/ocore/tools/update_stability.js] [Line 11: console.log] [Information Disclosure] The script logs the earlier_unit and arrLaterUnits to console - if logs are accessible to untrusted parties, does this reveal information about which units are being manually stabilized, potentially indicating database corruption or other issues that could be exploited?"
]