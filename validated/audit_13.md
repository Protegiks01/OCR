# Audit Report: Case-Insensitive Address Validation Causing Database-Dependent Fund Lock

## Summary

The Obyte protocol accepts payment outputs to mixed-case addresses through case-insensitive validation but enforces case-sensitive JavaScript string comparison during spending validation. Combined with MySQL's case-insensitive collation (`utf8mb4_unicode_520_ci`) versus SQLite's case-sensitive default, this creates permanent fund lock on SQLite nodes and network-wide balance divergence between database implementations.

## Impact

**Severity**: Critical  
**Category**: Permanent Fund Freeze + Network Consensus Divergence

**Concrete Financial Impact**:
- **SQLite nodes**: Funds sent to lowercase address variants are permanently locked with no recovery mechanism
- **MySQL nodes**: Funds theoretically spendable via non-standard lowercase author address (requires custom implementation)
- **Network-wide**: Different node types report different balances for identical cryptographic addresses, breaking consensus

**Affected Parties**: Any user receiving payments to non-uppercase address variants, all SQLite node operators, exchanges using different database backends

**Quantified Loss**: Any amount sent to lowercase addresses becomes permanently inaccessible on SQLite nodes

## Finding Description

**Location**: Multiple files in `byteball/ocore`

**Intended Logic**: The protocol should validate and store addresses in canonical uppercase form. All addresses generated by `getChash160()` are uppercase via base32 encoding, and outputs must be spendable by their rightful owners regardless of database backend.

**Actual Logic**: Output addresses pass validation via `isValidAddressAnyCase()` and are stored without normalization. Spending validation uses case-sensitive JavaScript `indexOf()` comparison. Database queries behave differently (MySQL case-insensitive, SQLite case-sensitive), causing network state divergence.

**Exploitation Path**:

1. **Preconditions**: Victim owns uppercase address `ABCD2345EFGH6789IJKL0123MNOP4567` (standard wallet-generated)

2. **Step 1 - Output Creation**: 
   - Attacker creates unit with output to lowercase `abcd2345efgh6789ijkl0123mnop4567`
   - Validation accepts via `isValidAddressAnyCase(output.address)` [1](#0-0) [2](#0-1) 
   - Address stored without normalization [3](#0-2) 

3. **Step 2 - Spending Attempt (Uppercase Author)**:
   - Victim creates unit with uppercase `author.address = "ABCD2345..."`
   - Spending validation: `arrAuthorAddresses.indexOf(owner_address) === -1` fails due to case mismatch [4](#0-3) 
   - **Result**: "output owner is not among authors"

4. **Step 3 - Recovery Attempt (Lowercase Author + Definition)**:
   - Victim tries lowercase `author.address = "abcd2345..."` with definition
   - Author validation accepts checksum [5](#0-4) 
   - Definition validation compares: `objectHash.getChash160(definition) !== objAuthor.address` [6](#0-5) 
   - Since `getChash160()` returns uppercase [7](#0-6)  but author is lowercase
   - **Result**: "wrong definition"

5. **Step 4 - Database-Dependent Behavior (Lowercase Author Without Definition)**:
   - System calls `readDefinitionByAddress(conn, "abcd2345...", ...)` [8](#0-7) 
   - Query executes `WHERE address=?` [9](#0-8) 
   - **On SQLite**: Case-sensitive query finds no match (only uppercase `ABCD2345...` exists) → **PERMANENT LOCK**
   - **On MySQL**: Case-insensitive collation [10](#0-9)  matches uppercase definition → **MAY SUCCEED**

6. **Step 5 - Balance Divergence**:
   - Balance queries use `WHERE address=?`
   - **MySQL**: Case-insensitive, includes lowercase outputs in balance
   - **SQLite**: Case-sensitive, excludes lowercase outputs from balance
   - **Result**: Network consensus break on balance calculations

**Security Properties Broken**:
- **Balance Conservation**: Funds become inaccessible on SQLite nodes
- **Network Consensus**: Different balance views across database implementations
- **Deterministic Validation**: Database backend affects transaction validity

**Root Cause Analysis**:
- Output validation uses `isValidAddressAnyCase()` instead of enforcing `isValidAddress()` (uppercase-only) [11](#0-10) 
- No address normalization before storage [12](#0-11) 
- Spending check uses case-sensitive `indexOf()` [13](#0-12) [14](#0-13) 
- Database collation differs: MySQL case-insensitive [15](#0-14)  vs SQLite case-sensitive

## Impact Explanation

**Affected Assets**: All assets (bytes and custom divisible/indivisible assets)

**Damage Severity**:
- **SQLite Nodes**: Complete permanent loss with no recovery except hard fork
- **MySQL Nodes**: Requires non-standard wallet implementation
- **Network-Wide**: Critical consensus divergence on fundamental balance queries

**User Impact**:
- **Who**: Any user receiving lowercase address payments
- **Conditions**: Single unit submission with lowercase address
- **Recovery on SQLite**: None without hard fork
- **Recovery on MySQL**: Requires custom wallet with lowercase author address support

**Systemic Risk**:
- Network state divergence between database types
- Exchange integrations show different balances
- Enables griefing attacks (lock user funds intentionally)

## Likelihood Explanation

**Attacker Profile**:
- **Identity**: Any user (including accidental via buggy integrations)
- **Resources**: Minimal (standard transaction fees)
- **Skill**: Low (basic unit construction with lowercase string)

**Preconditions**:
- Normal network operation
- Target address public knowledge
- No special timing required

**Execution Complexity**:
- Single unit submission with lowercase address
- No race conditions or coordination needed
- Can occur accidentally

**Frequency**: Unlimited repeatability, potential for accidental occurrence

**Overall Assessment**: High likelihood due to trivial execution and potential accidents

## Recommendation

**Immediate Mitigation**:
Enforce uppercase addresses in output validation by replacing `isValidAddressAnyCase()` with `isValidAddress()`:

```javascript
// File: byteball/ocore/validation.js (lines 1945, 1955)
// Change from:
if (!ValidationUtils.isValidAddressAnyCase(output.address))
// To:
if (!ValidationUtils.isValidAddress(output.address))
```

**Permanent Fix**:
1. Normalize all addresses to uppercase before storage in `writer.js`
2. Add migration to uppercase existing lowercase addresses
3. Enforce uppercase in author address validation

**Additional Measures**:
- Add test case verifying lowercase addresses are rejected in outputs
- Database migration to fix existing lowercase addresses
- Network upgrade to enforce new validation rules

**Validation**:
- Fix prevents new lowercase addresses in outputs
- Backward compatible after migration
- Eliminates database-dependent behavior

## Proof of Concept

```javascript
// File: test/case_sensitive_address.test.js
const test = require('ava');
const db = require('../db');
const validation = require('../validation');
const composer = require('../composer');

test.serial('lowercase address causes permanent lock on SQLite', async t => {
    // Setup: Create victim address (uppercase)
    const victimAddress = 'ABCD2345EFGH6789IJKL0123MNOP4567';
    
    // Step 1: Attacker sends to lowercase variant
    const lowercaseAddress = victimAddress.toLowerCase();
    const attackUnit = await composer.composePayment({
        outputs: [{ address: lowercaseAddress, amount: 1000 }]
    });
    
    // Verify output accepted (isValidAddressAnyCase passes)
    const validationResult = await validation.validate(attackUnit);
    t.is(validationResult, null); // No error
    
    // Step 2: Victim tries to spend with uppercase author
    const spendUnit = await composer.composePayment({
        authors: [{ address: victimAddress }],
        inputs: [{ unit: attackUnit.unit, output_index: 0 }]
    });
    
    // On SQLite: indexOf fails (case-sensitive)
    const spendResult = await validation.validate(spendUnit);
    t.regex(spendResult.error, /output owner is not among authors/);
    
    // Step 3: Victim tries lowercase author with definition
    const recoveryUnit = await composer.composePayment({
        authors: [{ 
            address: lowercaseAddress, 
            definition: victimDefinition 
        }]
    });
    
    // Fails: getChash160(definition) returns uppercase
    const recoveryResult = await validation.validate(recoveryUnit);
    t.regex(recoveryResult.error, /wrong definition/);
    
    // Step 4: Check balance divergence
    const mysqlBalance = await queryBalance(victimAddress, 'mysql');
    const sqliteBalance = await queryBalance(victimAddress, 'sqlite');
    
    // MySQL includes lowercase output (case-insensitive)
    // SQLite excludes lowercase output (case-sensitive)
    t.notDeepEqual(mysqlBalance, sqliteBalance);
    t.is(sqliteBalance, 0); // Permanent lock on SQLite
});
```

## Notes

This vulnerability demonstrates a critical inconsistency where:
1. Validation layer accepts lowercase addresses via checksum-only validation
2. Storage layer preserves case without normalization
3. Spending layer uses case-sensitive comparison
4. Database layer behavior varies by implementation

The combination creates a database-dependent fund lock that violates the core protocol invariant of address determinism and breaks network consensus on balance calculations.

### Citations

**File:** validation.js (L1015-1016)
```javascript
		if (!chash.isChashValid(objAuthor.address))
			return callback("address checksum invalid");
```

**File:** validation.js (L1022-1022)
```javascript
		storage.readDefinitionByAddress(conn, objAuthor.address, objValidationState.last_ball_mci, {
```

**File:** validation.js (L1296-1297)
```javascript
				if (objectHash.getChash160(arrAddressDefinition) !== definition_chash)
					return callback("wrong definition: "+objectHash.getChash160(arrAddressDefinition) +"!=="+ definition_chash);
```

**File:** validation.js (L1945-1946)
```javascript
			if ("address" in output && !ValidationUtils.isValidAddressAnyCase(output.address))
				return callback("output address "+output.address+" invalid");
```

**File:** validation.js (L1955-1956)
```javascript
			if (!ValidationUtils.isValidAddressAnyCase(output.address))
				return callback("output address "+output.address+" invalid");
```

**File:** validation.js (L2194-2194)
```javascript
						if (arrAuthorAddresses.indexOf(owner_address) === -1)
```

**File:** validation.js (L2260-2262)
```javascript
							var owner_address = src_output.address;
							if (arrAuthorAddresses.indexOf(owner_address) === -1)
								return cb("output owner is not among authors");
```

**File:** writer.js (L394-398)
```javascript
								conn.addQuery(arrQueries, 
									"INSERT INTO outputs \n\
									(unit, message_index, output_index, address, amount, asset, denomination, is_serial) VALUES(?,?,?,?,?,?,?,1)",
									[objUnit.unit, i, j, output.address, parseInt(output.amount), payload.asset, denomination]
								);
```

**File:** chash.js (L139-141)
```javascript
	var encoded = (chash_length === 160) ? base32.encode(chash).toString() : chash.toString('base64');
	//console.log(encoded);
	return encoded;
```

**File:** storage.js (L755-759)
```javascript
	conn.query(
		"SELECT definition_chash FROM address_definition_changes CROSS JOIN units USING(unit) \n\
		WHERE address=? AND is_stable=1 AND sequence='good' AND main_chain_index<=? ORDER BY main_chain_index DESC LIMIT 1", 
		[address, max_mci], 
		function(rows){
```

**File:** initial-db/byteball-mysql.sql (L39-39)
```sql
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;
```

**File:** initial-db/byteball-mysql.sql (L324-324)
```sql
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;
```

**File:** validation_utils.js (L56-62)
```javascript
function isValidAddressAnyCase(address){
	return isValidChash(address, 32);
}

function isValidAddress(address){
	return (typeof address === "string" && address === address.toUpperCase() && isValidChash(address, 32));
}
```
