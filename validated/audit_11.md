# Audit Report: Case-Insensitive Address Validation with Case-Sensitive Spending Check Causes Permanent Fund Lock

## Summary

The Obyte protocol accepts payment outputs to mixed-case addresses through case-insensitive checksum validation, but enforces case-sensitive string comparison during input spending validation. This mismatch permanently locks funds sent to lowercase/mixed-case addresses, as victims cannot spend outputs even with valid private keys. Recovery requires hard fork to normalize addresses or implement case-insensitive spending checks.

## Impact

**Severity**: Critical  
**Category**: Permanent Fund Freeze Requiring Hard Fork

**Concrete Financial Impact**:
- Attackers can permanently lock unlimited bytes/assets by sending to lowercase addresses
- Victims cannot spend outputs with standard wallets or custom unit construction
- All address types affected (user addresses, AA addresses, shared addresses)

**Affected Parties**:
- Any user whose address is targeted in mixed-case form
- Autonomous Agents receiving payments with incorrect casing
- Network integrity (MySQL vs SQLite nodes show different balances)

**Quantified Loss**: Unlimited per-attack (any amount can be locked indefinitely)

## Finding Description

**Location**: 

Output validation: [3](#0-2) 

Input validation: [5](#0-4) 

Storage: [6](#0-5) 

Address generation: [4](#0-3) 

Validation utilities: [7](#0-6) 

Definition validation: [1](#0-0) 

**Intended Logic**: 

Addresses should be validated consistently. The protocol generates uppercase addresses via `getChash160()` [2](#0-1) . Any valid output must be spendable by its rightful owner.

**Actual Logic**: 

Output addresses validated using `isValidAddressAnyCase()` which only checks checksum [8](#0-7) , stored without normalization [9](#0-8) , but input spending uses case-sensitive `indexOf()` comparison [5](#0-4) .

**Exploitation Path**:

1. **Preconditions**: Victim owns address "ABCD2345EFGH6789IJKL0123MNOP4567" (uppercase, generated by wallet)

2. **Step 1 - Malicious Output Creation**:
   - Attacker creates unit with payment to "abcd2345efgh6789ijkl0123mnop4567" (lowercase)
   - `validatePaymentInputsAndOutputs()` calls `isValidAddressAnyCase()` 
   - Checksum validates (base32 decoding is case-insensitive)
   - Unit accepted into DAG

3. **Step 2 - Storage Without Normalization**:
   - `writer.js` stores address as-is: `output.address` directly inserted
   - Database contains "abcd2345efgh6789ijkl0123mnop4567"

4. **Step 3 - Spending Attempt Fails (Standard Wallet)**:
   - Victim creates unit with author address "ABCD2345..." (from `getChash160()`)
   - `arrAuthorAddresses = objUnit.authors.map(author => author.address)` = ["ABCD..."]
   - Query retrieves `owner_address = src_output.address` = "abcd..."
   - Check: `arrAuthorAddresses.indexOf(owner_address) === -1` returns -1 (case-sensitive)
   - Validation fails: "output owner is not among authors"

5. **Step 4 - Custom Recovery Blocked**:
   - Victim attempts unit with lowercase author "abcd..."
   - Definition validation checks: `objectHash.getChash160(definition) !== objAuthor.address`
   - Since `getChash160()` returns uppercase "ABCD..." but author is "abcd...", check fails
   - Validation rejects: "wrong definition"

6. **Step 5 - Permanent Lock**:
   - Standard wallet cannot spend (uppercase author)
   - Custom unit cannot spend (definition validation)
   - Requires hard fork to add address normalization

**Security Properties Broken**:
- **Balance Conservation**: Funds locked without authorization
- **Input Validity**: Valid outputs become unspendable
- **Definition Evaluation Integrity**: Address derivation inconsistent with validation

**Root Cause Analysis**:
- Output validation uses `isValidAddressAnyCase()` (case-insensitive) [8](#0-7) 
- Storage has no normalization [9](#0-8) 
- Spending check uses case-sensitive `indexOf()` [5](#0-4) 
- Definition validation enforces uppercase from `getChash160()` [1](#0-0) 
- The strict `isValidAddress()` function exists but is NOT used for outputs [10](#0-9) 

## Impact Explanation

**Affected Assets**: All assets (bytes and custom divisible/indivisible assets)

**Damage Severity**:
- **Quantitative**: Unlimited - any amount sent to mixed-case addresses becomes permanently locked
- **Qualitative**: Complete loss of spendability, no standard recovery path, requires network-wide hard fork

**User Impact**:
- **Who**: Any user targeted, particularly those with public addresses (explorers, exchanges, AAs)
- **Conditions**: Single malicious unit submission, no special timing required
- **Recovery**: None without hard fork to normalize addresses or implement case-insensitive comparison

**Systemic Risk - Database Divergence**:

MySQL uses case-insensitive collation [11](#0-10)  (`utf8mb4_unicode_520_ci`), while SQLite uses case-sensitive comparison by default. Balance queries [12](#0-11)  use `WHERE address=?` causing:
- MySQL: Matches "ABCD..." when querying "abcd..." (includes output in balance)
- SQLite: No match (excludes output from balance)
- Result: Different balance calculations between node implementations

## Likelihood Explanation

**Attacker Profile**:
- **Identity**: Any user with ability to submit units
- **Resources Required**: Minimal (< 1 byte transaction fee)
- **Technical Skill**: Low (basic unit construction)

**Preconditions**:
- Normal network operation
- Knowledge of target address (public information)

**Execution Complexity**:
- Single unit submission with lowercase address
- No coordination or timing requirements
- Appears as normal payment

**Frequency**:
- Unlimited repeatability across all addresses
- Can target multiple addresses per unit

**Overall Assessment**: High likelihood - trivial execution, minimal cost, difficult to detect proactively

## Recommendation

**Immediate Mitigation**:
Normalize all addresses to uppercase during output validation before storage:

```javascript
// In validation.js validatePaymentInputsAndOutputs()
if (output.address)
    output.address = output.address.toUpperCase();
```

**Permanent Fix**:
Replace `isValidAddressAnyCase()` with `isValidAddress()` for output validation to enforce uppercase: [3](#0-2) 

Change to use strict validation that requires uppercase per the protocol design.

**Additional Measures**:
- Database migration: Normalize existing output addresses to uppercase
- Add test case verifying mixed-case addresses are rejected
- Update `indexOf` checks to use case-insensitive comparison as defense-in-depth
- Monitor for existing locked outputs on mainnet

## Proof of Concept

```javascript
const composer = require('ocore/composer.js');
const network = require('ocore/network.js');
const db = require('ocore/db.js');

// Test: Verify funds sent to lowercase address cannot be spent
async function testMixedCaseAddressLock() {
    // Setup: Create victim address (uppercase by default)
    const victimAddress = "ABCD2345EFGH6789IJKL0123MNOP4567";
    
    // Step 1: Attacker sends to lowercase version
    const lowercaseAddress = victimAddress.toLowerCase();
    await composer.composePaymentJoint(
        [attackerAddress],
        [{address: lowercaseAddress, amount: 1000}],
        attackerSigner,
        callbacks
    );
    
    // Step 2: Verify output stored with lowercase address
    const rows = await db.query(
        "SELECT address FROM outputs WHERE address=?",
        [lowercaseAddress]
    );
    console.assert(rows.length === 1, "Output stored with lowercase");
    console.assert(rows[0].address === lowercaseAddress, "No normalization");
    
    // Step 3: Victim attempts to spend (will fail)
    try {
        await composer.composePaymentJoint(
            [victimAddress], // uppercase author
            [{address: anyAddress, amount: 500}],
            victimSigner,
            callbacks
        );
        console.assert(false, "Should have failed validation");
    } catch (err) {
        console.assert(err.includes("output owner is not among authors"),
            "Expected case-sensitive indexOf failure");
    }
    
    // Step 4: Verify custom unit with lowercase author also fails
    try {
        const customUnit = {
            authors: [{
                address: lowercaseAddress, // lowercase to match output
                definition: victimDefinition
            }],
            // ... rest of unit structure
        };
        await network.handleJoint({unit: customUnit});
        console.assert(false, "Should have failed definition validation");
    } catch (err) {
        console.assert(err.includes("wrong definition"),
            "Expected definition hash mismatch");
    }
    
    // Conclusion: Funds permanently locked
    console.log("âœ— VULNERABILITY CONFIRMED: Funds locked, no recovery path");
}
```

**Notes**:

1. The vulnerability exists because output validation deliberately uses `isValidAddressAnyCase()` for flexibility, but this was never intended to allow non-uppercase addresses to be stored.

2. The two functions `isValidAddress()` (strict uppercase) and `isValidAddressAnyCase()` (lenient) should have been used consistently: strict for all on-chain addresses, lenient only for user input validation.

3. Database divergence between MySQL/SQLite creates additional UX issues where users see different balances depending on node implementation, though this doesn't directly break consensus.

4. The fix requires both validation changes (reject non-uppercase) and database migration (normalize existing addresses), making this a critical protocol upgrade.

### Citations

**File:** validation.js (L1296-1297)
```javascript
				if (objectHash.getChash160(arrAddressDefinition) !== definition_chash)
					return callback("wrong definition: "+objectHash.getChash160(arrAddressDefinition) +"!=="+ definition_chash);
```

**File:** validation.js (L1955-1956)
```javascript
			if (!ValidationUtils.isValidAddressAnyCase(output.address))
				return callback("output address "+output.address+" invalid");
```

**File:** validation.js (L2261-2262)
```javascript
							if (arrAuthorAddresses.indexOf(owner_address) === -1)
								return cb("output owner is not among authors");
```

**File:** chash.js (L139-141)
```javascript
	var encoded = (chash_length === 160) ? base32.encode(chash).toString() : chash.toString('base64');
	//console.log(encoded);
	return encoded;
```

**File:** wallet_defined_by_keys.js (L558-558)
```javascript
				var address = objectHash.getChash160(arrDefinition);
```

**File:** writer.js (L394-398)
```javascript
								conn.addQuery(arrQueries, 
									"INSERT INTO outputs \n\
									(unit, message_index, output_index, address, amount, asset, denomination, is_serial) VALUES(?,?,?,?,?,?,?,1)",
									[objUnit.unit, i, j, output.address, parseInt(output.amount), payload.asset, denomination]
								);
```

**File:** validation_utils.js (L56-62)
```javascript
function isValidAddressAnyCase(address){
	return isValidChash(address, 32);
}

function isValidAddress(address){
	return (typeof address === "string" && address === address.toUpperCase() && isValidChash(address, 32));
}
```

**File:** initial-db/byteball-mysql.sql (L39-39)
```sql
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;
```

**File:** balances.js (L14-18)
```javascript
	db.query(
		"SELECT asset, is_stable, SUM(amount) AS balance \n\
		FROM outputs "+join_my_addresses+" CROSS JOIN units USING(unit) \n\
		WHERE is_spent=0 AND "+where_condition+" AND sequence='good' \n\
		GROUP BY asset, is_stable",
```
