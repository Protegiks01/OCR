# Audit Report: Case-Insensitive Address Validation with Case-Sensitive Spending Check Causes Database-Dependent Fund Lock

## Summary

The Obyte protocol accepts payment outputs to mixed-case addresses through case-insensitive checksum validation [1](#0-0) , stores them without normalization [2](#0-1) , but enforces case-sensitive JavaScript `indexOf()` comparison during input spending validation [3](#0-2) . Combined with database collation differences (MySQL case-insensitive [4](#0-3)  vs SQLite case-sensitive), this creates permanent fund lock on SQLite nodes and network-wide balance divergence.

## Impact

**Severity**: Critical  
**Category**: Permanent Fund Freeze (SQLite nodes) / Network Consensus Divergence

**Concrete Financial Impact**:
- **SQLite nodes**: Funds sent to lowercase addresses are permanently locked with no recovery path
- **MySQL nodes**: Funds spendable via non-standard lowercase author address (normal wallets won't do this)
- **Network-wide**: Different node types report different balances for same addresses, breaking consensus

**Affected Parties**:
- Any user whose address receives payments in non-uppercase form
- SQLite node operators experience different balances than MySQL nodes
- Exchange integrations relying on balance queries show inconsistent values

**Quantified Loss**: Any amount sent to lowercase addresses becomes inaccessible on SQLite nodes

## Finding Description

**Location**: 
- Output validation: `validation.js:1945-1956` [5](#0-4) 
- Input spending check: `validation.js:2260-2262` [3](#0-2) 
- Storage: `writer.js:397` [2](#0-1) 
- Author address extraction: `validation.js:1908` [6](#0-5) 

**Intended Logic**: 

Addresses should be validated and stored consistently. The protocol generates uppercase addresses via `getChash160()` [7](#0-6) . Any valid output must be spendable by its rightful owner.

**Actual Logic**: 

Output addresses are validated using `isValidAddressAnyCase()` [8](#0-7)  which only checks checksums regardless of case. Addresses are stored exactly as provided without normalization. Spending validation creates `arrAuthorAddresses` from unit authors [6](#0-5)  and performs case-sensitive `indexOf()` comparison with stored output addresses [9](#0-8) .

**Exploitation Path**:

1. **Preconditions**: Victim owns address `ABCD2345EFGH6789IJKL0123MNOP4567` (uppercase, generated by standard wallet)

2. **Step 1 - Malicious Output Creation**:
   - Attacker creates unit with payment output to `abcd2345efgh6789ijkl0123mnop4567` (lowercase)
   - Validation calls `isValidAddressAnyCase(output.address)` which passes (checksum valid for lowercase)
   - Unit accepted into DAG

3. **Step 2 - Storage Without Normalization**:
   - Writer stores address directly: `output.address` inserted as-is
   - Database `outputs` table contains `abcd2345efgh6789ijkl0123mnop4567`

4. **Step 3 - Spending Attempt (Standard Wallet - Uppercase Author)**:
   - Victim creates unit with `author.address = "ABCD2345..."` (their normal address)
   - Validation creates `arrAuthorAddresses = ["ABCD2345..."]`
   - Query retrieves `owner_address = "abcd2345..."` from database
   - Check: `arrAuthorAddresses.indexOf(owner_address) === -1` returns true (case-sensitive mismatch)
   - **Fails**: "output owner is not among authors"

5. **Step 4 - Attempted Recovery (Lowercase Author WITH Definition)**:
   - Victim attempts unit with `author.address = "abcd2345..."` and provides definition
   - Validation compares: `objectHash.getChash160(definition) !== objAuthor.address` [10](#0-9) 
   - `getChash160()` returns `ABCD2345...` (uppercase) but author is `abcd2345...` (lowercase)
   - **Fails**: "wrong definition"

6. **Step 5 - Database-Dependent Behavior (Lowercase Author WITHOUT Definition)**:
   - Victim attempts unit with `author.address = "abcd2345..."`, no definition
   - Author validation only checks checksum [11](#0-10)  - passes
   - System attempts `readDefinitionByAddress(conn, "abcd2345...", ...)` [12](#0-11) 
   - **On SQLite** (case-sensitive): Query `WHERE definition_chash="abcd2345..."` finds no match (only `ABCD2345...` exists) - **PERMANENT LOCK**
   - **On MySQL** (case-insensitive): Query matches `ABCD2345...` definition - **MAY SUCCEED** but requires non-standard wallet behavior

7. **Step 6 - Balance Divergence**:
   - Balance query: `SELECT ... FROM outputs WHERE address=?` [13](#0-12) 
   - **MySQL** with `utf8mb4_unicode_520_ci` collation: Query for `ABCD...` matches output stored as `abcd...` (includes in balance)
   - **SQLite** (case-sensitive): Query for `ABCD...` does NOT match `abcd...` (excludes from balance)
   - **Result**: Different nodes report different balances for same address

**Security Properties Broken**:
- **Balance Conservation**: Funds become inaccessible on some node types
- **Network Consensus**: Different balance calculations across node implementations
- **Definition Evaluation Integrity**: Address validation inconsistent with storage and comparison

**Root Cause Analysis**:
- Output validation uses `isValidAddressAnyCase()` (case-insensitive checksum-only validation)
- No address normalization to uppercase before storage
- Spending check uses JavaScript `indexOf()` which is always case-sensitive
- Database collation varies: MySQL case-insensitive vs SQLite case-sensitive
- Two validation functions exist (`isValidAddress` enforcing uppercase, `isValidAddressAnyCase` not), but outputs use the permissive one

## Impact Explanation

**Affected Assets**: All assets (bytes and custom divisible/indivisible assets)

**Damage Severity**:
- **SQLite Nodes**: Complete permanent loss of spendability, no recovery path
- **MySQL Nodes**: Funds spendable via non-standard method (lowercase author address) that normal wallets don't implement
- **Network-Wide**: Consensus divergence on balance calculations between node types

**User Impact**:
- **Who**: Any user receiving payments to non-uppercase address variants
- **Conditions**: Single malicious or accidental unit submission with lowercase address
- **Recovery on SQLite**: None without database migration or hard fork
- **Recovery on MySQL**: Requires custom wallet implementation using lowercase author address

**Systemic Risk**:
- Network split in balance views between MySQL and SQLite nodes
- Exchange integrations may report different balances depending on database backend
- Protocol assumption of canonical uppercase addresses violated
- Enables griefing attacks (intentionally lock funds by sending to lowercase)

## Likelihood Explanation

**Attacker Profile**:
- **Identity**: Any user with ability to submit units (including accidental misuse)
- **Resources Required**: Minimal (standard transaction fee)
- **Technical Skill**: Low (basic unit construction with lowercase address)

**Preconditions**:
- Normal network operation
- Knowledge of target address (public information)
- No special timing or coordination required

**Execution Complexity**:
- Single unit submission with lowercase address in output
- No race conditions or precise timing needed
- Can be accidental (typo, case conversion error)

**Frequency**:
- Unlimited repeatability
- Can target any address
- Both intentional attacks and accidental misuse possible

**Overall Assessment**: High likelihood due to trivial execution and potential for accidental occurrence

## Recommendation

**Immediate Mitigation**:
Normalize all addresses to uppercase during output validation before storage:

```javascript
// In validation.js, after line 1945/1955
if ("address" in output && !ValidationUtils.isValidAddressAnyCase(output.address))
    return callback("output address "+output.address+" invalid");
// ADD: Normalize to uppercase
if ("address" in output)
    output.address = output.address.toUpperCase();
```

**Permanent Fix**:
1. Use strict `isValidAddress()` (uppercase-enforcing) instead of `isValidAddressAnyCase()` for output validation [14](#0-13) 
2. Add database migration to normalize existing lowercase addresses
3. Add validation to reject non-uppercase addresses in new units
4. Document that addresses must always be uppercase as protocol invariant

**Additional Measures**:
- Add test case verifying lowercase addresses are rejected or normalized
- Add monitoring for units with non-uppercase addresses
- Review all other uses of `isValidAddressAnyCase()` to ensure appropriateness

**Validation**:
- [ ] Fix normalizes or rejects lowercase addresses consistently
- [ ] Existing units with lowercase addresses migrated or documented
- [ ] Balance queries return consistent results across node types
- [ ] No breaking changes to legitimate existing addresses

## Proof of Concept

```javascript
// File: test/case_sensitive_address_lock.test.js
const composer = require('../composer.js');
const validation = require('../validation.js');
const db = require('../db.js');

describe('Case-Sensitive Address Lock', function() {
    it('should reject or normalize lowercase addresses in outputs', async function() {
        // Setup: Create victim with uppercase address ABCD...
        const victimAddress = 'ABCD2345EFGH6789IJKL0123MNOP4567'; // Example uppercase
        
        // Attack: Create unit with lowercase address in output
        const lowercaseAddress = victimAddress.toLowerCase();
        const maliciousUnit = {
            messages: [{
                app: 'payment',
                payload: {
                    outputs: [{
                        address: lowercaseAddress, // lowercase!
                        amount: 1000
                    }]
                }
            }]
        };
        
        // Validation should either:
        // 1. Reject non-uppercase addresses, OR
        // 2. Normalize to uppercase before storage
        
        // Current behavior: Accepts lowercase, causing lock
        // Expected behavior: Reject or normalize
        
        // After fix, this should not result in unspendable outputs
    });
    
    it('demonstrates balance divergence between MySQL and SQLite', async function() {
        // This test would show different balance results
        // when querying uppercase address on nodes with
        // outputs stored as lowercase
    });
});
```

**Notes**: 
- The report acknowledges MySQL nodes have a non-standard recovery path via lowercase author addresses
- SQLite nodes experience permanent lock with no recovery
- Primary vulnerability is network consensus divergence and SQLite permanent lock
- Both intentional attacks and accidental misuse are possible

### Citations

**File:** validation.js (L1015-1016)
```javascript
		if (!chash.isChashValid(objAuthor.address))
			return callback("address checksum invalid");
```

**File:** validation.js (L1296-1297)
```javascript
				if (objectHash.getChash160(arrAddressDefinition) !== definition_chash)
					return callback("wrong definition: "+objectHash.getChash160(arrAddressDefinition) +"!=="+ definition_chash);
```

**File:** validation.js (L1908-1908)
```javascript
	var arrAuthorAddresses = objUnit.authors.map(function(author) { return author.address; } );
```

**File:** validation.js (L1945-1956)
```javascript
			if ("address" in output && !ValidationUtils.isValidAddressAnyCase(output.address))
				return callback("output address "+output.address+" invalid");
			if (output.address)
				count_open_outputs++;
		}
		else{
			if ("blinding" in output)
				return callback("public output must not have blinding");
			if ("output_hash" in output)
				return callback("public output must not have output_hash");
			if (!ValidationUtils.isValidAddressAnyCase(output.address))
				return callback("output address "+output.address+" invalid");
```

**File:** validation.js (L2260-2262)
```javascript
							var owner_address = src_output.address;
							if (arrAuthorAddresses.indexOf(owner_address) === -1)
								return cb("output owner is not among authors");
```

**File:** writer.js (L397-397)
```javascript
									[objUnit.unit, i, j, output.address, parseInt(output.amount), payload.asset, denomination]
```

**File:** initial-db/byteball-mysql.sql (L39-39)
```sql
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;
```

**File:** chash.js (L139-139)
```javascript
	var encoded = (chash_length === 160) ? base32.encode(chash).toString() : chash.toString('base64');
```

**File:** validation_utils.js (L56-57)
```javascript
function isValidAddressAnyCase(address){
	return isValidChash(address, 32);
```

**File:** validation_utils.js (L60-61)
```javascript
function isValidAddress(address){
	return (typeof address === "string" && address === address.toUpperCase() && isValidChash(address, 32));
```

**File:** storage.js (L767-770)
```javascript
function readDefinitionByAddress(conn, address, max_mci, callbacks){
	readDefinitionChashByAddress(conn, address, max_mci, function(definition_chash){
		readDefinitionAtMci(conn, definition_chash, max_mci, callbacks);
	});
```

**File:** balances.js (L15-18)
```javascript
		"SELECT asset, is_stable, SUM(amount) AS balance \n\
		FROM outputs "+join_my_addresses+" CROSS JOIN units USING(unit) \n\
		WHERE is_spent=0 AND "+where_condition+" AND sequence='good' \n\
		GROUP BY asset, is_stable",
```
